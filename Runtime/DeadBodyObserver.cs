// <auto-generated>
//   This file is part of AI-Refactored, an open-source project focused on realistic AI behavior in Escape from Tarkov.
//   Licensed under the MIT License. See LICENSE in the repository root for more information.
//
//   THIS FILE IS SYSTEMATICALLY MANAGED.
//   Please follow strict StyleCop, ReSharper, and AI-Refactored code standards for all modifications.
// </auto-generated>

#nullable enable

namespace AIRefactored.Runtime
{
    using System.Collections.Generic;
    using AIRefactored.AI.Core;
    using AIRefactored.AI.Looting;
    using AIRefactored.Core;
    using EFT;
    using EFT.Interactive;
    using UnityEngine;

    /// <summary>
    /// Periodically checks for dead players and associates their corpse with a nearby loot container.
    /// Ensures bots prioritize relevant containers and avoids redundant corpse scans.
    /// Executes strictly on authoritative host instances.
    /// </summary>
    public sealed class DeadBodyObserver : MonoBehaviour
    {
        #region Constants

        private const float ScanIntervalSeconds = 1.0f;
        private const float MaxAssociationDistance = 1.5f;

        #endregion

        #region Fields

        private float _nextScanTime = -1f;

        #endregion

        #region Unity Lifecycle

        /// <summary>
        /// Unity update loop. Triggers corpse-container association logic periodically.
        /// </summary>
        private void Update()
        {
            if (!Application.isPlaying || !GameWorldHandler.IsInitialized || !GameWorldHandler.IsLocalHost())
            {
                return;
            }

            float now = Time.time;
            if (now < this._nextScanTime)
            {
                return;
            }

            this._nextScanTime = now + ScanIntervalSeconds;

            LootableContainer[] containers = Object.FindObjectsOfType<LootableContainer>();
            if (containers == null || containers.Length == 0)
            {
                return;
            }

            List<Player> players = GameWorldHandler.GetAllAlivePlayers();
            if (players == null || players.Count == 0)
            {
                return;
            }

            for (int i = 0; i < players.Count; i++)
            {
                Player player = players[i];
                if (player == null || player.HealthController == null || player.HealthController.IsAlive)
                {
                    continue;
                }

                string profileId = player.ProfileId;
                if (string.IsNullOrEmpty(profileId) || DeadBodyContainerCache.Contains(profileId))
                {
                    continue;
                }

                Vector3 corpsePosition = EFTPlayerUtil.GetPosition(player);
                Transform? playerRoot = player.Transform?.Original?.root;

                for (int j = 0; j < containers.Length; j++)
                {
                    LootableContainer container = containers[j];
                    if (container == null || !container.enabled)
                    {
                        continue;
                    }

                    Transform containerTransform = container.transform;
                    if (containerTransform == null)
                    {
                        continue;
                    }

                    bool rootMatch = playerRoot != null && containerTransform.root == playerRoot;
                    bool closeEnough = Vector3.Distance(containerTransform.position, corpsePosition) <= MaxAssociationDistance;

                    if (rootMatch || closeEnough)
                    {
                        DeadBodyContainerCache.Register(player, container);
                        break;
                    }
                }
            }
        }

        #endregion
    }
}
