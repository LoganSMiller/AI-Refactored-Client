// <auto-generated>
//   AI-Refactored: BotRecoveryService.cs (Supreme Arbitration, Universal Recovery, Max-Realism Ultimate Edition – June 2025)
//   No fallback, no terminal disables, all bots and overlays recover forever. SPT/FIKA/headless/client parity.
//   Hardened for anti-stuck, infinite reload, and overlay/event-only arbitration. MIT License.
// </auto-generated>

namespace AIRefactored.Runtime
{
    using AIRefactored.AI.Core;
    using AIRefactored.AI.Threads;
    using AIRefactored.Bootstrap;
    using AIRefactored.Core;
    using BepInEx.Logging;
    using Comfort.Common;
    using EFT;
    using EFT.Game.Spawning;
    using System;
    using System.Collections.Generic;
    using UnityEngine;

    /// <summary>
    /// Monolithic atomic bot lifecycle and full system/overlay/brain recovery watchdog.
    /// No fallback or terminal disables; all bots and overlays recover continuously.
    /// No overlay/event/intent ever blocks or disables another system. SPT/FIKA/client/headless parity.
    /// </summary>
    public sealed class BotRecoveryService : IAIWorldSystemBootstrapper
    {
        private const float TickInterval = 5f;
        private static readonly ManualLogSource Logger = Plugin.LoggerInstance;

        private static float _nextTickTime = -1f;
        private static bool _hasInitialized;
        private static bool _hookedSpawner;
        private static bool _teardownStarted;

        public static BotRecoveryService Instance { get; } = new BotRecoveryService();

        /// <summary>
        /// Initializes the recovery service and resets all static state (idempotent, domain reload safe).
        /// </summary>
        public void Initialize()
        {
            Reset();
            _hasInitialized = true;
            Logger.LogInfo("[BotRecoveryService] Initialized.");
        }

        /// <summary>
        /// Handles raid end/teardown: full detach, state reset, and recovery hook cleanup.
        /// </summary>
        public void OnRaidEnd()
        {
            SafeDetachHooks();
            Reset();
            _hasInitialized = false;
            Logger.LogInfo("[BotRecoveryService] OnRaidEnd: All state reset and hooks detached.");
        }

        public bool IsReady() => _hasInitialized && GameWorldHandler.IsReady();
        public WorldPhase RequiredPhase() => WorldPhase.WorldReady;

        /// <summary>
        /// Fully resets tick state and internal flags (idempotent, safe for domain reload).
        /// </summary>
        public static void Reset()
        {
            _nextTickTime = -1f;
            _hookedSpawner = false;
            _teardownStarted = false;
        }

        /// <summary>
        /// Main recovery tick: ensures all bots, brains, overlays, owners, and caches are valid and attached.
        /// Recovers and retries all bots and overlays until fully valid.
        /// </summary>
        public void Tick(float deltaTime)
        {
            try
            {
                if (!_hasInitialized || !GameWorldHandler.IsHost || !GameWorldHandler.IsReady())
                    return;

                float now = Time.time;
                if (now < _nextTickTime)
                    return;
                _nextTickTime = now + TickInterval;

                GameWorld world = GameWorldHandler.Get();
                if (world == null || world.AllAlivePlayersList == null)
                    return;

                EnsureSpawnHook();
                ValidateAll(world.AllAlivePlayersList);
            }
            catch (Exception ex)
            {
                Logger.LogError("[BotRecoveryService] Tick error: " + ex);
            }
        }

        /// <summary>
        /// Ensures BotSpawner event is always hooked for runtime bot brain injection and recovery.
        /// </summary>
        private static void EnsureSpawnHook()
        {
            try
            {
                if (_hookedSpawner || !Singleton<BotSpawner>.Instantiated)
                    return;

                Singleton<BotSpawner>.Instance.OnBotCreated -= GameWorldHandler.TryAttachBotBrain;
                Singleton<BotSpawner>.Instance.OnBotCreated += GameWorldHandler.TryAttachBotBrain;
                _hookedSpawner = true;
            }
            catch (Exception ex)
            {
                Logger.LogError("[BotRecoveryService] EnsureSpawnHook error: " + ex);
            }
        }

        /// <summary>
        /// Iterates all living AI players and ensures full owner/cache/brain/overlay recovery, recovers any missing subsystems.
        /// </summary>
        private static void ValidateAll(List<Player> players)
        {
            if (players == null) return;
            HashSet<string> seenProfiles = new HashSet<string>();

            for (int i = 0; i < players.Count; i++)
            {
                try
                {
                    Player player = players[i];
                    if (!EFTPlayerUtil.IsValid(player) || !player.IsAI || player.gameObject == null || player.HealthController == null || !player.HealthController.IsAlive)
                        continue;

                    string profileId = player.ProfileId ?? player.Profile?.Id;
                    if (string.IsNullOrEmpty(profileId))
                        continue;
                    if (!seenProfiles.Add(profileId))
                    {
                        Logger.LogWarning($"[BotRecoveryService] Duplicate profile detected: {profileId}");
                        continue;
                    }

                    // Ensure brain and core overlays
                    RecoverBotBrainAndCache(player);

                    // Recover overlays/arbitration if stuck in fallback or retreat overlays
                    RecoverBotOverlay(player);
                }
                catch (Exception ex)
                {
                    Logger.LogError("[BotRecoveryService] ValidateAll() bot error: " + ex);
                }
            }
        }

        /// <summary>
        /// Ensures BotBrain, AIRefactoredBotOwner, and cache are valid, always recovers and retries.
        /// </summary>
        private static void RecoverBotBrainAndCache(Player player)
        {
            try
            {
                if (player.gameObject.GetComponent<BotBrain>() != null)
                    return;

                if (player.AIData?.BotOwner == null)
                    return;

                var botOwner = player.AIData.BotOwner;
                var cache = BotComponentCacheRegistry.GetOrCreate(botOwner);

                if (cache == null || cache.Bot == null || cache.AIRefactoredBotOwner == null)
                    return;

                if (!cache.AIRefactoredBotOwner.HasPersonality())
                    cache.AIRefactoredBotOwner.InitProfile(cache.AIRefactoredBotOwner.PersonalityProfile, cache.AIRefactoredBotOwner.PersonalityName);

                GameWorldHandler.TryAttachBotBrain(botOwner);
            }
            catch (Exception ex)
            {
                Logger.LogError("[BotRecoveryService] RecoverBotBrainAndCache() error: " + ex);
            }
        }

        /// <summary>
        /// Detects and recovers bots stuck in fallback/retreat overlays, clears overlays, and triggers arbitration.
        /// </summary>
        private static void RecoverBotOverlay(Player player)
        {
            try
            {
                var botBrain = player.gameObject.GetComponent<BotBrain>();
                if (botBrain == null)
                    return;

                var botOwner = botBrain.BotOwner;
                if (botOwner == null)
                    return;

                var overlay = BotOverlayManager.GetActiveOverlayType(botOwner);

                // Supreme stuck overlay detection; expand here as needed for future overlays
                if (overlay == BotOverlayType.Fallback || overlay == BotOverlayType.Retreat)
                {
                    Logger.LogWarning($"[BotRecoveryService] Bot {player.ProfileId} was left in a stuck overlay ({overlay}). Forcing recovery.");
                    BotOverlayManager.ForceClear(botOwner);

                    // Nudge arbitration for overlay/event recovery
                    botBrain.RequestOverlayArbitrationNextTick();
                }
            }
            catch (Exception ex)
            {
                Logger.LogError("[BotRecoveryService] RecoverBotOverlay() error: " + ex);
            }
        }

        /// <summary>
        /// Fully detaches all hooks, for raid end, teardown, or reload. No exception ever escapes.
        /// </summary>
        private static void SafeDetachHooks()
        {
            try
            {
                if (_hookedSpawner && Singleton<BotSpawner>.Instantiated)
                {
                    Singleton<BotSpawner>.Instance.OnBotCreated -= GameWorldHandler.TryAttachBotBrain;
                    _hookedSpawner = false;
                }
            }
            catch (Exception ex)
            {
                Logger.LogError("[BotRecoveryService] SafeDetachHooks() failed: " + ex);
            }
        }
    }
}
