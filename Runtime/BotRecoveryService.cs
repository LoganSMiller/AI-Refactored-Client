// <auto-generated>
//   This file is part of AI-Refactored, an open-source project focused on realistic AI behavior in Escape from Tarkov.
//   Licensed under the MIT License. See LICENSE in the repository root for more information.
//
//   THIS FILE IS SYSTEMATICALLY MANAGED.
//   Please follow strict StyleCop, ReSharper, and AI-Refactored code standards for all modifications.
// </auto-generated>

namespace AIRefactored.Runtime
{
	using System;
	using System.Collections.Generic;
	using AIRefactored.AI.Core;
	using AIRefactored.AI.Hotspots;
	using AIRefactored.AI.Looting;
	using AIRefactored.AI.Navigation;
	using AIRefactored.AI.Threads;
	using AIRefactored.Bootstrap;
	using AIRefactored.Core;
	using BepInEx.Logging;
	using Comfort.Common;
	using EFT;
	using EFT.Game.Spawning;
	using UnityEngine;

	/// <summary>
	/// Monitors GameWorld state and ensures AIRefactored systems remain functional across sessions.
	/// Called externally by WorldBootstrapper, tick scheduler, or raid monitor.
	/// </summary>
	public sealed class BotRecoveryService : IAIWorldSystemBootstrapper
	{
		#region Constants

		private const float TickInterval = 5f;

		#endregion

		#region Fields

		private static readonly ManualLogSource Logger = Plugin.LoggerInstance;

		private static float _nextTickTime = -1f;
		private static bool _hasWarned;
		private static bool _hasRescanned;
		private static bool _hasInitialized;
		private static bool _hookedSpawner;

		public static BotRecoveryService Instance { get; } = new BotRecoveryService();

		#endregion

		#region Initialization

		public void Initialize()
		{
			try
			{
				Reset();
				_hasInitialized = true;
				Logger.LogDebug("[BotRecoveryService] ✅ Initialized.");
			}
			catch (Exception ex)
			{
				Logger.LogError("[BotRecoveryService] ❌ Initialize failed: " + ex);
			}
		}

		public void OnRaidEnd()
		{
			try
			{
				if (_hookedSpawner && Singleton<BotSpawner>.Instantiated)
				{
					Singleton<BotSpawner>.Instance.OnBotCreated -= GameWorldHandler.TryAttachBotBrain;
					_hookedSpawner = false;
				}

				Reset();
				_hasInitialized = false;

				Logger.LogDebug("[BotRecoveryService] 🧹 Reset on raid end.");
			}
			catch (Exception ex)
			{
				Logger.LogError("[BotRecoveryService] ❌ OnRaidEnd error: " + ex);
			}
		}

		public bool IsReady()
		{
			return _hasInitialized && GameWorldHandler.IsReady();
		}

		public WorldPhase RequiredPhase()
		{
			return WorldPhase.WorldReady;
		}

		public static void Reset()
		{
			_nextTickTime = -1f;
			_hasWarned = false;
			_hasRescanned = false;
			_hookedSpawner = false;
		}

		#endregion

		#region Tick Loop

		public void Tick(float deltaTime)
		{
			try
			{
				if (!_hasInitialized || !GameWorldHandler.IsHost || !GameWorldHandler.IsReady())
				{
					return;
				}

				float now = Time.time;
				if (now < _nextTickTime)
				{
					return;
				}

				_nextTickTime = now + TickInterval;

				GameWorld world = GameWorldHandler.Get();
				if (world == null || world.AllAlivePlayersList == null)
				{
					if (!_hasWarned)
					{
						Logger.LogWarning("[BotRecoveryService] ⚠ GameWorld not ready.");
						_hasWarned = true;
					}

					return;
				}

				if (_hasWarned)
				{
					Logger.LogDebug("[BotRecoveryService] ✅ GameWorld recovered.");
					_hasWarned = false;
				}

				EnsureSpawnHook();
				ValidateBotBrains(world.AllAlivePlayersList);
			}
			catch (Exception ex)
			{
				Logger.LogError("[BotRecoveryService] ❌ Tick error: " + ex);
			}
		}

		#endregion

		#region Spawn Hook and Bot Validation

		private static void EnsureSpawnHook()
		{
			try
			{
				if (_hookedSpawner || !Singleton<BotSpawner>.Instantiated)
				{
					return;
				}

				Singleton<BotSpawner>.Instance.OnBotCreated += GameWorldHandler.TryAttachBotBrain;
				_hookedSpawner = true;
				Logger.LogDebug("[BotRecoveryService] ✅ BotSpawner hook attached.");
			}
			catch (Exception ex)
			{
				Logger.LogError("[BotRecoveryService] ❌ EnsureSpawnHook error: " + ex);
			}
		}

		private static void ValidateBotBrains(List<Player> players)
		{
			for (int i = 0; i < players.Count; i++)
			{
				Player player = players[i];

				if (!EFTPlayerUtil.IsValid(player) || !player.IsAI || player.gameObject == null)
				{
					continue;
				}

				GameObject go = player.gameObject;
				BotBrain brain = go.GetComponent<BotBrain>();

				if (brain != null)
				{
					if (!brain.enabled)
					{
						brain.enabled = true;
						Logger.LogWarning("[BotRecoveryService] Re-enabled disabled BotBrain: " + player.ProfileId);
					}

					continue;
				}

				string botName = player.Profile?.Info?.Nickname ?? "Unknown";

				Logger.LogWarning("[BotRecoveryService] ⚠ Bot missing brain — restoring: " + botName);

				if (player.AIData != null && player.AIData.BotOwner != null)
				{
					try
					{
						GameWorldHandler.TryAttachBotBrain(player.AIData.BotOwner);
					}
					catch (Exception ex)
					{
						Logger.LogError("[BotRecoveryService] ❌ Failed to attach BotBrain to BotOwner: " + ex);
					}
				}

				if (!_hasRescanned)
				{
					_hasRescanned = true;
					RescanWorld();
				}
			}
		}

		#endregion

		#region World Refresh

		private static void RescanWorld()
		{
			try
			{
				string mapId = GameWorldHandler.TryGetValidMapName();
				if (string.IsNullOrEmpty(mapId))
				{
					Logger.LogWarning("[BotRecoveryService] ❌ Rescan aborted — invalid or missing mapId.");
					return;
				}

				Logger.LogDebug("[BotRecoveryService] 🔄 Rescanning world systems for map: " + mapId);

				HotspotRegistry.Clear();
				HotspotRegistry.Initialize(mapId);

				LootRegistry.Clear();
				LootBootstrapper.RegisterAllLoot();
				BotDeadBodyScanner.ScanAll();

				NavPointRegistry.Clear();
				NavPointRegistry.RegisterAll(mapId);

				Logger.LogDebug("[BotRecoveryService] ✅ World rescan complete.");
			}
			catch (Exception ex)
			{
				Logger.LogError("[BotRecoveryService] ❌ RescanWorld error: " + ex);
			}
		}

		#endregion
	}
}
