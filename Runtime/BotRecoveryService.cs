// <auto-generated>
//   This file is part of AI-Refactored, an open-source project focused on realistic AI behavior in Escape from Tarkov.
//   Licensed under the MIT License. See LICENSE in the repository root for more information.
//
//   THIS FILE IS SYSTEMATICALLY MANAGED.
//   Failures in AIRefactored logic must always trigger safe retry and recovery. No fallback or terminal state.
//   Bulletproof: All failures are strictly localized and cannot break the mod.
// </auto-generated>

namespace AIRefactored.Runtime
{
	using System;
	using System.Collections.Generic;
	using AIRefactored.AI.Core;
	using AIRefactored.AI.Hotspots;
	using AIRefactored.AI.Looting;
	using AIRefactored.AI.Navigation;
	using AIRefactored.AI.Threads;
	using AIRefactored.Bootstrap;
	using AIRefactored.Core;
	using BepInEx.Logging;
	using Comfort.Common;
	using EFT;
	using EFT.Game.Spawning;
	using UnityEngine;

	public sealed class BotRecoveryService : IAIWorldSystemBootstrapper
	{
		private const float TickInterval = 5f;

		private static readonly ManualLogSource Logger = Plugin.LoggerInstance;

		private static float _nextTickTime = -1f;
		private static bool _hasWarned;
		private static bool _hasRescanned;
		private static bool _hasInitialized;
		private static bool _hookedSpawner;

		public static BotRecoveryService Instance { get; } = new BotRecoveryService();

		public void Initialize()
		{
			try
			{
				Reset();
				_hasInitialized = true;
				LogDebug("[BotRecoveryService] ✅ Initialized.");
			}
			catch (Exception ex)
			{
				LogError("[BotRecoveryService] ❌ Initialize failed: " + ex);
			}
		}

		public void OnRaidEnd()
		{
			try
			{
				if (_hookedSpawner && Singleton<BotSpawner>.Instantiated)
				{
					Singleton<BotSpawner>.Instance.OnBotCreated -= GameWorldHandler.TryAttachBotBrain;
					_hookedSpawner = false;
				}

				Reset();
				_hasInitialized = false;
				LogDebug("[BotRecoveryService] 🧹 Reset on raid end.");
			}
			catch (Exception ex)
			{
				LogError("[BotRecoveryService] ❌ OnRaidEnd error: " + ex);
			}
		}

		public bool IsReady() => _hasInitialized && GameWorldHandler.IsReady();

		public WorldPhase RequiredPhase() => WorldPhase.WorldReady;

		public static void Reset()
		{
			_nextTickTime = -1f;
			_hasWarned = false;
			_hasRescanned = false;
			_hookedSpawner = false;
		}

		public void Tick(float deltaTime)
		{
			try
			{
				if (!_hasInitialized || !GameWorldHandler.IsHost || !GameWorldHandler.IsReady())
					return;

				float now = Time.time;
				if (now < _nextTickTime)
					return;

				_nextTickTime = now + TickInterval;

				GameWorld world = GameWorldHandler.Get();
				if (world == null || world.AllAlivePlayersList == null)
				{
					if (!_hasWarned)
					{
						LogWarn("[BotRecoveryService] ⚠ GameWorld not ready.");
						_hasWarned = true;
					}
					return;
				}

				if (_hasWarned)
				{
					_hasWarned = false;
					LogDebug("[BotRecoveryService] ✅ GameWorld recovered.");
				}

				EnsureSpawnHook();
				ValidateBotBrains(world.AllAlivePlayersList);
			}
			catch (Exception ex)
			{
				LogError("[BotRecoveryService] ❌ Tick error: " + ex);
			}
		}

		private static void EnsureSpawnHook()
		{
			try
			{
				if (_hookedSpawner || !Singleton<BotSpawner>.Instantiated)
					return;

				Singleton<BotSpawner>.Instance.OnBotCreated += GameWorldHandler.TryAttachBotBrain;
				_hookedSpawner = true;
				LogDebug("[BotRecoveryService] ✅ BotSpawner hook attached.");
			}
			catch (Exception ex)
			{
				LogError("[BotRecoveryService] ❌ EnsureSpawnHook error: " + ex);
			}
		}

		private static void ValidateBotBrains(List<Player> players)
		{
			for (int i = 0; i < players.Count; i++)
			{
				try
				{
					Player player = players[i];
					if (!EFTPlayerUtil.IsValid(player) || !player.IsAI || player.gameObject == null)
						continue;

					string profileId = player.ProfileId ?? player.Profile?.Id;
					if (string.IsNullOrEmpty(profileId))
						continue;

					BotBrain brain = player.gameObject.GetComponent<BotBrain>();
					if (brain != null)
					{
						if (!brain.enabled)
						{
							brain.enabled = true;
							LogWarn("[BotRecoveryService] ♻ Re-enabled disabled BotBrain: " + profileId);
						}
						continue;
					}

					if (player.AIData?.BotOwner != null)
					{
						GameWorldHandler.TryAttachBotBrain(player.AIData.BotOwner);
						LogWarn("[BotRecoveryService] ⚠ BotBrain missing — injected late for: " + (player.Profile?.Info?.Nickname ?? "Unknown"));
					}

					if (!_hasRescanned && GameWorldHandler.IsReady() && WorldInitState.IsInPhase(WorldPhase.WorldReady))
					{
						_hasRescanned = true;
						RescanWorld();
					}
				}
				catch (Exception ex)
				{
					LogError("[BotRecoveryService] ValidateBotBrains() error: " + ex);
				}
			}
		}

		private static void RescanWorld()
		{
			try
			{
				if (!GameWorldHandler.IsReady() || !WorldInitState.IsInPhase(WorldPhase.WorldReady))
				{
					LogWarn("[BotRecoveryService] ❌ Rescan aborted — world or phase not ready.");
					return;
				}

				string mapId = GameWorldHandler.TryGetValidMapName();
				if (string.IsNullOrEmpty(mapId))
				{
					LogWarn("[BotRecoveryService] ❌ Rescan aborted — mapId missing or invalid.");
					return;
				}

				LogDebug("[BotRecoveryService] 🔄 Rescanning world systems for map: " + mapId);

				HotspotRegistry.Clear();
				HotspotRegistry.Initialize(mapId);

				LootRegistry.Clear();
				LootBootstrapper.RegisterAllLoot();
				BotDeadBodyScanner.ScanAll();

				LogDebug("[BotRecoveryService] ✅ World rescan complete.");
			}
			catch (Exception ex)
			{
				LogError("[BotRecoveryService] ❌ RescanWorld error: " + ex);
			}
		}

		private static void LogDebug(string msg)
		{
			if (!FikaHeadlessDetector.IsHeadless)
				Logger.LogDebug(msg);
		}

		private static void LogWarn(string msg)
		{
			if (!FikaHeadlessDetector.IsHeadless)
				Logger.LogWarning(msg);
		}

		private static void LogError(string msg)
		{
			if (!FikaHeadlessDetector.IsHeadless)
				Logger.LogError(msg);
		}
	}
}
