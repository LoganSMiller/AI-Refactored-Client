// <auto-generated>
//   This file is part of AI-Refactored, an open-source project focused on realistic AI behavior in Escape from Tarkov.
//   Licensed under the MIT License. See LICENSE in the repository root for more information.
//
//   THIS FILE IS SYSTEMATICALLY MANAGED.
//   Please follow strict StyleCop, ReSharper, and AI-Refactored code standards for all modifications.
// </auto-generated>

#nullable enable

namespace AIRefactored.Runtime
{
    using System;
    using System.Collections;
    using System.Collections.Generic;
    using AIRefactored.AI.Core;
    using AIRefactored.Core;
    using BepInEx.Logging;
    using EFT;
    using UnityEngine;

    /// <summary>
    /// Global runtime controller for AI-Refactored.
    /// Handles deferred world bootstrap, system recovery, and coroutine utility dispatch.
    /// </summary>
    public sealed class AIRefactoredController : MonoBehaviour
    {
        #region Static Fields

        private static AIRefactoredController? _instance;
        private static ManualLogSource? _logger;
        private static readonly object LockObj = new object();

        #endregion

        #region Instance Fields

        private bool _bootstrapComplete;
        private bool _worldInitialized;

        #endregion

        #region Properties

        /// <summary>
        /// Gets the shared AI-Refactored logger instance.
        /// </summary>
        public static ManualLogSource Logger =>
            _logger ?? throw new InvalidOperationException("[AIRefactored] Logger accessed before controller initialization.");

        /// <summary>
        /// Gets a value indicating whether the controller has been initialized.
        /// </summary>
        public static bool IsInitialized => _instance != null;

        #endregion

        #region Unity Lifecycle

        private void Awake()
        {
            lock (LockObj)
            {
                if (_instance != null && _instance != this)
                {
                    Destroy(this.gameObject);
                    return;
                }

                _instance = this;
                DontDestroyOnLoad(this.gameObject);
            }

            Logger?.LogInfo("[AIRefactored] [Awake] Initialization started.");
        }

        private void OnDestroy()
        {
            lock (LockObj)
            {
                if (_instance == this)
                {
                    _instance = null;
                    _bootstrapComplete = false;
                    _worldInitialized = false;
                }
            }

            Logger?.LogInfo("[AIRefactored] [OnDestroy] Controller destroyed.");
        }

        #endregion

        #region Initialization

        /// <summary>
        /// Initializes the runtime AI-Refactored controller.
        /// Safe for both client-hosted and headless environments.
        /// </summary>
        /// <param name="logger">The BepInEx logger to use for diagnostics.</param>
        public static void Initialize(ManualLogSource logger)
        {
            lock (LockObj)
            {
                if (_instance != null)
                {
                    logger.LogWarning("[AIRefactored] [Init] Runtime controller already active — skipping duplicate initialization.");
                    return;
                }

                _logger = logger ?? throw new ArgumentNullException(nameof(logger));

                GameObject host = new GameObject("AIRefactoredController");
                _instance = host.AddComponent<AIRefactoredController>();
                DontDestroyOnLoad(host);

                _logger.LogInfo("[AIRefactored] [Init] Runtime controller initialized. Awaiting GameWorld...");

                _instance.StartCoroutine(_instance.RunDeferredBootstrap());
            }
        }

        #endregion

        #region Deferred Bootstrap

        private IEnumerator RunDeferredBootstrap()
        {
            // Log to see when the bootstrap starts and if it's running in headless mode
            Logger?.LogInfo("[AIRefactored] [RunDeferredBootstrap] Starting bootstrap process.");

            // Instead of retrying, we wait for the game world to be ready before proceeding
            while (!_worldInitialized && !_bootstrapComplete)
            {
                yield return null;

                // Trigger world initialization check only when relevant game states are ready.
                if (GameWorldHandler.IsInitialized)
                {
                    Logger?.LogInfo("[AIRefactored] [Bootstrap] GameWorld successfully initialized.");
                    _worldInitialized = true;
                    _bootstrapComplete = true; // Set bootstrap as complete when the world is initialized
                    break;
                }
            }

            if (!_bootstrapComplete)
            {
                Logger?.LogError("[AIRefactored] [Bootstrap] Failed to initialize GameWorld.");
            }
        }

        #endregion

        #region Utility

        /// <summary>
        /// Executes a coroutine from any static context using the controller instance.
        /// </summary>
        /// <param name="routine">Coroutine routine to run.</param>
        public static void RunCoroutine(IEnumerator routine)
        {
            lock (LockObj)
            {
                if (_instance != null)
                {
                    _instance.StartCoroutine(routine);
                }
                else if (_logger != null)
                {
                    _logger.LogError("[AIRefactored] [RunCoroutine] Cannot execute coroutine — controller not initialized.");
                }
            }
        }

        /// <summary>
        /// Attempts to get the controller instance.
        /// </summary>
        /// <param name="controller">The current instance, or null if not initialized.</param>
        /// <returns>True if initialized, false otherwise.</returns>
        public static bool TryGetInstance(out AIRefactoredController? controller)
        {
            lock (LockObj)
            {
                controller = _instance;
                return controller != null;
            }
        }

        #endregion
    }
}
