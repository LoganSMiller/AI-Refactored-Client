// <auto-generated>
//   This file is part of AI-Refactored, an open-source project focused on realistic AI behavior in Escape from Tarkov.
//   Licensed under the MIT License. See LICENSE in the repository root for more information.
//
//   THIS FILE IS SYSTEMATICALLY MANAGED.
//   Please follow strict StyleCop, ReSharper, and AI-Refactored code standards for all modifications.
// </auto-generated>

#nullable enable

namespace AIRefactored.Runtime
{
    using System;
    using System.Collections;
    using BepInEx.Logging;
    using EFT;
    using UnityEngine;
    using AIRefactored.Core;

    /// <summary>
    /// Global runtime controller for AI-Refactored.
    /// Handles deferred world bootstrap, system recovery, and coroutine utility dispatch.
    /// </summary>
    public sealed class AIRefactoredController : MonoBehaviour
    {
        #region Static Fields

        private static AIRefactoredController? _instance;
        private static ManualLogSource? _logger;
        private static readonly object LockObj = new object();
        private static volatile bool _bootstrapStarted;
        private static GameObject? _host;

        #endregion

        #region Instance Fields

        private bool _bootstrapComplete;
        private bool _worldInitialized;

        #endregion

        #region Properties

        public static ManualLogSource Logger =>
            _logger ?? throw new InvalidOperationException("[AIRefactored] Logger accessed before controller initialization.");

        public static bool IsInitialized => _instance != null;

        #endregion

        #region Unity Lifecycle

        private void Awake()
        {
            lock (LockObj)
            {
                // If we already have a different instance, destroy this one.
                if (_instance != null && _instance != this)
                {
                    Destroy(this.gameObject);
                    return;
                }

                _instance = this;
                DontDestroyOnLoad(this.gameObject);
            }

            Logger.LogInfo("[AIRefactored] [Awake] Controller instance active.");
        }

        private void OnDestroy()
        {
            lock (LockObj)
            {
                if (_instance == this)
                {
                    _instance = null;
                    _bootstrapStarted = false;

                    // If this GameObject was our host, clear the reference
                    if (_host == this.gameObject)
                    {
                        _host = null;
                    }
                }
            }

            _bootstrapComplete = false;
            _worldInitialized = false;

            Logger.LogInfo("[AIRefactored] [OnDestroy] Controller destroyed.");
        }

        #endregion

        #region Initialization

        /// <summary>
        /// Initializes the runtime AI-Refactored controller.
        /// Safe for both client-hosted and headless environments.
        /// </summary>
        public static void Initialize(ManualLogSource logger)
        {
            lock (LockObj)
            {
                if (_instance != null)
                {
                    logger.LogWarning("[AIRefactored] [Init] Controller already initialized — skipping.");
                    return;
                }

                if (_host != null)
                {
                    logger.LogWarning("[AIRefactored] [Init] Host GameObject already exists — skipping.");
                    return;
                }

                _logger = logger ?? throw new ArgumentNullException(nameof(logger));

                // Create exactly one host GameObject and attach the controller
                _host = new GameObject("AIRefactoredController");
                DontDestroyOnLoad(_host);
                _instance = _host.AddComponent<AIRefactoredController>();

                _logger.LogInfo("[AIRefactored] [Init] Controller created — starting deferred bootstrap.");

                if (!_bootstrapStarted)
                {
                    _bootstrapStarted = true;
                    _instance.StartCoroutine(_instance.RunDeferredBootstrap());
                }
            }
        }

        #endregion

        #region Deferred Bootstrap

        private IEnumerator RunDeferredBootstrap()
        {
            Logger.LogInfo("[AIRefactored] [RunDeferredBootstrap] Starting...");

            while (!_worldInitialized && !_bootstrapComplete)
            {
                yield return null;

                if (GameWorldHandler.IsInitialized)
                {
                    Logger.LogInfo("[AIRefactored] [Bootstrap] GameWorld initialized successfully.");
                    _worldInitialized = true;
                    _bootstrapComplete = true;
                    yield break;
                }
            }

            if (!_bootstrapComplete)
            {
                Logger.LogError("[AIRefactored] [Bootstrap] World initialization never completed.");
            }
        }

        #endregion

        #region Utility

        /// <summary>
        /// Executes a coroutine from any static context using the controller instance.
        /// </summary>
        /// <param name="routine">Coroutine routine to run.</param>
        public static void RunCoroutine(IEnumerator routine)
        {
            lock (LockObj)
            {
                if (_instance != null)
                {
                    _instance.StartCoroutine(routine);
                }
                else if (_logger != null)
                {
                    _logger.LogError("[AIRefactored] [RunCoroutine] Cannot execute coroutine — controller not initialized.");
                }
            }
        }

        /// <summary>
        /// Attempts to get the controller instance.
        /// </summary>
        /// <param name="controller">Outputs the current instance if initialized.</param>
        /// <returns>True if initialized; false otherwise.</returns>
        public static bool TryGetInstance(out AIRefactoredController? controller)
        {
            lock (LockObj)
            {
                controller = _instance;
                return controller != null;
            }
        }

        #endregion
    }
}
