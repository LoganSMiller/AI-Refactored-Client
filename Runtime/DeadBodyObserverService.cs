// <auto-generated>
//   This file is part of AI-Refactored, an open-source project focused on realistic AI behavior in Escape from Tarkov.
//   Licensed under the MIT License. See LICENSE in the repository root for more information.
//
//   THIS FILE IS SYSTEMATICALLY MANAGED.
//   Please follow strict StyleCop, ReSharper, and AI-Refactored code standards for all modifications.
// </auto-generated>

namespace AIRefactored.Runtime
{
	using System;
	using System.Collections.Generic;
	using AIRefactored.AI.Core;
	using AIRefactored.AI.Looting;
	using AIRefactored.Bootstrap;
	using AIRefactored.Core;
	using AIRefactored.Pools;
	using BepInEx.Logging;
	using EFT;
	using EFT.Interactive;
	using UnityEngine;

	/// <summary>
	/// Scans for dead players and associates them with nearby loot containers.
	/// Executed as a runtime service from WorldBootstrapper or BotWorkScheduler.
	/// </summary>
	public sealed class DeadBodyObserverService : IAIWorldSystemBootstrapper
	{
		#region Constants

		private const float ScanIntervalSeconds = 1.0f;
		private const float AssociationRadius = 1.5f;

		#endregion

		#region Fields

		private static readonly ManualLogSource Logger = Plugin.LoggerInstance;

		private static LootableContainer[] _containers = Array.Empty<LootableContainer>();
		private static float _nextScanTime = -1f;
		private static bool _containersUpdated;
		private static bool _hasLoggedReset;

		#endregion

		#region Lifecycle

		public void Initialize()
		{
			try
			{
				_hasLoggedReset = false;
				Reset();
				Logger.LogDebug("[DeadBodyObserver] Initialized.");
			}
			catch (Exception ex)
			{
				Logger.LogError("[DeadBodyObserver] Initialize failed: " + ex);
			}
		}

		public void Tick(float deltaTime)
		{
			try
			{
				if (!Application.isPlaying || !GameWorldHandler.IsInitialized || !GameWorldHandler.IsHost || !GameWorldHandler.IsReady())
				{
					return;
				}

				float now = Time.time;
				if (now < _nextScanTime)
				{
					return;
				}

				_nextScanTime = now + ScanIntervalSeconds;

				if (!_containersUpdated)
				{
					try
					{
						_containers = UnityEngine.Object.FindObjectsOfType<LootableContainer>();
						_containersUpdated = true;
						Logger.LogDebug("[DeadBodyObserver] Found " + _containers.Length + " lootable containers.");
					}
					catch (Exception ex)
					{
						Logger.LogError("[DeadBodyObserver] Failed to find containers: " + ex);
						return;
					}
				}

				if (_containers.Length == 0)
				{
					return;
				}

				List<Player> players = GameWorldHandler.GetAllAlivePlayers();
				if (players == null || players.Count == 0)
				{
					return;
				}

				List<Player> validPlayers = TempListPool.Rent<Player>();

				try
				{
					for (int i = 0; i < players.Count; i++)
					{
						Player p = players[i];
						if (EFTPlayerUtil.IsValid(p))
						{
							validPlayers.Add(p);
						}
					}

					for (int i = 0; i < validPlayers.Count; i++)
					{
						Player player = validPlayers[i];
						if (player == null || player.HealthController == null || player.HealthController.IsAlive)
						{
							continue;
						}

						string profileId = player.ProfileId;
						if (string.IsNullOrEmpty(profileId) || DeadBodyContainerCache.Contains(profileId))
						{
							continue;
						}

						Vector3 corpsePosition = EFTPlayerUtil.GetPosition(player);
						Transform root = player.Transform != null ? player.Transform.Original?.root : null;
						if (root == null)
						{
							continue;
						}

						for (int j = 0; j < _containers.Length; j++)
						{
							LootableContainer container = _containers[j];
							if (container == null || !container.enabled || container.transform == null)
							{
								continue;
							}

							bool isRootMatch = container.transform.root == root;
							bool isNearby = Vector3.Distance(container.transform.position, corpsePosition) <= AssociationRadius;

							if (isRootMatch || isNearby)
							{
								DeadBodyContainerCache.Register(player, container);
								string nickname = player.Profile != null && player.Profile.Info != null && !string.IsNullOrEmpty(player.Profile.Info.Nickname)
									? player.Profile.Info.Nickname
									: "Unnamed";

								Logger.LogDebug("[DeadBodyObserver] Associated container with dead bot: " + nickname);
								break;
							}
						}
					}
				}
				catch (Exception ex)
				{
					Logger.LogError("[DeadBodyObserver] Tick scan error: " + ex);
				}
				finally
				{
					TempListPool.Return(validPlayers);
					TempListPool.Return(players);
				}
			}
			catch (Exception ex)
			{
				Logger.LogError("[DeadBodyObserver] Tick outer error: " + ex);
			}
		}

		public void OnRaidEnd()
		{
			try
			{
				Reset();
			}
			catch (Exception ex)
			{
				Logger.LogError("[DeadBodyObserver] OnRaidEnd error: " + ex);
			}
		}

		public static void Reset()
		{
			if (_hasLoggedReset)
			{
				return;
			}

			_nextScanTime = -1f;
			_containers = Array.Empty<LootableContainer>();
			_containersUpdated = false;
			_hasLoggedReset = true;

			try
			{
				Logger.LogDebug("[DeadBodyObserver] Reset.");
			}
			catch
			{
				// Logger may be null at teardown
			}
		}

		public bool IsReady()
		{
			return true;
		}

		public WorldPhase RequiredPhase()
		{
			return WorldPhase.WorldReady;
		}

		#endregion
	}
}
