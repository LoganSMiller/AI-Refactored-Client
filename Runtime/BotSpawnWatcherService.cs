// <auto-generated>
//   AI-Refactored: BotSpawnWatcherService.cs (Ultimate Parity & Bulletproof Injection Edition, June 2025)
//   Enforces robust, atomic, and headless/client-identical BotBrain/Owner injection for all bots.
//   Bulletproof: Strict retries, never disables, zero invalid field access, no log spam, multiplayer/headless safe.
//   MIT License.
// </auto-generated>

namespace AIRefactored.Runtime
{
	using System;
	using System.Collections.Generic;
	using AIRefactored.AI.Core;
	using AIRefactored.AI.Navigation;
	using AIRefactored.AI.Threads;
	using AIRefactored.Bootstrap;
	using AIRefactored.Core;
	using BepInEx.Logging;
	using Comfort.Common;
	using EFT;
	using UnityEngine;

	/// <summary>
	/// Bulletproof, headless-safe wiring system for BotBrain, BotComponentCache, and AIRefactoredBotOwner.
	/// Runs only in WorldReady phase and retries up to N times for late bots.
	/// </summary>
	public sealed class BotSpawnWatcherService : IAIWorldSystemBootstrapper
	{
		private const float PollInterval = 1.5f;
		private const int MaxRetriesPerBot = 12;

		private static readonly HashSet<int> SeenBotIds = new HashSet<int>();
		private static readonly HashSet<string> SeenProfileIds = new HashSet<string>();
		private static readonly Dictionary<string, int> RetryCounts = new Dictionary<string, int>();
		private static readonly ManualLogSource Logger = Plugin.LoggerInstance;

		private static float _nextPollTime = -1f;

		public void Initialize() => Reset();
		public void OnRaidEnd() => Reset();

		public static void Reset()
		{
			SeenBotIds.Clear();
			SeenProfileIds.Clear();
			RetryCounts.Clear();
			_nextPollTime = -1f;
		}

		public void Tick(float deltaTime)
		{
			try
			{
				if (!GameWorldHandler.IsHost || !GameWorldHandler.IsInitialized || !GameWorldHandler.IsReady() || !WorldInitState.IsInPhase(WorldPhase.WorldReady))
					return;

				float now = Time.time;
				if (now < _nextPollTime)
					return;
				_nextPollTime = now + PollInterval;

				List<Player> players = GameWorldHandler.GetAllAlivePlayers();
				if (players == null || players.Count == 0)
					return;

				for (int i = 0; i < players.Count; i++)
				{
					Player player = players[i];
					if (!EFTPlayerUtil.IsValid(player) || !player.IsAI || player.gameObject == null || player.HealthController == null || !player.HealthController.IsAlive)
						continue;

					GameObject go = player.gameObject;
					int instanceId = go.GetInstanceID();
					string profileId = player.ProfileId ?? player.Profile?.Id;

					if (!SeenBotIds.Contains(instanceId)) SeenBotIds.Add(instanceId);
					if (!string.IsNullOrEmpty(profileId) && !SeenProfileIds.Contains(profileId)) SeenProfileIds.Add(profileId);
					if (RetryCounts.TryGetValue(profileId, out int retries) && retries >= MaxRetriesPerBot)
						continue;

					if (go.GetComponent<BotBrain>() != null)
						continue;

					BotOwner botOwner = player.AIData?.BotOwner;
					if (botOwner == null)
					{
						IncrementRetry(profileId);
						continue;
					}

					BotComponentCache cache = BotComponentCacheRegistry.GetOrCreate(botOwner);
					if (cache == null)
					{
						IncrementRetry(profileId);
						continue;
					}

					cache.Initialize(botOwner);

					var owner = cache.AIRefactoredBotOwner;
					if (owner == null)
					{
						IncrementRetry(profileId);
						continue;
					}

					if (!owner.HasPersonality())
						owner.InitProfile(owner.PersonalityProfile, owner.PersonalityName);

					BotBrainGuardian.Enforce(go);
					GameWorldHandler.TryAttachBotBrain(botOwner);
				}
			}
			catch (Exception ex)
			{
				Logger.LogError("[BotSpawnWatcher] Tick() error: " + ex);
			}
		}

		public bool IsReady() => WorldInitState.IsInPhase(WorldPhase.WorldReady);
		public WorldPhase RequiredPhase() => WorldPhase.WorldReady;

		private static void IncrementRetry(string profileId)
		{
			if (string.IsNullOrEmpty(profileId))
				return;
			if (!RetryCounts.ContainsKey(profileId))
				RetryCounts[profileId] = 0;
			RetryCounts[profileId]++;
		}
	}
}
