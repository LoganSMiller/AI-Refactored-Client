// <auto-generated>
//   This file is part of AI-Refactored, an open-source project focused on realistic AI behavior in Escape from Tarkov.
//   Licensed under the MIT License. See LICENSE in the repository root for more information.
//
//   THIS FILE IS SYSTEMATICALLY MANAGED.
//   Please follow strict StyleCop, ReSharper, and AI-Refactored code standards for all modifications.
// </auto-generated>

namespace AIRefactored.Runtime
{
    using System;
    using System.Collections.Generic;
    using AIRefactored.AI;
    using AIRefactored.AI.Core;
    using AIRefactored.AI.Threads;
    using AIRefactored.Bootstrap;
    using AIRefactored.Core;
    using BepInEx.Logging;
    using EFT;
    using UnityEngine;

    /// <summary>
    /// Static bot spawn tracker. Injects brains for new bots without using MonoBehaviours.
    /// Called externally on update by WorldBootstrapper or BotWorkScheduler.
    /// </summary>
    public sealed class BotSpawnWatcherService : IAIWorldSystemBootstrapper
    {
        private const float PollInterval = 1.5f;

        private static readonly HashSet<int> SeenBotIds = new HashSet<int>();
        private static readonly ManualLogSource Logger = Plugin.LoggerInstance;

        private static float _nextPollTime = -1f;
        private static bool _hasWarnedInvalid;

        public static BotSpawnWatcherService Instance { get; } = new BotSpawnWatcherService();

        public void Initialize()
        {
            try
            {
                Reset();
                Logger.LogInfo("[BotSpawnWatcher] Initialized.");
            }
            catch (Exception ex)
            {
                Logger.LogError("[BotSpawnWatcher] Initialize failed: " + ex);
            }
        }

        public void Tick(float deltaTime)
        {
            try
            {
                if (!FikaHeadlessDetector.IsReady || !GameWorldHandler.IsSafeToInitialize || !GameWorldHandler.IsInitialized || !GameWorldHandler.IsLocalHost())
                {
                    return;
                }

                if (!GameWorldHandler.IsReady())
                {
                    if (!_hasWarnedInvalid)
                    {
                        Logger.LogWarning("[BotSpawnWatcher] GameWorld not ready — deferring.");
                        _hasWarnedInvalid = true;
                    }

                    return;
                }

                if (_hasWarnedInvalid)
                {
                    Logger.LogInfo("[BotSpawnWatcher] World is now ready. Resuming.");
                    _hasWarnedInvalid = false;
                }

                float now = Time.time;
                if (now < _nextPollTime)
                {
                    return;
                }

                _nextPollTime = now + PollInterval;

                List<Player> players = GameWorldHandler.GetAllAlivePlayers();
                if (players.Count == 0)
                {
                    return;
                }

                for (int i = 0; i < players.Count; i++)
                {
                    Player player = players[i];
                    if (player == null || !player.IsAI)
                    {
                        continue;
                    }

                    GameObject go = player.gameObject;
                    if (go == null)
                    {
                        continue;
                    }

                    int id = go.GetInstanceID();
                    if (!SeenBotIds.Add(id))
                    {
                        continue;
                    }

                    if (go.GetComponent<BotBrain>() != null)
                    {
                        continue;
                    }

                    if (player.AIData == null || player.AIData.BotOwner == null || player.Profile == null)
                    {
                        Logger.LogWarning("[BotSpawnWatcher] Skipped bot — missing AIData or Profile: " + player.name);
                        continue;
                    }

                    try
                    {
                        BotOwner owner = player.AIData.BotOwner;
                        string profileId = player.Profile.Id;

                        BotPersonalityProfile personality = BotPersonalityPresets.GenerateProfile(PersonalityType.Balanced);
                        BotRegistry.Register(profileId, personality);

                        BotBrain brain = go.AddComponent<BotBrain>();
                        brain.Initialize(owner);

                        string nickname = player.Profile.Info != null ? player.Profile.Info.Nickname : "Unnamed";
                        Logger.LogDebug("[BotSpawnWatcher] Brain injected for bot: " + nickname);
                    }
                    catch (Exception ex)
                    {
                        Logger.LogError("[BotSpawnWatcher] Brain injection failed: " + ex);
                    }
                }
            }
            catch (Exception ex)
            {
                Logger.LogError("[BotSpawnWatcher] Tick error: " + ex);
            }
        }

        public void OnRaidEnd()
        {
            try
            {
                Reset();
            }
            catch (Exception ex)
            {
                Logger.LogError("[BotSpawnWatcher] OnRaidEnd error: " + ex);
            }
        }

        public static void Reset()
        {
            SeenBotIds.Clear();
            _nextPollTime = -1f;
            _hasWarnedInvalid = false;

            try
            {
                Logger.LogInfo("[BotSpawnWatcher] Reset.");
            }
            catch
            {
                // Silent fail: logger not ready
            }
        }

        public bool IsReady()
        {
            return true;
        }

        public WorldPhase RequiredPhase()
        {
            return WorldPhase.WorldReady;
        }
    }
}
