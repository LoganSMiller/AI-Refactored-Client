// <auto-generated>
//   This file is part of AI-Refactored, an open-source project focused on realistic AI behavior in Escape from Tarkov.
//   Licensed under the MIT License. See LICENSE in the repository root for more information.
//
//   THIS FILE IS SYSTEMATICALLY MANAGED.
//   Please follow strict StyleCop, ReSharper, and AI-Refactored code standards for all modifications.
// </auto-generated>

#nullable enable

namespace AIRefactored.AI.Groups
{
    using System;
    using System.Collections.Generic;
    using System.Threading.Tasks;
    using AIRefactored.AI.Core;
    using EFT;
    using UnityEngine;
    using Random = UnityEngine.Random;

    /// <summary>
    /// Coordinates squad-level signal sharing (loot targets, fallback points, danger events).
    /// Syncs between group members using staggered, randomized intervals.
    /// </summary>
    public sealed class BotGroupSyncCoordinator
    {
        #region Constants

        private const float BaseSyncInterval = 0.5f;
        private const float PositionEpsilon = 0.15f;

        #endregion

        #region Fields

        private static readonly List<BotOwner> TempTeammates = new List<BotOwner>(8);

        private readonly Dictionary<BotOwner, BotComponentCache> teammateCaches = new Dictionary<BotOwner, BotComponentCache>(8);

        private BotOwner? bot;
        private BotComponentCache? cache;
        private BotsGroup? group;
        private Vector3? extractPoint;
        private Vector3? fallbackPoint;
        private Vector3? lootPoint;
        private float nextSyncTime;

        #endregion

        #region Properties

        /// <summary>
        /// Gets the last broadcast danger timestamp.
        /// </summary>
        public float LastDangerBroadcastTime { get; private set; } = -999f;

        /// <summary>
        /// Gets the last danger broadcasted position.
        /// </summary>
        public Vector3 LastDangerPosition { get; private set; }

        #endregion

        #region Public Methods

        /// <summary>
        /// Initializes the group sync for the specified bot.
        /// </summary>
        /// <param name="botOwner">The bot owner instance.</param>
        public void Initialize(BotOwner botOwner)
        {
            this.bot = botOwner ?? throw new ArgumentNullException(nameof(botOwner));
            this.group = botOwner.BotsGroup;

            if (this.bot.GetPlayer?.IsAI != true || this.group == null)
            {
                return;
            }

            this.group.OnMemberAdd += this.OnMemberAdded;
            this.group.OnMemberRemove += this.OnMemberRemoved;
        }

        /// <summary>
        /// Injects the local bot cache.
        /// </summary>
        /// <param name="localCache">The bot's cache instance.</param>
        public void InjectLocalCache(BotComponentCache localCache)
        {
            this.cache = localCache ?? throw new ArgumentNullException(nameof(localCache));
        }

        /// <summary>
        /// Injects a teammate cache into the squad system.
        /// </summary>
        /// <param name="owner">The teammate's bot owner.</param>
        /// <param name="teammateCache">The teammate's cache.</param>
        public void InjectTeammateCache(BotOwner owner, BotComponentCache teammateCache)
        {
            if (owner == null || teammateCache == null || this.teammateCaches.ContainsKey(owner))
            {
                return;
            }

            this.teammateCaches[owner] = teammateCache;
        }

        /// <summary>
        /// Broadcasts a squad fallback point.
        /// </summary>
        /// <param name="point">The fallback point to broadcast.</param>
        public void BroadcastFallbackPoint(Vector3 point)
        {
            this.fallbackPoint = point;

            foreach (var teammate in this.teammateCaches.Values)
            {
                teammate.Combat?.TriggerFallback(point);

                if (teammate.PanicHandler != null && !teammate.PanicHandler.IsPanicking)
                {
                    teammate.PanicHandler.TriggerPanic();
                }
            }
        }

        /// <summary>
        /// Broadcasts a squad extraction point.
        /// </summary>
        /// <param name="point">The extraction point.</param>
        public void BroadcastExtractPoint(Vector3 point)
        {
            this.extractPoint = point;
        }

        /// <summary>
        /// Broadcasts a loot target to the squad.
        /// </summary>
        /// <param name="point">The loot target position.</param>
        public void BroadcastLootPoint(Vector3 point)
        {
            this.lootPoint = point;
        }

        /// <summary>
        /// Broadcasts a squad-wide danger event.
        /// </summary>
        /// <param name="position">The position of the danger.</param>
        public void BroadcastDanger(Vector3 position)
        {
            this.LastDangerBroadcastTime = Time.time;
            this.LastDangerPosition = position;

            foreach (var cacheEntry in this.teammateCaches.Values)
            {
                if (cacheEntry?.PanicHandler != null && !cacheEntry.PanicHandler.IsPanicking)
                {
                    var delay = Random.Range(0.1f, 0.35f);
                    FireDelayedPanic(cacheEntry, delay);
                }
            }
        }

        /// <summary>
        /// Returns whether the squad has functional members.
        /// </summary>
        public bool IsSquadReady()
        {
            return this.bot != null && this.group != null && this.teammateCaches.Count > 0;
        }

        /// <summary>
        /// Prints basic squad state information.
        /// </summary>
        public void PrintSquadState()
        {
            Debug.Log(
                $"[GroupSync] Bot: {this.bot?.Profile?.Info?.Nickname ?? "Unknown"}, SquadSize: {this.teammateCaches.Count}, Fallback: {this.fallbackPoint}, Loot: {this.lootPoint}");
        }

        /// <summary>
        /// Called each frame to sync fallback or danger data.
        /// </summary>
        /// <param name="time">The current time.</param>
        public void Tick(float time)
        {
            if (this.cache?.Bot?.GetPlayer?.IsAI != true || this.teammateCaches.Count == 0)
            {
                return;
            }

            if (time < this.nextSyncTime)
            {
                return;
            }

            this.nextSyncTime = time + (BaseSyncInterval * Random.Range(0.8f, 1.2f));

            if (this.cache.PanicHandler?.IsPanicking != true || this.bot == null)
            {
                return;
            }

            var myPos = this.bot.Position;

            if (!this.fallbackPoint.HasValue || Vector3.SqrMagnitude(this.fallbackPoint.Value - myPos) > (PositionEpsilon * PositionEpsilon))
            {
                this.BroadcastFallbackPoint(myPos);
            }

            if (Vector3.SqrMagnitude(this.LastDangerPosition - myPos) > (PositionEpsilon * PositionEpsilon))
            {
                this.BroadcastDanger(myPos);
            }
        }

        /// <summary>
        /// Gets the local bot cache of a squadmate.
        /// </summary>
        /// <param name="teammate">The squadmate.</param>
        /// <returns>Bot cache if available; otherwise null.</returns>
        public BotComponentCache? GetCache(BotOwner teammate)
        {
            return this.teammateCaches.TryGetValue(teammate, out var cacheFound) ? cacheFound : null;
        }

        /// <summary>
        /// Gets the squad's shared fallback point, if any.
        /// </summary>
        public Vector3? GetSharedFallbackTarget()
        {
            return this.fallbackPoint;
        }

        /// <summary>
        /// Gets the squad's shared loot target, if any.
        /// </summary>
        public Vector3? GetSharedLootTarget()
        {
            return this.lootPoint;
        }

        /// <summary>
        /// Gets the squad's shared extraction point, if any.
        /// </summary>
        public Vector3? GetSharedExtractTarget()
        {
            return this.extractPoint;
        }

        /// <summary>
        /// Returns the active teammates (alive, AI, not dead).
        /// </summary>
        public IReadOnlyList<BotOwner> GetTeammates()
        {
            TempTeammates.Clear();

            foreach (var kv in this.teammateCaches)
            {
                var mate = kv.Key;
                if (mate != null && !mate.IsDead && mate.GetPlayer?.IsAI == true)
                {
                    TempTeammates.Add(mate);
                }
            }

            return TempTeammates;
        }

        #endregion

        #region Private Methods

        private static void FireDelayedPanic(BotComponentCache cache, float delay)
        {
            Task.Run(async () =>
            {
                await Task.Delay((int)(delay * 1000f));

                if (cache.Bot?.IsDead == false)
                {
                    cache.PanicHandler?.TriggerPanic();
                }
            });
        }

        /// <summary>
        /// Called when a new teammate joins the squad. Registers their cache for group sync.
        /// </summary>
        /// <param name="teammate">The new BotOwner teammate.</param>
        private void OnMemberAdded(BotOwner teammate)
        {
            if (teammate == null)
            {
                return;
            }

            if (this.bot == null || teammate == this.bot)
            {
                return;
            }

            if (this.teammateCaches.ContainsKey(teammate))
            {
                return;
            }

            if (teammate.GetPlayer?.IsAI != true || teammate.IsDead)
            {
                return;
            }

            var refactoredOwner = BotRegistry.TryGetRefactoredOwner(teammate.ProfileId);
            if (refactoredOwner == null)
            {
                return;
            }

            var cache = new BotComponentCache();
            cache.Initialize(teammate);
            cache.SetOwner(refactoredOwner);
            this.teammateCaches.Add(teammate, cache);
        }

        private void OnMemberRemoved(BotOwner teammate)
        {
            this.teammateCaches.Remove(teammate);
        }

        #endregion
    }
}
