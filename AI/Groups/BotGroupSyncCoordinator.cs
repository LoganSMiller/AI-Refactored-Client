// <auto-generated>
//   AI-Refactored: BotGroupSyncCoordinator.cs (Beyond Diamond, BotBrain Edition)
//   All squad sync, fallback, danger, and loot sharing logic is strictly BotBrain tick-driven.
//   No timers, coroutines, or async logic outside BotBrain. All errors are strictly local.
//   MIT License.
// </auto-generated>

namespace AIRefactored.AI.Groups
{
    using System;
    using System.Collections.Generic;
    using AIRefactored.AI.Core;
    using AIRefactored.Core;
    using AIRefactored.Pools;
    using EFT;
    using UnityEngine;

    /// <summary>
    /// Coordinates squad-level fallback, loot, extract, and panic signal sharing.
    /// All sync is handled in BotBrain's tick, never internally.
    /// Bulletproof: No error propagates; all allocations use pooling.
    /// Fully humanized: All signal sharing, fallback, and loot arbitration is squad-aware, personality-influenced, and error-resilient.
    /// </summary>
    public sealed class BotGroupSyncCoordinator
    {
        #region Constants

        private const float BaseSyncInterval = 0.5f;
        private const float PositionEpsilonSqr = 0.0225f;
        private const float DangerResendTime = 4.2f;
        private const float FallbackResendTime = 3.0f;
        private const float MaxSyncJitter = 0.16f;

        #endregion

        #region Fields

        private readonly Dictionary<BotOwner, BotComponentCache> _teammateCaches = new Dictionary<BotOwner, BotComponentCache>(8);

        private BotOwner _bot;
        private BotComponentCache _cache;
        private BotsGroup _group;

        private Vector3 _fallbackPoint;
        private float _lastFallbackSendTime;
        private bool _hasFallback;

        private Vector3 _lootPoint;
        private float _lastLootSendTime;
        private bool _hasLoot;

        private Vector3 _extractPoint;
        private float _lastExtractSendTime;
        private bool _hasExtract;

        private float _lastDangerBroadcastTime;
        private Vector3 _lastDangerPosition;

        private float _nextSyncTime;

        #endregion

        #region Properties

        public float LastDangerBroadcastTime => _lastDangerBroadcastTime;
        public Vector3 LastDangerPosition => _lastDangerPosition;
        public bool IsActive => _bot != null && !_bot.IsDead && _group != null && _cache != null;

        /// <summary>
        /// Indicates if squad loot arbitration is supported by this coordinator.
        /// </summary>
        public bool SupportsLootPoint => true;

        #endregion

        #region Initialization

        /// <summary>
        /// Wires this coordinator for a bot and squad. Should be called from BotBrain init only.
        /// </summary>
        public void Initialize(BotOwner botOwner)
        {
            try
            {
                _bot = botOwner;
                _group = botOwner?.BotsGroup;
                if (_group == null) throw new ArgumentException("[BotGroupSyncCoordinator] BotsGroup is null.");
                _group.OnMemberAdd += OnMemberAdded;
                _group.OnMemberRemove += OnMemberRemoved;
                ResetSync();
            }
            catch
            {
                _bot = null;
                _group = null;
                ResetSync();
            }
        }

        public void InjectLocalCache(BotComponentCache localCache)
        {
            _cache = localCache;
        }

        public void ResetSync()
        {
            _teammateCaches.Clear();
            _fallbackPoint = Vector3.zero;
            _lootPoint = Vector3.zero;
            _extractPoint = Vector3.zero;
            _lastFallbackSendTime = -99f;
            _lastLootSendTime = -99f;
            _lastExtractSendTime = -99f;
            _hasFallback = false;
            _hasLoot = false;
            _hasExtract = false;
            _nextSyncTime = Time.time + GetSyncJitter(_bot?.ProfileId, Time.frameCount);
            _lastDangerBroadcastTime = -99f;
            _lastDangerPosition = Vector3.zero;
        }

        #endregion

        #region Public API (BotBrain Driven)

        /// <summary>
        /// Should be called every tick by BotBrain.
        /// Handles all fallback/danger/loot/extract comms.
        /// </summary>
        public void Tick(float time)
        {
            try
            {
                if (!IsActive || time < _nextSyncTime)
                    return;

                float syncJitter = GetSyncJitter(_bot.ProfileId, Time.frameCount);
                float interval = Mathf.Clamp(BaseSyncInterval * (0.91f + syncJitter), 0.41f, 0.67f);
                _nextSyncTime = time + interval;

                // Update caches for group
                RefreshTeammateCaches();

                // Fallback point sharing (fully humanized - only send if fallback recently changed or if squad is out of sync)
                if (_hasFallback && time - _lastFallbackSendTime > FallbackResendTime)
                {
                    ShareFallbackToSquad(_fallbackPoint);
                    _lastFallbackSendTime = time;
                }

                // Danger signal propagation (panic triggers)
                if (_cache?.PanicHandler != null && _cache.PanicHandler.IsPanicking)
                {
                    if ((time - _lastDangerBroadcastTime > DangerResendTime) ||
                        ((_bot.Position - _lastDangerPosition).sqrMagnitude > PositionEpsilonSqr))
                    {
                        ShareDangerToSquad(_bot.Position);
                        _lastDangerBroadcastTime = time;
                        _lastDangerPosition = _bot.Position;
                    }
                }

                // Loot/extract point arbitration (reshare if flagged; could be expanded to arbitration logic)
                if (_hasLoot && time - _lastLootSendTime > 7.0f)
                {
                    ShareLootToSquad(_lootPoint);
                    _lastLootSendTime = time;
                }

                if (_hasExtract && time - _lastExtractSendTime > 12.0f)
                {
                    ShareExtractToSquad(_extractPoint);
                    _lastExtractSendTime = time;
                }
            }
            catch { /* Strictly isolated; never breaks parent. */ }
        }

        /// <summary>
        /// Share a fallback retreat point with squad (triggered by fallback or panic).
        /// </summary>
        public void ShareFallbackToSquad(Vector3 fallback)
        {
            _fallbackPoint = fallback;
            _hasFallback = true;
            foreach (var mate in _teammateCaches.Values)
            {
                try
                {
                    if (mate?.Bot == null || mate.Bot.IsDead)
                        continue;
                    mate.Combat?.TriggerFallback(fallback);
                }
                catch { }
            }
        }

        /// <summary>
        /// Share danger (panic/alert) signal with squad.
        /// </summary>
        public void ShareDangerToSquad(Vector3 dangerPos)
        {
            _lastDangerPosition = dangerPos;
            _lastDangerBroadcastTime = Time.time;
            foreach (var mate in _teammateCaches.Values)
            {
                try
                {
                    if (mate?.Bot == null || mate.Bot.IsDead)
                        continue;
                    if (mate.PanicHandler != null && !mate.PanicHandler.IsPanicking)
                        mate.PanicHandler.TriggerPanic();
                }
                catch { }
            }
        }

        /// <summary>
        /// Share loot target point with squad for distributed looting.
        /// </summary>
        public void ShareLootToSquad(Vector3 loot)
        {
            _lootPoint = loot;
            _hasLoot = true;
            foreach (var mate in _teammateCaches.Values)
            {
                try { mate.LootScanner?.RegisterSquadLootTarget(loot); } catch { }
            }
        }

        /// <summary>
        /// Share extraction/exit target point with squad.
        /// </summary>
        public void ShareExtractToSquad(Vector3 extract)
        {
            _extractPoint = extract;
            _hasExtract = true;
            foreach (var mate in _teammateCaches.Values)
            {
                try { mate.TacticalMemory?.MarkExtractionStarted(); } catch { }
            }
        }

        #endregion

        #region Squad Queries

        public Vector3? GetSharedFallbackTarget() => _hasFallback ? (Vector3?)_fallbackPoint : null;
        public Vector3? GetSharedLootTarget() => _hasLoot ? (Vector3?)_lootPoint : null;
        public Vector3? GetSharedExtractTarget() => _hasExtract ? (Vector3?)_extractPoint : null;

        public bool IsSquadReady() => _teammateCaches.Count > 0;

        public IReadOnlyList<BotOwner> GetTeammates()
        {
            var result = TempListPool.Rent<BotOwner>();
            try
            {
                foreach (var kv in _teammateCaches)
                {
                    BotOwner bot = kv.Key;
                    if (bot != null && !bot.IsDead && bot.GetPlayer != null && bot.GetPlayer.IsAI)
                        result.Add(bot);
                }
                return result;
            }
            catch
            {
                result.Clear();
                return result;
            }
        }

        public BotComponentCache GetCache(BotOwner teammate)
        {
            if (teammate == null || !_teammateCaches.TryGetValue(teammate, out BotComponentCache cache) || cache == null)
                return BotComponentCache.Empty;
            return cache;
        }

        #endregion

        #region Internal

        private void RefreshTeammateCaches()
        {
            if (_group == null)
                return;

            for (int i = 0; i < _group.MembersCount; i++)
            {
                BotOwner member = _group.Member(i);
                if (member == null || ReferenceEquals(member, _bot) || member.IsDead)
                    continue;
                if (!_teammateCaches.ContainsKey(member))
                {
                    if (!BotRegistry.TryGetRefactoredOwner(member.ProfileId, out AIRefactoredBotOwner owner))
                        continue;
                    var cache = new BotComponentCache();
                    cache.Initialize(member);
                    cache.SetOwner(owner);
                    _teammateCaches[member] = cache;
                }
            }

            // Remove dead or departed
            var toRemove = TempListPool.Rent<BotOwner>();
            foreach (var kv in _teammateCaches)
            {
                if (kv.Key == null || kv.Key.IsDead)
                    toRemove.Add(kv.Key);
            }
            foreach (var bot in toRemove)
                _teammateCaches.Remove(bot);
            TempListPool.Return(toRemove);
        }

        private void OnMemberAdded(BotOwner teammate)
        {
            if (teammate == null || ReferenceEquals(teammate, _bot) || _teammateCaches.ContainsKey(teammate))
                return;
            if (teammate.IsDead || teammate.GetPlayer == null || !teammate.GetPlayer.IsAI)
                return;
            if (!BotRegistry.TryGetRefactoredOwner(teammate.ProfileId, out AIRefactoredBotOwner owner))
                return;
            var cache = new BotComponentCache();
            cache.Initialize(teammate);
            cache.SetOwner(owner);
            _teammateCaches[teammate] = cache;
        }

        private void OnMemberRemoved(BotOwner teammate)
        {
            _teammateCaches.Remove(teammate);
        }

        private static float GetSyncJitter(string profileId, int tick)
        {
            int hash = (profileId?.GetHashCode() ?? 0) ^ (tick * 23) ^ 0x1B27C9;
            unchecked
            {
                hash = (int)((uint)(hash ^ (hash >> 15)) * 0x85ebca6bU);
                float frac = ((int)(hash & 0xFFFF)) / 65536f;
                return frac * MaxSyncJitter;
            }
        }

        #endregion
    }
}
