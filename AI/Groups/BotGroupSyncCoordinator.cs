// <auto-generated>
//   This file is part of AI-Refactored, an open-source project focused on realistic AI behavior in Escape from Tarkov.
//   Licensed under the MIT License. See LICENSE in the repository root for more information.
//
//   THIS FILE IS SYSTEMATICALLY MANAGED.
//   Please follow strict StyleCop, ReSharper, and AI-Refactored code standards for all modifications.
// </auto-generated>

namespace AIRefactored.AI.Groups
{
    using System;
    using System.Collections.Generic;
    using System.Threading.Tasks;
    using AIRefactored.AI.Core;
    using AIRefactored.Pools;
    using EFT;
    using UnityEngine;

    /// <summary>
    /// Coordinates squad-level signal sharing (loot targets, fallback points, danger events).
    /// Syncs between group members using staggered, randomized intervals.
    /// </summary>
    public sealed class BotGroupSyncCoordinator
    {
        private const float BaseSyncInterval = 0.5f;
        private const float PositionEpsilon = 0.15f;

        private readonly Dictionary<BotOwner, BotComponentCache> _teammateCaches = new Dictionary<BotOwner, BotComponentCache>(8);

        private BotOwner _bot;
        private BotComponentCache _cache;
        private BotsGroup _group;

        private Vector3 _extractPoint;
        private Vector3 _fallbackPoint;
        private Vector3 _lootPoint;

        private bool _hasExtract;
        private bool _hasFallback;
        private bool _hasLoot;

        private float _nextSyncTime;

        public float LastDangerBroadcastTime { get; private set; }
        public Vector3 LastDangerPosition { get; private set; }

        public void Initialize(BotOwner botOwner)
        {
            if (botOwner == null || botOwner.GetPlayer == null || !botOwner.GetPlayer.IsAI)
            {
                throw new ArgumentException("BotOwner is null or invalid AI player.");
            }

            _bot = botOwner;
            _group = botOwner.BotsGroup ?? throw new ArgumentException("BotsGroup is null.");
            _group.OnMemberAdd += OnMemberAdded;
            _group.OnMemberRemove += OnMemberRemoved;

            LastDangerBroadcastTime = -999f;
        }

        public void InjectLocalCache(BotComponentCache localCache)
        {
            if (localCache == null)
            {
                throw new ArgumentNullException(nameof(localCache));
            }

            _cache = localCache;
        }

        public void BroadcastFallbackPoint(Vector3 point)
        {
            _fallbackPoint = point;
            _hasFallback = true;

            foreach (var teammate in _teammateCaches.Values)
            {
                if (!teammate.Bot.IsDead)
                {
                    teammate.Combat?.TriggerFallback(point);
                    if (!teammate.PanicHandler.IsPanicking)
                    {
                        teammate.PanicHandler.TriggerPanic();
                    }
                }
            }
        }

        public void BroadcastExtractPoint(Vector3 point)
        {
            _extractPoint = point;
            _hasExtract = true;
        }

        public void BroadcastLootPoint(Vector3 point)
        {
            _lootPoint = point;
            _hasLoot = true;
        }

        public void BroadcastDanger(Vector3 position)
        {
            LastDangerBroadcastTime = Time.time;
            LastDangerPosition = position;

            foreach (var teammate in _teammateCaches.Values)
            {
                if (!teammate.Bot.IsDead && !teammate.PanicHandler.IsPanicking)
                {
                    float delay = UnityEngine.Random.Range(0.1f, 0.35f);
                    TriggerDelayedPanic(teammate, delay);
                }
            }
        }

        public void Tick(float time)
        {
            if (!_bot.GetPlayer.IsAI || _teammateCaches.Count == 0 || time < _nextSyncTime)
            {
                return;
            }

            _nextSyncTime = time + BaseSyncInterval * UnityEngine.Random.Range(0.8f, 1.2f);
            if (!_cache.PanicHandler.IsPanicking)
            {
                return;
            }

            Vector3 myPos = _bot.Position;

            if (!_hasFallback || (_fallbackPoint - myPos).sqrMagnitude > PositionEpsilon * PositionEpsilon)
            {
                BroadcastFallbackPoint(myPos);
            }

            if ((LastDangerPosition - myPos).sqrMagnitude > PositionEpsilon * PositionEpsilon)
            {
                BroadcastDanger(myPos);
            }
        }

        public Vector3? GetSharedFallbackTarget()
        {
            return _hasFallback ? (Vector3?)_fallbackPoint : null;
        }

        public Vector3? GetSharedLootTarget()
        {
            return _hasLoot ? (Vector3?)_lootPoint : null;
        }

        public Vector3? GetSharedExtractTarget()
        {
            return _hasExtract ? (Vector3?)_extractPoint : null;
        }

        public bool IsSquadReady()
        {
            return _teammateCaches.Count > 0;
        }

        public BotComponentCache GetCache(BotOwner teammate)
        {
            BotComponentCache result;
            if (_teammateCaches.TryGetValue(teammate, out result))
            {
                return result;
            }

            throw new KeyNotFoundException("No teammate cache found for: " + teammate?.ProfileId);
        }

        public IReadOnlyList<BotOwner> GetTeammates()
        {
            List<BotOwner> list = TempListPool.Rent<BotOwner>();

            foreach (KeyValuePair<BotOwner, BotComponentCache> kvp in _teammateCaches)
            {
                BotOwner mate = kvp.Key;
                Player player = mate.GetPlayer;
                if (!mate.IsDead && player != null && player.IsAI)
                {
                    list.Add(mate);
                }
            }

            List<BotOwner> result = new List<BotOwner>(list);
            TempListPool.Return(list);

            return result;
        }

        private void OnMemberAdded(BotOwner teammate)
        {
            if (teammate == null || teammate == _bot || _teammateCaches.ContainsKey(teammate))
            {
                return;
            }

            if (teammate.IsDead || teammate.GetPlayer == null || !teammate.GetPlayer.IsAI)
            {
                return;
            }

            AIRefactoredBotOwner owner;
            if (!BotRegistry.TryGetRefactoredOwner(teammate.ProfileId, out owner))
            {
                return;
            }

            BotComponentCache cache = new BotComponentCache();
            cache.Initialize(teammate);
            cache.SetOwner(owner);

            _teammateCaches[teammate] = cache;
        }

        private void OnMemberRemoved(BotOwner teammate)
        {
            _teammateCaches.Remove(teammate);
        }

        private static void TriggerDelayedPanic(BotComponentCache cache, float delay)
        {
            Task.Run(async () =>
            {
                await Task.Delay((int)(delay * 1000f));
                if (!cache.Bot.IsDead && !cache.PanicHandler.IsPanicking)
                {
                    cache.PanicHandler.TriggerPanic();
                }
            });
        }
    }
}
