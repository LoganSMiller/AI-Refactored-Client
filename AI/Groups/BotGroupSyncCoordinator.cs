// <auto-generated>
//   AI-Refactored: BotGroupSyncCoordinator.cs (Beyond Diamond – Arbitration/Event/Fallback/Loot/Extract/SquadDanger, June 2025, Arbitration-Only Plan)
//   Squad sync is 100% BotBrain-driven, overlay/event intent-only. Never disables, never teleports, all errors locally contained.
//   Bulletproof, pooled, SPT/FIKA/headless/client safe, rooted in real EFT squad and fallback logic. MIT License.
// </auto-generated>

namespace AIRefactored.AI.Groups
{
    using System;
    using System.Collections.Generic;
    using AIRefactored.AI.Core;
    using AIRefactored.AI.Looting;
    using AIRefactored.AI.Movement;
    using AIRefactored.AI.Navigation;
    using AIRefactored.Pools;
    using AIRefactored.Core;
    using EFT;
    using UnityEngine;

    /// <summary>
    /// Coordinates all squad fallback, danger, loot, extract, and anticipation overlays.
    /// Driven 100% by BotBrain/event-only. Arbitration-only; never disables, never teleports.
    /// All errors isolated. Strictly pooled, multiplayer/headless/client safe, never allocates in hot path.
    /// </summary>
    public sealed class BotGroupSyncCoordinator
    {
        #region Constants

        private const float PositionEpsilonSqr = 0.0225f;
        private const float MaxSyncJitter = 0.16f;
        private const float DangerCooldown = 6.7f;
        private const float FallbackEchoRadius = 18.0f;
        private const float LootEchoRadius = 14.5f;
        private const float ExtractEchoRadius = 17.0f;
        private static readonly float FallbackEchoRadiusSqr = FallbackEchoRadius * FallbackEchoRadius;
        private static readonly float LootEchoRadiusSqr = LootEchoRadius * LootEchoRadius;
        private static readonly float ExtractEchoRadiusSqr = ExtractEchoRadius * ExtractEchoRadius;

        #endregion

        #region Fields

        private readonly Dictionary<BotOwner, BotComponentCache> _teammateCaches = new Dictionary<BotOwner, BotComponentCache>(8);

        private BotOwner _bot;
        private BotComponentCache _cache;
        private BotsGroup _group;

        private Vector3 _fallbackPoint;
        private bool _hasFallback;
        private Vector3 _lootPoint;
        private bool _hasLoot;
        private Vector3 _extractPoint;
        private bool _hasExtract;
        private float _lastDangerBroadcastTime;
        private Vector3 _lastDangerPosition;
        private float _lastFallbackEcho;
        private float _lastLootEcho;
        private float _lastExtractEcho;

        #endregion

        #region Properties

        public float LastDangerBroadcastTime => _lastDangerBroadcastTime;
        public Vector3 LastDangerPosition => _lastDangerPosition;
        public bool IsActive => _bot != null && !_bot.IsDead && _group != null && _cache != null;
        public bool SupportsLootPoint => true;

        #endregion

        #region Initialization

        /// <summary>
        /// Initializes the group sync coordinator for this bot and squad.
        /// </summary>
        public void Initialize(BotOwner botOwner)
        {
            _bot = botOwner;
            _group = botOwner?.BotsGroup;
            _teammateCaches.Clear();
            _fallbackPoint = Vector3.zero;
            _lootPoint = Vector3.zero;
            _extractPoint = Vector3.zero;
            _hasFallback = false;
            _hasLoot = false;
            _hasExtract = false;
            _lastDangerBroadcastTime = -99f;
            _lastDangerPosition = Vector3.zero;
            _lastFallbackEcho = -99f;
            _lastLootEcho = -99f;
            _lastExtractEcho = -99f;

            if (_group != null)
            {
                _group.OnMemberAdd += OnMemberAdded;
                _group.OnMemberRemove += OnMemberRemoved;
            }
        }

        public void InjectLocalCache(BotComponentCache localCache)
        {
            _cache = localCache;
        }

        public void ResetSync()
        {
            _teammateCaches.Clear();
            _fallbackPoint = Vector3.zero;
            _lootPoint = Vector3.zero;
            _extractPoint = Vector3.zero;
            _hasFallback = false;
            _hasLoot = false;
            _hasExtract = false;
            _lastDangerBroadcastTime = -99f;
            _lastDangerPosition = Vector3.zero;
            _lastFallbackEcho = -99f;
            _lastLootEcho = -99f;
            _lastExtractEcho = -99f;
        }

        #endregion

        #region BotBrain-Driven Sync

        /// <summary>
        /// Called from BotBrain. Refreshes squad member caches (no timers, event-only).
        /// </summary>
        public void Tick(float time)
        {
            if (!IsActive) return;
            try { RefreshTeammateCaches(); } catch { }
        }

        /// <summary>
        /// One-shot: Broadcasts fallback intent to all living squadmates (event-only, pooled, never disables/teleports).
        /// </summary>
        public void ShareFallbackToSquad(Vector3 fallback, float now)
        {
            _fallbackPoint = fallback;
            _hasFallback = true;
            if (now - _lastFallbackEcho < 1.8f)
                return;
            _lastFallbackEcho = now;

            foreach (var mate in _teammateCaches.Values)
            {
                try
                {
                    if (mate?.Bot == null || mate.Bot.IsDead) continue;
                    if ((mate.Bot.Position - fallback).sqrMagnitude < FallbackEchoRadiusSqr)
                        mate.Combat?.TriggerFallback(fallback, now);
                }
                catch { }
            }
        }

        /// <summary>
        /// One-shot: Broadcasts danger/panic to all living squadmates (event-only, pooled, never disables).
        /// </summary>
        public void ShareDangerToSquad(Vector3 dangerPos, float now)
        {
            if (now - _lastDangerBroadcastTime < DangerCooldown)
                return;

            _lastDangerPosition = dangerPos;
            _lastDangerBroadcastTime = now;

            foreach (var mate in _teammateCaches.Values)
            {
                try
                {
                    if (mate?.Bot == null || mate.Bot.IsDead) continue;
                    // Do not trigger panic if already panicking
                    if (!(mate.PanicHandler?.IsPanicking ?? true))
                        mate.PanicHandler?.TriggerPanic();
                }
                catch { }
            }
        }

        /// <summary>
        /// One-shot: Broadcasts loot intent to all living squadmates (event-only, pooled, never disables).
        /// </summary>
        public void ShareLootToSquad(Vector3 loot, float now = -1)
        {
            _lootPoint = loot;
            _hasLoot = true;
            if (now < 0) now = Time.time;
            if (now - _lastLootEcho < 1.8f)
                return;
            _lastLootEcho = now;

            foreach (var mate in _teammateCaches.Values)
            {
                try
                {
                    if (mate?.Bot == null || mate.Bot.IsDead) continue;
                    if ((mate.Bot.Position - loot).sqrMagnitude < LootEchoRadiusSqr)
                        mate.LootScanner?.RegisterSquadLootTarget(loot);
                }
                catch { }
            }
        }

        /// <summary>
        /// One-shot: Broadcasts extract intent to all living squadmates (event-only, pooled, never disables).
        /// </summary>
        public void ShareExtractToSquad(Vector3 extract, float now = -1)
        {
            _extractPoint = extract;
            _hasExtract = true;
            if (now < 0) now = Time.time;
            if (now - _lastExtractEcho < 2.1f)
                return;
            _lastExtractEcho = now;

            foreach (var mate in _teammateCaches.Values)
            {
                try
                {
                    if (mate?.Bot == null || mate.Bot.IsDead) continue;
                    if ((mate.Bot.Position - extract).sqrMagnitude < ExtractEchoRadiusSqr)
                        mate.TacticalMemory?.MarkForcedExtract();
                }
                catch { }
            }
        }

        #endregion

        #region Squad Queries

        public Vector3? GetSharedFallbackTarget() => _hasFallback ? (Vector3?)_fallbackPoint : null;
        public Vector3? GetSharedLootTarget() => _hasLoot ? (Vector3?)_lootPoint : null;
        public Vector3? GetSharedExtractTarget() => _hasExtract ? (Vector3?)_extractPoint : null;
        public bool IsSquadReady() => _teammateCaches.Count > 0;

        public IReadOnlyList<BotOwner> GetTeammates()
        {
            var result = TempListPool.Rent<BotOwner>();
            foreach (var kv in _teammateCaches)
            {
                var b = kv.Key;
                if (b != null && !b.IsDead && b.GetPlayer != null && b.GetPlayer.IsAI)
                    result.Add(b);
            }
            return result;
        }

        public BotComponentCache GetCache(BotOwner teammate)
        {
            if (teammate == null || !_teammateCaches.TryGetValue(teammate, out var cache) || cache == null)
                return BotComponentCache.Empty;
            return cache;
        }

        #endregion

        #region Internal

        /// <summary>
        /// Updates teammate cache for current squad (event-only, never disables, never allocates in hot path).
        /// </summary>
        private void RefreshTeammateCaches()
        {
            if (_group == null) return;
            for (int i = 0; i < _group.MembersCount; i++)
            {
                BotOwner member = _group.Member(i);
                if (member == null || ReferenceEquals(member, _bot) || member.IsDead) continue;
                if (!_teammateCaches.ContainsKey(member))
                {
                    if (!BotRegistry.TryGetRefactoredOwner(member.ProfileId, out var owner))
                        continue;
                    var cache = new BotComponentCache();
                    cache.Initialize(member);
                    cache.SetOwner(owner);
                    _teammateCaches[member] = cache;
                }
            }
            var toRemove = TempListPool.Rent<BotOwner>();
            foreach (var kv in _teammateCaches)
            {
                if (kv.Key == null || kv.Key.IsDead)
                    toRemove.Add(kv.Key);
            }
            foreach (var bot in toRemove)
                _teammateCaches.Remove(bot);
            TempListPool.Return(toRemove);
        }

        /// <summary>
        /// Adds new squadmate to local cache (event/overlay, bulletproof).
        /// </summary>
        private void OnMemberAdded(BotOwner teammate)
        {
            if (teammate == null || ReferenceEquals(teammate, _bot) || _teammateCaches.ContainsKey(teammate)) return;
            if (teammate.IsDead || teammate.GetPlayer == null || !teammate.GetPlayer.IsAI) return;
            if (!BotRegistry.TryGetRefactoredOwner(teammate.ProfileId, out var owner))
                return;
            var cache = new BotComponentCache();
            cache.Initialize(teammate);
            cache.SetOwner(owner);
            _teammateCaches[teammate] = cache;
        }

        /// <summary>
        /// Removes squadmate from cache (event/overlay, bulletproof).
        /// </summary>
        private void OnMemberRemoved(BotOwner teammate)
        {
            _teammateCaches.Remove(teammate);
        }

        /// <summary>
        /// Generates a micro-jitter for fallback/loot/extract intent to mimic human imperfection (deterministic by tick/profile).
        /// </summary>
        private static float GetSyncJitter(string profileId, int tick)
        {
            int hash = (profileId?.GetHashCode() ?? 0) ^ (tick * 23) ^ 0x1B27C9;
            unchecked
            {
                hash = (int)((uint)(hash ^ (hash >> 15)) * 0x85ebca6bU);
                float frac = ((int)(hash & 0xFFFF)) / 65536f;
                return frac * MaxSyncJitter;
            }
        }

        #endregion
    }
}
