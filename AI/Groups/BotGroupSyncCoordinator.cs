// <auto-generated>
//   AI-Refactored: BotGroupSyncCoordinator.cs (Beyond Diamond – Arbitration/Event/Fallback/Loot/Extract Edition, June 2025, Arbitration-Only Plan)
//   Bulletproof: Squad sync is 100% BotBrain-driven, overlay/event intent-only. No internal timers/coroutines.
//   No teleports, never disables, no side effects—fully pooled, multiplayer/headless safe.
//   All errors locally contained. Never allocates in hot path.
//   MIT License.
// </auto-generated>

namespace AIRefactored.AI.Groups
{
    using System;
    using System.Collections.Generic;
    using AIRefactored.AI.Core;
    using AIRefactored.Core;
    using AIRefactored.Pools;
    using EFT;
    using UnityEngine;

    /// <summary>
    /// Coordinates squad fallback, danger, loot, and extract signals. All sync is BotBrain/event-only.
    /// Bulletproof: overlay-only, never disables, never teleports, strictly pooled, multiplayer/headless safe.
    /// </summary>
    public sealed class BotGroupSyncCoordinator
    {
        #region Constants

        private const float PositionEpsilonSqr = 0.0225f;
        private const float MaxSyncJitter = 0.16f;

        #endregion

        #region Fields

        private readonly Dictionary<BotOwner, BotComponentCache> _teammateCaches = new Dictionary<BotOwner, BotComponentCache>(8);

        private BotOwner _bot;
        private BotComponentCache _cache;
        private BotsGroup _group;

        private Vector3 _fallbackPoint;
        private bool _hasFallback;
        private Vector3 _lootPoint;
        private bool _hasLoot;
        private Vector3 _extractPoint;
        private bool _hasExtract;
        private float _lastDangerBroadcastTime;
        private Vector3 _lastDangerPosition;

        #endregion

        #region Properties

        public float LastDangerBroadcastTime => _lastDangerBroadcastTime;
        public Vector3 LastDangerPosition => _lastDangerPosition;
        public bool IsActive => _bot != null && !_bot.IsDead && _group != null && _cache != null;
        public bool SupportsLootPoint => true;

        #endregion

        #region Initialization

        /// <summary>
        /// Initializes the group sync coordinator for this bot and squad.
        /// </summary>
        public void Initialize(BotOwner botOwner)
        {
            _bot = botOwner;
            _group = botOwner?.BotsGroup;
            _teammateCaches.Clear();
            _fallbackPoint = Vector3.zero;
            _lootPoint = Vector3.zero;
            _extractPoint = Vector3.zero;
            _hasFallback = false;
            _hasLoot = false;
            _hasExtract = false;
            _lastDangerBroadcastTime = -99f;
            _lastDangerPosition = Vector3.zero;

            if (_group != null)
            {
                _group.OnMemberAdd += OnMemberAdded;
                _group.OnMemberRemove += OnMemberRemoved;
            }
        }

        public void InjectLocalCache(BotComponentCache localCache)
        {
            _cache = localCache;
        }

        public void ResetSync()
        {
            _teammateCaches.Clear();
            _fallbackPoint = Vector3.zero;
            _lootPoint = Vector3.zero;
            _extractPoint = Vector3.zero;
            _hasFallback = false;
            _hasLoot = false;
            _hasExtract = false;
            _lastDangerBroadcastTime = -99f;
            _lastDangerPosition = Vector3.zero;
        }

        #endregion

        #region BotBrain-Driven Sync

        /// <summary>
        /// Called from BotBrain. Refreshes squad member caches (no timers).
        /// </summary>
        public void Tick(float time)
        {
            if (!IsActive) return;
            try { RefreshTeammateCaches(); } catch { }
        }

        /// <summary>
        /// One-shot: Broadcasts fallback intent to all living squadmates (event-only).
        /// </summary>
        public void ShareFallbackToSquad(Vector3 fallback, float now)
        {
            _fallbackPoint = fallback;
            _hasFallback = true;
            foreach (var mate in _teammateCaches.Values)
            {
                try
                {
                    if (mate?.Bot == null || mate.Bot.IsDead) continue;
                    mate.Combat?.TriggerFallback(fallback, now);
                }
                catch { }
            }
        }

        /// <summary>
        /// One-shot: Broadcasts danger/panic to all living squadmates (event-only).
        /// </summary>
        public void ShareDangerToSquad(Vector3 dangerPos, float now)
        {
            _lastDangerPosition = dangerPos;
            _lastDangerBroadcastTime = now;
            foreach (var mate in _teammateCaches.Values)
            {
                try
                {
                    if (mate?.Bot == null || mate.Bot.IsDead) continue;
                    if (!(mate.PanicHandler?.IsPanicking ?? true))
                        mate.PanicHandler?.TriggerPanic();
                }
                catch { }
            }
        }

        /// <summary>
        /// One-shot: Broadcasts loot intent to all living squadmates (event-only).
        /// </summary>
        public void ShareLootToSquad(Vector3 loot)
        {
            _lootPoint = loot;
            _hasLoot = true;
            foreach (var mate in _teammateCaches.Values)
            {
                try { mate.LootScanner?.RegisterSquadLootTarget(loot); } catch { }
            }
        }

        /// <summary>
        /// One-shot: Broadcasts extract intent to all living squadmates (event-only).
        /// </summary>
        public void ShareExtractToSquad(Vector3 extract)
        {
            _extractPoint = extract;
            _hasExtract = true;
            foreach (var mate in _teammateCaches.Values)
            {
                try { mate.TacticalMemory?.MarkForcedExtract(); } catch { }
            }
        }

        #endregion

        #region Squad Queries

        public Vector3? GetSharedFallbackTarget() => _hasFallback ? (Vector3?)_fallbackPoint : null;
        public Vector3? GetSharedLootTarget() => _hasLoot ? (Vector3?)_lootPoint : null;
        public Vector3? GetSharedExtractTarget() => _hasExtract ? (Vector3?)_extractPoint : null;
        public bool IsSquadReady() => _teammateCaches.Count > 0;

        public IReadOnlyList<BotOwner> GetTeammates()
        {
            var result = TempListPool.Rent<BotOwner>();
            foreach (var kv in _teammateCaches)
            {
                var b = kv.Key;
                if (b != null && !b.IsDead && b.GetPlayer != null && b.GetPlayer.IsAI)
                    result.Add(b);
            }
            return result;
        }

        public BotComponentCache GetCache(BotOwner teammate)
        {
            if (teammate == null || !_teammateCaches.TryGetValue(teammate, out var cache) || cache == null)
                return BotComponentCache.Empty;
            return cache;
        }

        #endregion

        #region Internal

        private void RefreshTeammateCaches()
        {
            if (_group == null) return;
            for (int i = 0; i < _group.MembersCount; i++)
            {
                BotOwner member = _group.Member(i);
                if (member == null || ReferenceEquals(member, _bot) || member.IsDead) continue;
                if (!_teammateCaches.ContainsKey(member))
                {
                    if (!BotRegistry.TryGetRefactoredOwner(member.ProfileId, out var owner))
                        continue;
                    var cache = new BotComponentCache();
                    cache.Initialize(member);
                    cache.SetOwner(owner);
                    _teammateCaches[member] = cache;
                }
            }
            var toRemove = TempListPool.Rent<BotOwner>();
            foreach (var kv in _teammateCaches)
            {
                if (kv.Key == null || kv.Key.IsDead)
                    toRemove.Add(kv.Key);
            }
            foreach (var bot in toRemove)
                _teammateCaches.Remove(bot);
            TempListPool.Return(toRemove);
        }

        private void OnMemberAdded(BotOwner teammate)
        {
            if (teammate == null || ReferenceEquals(teammate, _bot) || _teammateCaches.ContainsKey(teammate)) return;
            if (teammate.IsDead || teammate.GetPlayer == null || !teammate.GetPlayer.IsAI) return;
            if (!BotRegistry.TryGetRefactoredOwner(teammate.ProfileId, out var owner))
                return;
            var cache = new BotComponentCache();
            cache.Initialize(teammate);
            cache.SetOwner(owner);
            _teammateCaches[teammate] = cache;
        }

        private void OnMemberRemoved(BotOwner teammate)
        {
            _teammateCaches.Remove(teammate);
        }

        private static float GetSyncJitter(string profileId, int tick)
        {
            int hash = (profileId?.GetHashCode() ?? 0) ^ (tick * 23) ^ 0x1B27C9;
            unchecked
            {
                hash = (int)((uint)(hash ^ (hash >> 15)) * 0x85ebca6bU);
                float frac = ((int)(hash & 0xFFFF)) / 65536f;
                return frac * MaxSyncJitter;
            }
        }

        #endregion
    }
}
