// <auto-generated>
//   This file is part of AI-Refactored, an open-source project focused on realistic AI behavior in Escape from Tarkov.
//   Licensed under the MIT License. See LICENSE in the repository root for more information.
//
//   THIS FILE IS SYSTEMATICALLY MANAGED.
//   All squad offset logic is bulletproof and isolated; squad formations remain human-like and resilient.
// </auto-generated>

namespace AIRefactored.AI.Groups
{
    using AIRefactored.AI.Core;
    using EFT;
    using UnityEngine;

    /// <summary>
    /// Controls squad-based movement offsets to prevent clumping and collisions.
    /// Dynamically spaces bots based on squad size and formation pattern.
    /// Ensures organic, realistic formation drift, with minor personal error and natural squad behavior.
    /// </summary>
    public sealed class SquadPathCoordinator
    {
        #region Constants

        private const float BaseSpacing = 2.25f;
        private const float MaxSpacing = 6.5f;
        private const float MinSpacing = 1.25f;
        private const float FormationJitterRadius = 0.28f;
        private const float DriftChangeInterval = 5.7f; // Seconds
        private const float MaxDriftDistance = 0.41f;   // Max meters of personal drift from formation

        #endregion

        #region Fields

        private BotOwner _bot;
        private BotsGroup _group;
        private Vector3 _cachedOffset;
        private int _lastGroupSize;
        private bool _offsetInitialized;

        // Realistic "human error" drift
        private float _nextDriftUpdate;
        private Vector2 _driftOffset;

        #endregion

        #region Initialization

        /// <summary>
        /// Initializes the offset logic for the given bot.
        /// </summary>
        public void Initialize(BotComponentCache cache)
        {
            if (cache == null || cache.Bot == null || cache.Bot.IsDead)
            {
                _bot = null;
                _group = null;
                _offsetInitialized = false;
                _lastGroupSize = -1;
                _cachedOffset = Vector3.zero;
                _driftOffset = Vector2.zero;
                _nextDriftUpdate = 0f;
                return;
            }

            _bot = cache.Bot;
            _group = _bot.BotsGroup;

            if (_group == null)
            {
                _bot = null;
                _offsetInitialized = false;
                _lastGroupSize = -1;
                _cachedOffset = Vector3.zero;
                _driftOffset = Vector2.zero;
                _nextDriftUpdate = 0f;
                return;
            }

            _cachedOffset = Vector3.zero;
            _offsetInitialized = false;
            _lastGroupSize = -1;
            _driftOffset = Vector2.zero;
            _nextDriftUpdate = Time.realtimeSinceStartup + GetInitialDriftInterval();
        }

        #endregion

        #region Public Methods

        /// <summary>
        /// Returns an offset-adjusted destination to reduce clumping, including minor human error drift.
        /// </summary>
        public Vector3 ApplyOffsetTo(Vector3 sharedDestination)
        {
            return sharedDestination + GetCurrentOffset();
        }

        /// <summary>
        /// Gets the current assigned formation offset, including organic drift.
        /// </summary>
        public Vector3 GetCurrentOffset()
        {
            if (_bot == null || _group == null)
                return Vector3.zero;

            int currentSize = _group.MembersCount;
            if (!_offsetInitialized || currentSize != _lastGroupSize)
            {
                _cachedOffset = ComputeOffset();
                _offsetInitialized = true;
                _lastGroupSize = currentSize;
            }

            UpdateDrift();
            Vector3 drift = new Vector3(_driftOffset.x, 0f, _driftOffset.y);
            return _cachedOffset + drift;
        }

        #endregion

        #region Private Methods

        /// <summary>
        /// Computes a unique, naturalistic squad offset for this bot using deterministic per-bot random seed.
        /// Uses variable angle, spacing, and a small personal bias to simulate a real human squad.
        /// </summary>
        private Vector3 ComputeOffset()
        {
            try
            {
                if (_bot == null || _group == null || _bot.IsDead || _group.MembersCount < 2)
                    return Vector3.zero;

                int index = GetBotIndexInGroup(_bot, _group);
                if (index < 0)
                    return Vector3.zero;

                string profileId = _bot.ProfileId;
                if (string.IsNullOrEmpty(profileId))
                    return Vector3.zero;

                int squadSize = _group.MembersCount;
                int seed = unchecked(profileId.GetHashCode() ^ (squadSize * 397));
                var localRand = new System.Random(seed);

                // Base spacing and randomness
                float baseNoise = (float)(localRand.NextDouble() * 0.9 - 0.45f); // [-0.45, 0.45]
                float spacing = Mathf.Clamp(BaseSpacing + baseNoise, MinSpacing, MaxSpacing);

                // Organic, asymmetric formation instead of strict circle
                float formationTypeRand = (float)localRand.NextDouble();
                float angleStep, formationAngle;
                if (formationTypeRand < 0.43f)
                {
                    // Looser arc or "comet tail" behind leader
                    angleStep = 70f / (squadSize - 1);
                    formationAngle = (-35f) + (index * angleStep);
                }
                else if (formationTypeRand < 0.76f)
                {
                    // Broad V formation
                    angleStep = 60f / (squadSize - 1);
                    formationAngle = (-30f) + (index * angleStep);
                }
                else
                {
                    // Partial circle for static/idle
                    angleStep = 360f / squadSize;
                    formationAngle = (index * angleStep) + (float)(localRand.NextDouble() * 16.0 - 8.0); // [-8, 8]
                }

                float radians = formationAngle * Mathf.Deg2Rad;
                float x = Mathf.Cos(radians) * spacing;
                float z = Mathf.Sin(radians) * spacing;

                // Subtle per-bot offset to avoid identical overlaps
                float biasX = (float)(localRand.NextDouble() * 0.16 - 0.08); // [-0.08, 0.08]
                float biasZ = (float)(localRand.NextDouble() * 0.16 - 0.08);

                return new Vector3(x + biasX, 0f, z + biasZ);
            }
            catch
            {
                // If anything fails, disable offset for this bot only (zero offset)
                return Vector3.zero;
            }
        }

        /// <summary>
        /// Periodically updates per-bot "drift" for organic, player-like movement.
        /// </summary>
        private void UpdateDrift()
        {
            float now = Time.realtimeSinceStartup;
            if (now < _nextDriftUpdate)
                return;

            // Deterministic seed: per-bot, but updates with time for drift
            int tick = Mathf.FloorToInt(now / DriftChangeInterval);
            int driftSeed = unchecked((_bot.ProfileId?.GetHashCode() ?? 0) ^ tick ^ 0x1F4B6C3);

            var rand = new System.Random(driftSeed);
            float angle = (float)(rand.NextDouble() * Mathf.PI * 2.0);
            float radius = (float)(rand.NextDouble() * MaxDriftDistance);

            _driftOffset = new Vector2(
                Mathf.Cos(angle) * radius,
                Mathf.Sin(angle) * radius
            );

            _nextDriftUpdate = now + DriftChangeInterval + (float)(rand.NextDouble() * 2.2 - 1.1f);
        }

        /// <summary>
        /// Used only at initialization for slight randomization.
        /// </summary>
        private float GetInitialDriftInterval()
        {
            int seed = unchecked((_bot?.ProfileId?.GetHashCode() ?? 0) ^ 0xBADC0DE);
            var rand = new System.Random(seed);
            return DriftChangeInterval * 0.66f + (float)(rand.NextDouble() * 0.66f);
        }

        /// <summary>
        /// Finds the index of the bot within its squad for formation placement.
        /// </summary>
        private static int GetBotIndexInGroup(BotOwner bot, BotsGroup group)
        {
            if (bot == null || group == null || string.IsNullOrEmpty(bot.ProfileId))
                return -1;

            int count = group.MembersCount;
            for (int i = 0; i < count; i++)
            {
                BotOwner member = group.Member(i);
                if (member != null && !member.IsDead && member.ProfileId == bot.ProfileId)
                {
                    return i;
                }
            }

            return -1;
        }

        #endregion
    }
}
