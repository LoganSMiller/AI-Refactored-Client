// <auto-generated>
//   This file is part of AI-Refactored, an open-source project focused on realistic AI behavior in Escape from Tarkov.
//   Licensed under the MIT License. See LICENSE in the repository root for more information.
//
//   THIS FILE IS SYSTEMATICALLY MANAGED.
//   Please follow strict StyleCop, ReSharper, and AI-Refactored code standards for all modifications.
// </auto-generated>

#nullable enable

namespace AIRefactored.AI.Groups
{
    using AIRefactored.AI.Core;
    using EFT;
    using UnityEngine;

    /// <summary>
    /// Controls squad-based movement offsets to prevent clumping and collisions.
    /// Dynamically spaces bots based on squad size and formation pattern.
    /// </summary>
    public sealed class SquadPathCoordinator
    {
        #region Constants

        private const float BaseSpacing = 2.25f;
        private const float MaxSpacing = 6.5f;
        private const float MinSpacing = 1.25f;

        #endregion

        #region Fields

        private BotOwner? bot;
        private BotsGroup? group;
        private Vector3 cachedOffset = Vector3.zero;
        private int lastGroupSize = -1;
        private bool offsetInitialized;

        #endregion

        #region Public Methods

        /// <summary>
        /// Initializes the squad path coordinator for the given bot cache.
        /// </summary>
        /// <param name="cache">The bot component cache.</param>
        public void Initialize(BotComponentCache cache)
        {
            this.bot = cache.Bot;
            this.group = this.bot?.BotsGroup;
            this.offsetInitialized = false;
        }

        /// <summary>
        /// Returns a spacing offset applied to a squad-shared destination, unique to this bot.
        /// </summary>
        /// <param name="sharedDestination">The shared squad destination.</param>
        public Vector3 ApplyOffsetTo(Vector3 sharedDestination)
        {
            return sharedDestination + this.GetCurrentOffset();
        }

        /// <summary>
        /// Gets the cached or recalculated squad offset for this bot.
        /// </summary>
        public Vector3 GetCurrentOffset()
        {
            if (this.bot == null || this.group == null)
            {
                return Vector3.zero;
            }

            int currentSize = this.group.MembersCount;

            if (!this.offsetInitialized || currentSize != this.lastGroupSize)
            {
                this.cachedOffset = this.ComputeOffset();
                this.offsetInitialized = true;
                this.lastGroupSize = currentSize;
            }

            return this.cachedOffset;
        }

        #endregion

        #region Private Methods

        private Vector3 ComputeOffset()
        {
            if (this.bot == null || this.group == null || this.group.MembersCount < 2)
            {
                return Vector3.zero;
            }

            int botIndex = GetBotIndexInGroup(this.bot, this.group);
            if (botIndex < 0)
            {
                return Vector3.zero;
            }

            int squadSize = this.group.MembersCount;

            int seed = this.bot.ProfileId.GetHashCode() ^ squadSize;
            Random.InitState(seed);

            float spacing = Mathf.Clamp(BaseSpacing + Random.Range(-0.4f, 0.4f), MinSpacing, MaxSpacing);
            float angleStep = 360f / squadSize;
            float angle = botIndex * angleStep + Random.Range(-8f, 8f);
            float radians = angle * Mathf.Deg2Rad;

            return new Vector3(Mathf.Cos(radians), 0f, Mathf.Sin(radians)) * spacing;
        }

        private static int GetBotIndexInGroup(BotOwner bot, BotsGroup group)
        {
            for (int i = 0; i < group.MembersCount; i++)
            {
                BotOwner? member = group.Member(i);
                if (member != null && member.ProfileId == bot.ProfileId)
                {
                    return i;
                }
            }

            return -1;
        }

        #endregion
    }
}
