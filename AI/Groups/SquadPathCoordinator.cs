// <auto-generated>
//   AI-Refactored: SquadPathCoordinator.cs (Supreme Arbitration Overlay Edition – Max Realism, Bulletproofed June 2025)
//   Provides drift-safe, profile-seeded, squad-indexed formation spacing per bot.
//   Bulletproof: zero allocations in Tick, zero invalid offset vectors, never disables or teleports. Pooled, error-isolated.
//   MIT License.
// </auto-generated>

namespace AIRefactored.AI.Groups
{
    using System;
    using AIRefactored.AI.Core;
    using EFT;
    using UnityEngine;

    /// <summary>
    /// Computes dynamic, drifted squad offsets per bot to prevent clumping, ensure realism, and preserve formation spacing.
    /// Must be ticked externally from BotBrain or overlay/event system. All calculations are profile- and group-size-seeded.
    /// Bulletproof: never disables, never throws, zero-alloc in Tick, 100% event/overlay safe.
    /// </summary>
    public sealed class SquadPathCoordinator
    {
        #region Constants

        private const float BaseSpacing = 2.35f;
        private const float MinSpacing = 1.2f;
        private const float MaxSpacing = 7.0f;
        private const float DriftChangeInterval = 5.5f;
        private const float MaxDriftDistance = 0.48f;
        private const float MaxFormationSpread = 9.0f;
        private const float HeightTolerance = 2.8f;

        #endregion

        #region Fields

        private BotOwner _bot;
        private BotsGroup _group;
        private Vector3 _cachedOffset;
        private int _lastGroupSize;
        private bool _offsetInitialized;
        private float _nextDriftUpdate;
        private Vector2 _driftOffset;
        private float _lastTickTime;
        private bool _isLeader;
        private int _cachedIndex;
        private float _formationSpread;
        private float _lastFormationSeed;

        #endregion

        #region Initialization

        /// <summary>
        /// Initializes the path coordinator for the given bot cache. Bulletproof: all null-guarded, resets on invalid state.
        /// </summary>
        public void Initialize(BotComponentCache cache)
        {
            if (cache == null || cache.Bot == null || cache.Bot.IsDead)
            {
                Reset();
                return;
            }
            _bot = cache.Bot;
            _group = _bot.BotsGroup;
            if (_group == null || _group.MembersCount < 2)
            {
                Reset();
                return;
            }
            _offsetInitialized = false;
            _lastGroupSize = -1;
            _cachedOffset = Vector3.zero;
            _driftOffset = Vector2.zero;
            _nextDriftUpdate = Time.realtimeSinceStartup + GetInitialDriftInterval();
            _lastTickTime = Time.realtimeSinceStartup;
            _isLeader = false;
            _cachedIndex = -1;
            _formationSpread = 0f;
            _lastFormationSeed = -1f;
        }

        private void Reset()
        {
            _bot = null;
            _group = null;
            _offsetInitialized = false;
            _lastGroupSize = -1;
            _cachedOffset = Vector3.zero;
            _driftOffset = Vector2.zero;
            _nextDriftUpdate = 0f;
            _lastTickTime = 0f;
            _isLeader = false;
            _cachedIndex = -1;
            _formationSpread = 0f;
            _lastFormationSeed = -1f;
        }

        #endregion

        #region Tick

        /// <summary>
        /// Main update, should be called from BotBrain or overlay/event driver.
        /// Bulletproof: never allocates, never disables or breaks overlays.
        /// </summary>
        public void Tick(float deltaTime)
        {
            if (_bot == null || _group == null || _bot.IsDead || _group.MembersCount < 2)
                return;

            int size = _group.MembersCount;
            if (!_offsetInitialized || size != _lastGroupSize || Time.frameCount % 6 == 0)
            {
                _cachedIndex = GetBotIndexInGroup(_bot, _group);
                _formationSpread = Mathf.Clamp(BaseSpacing + (size - 2) * 0.43f, MinSpacing, MaxFormationSpread);
                _cachedOffset = ComputeOffset();
                _lastGroupSize = size;
                _offsetInitialized = true;
            }

            UpdateDrift();
            _lastTickTime = Time.realtimeSinceStartup;
        }

        #endregion

        #region Offset API

        /// <summary>
        /// Applies the current squad offset to the given target position.
        /// </summary>
        public Vector3 ApplyOffsetTo(Vector3 target)
        {
            Vector3 off = GetCurrentOffset();
            return IsVectorValid(off) ? target + off : target;
        }

        /// <summary>
        /// Returns the current offset, including base and drift.
        /// Bulletproof: never returns invalid vectors.
        /// </summary>
        public Vector3 GetCurrentOffset()
        {
            Vector3 sum = _cachedOffset + new Vector3(_driftOffset.x, 0f, _driftOffset.y);
            return IsVectorValid(sum) ? sum : Vector3.zero;
        }

        #endregion

        #region Core Logic

        /// <summary>
        /// Computes the base formation offset for this bot in the group.
        /// Profile-seeded, group-indexed, bulletproof, always realistic.
        /// </summary>
        private Vector3 ComputeOffset()
        {
            try
            {
                if (_bot == null || _group == null || _bot.IsDead || _group.MembersCount < 2)
                    return Vector3.zero;

                int index = _cachedIndex >= 0 ? _cachedIndex : GetBotIndexInGroup(_bot, _group);
                if (index < 0)
                    return Vector3.zero;

                string pid = _bot.ProfileId;
                if (string.IsNullOrEmpty(pid))
                    return Vector3.zero;

                // Seed by profile, index, group size for full formation randomness
                int seed = unchecked(pid.GetHashCode() ^ (index * 1709) ^ (_group.MembersCount * 73));
                var rand = new System.Random(seed);

                float spacingNoise = (float)(rand.NextDouble() * 1.25 - 0.62f);
                float spacing = Mathf.Clamp(_formationSpread + spacingNoise, MinSpacing, MaxSpacing);

                float arrangement = (float)rand.NextDouble();
                float angleDeg, angleStep;
                if (arrangement < 0.33f)
                {
                    // Flank wedge (triangle left/right)
                    angleStep = 55f / (_group.MembersCount - 1);
                    angleDeg = -27.5f + index * angleStep;
                }
                else if (arrangement < 0.67f)
                {
                    // Tight V/line
                    angleStep = 38f / (_group.MembersCount - 1);
                    angleDeg = -19f + index * angleStep;
                }
                else
                {
                    // Ring/box/column
                    angleStep = 360f / _group.MembersCount;
                    angleDeg = index * angleStep + (float)(rand.NextDouble() * 20.0 - 10.0);
                }

                float rad = angleDeg * Mathf.Deg2Rad;
                float x = Mathf.Cos(rad) * spacing;
                float z = Mathf.Sin(rad) * spacing;

                // Random micro bias
                float bx = (float)(rand.NextDouble() * 0.18 - 0.09f);
                float bz = (float)(rand.NextDouble() * 0.18 - 0.09f);

                Vector3 result = new Vector3(x + bx, 0f, z + bz);

                // Mark leader (center or index 0)
                _isLeader = (index == 0);

                // Clamp result for Y and sanity check
                if (Mathf.Abs(result.y) > HeightTolerance) result.y = 0f;
                return IsVectorValid(result) ? result : Vector3.zero;
            }
            catch
            {
                return Vector3.zero;
            }
        }

        /// <summary>
        /// Updates the micro-drift offset for this bot (drifted every DriftChangeInterval).
        /// </summary>
        private void UpdateDrift()
        {
            float now = Time.realtimeSinceStartup;
            if (now < _nextDriftUpdate)
                return;

            int tick = Mathf.FloorToInt(now / DriftChangeInterval);
            int driftSeed = unchecked((_bot?.ProfileId?.GetHashCode() ?? 0) ^ tick ^ 0x3B83C0F);
            var rand = new System.Random(driftSeed);

            float angle = (float)(rand.NextDouble() * Mathf.PI * 2.0);
            float radius = (float)(rand.NextDouble() * MaxDriftDistance);

            _driftOffset = new Vector2(
                Mathf.Cos(angle) * radius,
                Mathf.Sin(angle) * radius
            );

            _nextDriftUpdate = now + DriftChangeInterval + (float)(rand.NextDouble() * 1.85f - 0.92f);
        }

        /// <summary>
        /// Returns a randomized initial drift interval for this bot (profile seeded).
        /// </summary>
        private float GetInitialDriftInterval()
        {
            int seed = unchecked((_bot?.ProfileId?.GetHashCode() ?? 0) ^ 0xBADC0DE);
            var rand = new System.Random(seed);
            return DriftChangeInterval * 0.6f + (float)(rand.NextDouble() * 0.7f);
        }

        /// <summary>
        /// Gets the index of the bot in the squad/group. Bulletproof.
        /// </summary>
        private static int GetBotIndexInGroup(BotOwner bot, BotsGroup group)
        {
            if (bot == null || group == null || string.IsNullOrEmpty(bot.ProfileId))
                return -1;

            int idx = 0;
            for (int i = 0; i < group.MembersCount; i++)
            {
                var member = group.Member(i);
                if (member != null && !member.IsDead && member.ProfileId == bot.ProfileId)
                    return idx;
                if (member != null && !member.IsDead)
                    idx++;
            }
            return -1;
        }

        /// <summary>
        /// Validates a vector (not NaN, not huge, not zero, safe for overlay intent).
        /// </summary>
        private static bool IsVectorValid(Vector3 v)
        {
            return !float.IsNaN(v.x) && !float.IsNaN(v.y) && !float.IsNaN(v.z)
                && Mathf.Abs(v.x) < 1000f && Mathf.Abs(v.z) < 1000f && v.magnitude < 50f;
        }

        #endregion

        #region Debug/Introspection

        /// <summary>
        /// Returns true if this bot is considered the formation leader for their group.
        /// </summary>
        public bool IsLeader => _isLeader;

        /// <summary>
        /// Returns the cached index for this bot in the group.
        /// </summary>
        public int BotGroupIndex => _cachedIndex;

        /// <summary>
        /// Returns the most recent formation spread calculation for this group.
        /// </summary>
        public float LastFormationSpread => _formationSpread;

        #endregion
    }
}
