// <auto-generated>
//   This file is part of AI-Refactored, an open-source project focused on realistic AI behavior in Escape from Tarkov.
//   Licensed under the MIT License. See LICENSE in the repository root for more information.
//
//   THIS FILE IS SYSTEMATICALLY MANAGED.
//   Please follow strict StyleCop, ReSharper, and AI-Refactored code standards for all modifications.
// </auto-generated>

namespace AIRefactored.AI.Groups
{
    using System.Collections.Generic;
    using AIRefactored.Core;
    using EFT;

    /// <summary>
    /// Tracks and manages squads of bots by GroupId for tactical queries and squad-level behaviors.
    /// Used by fallback, VO coordination, and dynamic routing systems.
    /// </summary>
    public static class BotTeamTracker
    {
        #region Static State

        private static readonly Dictionary<string, List<BotOwner>> Groups = new Dictionary<string, List<BotOwner>>(32);
        private static readonly List<BotOwner> TempBuffer = new List<BotOwner>(8);

        #endregion

        #region Public API

        /// <summary>
        /// Clears all registered groups and members. Called on raid end.
        /// </summary>
        public static void Clear()
        {
            Groups.Clear();
        }

        /// <summary>
        /// Returns a copy of all bot groups and their current live members.
        /// </summary>
        public static Dictionary<string, List<BotOwner>> GetAllGroups()
        {
            var copy = new Dictionary<string, List<BotOwner>>(Groups.Count);

            foreach (var pair in Groups)
            {
                var filtered = new List<BotOwner>(pair.Value.Count);
                for (int i = 0; i < pair.Value.Count; i++)
                {
                    BotOwner bot = pair.Value[i];
                    if (EFTPlayerUtil.IsValidBotOwner(bot))
                    {
                        filtered.Add(bot);
                    }
                }

                if (filtered.Count > 0)
                {
                    copy[pair.Key] = filtered;
                }
            }

            return copy;
        }

        /// <summary>
        /// Returns a list of valid, alive AI squadmates in the given group ID.
        /// </summary>
        public static List<BotOwner> GetGroup(string groupId)
        {
            TempBuffer.Clear();

            if (!string.IsNullOrEmpty(groupId) && Groups.TryGetValue(groupId, out List<BotOwner> members))
            {
                for (int i = 0; i < members.Count; i++)
                {
                    BotOwner bot = members[i];
                    if (EFTPlayerUtil.IsValidBotOwner(bot))
                    {
                        TempBuffer.Add(bot);
                    }
                }
            }

            return new List<BotOwner>(TempBuffer);
        }

        /// <summary>
        /// Registers a bot into the specified group ID.
        /// </summary>
        public static void Register(string groupId, BotOwner bot)
        {
            if (string.IsNullOrEmpty(groupId) || !EFTPlayerUtil.IsValidBotOwner(bot))
            {
                return;
            }

            if (!Groups.TryGetValue(groupId, out List<BotOwner> list))
            {
                list = new List<BotOwner>(4);
                Groups[groupId] = list;
            }

            if (!list.Contains(bot))
            {
                list.Add(bot);
            }
        }

        /// <summary>
        /// Attempts to register the given bot by auto-extracting its GroupId.
        /// </summary>
        public static void RegisterFromBot(BotOwner bot)
        {
            if (!EFTPlayerUtil.IsValidBotOwner(bot))
            {
                return;
            }

            string groupId = bot.GetPlayer?.Profile?.Info?.GroupId;
            if (!string.IsNullOrEmpty(groupId))
            {
                Register(groupId, bot);
            }
        }

        /// <summary>
        /// Unregisters the specified bot from all groups.
        /// </summary>
        public static void Unregister(BotOwner bot)
        {
            if (bot == null)
            {
                return;
            }

            string groupToRemove = null;

            foreach (var kvp in Groups)
            {
                List<BotOwner> list = kvp.Value;
                if (list.Remove(bot) && list.Count == 0)
                {
                    groupToRemove = kvp.Key;
                    break;
                }
            }

            if (!string.IsNullOrEmpty(groupToRemove))
            {
                Groups.Remove(groupToRemove);
            }
        }

        #endregion
    }
}
