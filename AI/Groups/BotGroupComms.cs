// <auto-generated>
//   AI-Refactored: BotGroupComms.cs (Supreme Arbitration, Beyond Diamond – Mastermoveplan, Squad Realism, June 2025)
//   Human-level squad comms: fallback, frag, suppression, looting, cover, squad echo, robust cooldowns, voice dedup, anti-echo, group sync, dynamic intent overlays.
//   Bulletproof: All comms driven by BotBrain.Tick(), never disables, never allocates in hot path, SPT/FIKA/headless/client parity, multiplayer safe.
//   MIT License.
// </auto-generated>

namespace AIRefactored.AI.Groups
{
    using System;
    using System.Collections.Generic;
    using AIRefactored.AI.Core;
    using AIRefactored.AI.Helpers;
    using AIRefactored.Pools;
    using EFT;
    using UnityEngine;

    /// <summary>
    /// Handles squad-level voice/comms: fallback, frag, suppression, looting, anti-echo, arbitration overlays. Human-level realism, bulletproof, no self-tick.
    /// All logic is pooled, headless/multiplayer safe, and 100% error-isolated.
    /// </summary>
    public sealed class BotGroupComms
    {
        #region Constants

        private const float AllyRadius = 12f;
        private const float VoiceCooldownMin = 3.15f;
        private const float VoiceCooldownMax = 5.25f;
        private const float GroupEchoCooldown = 3.09f;
        private const float PhraseStaleTime = 10.4f;
        private const float StaggerChance = 0.09f;
        private static readonly float AllyRadiusSqr = AllyRadius * AllyRadius;

        #endregion

        #region Fields

        private readonly BotOwner _bot;
        private readonly BotComponentCache _cache;

        private float _nextLocalVoiceTime;
        private float _nextGroupCommsAllowed;
        private bool _lastIsMuted;

        // Global comms anti-echo memory (pooled for all squad comms)
        private static string _lastCommsPhrase = string.Empty;
        private static float _lastCommsTime = -99f;
        private static string _lastLootId = string.Empty;
        private static float _lastLootRequestTime = -99f;
        private static readonly Dictionary<string, float> _groupLootCooldowns = new Dictionary<string, float>(24);

        #endregion

        #region Properties

        public bool IsMuted { get; private set; }
        public bool IsSquadCommsReady => !IsMuted && _bot != null && !_bot.IsDead && _bot.BotTalk != null;

        #endregion

        #region Constructor

        public BotGroupComms(BotComponentCache cache)
        {
            _cache = cache;
            _bot = cache?.Bot;
            IsMuted = _bot == null || _bot.BotTalk == null;
            _nextLocalVoiceTime = 0f;
            _nextGroupCommsAllowed = 0f;
        }

        #endregion

        #region BotBrain-Driven Tick API

        /// <summary>
        /// Tick must be called by BotBrain to clear phrase tracking, anti-echo, and loot comms memory.
        /// </summary>
        public void Tick(float deltaTime)
        {
            float now = Time.time;
            if (now - _lastCommsTime > PhraseStaleTime)
                _lastCommsPhrase = string.Empty;
            if (now - _lastLootRequestTime > PhraseStaleTime)
                _lastLootId = string.Empty;
            // Prune stale loot cooldowns
            if (_groupLootCooldowns.Count > 12)
            {
                var keys = TempListPool.Rent<string>(_groupLootCooldowns.Count);
                keys.AddRange(_groupLootCooldowns.Keys);
                foreach (var k in keys)
                    if (now - _groupLootCooldowns[k] > PhraseStaleTime) _groupLootCooldowns.Remove(k);
                TempListPool.Return(keys);
            }
        }

        #endregion

        #region Voice Triggers: Realistic Squad Calls

        public void Say(EPhraseTrigger phrase) => TrySay(phrase, 1f, true, false);

        public void SayFallback() => TrySay(EPhraseTrigger.GetBack, 0.68f, true, true);

        public void SayFragOut() => TrySay(EPhraseTrigger.OnEnemyGrenade, HasNearbyAlly() ? 0.85f : 0.12f, true, true);

        public void SayHit() => TrySay(EPhraseTrigger.OnBeingHurt, UnityEngine.Random.Range(0.68f, 0.92f), true, true);

        public void SaySuppression() => TrySay(EPhraseTrigger.Suppress, 0.77f, true, true);

        public void SayLootRequest() => TrySay(EPhraseTrigger.GoLoot, 0.94f, true, false);

        public void SayScanArea() => TrySay(EPhraseTrigger.Look, 0.89f, true, true);

        public void SayLootMove() => TrySay(EPhraseTrigger.OnPosition, 0.87f, false, false);

        public void SayLootOpen() => TrySay(EPhraseTrigger.OnLoot, 0.81f, false, false);

        public void SayLootSearch() => TrySay(EPhraseTrigger.LootGeneric, 0.77f, false, false);

        public void SayLootTake() => TrySay(EPhraseTrigger.LootContainer, 0.92f, false, false);

        public void SayLootDone() => TrySay(EPhraseTrigger.GoodWork, 0.73f, false, false);

        public void SayLootGiveUp() => TrySay(EPhraseTrigger.LootNothing, 0.79f, false, false);

        /// <summary>
        /// Universal squad/anti-echo comms trigger. Handles squad voice, anti-parallel, echo sync, arbitration overlays.
        /// Returns true if the phrase was spoken.
        /// </summary>
        public bool TrySay(EPhraseTrigger phrase, float chance = 1.0f, bool squadSync = true, bool antiEcho = true)
        {
            if (!IsEligible()) return false;
            float now = Time.time;

            if (now < _nextLocalVoiceTime)
                return false;

            // Global squad anti-echo (only allow if phrase isn't recent)
            if (antiEcho && _lastCommsPhrase == phrase.ToString() && now - _lastCommsTime < GroupEchoCooldown)
                return false;

            // Staggered timing for multiple bots in squad, prevent instant chorus
            if (squadSync && UnityEngine.Random.value < StaggerChance)
            {
                _nextLocalVoiceTime = now + UnityEngine.Random.Range(0.23f, 0.51f);
                return false;
            }

            if (chance < 1f && UnityEngine.Random.value > chance)
                return false;

            _nextLocalVoiceTime = now + UnityEngine.Random.Range(VoiceCooldownMin, VoiceCooldownMax);

            try
            {
                _bot.BotTalk.TrySay(phrase);
                if (squadSync || antiEcho)
                {
                    _lastCommsPhrase = phrase.ToString();
                    _lastCommsTime = now;
                }
                return true;
            }
            catch
            {
                IsMuted = true;
                return false;
            }
        }

        #endregion

        #region Group Loot Arbitration & Coordination

        /// <summary>
        /// Claims loot for this profileId (anti-parallel, anti-spam for group looting). Arbitration via cooldowns.
        /// </summary>
        public bool TryRequestLootClaim(string profileId)
        {
            if (string.IsNullOrEmpty(profileId)) return false;
            float now = Time.time;
            if (_groupLootCooldowns.TryGetValue(profileId, out float t) && now - t < GroupEchoCooldown)
                return false;
            _groupLootCooldowns[profileId] = now;
            _lastLootRequestTime = now;
            _lastLootId = profileId;
            return true;
        }

        public void RegisterLootTaken(string lootId)
        {
            if (!string.IsNullOrEmpty(lootId))
            {
                _groupLootCooldowns[lootId] = Time.time;
            }
        }

        /// <summary>
        /// Returns true if any group comms loot arbitration is active (e.g. group looting).
        /// </summary>
        public bool IsGroupLooting()
        {
            float now = Time.time;
            foreach (var kv in _groupLootCooldowns)
                if (now - kv.Value < GroupEchoCooldown) return true;
            return false;
        }

        #endregion

        #region Robust Eligibility Logic

        private bool IsEligible()
        {
            if (IsMuted)
                return false;
            if (_bot == null || _bot.IsDead || _bot.BotTalk == null || _bot.GetPlayer == null)
                return false;
            if (!_bot.GetPlayer.IsAI)
                return false;
            // In headless, only allow comms if human/VOIP fallback is needed, otherwise skip.
            if (FikaHeadlessDetector.IsHeadless)
                return false;
            return true;
        }

        private bool HasNearbyAlly()
        {
            if (_bot?.Profile?.Info == null) return false;

            string groupId = _bot.Profile.Info.GroupId;
            if (string.IsNullOrEmpty(groupId)) return false;

            Vector3 pos = _bot.Position;
            foreach (var other in BotCacheUtility.AllActiveBots())
            {
                if (ReferenceEquals(other, _cache) || other?.Bot == null || other.Bot.IsDead) continue;
                if (other.Bot.Profile?.Info?.GroupId != groupId) continue;
                if ((other.Bot.Position - pos).sqrMagnitude <= AllyRadiusSqr)
                    return true;
            }
            return false;
        }

        #endregion
    }
}
