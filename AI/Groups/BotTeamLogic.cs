// <auto-generated>
//   This file is part of AI-Refactored, an open-source project focused on realistic AI behavior in Escape from Tarkov.
//   Licensed under the MIT License. See LICENSE in the repository root for more information.
//
//   THIS FILE IS SYSTEMATICALLY MANAGED.
//   Please follow strict StyleCop, ReSharper, and AI-Refactored code standards for all modifications.
// </auto-generated>

#nullable enable

namespace AIRefactored.AI.Groups
{
    using System;
    using System.Collections.Generic;
    using System.Threading.Tasks;
    using AIRefactored.AI.Combat;
    using AIRefactored.AI.Core;
    using AIRefactored.AI.Helpers;
    using AIRefactored.Core;
    using EFT;
    using UnityEngine;
    using static AIRefactored.AI.Missions.BotMissionController;
    using Random = UnityEngine.Random;

    /// <summary>
    /// Coordinates squad-level tactical behavior including fallback broadcast, enemy sharing, and regrouping.
    /// </summary>
    public sealed class BotTeamLogic
    {
        #region Constants

        private const float RegroupJitterRadius = 1.5f;
        private const float RegroupThreshold = 2.5f;

        #endregion

        #region Fields

        private readonly BotOwner bot;
        private readonly Dictionary<BotOwner, CombatStateMachine> combatMap = new Dictionary<BotOwner, CombatStateMachine>(8);
        private readonly List<BotOwner> teammates = new List<BotOwner>(8);

        #endregion

        #region Constructor

        public BotTeamLogic(BotOwner bot)
        {
            this.bot = bot ?? throw new ArgumentNullException(nameof(bot));
        }

        #endregion

        #region Public Methods

        public static void AddEnemy(BotOwner bot, global::EFT.IPlayer target)
        {
            if (bot == null || bot.IsDead || target == null || bot.BotsGroup == null || bot.Memory == null)
            {
                return;
            }

            // Resolve EFT.Player from incoming target
            Player? targetPlayer = EFTPlayerUtil.AsEFTPlayer(target);
            if (!EFTPlayerUtil.IsValid(targetPlayer))
            {
                return;
            }

            string? profileId = targetPlayer?.ProfileId;
            if (profileId == null || profileId.Length == 0)
            {
                return;
            }

            // Resolve fresh copy from world by profileId to avoid stale refs
            Player? resolvedPlayer = EFTPlayerUtil.ResolvePlayerById(profileId);
            if (!EFTPlayerUtil.IsValid(resolvedPlayer))
            {
                return;
            }

            global::EFT.IPlayer? safeTarget = EFTPlayerUtil.AsSafeIPlayer(resolvedPlayer);
            if (safeTarget == null)
            {
                return;
            }

            // Share enemy with squadmates
            for (int i = 0; i < bot.BotsGroup.MembersCount; i++)
            {
                BotOwner? mate = bot.BotsGroup.Member(i);
                if (mate == null || mate == bot || mate.IsDead || mate.BotsGroup == null || mate.Memory == null)
                {
                    continue;
                }

                ForceRegisterEnemy(mate, safeTarget);
            }
        }

        public static void BroadcastMissionType(BotOwner bot, MissionType mission)
        {
            if (bot == null || bot.IsDead || FikaHeadlessDetector.IsHeadless)
            {
                return;
            }

            BotsGroup? group = bot.BotsGroup;
            if (group == null)
            {
                return;
            }

            for (int i = 0; i < group.MembersCount; i++)
            {
                BotOwner? mate = group.Member(i);
                if (mate != null && mate != bot && !mate.IsDead && mate.GetPlayer?.IsAI == true)
                {
                    mate.BotTalk?.TrySay(EPhraseTrigger.Cooperation);
                }
            }
        }

        public void BroadcastFallback(Vector3 retreatPoint)
        {
            foreach (KeyValuePair<BotOwner, CombatStateMachine> entry in this.combatMap)
            {
                BotOwner mate = entry.Key;
                CombatStateMachine fsm = entry.Value;

                if (mate != null && mate != this.bot && !mate.IsDead)
                {
                    TriggerDelayedFallback(fsm, retreatPoint);
                }
            }
        }

        public void CoordinateMovement()
        {
            if (this.bot.IsDead || this.teammates.Count == 0)
            {
                return;
            }

            Vector3 center = Vector3.zero;
            int count = 0;

            for (int i = 0; i < this.teammates.Count; i++)
            {
                BotOwner mate = this.teammates[i];
                if (mate != null && !mate.IsDead)
                {
                    center += mate.Transform.position;
                    count++;
                }
            }

            if (count == 0)
            {
                return;
            }

            center /= count;
            Vector3 jitter = Random.insideUnitSphere * RegroupJitterRadius;
            jitter.y = 0f;

            Vector3 target = center + jitter;
            float distSq = (this.bot.Transform.position - target).sqrMagnitude;

            if (distSq > (RegroupThreshold * RegroupThreshold))
            {
                BotMovementHelper.SmoothMoveTo(this.bot, target, false);
            }
        }

        public void InjectCombatState(BotOwner mate, CombatStateMachine fsm)
        {
            if (mate != null && fsm != null && mate != this.bot && !this.combatMap.ContainsKey(mate))
            {
                this.combatMap[mate] = fsm;
            }
        }

        public void SetTeammates(List<BotOwner> allBots)
        {
            this.teammates.Clear();

            Player? player = this.bot.GetPlayer;
            if (player == null || player.Profile == null)
            {
                return;
            }

            string? groupId = player.Profile.Info?.GroupId;
            if (string.IsNullOrEmpty(groupId))
            {
                return;
            }

            for (int i = 0; i < allBots.Count; i++)
            {
                BotOwner other = allBots[i];
                if (other == null || other == this.bot || other.IsDead)
                {
                    continue;
                }

                Player? otherPlayer = other.GetPlayer;
                if (otherPlayer == null || !otherPlayer.IsAI || otherPlayer.Profile == null)
                {
                    continue;
                }

                string? otherGroupId = otherPlayer.Profile.Info?.GroupId;
                if (!string.IsNullOrEmpty(otherGroupId) && otherGroupId == groupId)
                {
                    this.teammates.Add(other);
                }
            }
        }

        public void ShareTarget(global::EFT.IPlayer enemy)
        {
            if (enemy == null || string.IsNullOrEmpty(enemy.ProfileId))
            {
                return;
            }
            Player? resolvedPlayer = EFTPlayerUtil.ResolvePlayerById(enemy.ProfileId);
            if (!EFTPlayerUtil.IsValid(resolvedPlayer))
            {
                return;
            }

            global::EFT.IPlayer? safeTarget = EFTPlayerUtil.AsSafeIPlayer(resolvedPlayer);
            if (safeTarget == null)
            {
                return;
            }

            for (int i = 0; i < this.teammates.Count; i++)
            {
                BotOwner mate = this.teammates[i];
                if (mate != null && !mate.IsDead)
                {
                    ForceRegisterEnemy(mate, safeTarget);
                }
            }
        }

        #endregion

        #region Private Methods

        private static void ForceRegisterEnemy(BotOwner receiver, EFT.IPlayer enemy)
        {
            if (receiver == null || receiver.IsDead || enemy == null)
            {
                return;
            }

            if (!receiver.BotsGroup.IsEnemy(enemy))
            {
                receiver.BotsGroup.AddEnemy(enemy, EBotEnemyCause.zryachiyLogic);
            }

            if (!receiver.EnemiesController.EnemyInfos.ContainsKey(enemy))
            {
                BotSettingsClass settings = new BotSettingsClass(enemy as Player, receiver.BotsGroup, EBotEnemyCause.zryachiyLogic);
                receiver.Memory.AddEnemy(enemy, settings, false);
            }
        }

        private static void TriggerDelayedFallback(CombatStateMachine fsm, Vector3 point)
        {
            Task.Run(async () =>
            {
                await Task.Delay(Random.Range(150, 400));
                fsm.TriggerFallback(point);
            });
        }

        #endregion
    }
}
