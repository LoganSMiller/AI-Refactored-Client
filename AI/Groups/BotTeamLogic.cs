// <auto-generated>
//   AI-Refactored: BotTeamLogic.cs (Ultimate Realism – Squad Tactical Coordinator Edition, June 2025, Arbitration-Overlay Edition)
//   Realistic squad-level behavior: fallback, enemy comms, mission sync, regrouping, async isolation.
//   Bulletproof: All errors isolated, no coroutine use, BotBrain-integrated, headless/client safe.
//   All squad movement is arbitration/event/overlay only. No cooldowns or artificial spam limits.
//   MIT License.
// </auto-generated>

namespace AIRefactored.AI.Groups
{
    using System;
    using System.Collections.Generic;
    using System.Threading.Tasks;
    using AIRefactored.AI;
    using AIRefactored.AI.Combat;
    using AIRefactored.AI.Core;
    using AIRefactored.AI.Helpers;
    using AIRefactored.AI.Navigation;
    using AIRefactored.Core;
    using AIRefactored.Pools;
    using EFT;
    using UnityEngine;
    using static AIRefactored.AI.Missions.BotMissionController;
    using Random = UnityEngine.Random;

    /// <summary>
    /// Ultimate squad tactical logic: fallback, enemy comms, mission sync, dynamic regrouping, async error isolation.
    /// Arbitration/event/overlay-only. No disables or teleports. Fully multiplayer/headless safe.
    /// Personality-aware, context-driven, bulletproof.
    /// </summary>
    public sealed class BotTeamLogic
    {
        #region Constants

        private const float RegroupJitterRadius = 1.55f;
        private const float MinMoveDeltaSqr = 0.13f;
        private const float MaxCommsRadius = 22.2f;
        private const float SquadDangerZonePersist = 1.99f;
        private static readonly float MaxCommsRadiusSqr = MaxCommsRadius * MaxCommsRadius;

        #endregion

        #region Fields

        private readonly BotOwner _bot;
        private readonly List<BotOwner> _teammates = new List<BotOwner>(8);
        private readonly Dictionary<BotOwner, CombatStateMachine> _combatMap = new Dictionary<BotOwner, CombatStateMachine>(8);

        private Vector3 _lastMoveTarget = Vector3.zero;
        private float _lastSquadDangerBroadcast = -99f;
        private Vector3 _lastSquadDangerPosition = Vector3.zero;

        #endregion

        #region Constructor

        public BotTeamLogic(BotOwner bot)
        {
            if (!EFTPlayerUtil.IsValidBotOwner(bot))
                throw new ArgumentException("[BotTeamLogic] Invalid bot owner.");
            _bot = bot;
        }

        #endregion

        #region Public API

        /// <summary>
        /// Shares an enemy IPlayer with all squadmates (delayed/async, arbitration-safe, error-isolated).
        /// </summary>
        public static void AddEnemy(BotOwner bot, IPlayer target)
        {
            try
            {
                if (!EFTPlayerUtil.IsValidBotOwner(bot) || target == null || bot.BotsGroup == null)
                    return;

                Player resolved = EFTPlayerUtil.ResolvePlayerById(target.ProfileId);
                if (!EFTPlayerUtil.IsValid(resolved))
                    return;

                IPlayer safe = EFTPlayerUtil.AsSafeIPlayer(resolved);
                for (int i = 0; i < bot.BotsGroup.MembersCount; i++)
                {
                    BotOwner mate = bot.BotsGroup.Member(i);
                    if (EFTPlayerUtil.IsValidBotOwner(mate) && mate != bot)
                    {
                        float delay = Random.Range(0.07f, 0.27f);
                        _ = TriggerDelayedRegisterEnemy(mate, safe, delay);
                    }
                }
            }
            catch { }
        }

        /// <summary>
        /// Broadcasts a squad mission (voice) to all squadmates (async, safe, randomized timing).
        /// </summary>
        public static void BroadcastMissionType(BotOwner bot, MissionType mission)
        {
            try
            {
                if (!EFTPlayerUtil.IsValidBotOwner(bot) || bot.BotsGroup == null)
                    return;

                for (int i = 0; i < bot.BotsGroup.MembersCount; i++)
                {
                    BotOwner mate = bot.BotsGroup.Member(i);
                    if (EFTPlayerUtil.IsValidBotOwner(mate) && mate != bot && mate.BotTalk != null)
                    {
                        float delay = Random.Range(0.13f, 0.37f);
                        _ = Task.Run(async () =>
                        {
                            try
                            {
                                await Task.Delay((int)(delay * 1000f));
                                if (Random.value < 0.72f)
                                    mate.BotTalk.TrySay(EPhraseTrigger.Cooperation);
                            }
                            catch { }
                        });
                    }
                }
            }
            catch { }
        }

        /// <summary>
        /// Broadcasts fallback/retreat to all squadmates (async, error-shielded, overlay-only, never disables or teleports).
        /// </summary>
        public void BroadcastFallback(Vector3 retreatPoint)
        {
            float now = Time.time;
            foreach (var kv in _combatMap)
            {
                BotOwner mate = kv.Key;
                CombatStateMachine fsm = kv.Value;

                if (EFTPlayerUtil.IsValidBotOwner(mate) && mate != _bot && fsm != null)
                {
                    float delay = Random.Range(0.11f, 0.29f);
                    _ = TriggerDelayedFallback(fsm, retreatPoint, now, delay);
                }
            }
        }

        /// <summary>
        /// Shares an enemy (target) with all teammates (async, error-shielded).
        /// </summary>
        public void ShareTarget(IPlayer enemy)
        {
            try
            {
                if (enemy == null || string.IsNullOrEmpty(enemy.ProfileId))
                    return;

                Player resolved = EFTPlayerUtil.ResolvePlayerById(enemy.ProfileId);
                if (!EFTPlayerUtil.IsValid(resolved))
                    return;

                IPlayer safe = EFTPlayerUtil.AsSafeIPlayer(resolved);
                for (int i = 0; i < _teammates.Count; i++)
                {
                    BotOwner mate = _teammates[i];
                    if (EFTPlayerUtil.IsValidBotOwner(mate))
                    {
                        float delay = Random.Range(0.07f, 0.23f);
                        _ = TriggerDelayedRegisterEnemy(mate, safe, delay);
                    }
                }
            }
            catch { }
        }

        /// <summary>
        /// Regroups squadmates to the squad center, arbitration-only overlay movement (never disables/teleports, deduped).
        /// Personality-aware spacing, squad role-aware dynamic formation, micro-drift for realism.
        /// </summary>
        public void CoordinateMovement()
        {
            try
            {
                if (_bot == null || _bot.IsDead || _teammates.Count == 0)
                    return;

                if (!BotOverlayManager.CanIssueMove(_bot, BotOverlayType.SquadMove))
                    return;

                Vector3 center = Vector3.zero;
                int count = 0;
                float cohesionSum = 0f;

                for (int i = 0; i < _teammates.Count; i++)
                {
                    BotOwner mate = _teammates[i];
                    if (EFTPlayerUtil.IsValidBotOwner(mate))
                    {
                        center += mate.Position;
                        if (BotRegistry.TryGet(mate.ProfileId, out var p)) cohesionSum += p.Cohesion;
                        count++;
                    }
                }

                if (count == 0)
                    return;

                center /= count;
                float squadCohesion = cohesionSum / count;
                float spread = 2.4f + 1.2f * (1f - squadCohesion); // tighter for cohesive squads

                // Realistic formation: project a circle around the center (if more than 2 bots)
                int myIdx = 0, squadCount = _teammates.Count + 1;
                for (int i = 0; i < _teammates.Count; i++)
                    if (_teammates[i] == _bot) myIdx = i + 1; // slot 1 after teammate list

                float angle = 2 * Mathf.PI * myIdx / squadCount;
                Vector3 formationOffset = new Vector3(Mathf.Cos(angle), 0f, Mathf.Sin(angle)) * spread;

                Vector3 jitter = UnityEngine.Random.insideUnitSphere * RegroupJitterRadius * (1f - squadCohesion + 0.25f);
                jitter.y = 0f;

                Vector3 target = center + formationOffset + jitter;

                if ((target - _lastMoveTarget).sqrMagnitude > MinMoveDeltaSqr)
                {
                    if (BotNavHelper.TryGetNavMeshSafePosition(target, _bot.Position, out Vector3 navSafe))
                    {
                        var profile = BotRegistry.GetOrRegister(_bot);
                        Vector3 drifted = BotMovementHelper.ApplyMicroDrift(navSafe, _bot.ProfileId, Time.frameCount, profile);
                        BotMovementHelper.SmoothMoveToSafe(_bot, drifted, slow: true, cohesion: profile.Cohesion);
                        _lastMoveTarget = drifted;
                        BotOverlayManager.RegisterMove(_bot, BotOverlayType.SquadMove);
                    }
                }
            }
            catch { }
        }

        /// <summary>
        /// Squad danger broadcast (panic, suppression, grenade) to all alive teammates (arbitration/event, async error shielded).
        /// </summary>
        public void BroadcastDanger(Vector3 dangerPos)
        {
            float now = Time.time;
            if ((dangerPos - _lastSquadDangerPosition).sqrMagnitude < 2.25f && now - _lastSquadDangerBroadcast < SquadDangerZonePersist)
                return;

            _lastSquadDangerPosition = dangerPos;
            _lastSquadDangerBroadcast = now;

            for (int i = 0; i < _teammates.Count; i++)
            {
                BotOwner mate = _teammates[i];
                if (!EFTPlayerUtil.IsValidBotOwner(mate) || mate == _bot) continue;
                if ((mate.Position - dangerPos).sqrMagnitude < MaxCommsRadiusSqr)
                {
                    try
                    {
                        if (BotComponentCacheRegistry.TryGetByPlayer(mate.GetPlayer, out var cache) && cache?.PanicHandler != null)
                        {
                            cache.PanicHandler.TriggerPanic("squad-danger");
                        }
                    }
                    catch { }
                }
            }
        }

        /// <summary>
        /// Wires squadmate combat FSMs for event overlays, fallback, and group comms.
        /// </summary>
        public void InjectCombatState(BotOwner mate, CombatStateMachine fsm)
        {
            if (EFTPlayerUtil.IsValidBotOwner(mate) && fsm != null && mate != _bot && !_combatMap.ContainsKey(mate))
                _combatMap[mate] = fsm;
        }

        /// <summary>
        /// Sets all current teammates for use in comms and regroup logic. Always called by BotBrain.
        /// </summary>
        public void SetTeammates(List<BotOwner> allBots)
        {
            _teammates.Clear();
            try
            {
                var selfProfile = _bot.GetPlayer?.Profile?.Info;
                if (selfProfile == null) return;

                string groupId = selfProfile.GroupId;
                if (string.IsNullOrEmpty(groupId)) return;

                for (int i = 0; i < allBots.Count; i++)
                {
                    BotOwner other = allBots[i];
                    if (EFTPlayerUtil.IsValidBotOwner(other) &&
                        other != _bot &&
                        other.GetPlayer?.Profile?.Info?.GroupId == groupId)
                    {
                        _teammates.Add(other);
                    }
                }
            }
            catch { }
        }

        #endregion

        #region Internals (Async, Arbitration, Bulletproof)

        private static async Task TriggerDelayedRegisterEnemy(BotOwner receiver, IPlayer enemy, float delay)
        {
            if (!EFTPlayerUtil.IsValidBotOwner(receiver) || enemy == null)
                return;

            try
            {
                await Task.Delay((int)(delay * 1000f));
                ForceRegisterEnemy(receiver, enemy);
            }
            catch { }
        }

        private static async Task TriggerDelayedFallback(CombatStateMachine fsm, Vector3 point, float now, float delay)
        {
            if (fsm == null) return;
            try
            {
                await Task.Delay((int)(delay * 1000f));
                fsm.TriggerFallback(point, now);
            }
            catch { }
        }

        /// <summary>
        /// Registers an enemy into the bots' memory and group. Event/arbitration only.
        /// </summary>
        private static void ForceRegisterEnemy(BotOwner receiver, IPlayer enemy)
        {
            try
            {
                if (receiver.BotsGroup != null && !receiver.BotsGroup.IsEnemy(enemy))
                    receiver.BotsGroup.AddEnemy(enemy, EBotEnemyCause.zryachiyLogic);

                if (!receiver.EnemiesController.EnemyInfos.ContainsKey(enemy))
                {
                    var settings = new BotSettingsClass((Player)enemy, receiver.BotsGroup, EBotEnemyCause.zryachiyLogic);
                    receiver.Memory?.AddEnemy(enemy, settings, false);
                }
            }
            catch { }
        }

        #endregion
    }
}
