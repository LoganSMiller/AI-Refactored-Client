// <auto-generated>
//   This file is part of AI-Refactored, an open-source project focused on realistic AI behavior in Escape from Tarkov.
//   Licensed under the MIT License. See LICENSE in the repository root for more information.
//
//   THIS FILE IS SYSTEMATICALLY MANAGED.
//   All squad cohesion is human-like: realistic organic spacing, gentle repulsion, and flocking. No vanilla fallback unless nav is invalid.
// </auto-generated>

namespace AIRefactored.AI.Groups
{
    using System;
    using AIRefactored.AI.Core;
    using AIRefactored.AI.Helpers;
    using AIRefactored.Core;
    using EFT;
    using UnityEngine;

    /// <summary>
    /// Maintains passive squad cohesion when idle or patrolling:
    /// • Repels bots that are too close (human-like personal space)
    /// • Follows furthest idle mate if too far (flocking)
    /// • Adds subtle deterministic jitter and drift for organic movement
    /// Bulletproof: All failures isolated; fallback to vanilla AI movement only on total nav failure.
    /// </summary>
    public sealed class BotGroupBehavior
    {
        #region Constants

        private const float MaxSpacing = 7.5f;
        private const float MinSpacing = 2.25f;
        private const float SpacingTolerance = 0.28f;
        private const float RepulseStrength = 1.15f;
        private const float JitterAmount = 0.11f;
        private const float DriftSpeed = 0.13f;
        private const float MaxSquadRadius = 12.0f;
        private const float MinTickMoveInterval = 0.37f;

        private static readonly float MinSpacingSqr = MinSpacing * MinSpacing;
        private static readonly float MaxSpacingSqr = MaxSpacing * MaxSpacing;
        private static readonly float MaxSquadRadiusSqr = MaxSquadRadius * MaxSquadRadius;

        #endregion

        #region Fields

        private BotOwner _bot;
        private BotComponentCache _cache;
        private BotsGroup _group;

        private Vector3 _lastMoveTarget;
        private bool _hasLastTarget;
        private float _lastMoveTime;
        private Vector2 _personalDrift;

        #endregion

        #region Properties

        public BotGroupSyncCoordinator GroupSync { get; private set; }

        #endregion

        #region Initialization

        public void Initialize(BotComponentCache componentCache)
        {
            try
            {
                if (componentCache == null || componentCache.Bot == null)
                    throw new ArgumentException("[BotGroupBehavior] Invalid component cache.");

                _cache = componentCache;
                _bot = componentCache.Bot;
                _group = _bot.BotsGroup;

                GroupSync = new BotGroupSyncCoordinator();
                GroupSync.Initialize(_bot);
                GroupSync.InjectLocalCache(_cache);

                _personalDrift = ComputePersonalDrift(_bot.ProfileId);
                _hasLastTarget = false;
            }
            catch (Exception ex)
            {
                Plugin.LoggerInstance.LogError("[BotGroupBehavior] Initialization failed: " + ex);
                FallbackMoveStatic();
            }
        }

        #endregion

        #region Tick

        public void Tick(float deltaTime)
        {
            try
            {
                if (!IsEligible() || _bot.Memory == null || _bot.Memory.GoalEnemy != null)
                    return;

                Vector3 myPos = _bot.Position;
                Vector3 repulsion = Vector3.zero;
                Vector3 furthest = Vector3.zero;
                float maxDistSqr = MinSpacingSqr;
                bool hasFurthest = false;

                int memberCount = _group.MembersCount;
                for (int i = 0; i < memberCount; i++)
                {
                    BotOwner mate = _group.Member(i);
                    if (mate == null || ReferenceEquals(mate, _bot) || mate.IsDead || mate.Memory == null)
                        continue;

                    Vector3 offset = mate.Position - myPos;
                    float distSqr = offset.sqrMagnitude;

                    if (distSqr < MinSpacingSqr)
                    {
                        float push = MinSpacing - Mathf.Sqrt(distSqr);
                        repulsion += -offset.normalized * push * 0.73f;
                    }
                    else if (distSqr > MaxSpacingSqr && distSqr > maxDistSqr && distSqr < MaxSquadRadiusSqr && mate.Memory.GoalEnemy == null)
                    {
                        maxDistSqr = distSqr;
                        furthest = mate.Position;
                        hasFurthest = true;
                    }
                }

                if (repulsion.sqrMagnitude > 0.012f)
                {
                    IssueMove(SmoothDriftMove(myPos, repulsion.normalized * RepulseStrength, deltaTime));
                    return;
                }

                if (hasFurthest)
                {
                    Vector3 dir = furthest - myPos;
                    if (dir.sqrMagnitude > 0.0007f)
                        IssueMove(SmoothDriftMove(myPos, dir.normalized * MaxSpacing * 0.65f, deltaTime));
                }
            }
            catch (Exception ex)
            {
                Plugin.LoggerInstance.LogError("[BotGroupBehavior] Tick failed: " + ex);
                FallbackMoveStatic();
            }
        }

        #endregion

        #region Movement Helpers

        private bool IsEligible()
        {
            return _bot != null &&
                   _group != null &&
                   !_bot.IsDead &&
                   EFTPlayerUtil.IsValidBotOwner(_bot) &&
                   _group.MembersCount > 1;
        }

        private Vector3 SmoothDriftMove(Vector3 basePos, Vector3 direction, float deltaTime)
        {
            Vector3 jitter = DeterministicJitter(_bot.ProfileId, Time.frameCount) * JitterAmount;
            Vector3 drift = direction.normalized * DriftSpeed * Mathf.Clamp(deltaTime * 2f, 0.12f, 0.32f);
            Vector3 personalBias = new Vector3(_personalDrift.x, 0f, _personalDrift.y) * 0.6f;

            return basePos + drift + jitter + personalBias;
        }

        private void IssueMove(Vector3 target)
        {
            try
            {
                Vector3 jitteredTarget = target + DeterministicJitter(_bot.ProfileId, Time.frameCount * 2) * JitterAmount;
                float now = Time.time;

                if (!_hasLastTarget || Vector3.Distance(_lastMoveTarget, jitteredTarget) > SpacingTolerance || now - _lastMoveTime > MinTickMoveInterval)
                {
                    _lastMoveTarget = jitteredTarget;
                    _hasLastTarget = true;
                    _lastMoveTime = now;
                    BotMovementHelper.SmoothMoveTo(_bot, jitteredTarget, false);
                }
            }
            catch (Exception ex)
            {
                Plugin.LoggerInstance.LogError("[BotGroupBehavior] IssueMove failed: " + ex);
                FallbackMoveStatic();
            }
        }

        private static Vector3 DeterministicJitter(string profileId, int tick)
        {
            int hash = (profileId.GetHashCode()) ^ (tick * 31) ^ 0x7F4A12B;
            unchecked
            {
                hash = (hash ^ (hash >> 13)) * 0x5bd1e995;
                float x = ((hash & 0xFFFF) / 32768f) - 1.0f;
                float z = (((hash >> 16) & 0xFFFF) / 32768f) - 1.0f;
                return new Vector3(x, 0f, z);
            }
        }

        private static Vector2 ComputePersonalDrift(string profileId)
        {
            int seed = profileId.GetHashCode() ^ 0x181A91C;
            var rand = new System.Random(seed);
            float angle = (float)(rand.NextDouble() * Mathf.PI * 2.0);
            float radius = 0.18f + (float)(rand.NextDouble() * 0.18f);
            return new Vector2(Mathf.Cos(angle) * radius, Mathf.Sin(angle) * radius);
        }

        private void FallbackMoveStatic()
        {
            try
            {
                if (_bot != null && !_bot.IsDead && _bot.Mover != null)
                    _bot.Mover.GoToPoint(_bot.Position, true, 1.0f);
            }
            catch
            {
                // Absolute fail-safe.
            }
        }

        #endregion
    }
}
