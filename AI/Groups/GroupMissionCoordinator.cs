// <auto-generated>
//   AI-Refactored: GroupMissionCoordinator.cs (Supreme Arbitration & Overlay Edition – June 2025, Bulletproofed, Beyond Diamond)
//   Dynamically assigns and caches squad missions by group ID. Personality, map, and squad-aware.
//   Bulletproof: Strict null guards, error isolation, zero static persistence post-raid, pooled logic, no propagation.
//   MIT License.
// </auto-generated>

namespace AIRefactored.AI.Groups
{
    using System;
    using System.Collections.Generic;
    using AIRefactored.AI.Missions;
    using AIRefactored.AI.Core;
    using AIRefactored.Core;
    using EFT;
    using UnityEngine;

    /// <summary>
    /// Dynamically assigns and caches squad missions (Loot, Fight, Quest) per group, with map, squad, and bot personality awareness.
    /// Arbitration/event-safe, bulletproof, zero alloc in hot path, zero static persistence after raid.
    /// </summary>
    public static class GroupMissionCoordinator
    {
        #region Static State

        private static readonly Dictionary<string, BotMissionController.MissionType> AssignedMissions =
            new Dictionary<string, BotMissionController.MissionType>(32, StringComparer.OrdinalIgnoreCase);

        #endregion

        #region Public API

        /// <summary>
        /// Explicitly assign a mission to a group. Overlay/event safe.
        /// </summary>
        public static void ForceMissionForGroup(string groupId, BotMissionController.MissionType mission)
        {
            if (!string.IsNullOrEmpty(groupId))
                AssignedMissions[groupId] = mission;
        }

        /// <summary>
        /// Gets the current mission for a bot's squad, generating if none exists.
        /// Always returns a valid mission, fully overlay/event-bulletproof.
        /// </summary>
        public static BotMissionController.MissionType GetMissionForGroup(BotOwner bot)
        {
            try
            {
                if (!EFTPlayerUtil.IsValidBotOwner(bot))
                    return BotMissionController.MissionType.Loot;

                string groupId = bot.GetPlayer?.Profile?.Info?.GroupId;
                if (string.IsNullOrEmpty(groupId))
                    return PickMission(bot);

                if (!AssignedMissions.TryGetValue(groupId, out var mission))
                {
                    mission = PickMission(bot);
                    AssignedMissions[groupId] = mission;
                }

                return mission;
            }
            catch
            {
                return BotMissionController.MissionType.Loot;
            }
        }

        /// <summary>
        /// Registers a bot's squad for mission generation if not present.
        /// Overlay/event bulletproof, never disables or throws.
        /// </summary>
        public static void RegisterFromBot(BotOwner bot)
        {
            try
            {
                if (!EFTPlayerUtil.IsValidBotOwner(bot))
                    return;

                string groupId = bot.GetPlayer?.Profile?.Info?.GroupId;
                if (!string.IsNullOrEmpty(groupId) && !AssignedMissions.ContainsKey(groupId))
                    AssignedMissions[groupId] = PickMission(bot);
            }
            catch { }
        }

        /// <summary>
        /// Resets all mission assignments. Should be called on raid/round end.
        /// </summary>
        public static void Reset()
        {
            AssignedMissions.Clear();
        }

        #endregion

        #region Internal Mission Logic

        /// <summary>
        /// Picks a mission using map, squad personality, and role weighting.
        /// No alloc in hot path, overlay/event-bulletproof, randomized for squad diversity.
        /// </summary>
        private static BotMissionController.MissionType PickMission(BotOwner bot)
        {
            float loot = 1f, fight = 1f, quest = 1f;
            int squadCount = 1;

            try
            {
                string map = GameWorldHandler.TryGetValidMapName();
                switch (map)
                {
                    case "factory4_day":
                    case "factory4_night": fight += 1.7f; break;
                    case "woods": loot += 1.5f; break;
                    case "bigmap": quest += 0.9f; fight += 0.2f; break;
                    case "interchange": loot += 1.3f; break;
                    case "rezervbase": fight += 1.2f; loot += 0.4f; break;
                    case "lighthouse": quest += 1.2f; loot += 0.9f; break;
                    case "shoreline": quest += 1.4f; loot += 0.8f; break;
                    case "tarkovstreets": fight += 1.5f; loot += 0.5f; break;
                    case "laboratory": fight += 2.3f; break;
                    case "sandbox":
                    case "sandbox_high":
                    case "groundzero": loot += 1.2f; break;
                    default: loot += 0.7f; break;
                }

                string groupId = bot.GetPlayer?.Profile?.Info?.GroupId;
                if (!string.IsNullOrEmpty(groupId))
                    squadCount = Math.Max(1, BotTeamTracker.GetGroup(groupId).Count);

                if (BotRegistry.TryGet(bot.ProfileId, out var profile))
                {
                    // Weighted by personality traits
                    loot += profile.Caution * 1.05f + (profile.IsFearful ? 1.25f : 0f);
                    quest += profile.Caution * 0.52f + (profile.IsCamper ? 1.1f : 0f);
                    fight += profile.AggressionLevel * 1.35f + (profile.IsFrenzied ? 1.55f : 0f);

                    // Squad size scaling: larger squads more likely to fight or quest
                    fight += 0.25f * squadCount;
                    quest += 0.18f * squadCount;
                }
            }
            catch { }

            float total = loot + fight + quest;
            float roll = UnityEngine.Random.value * total;

            if (roll < loot)
                return BotMissionController.MissionType.Loot;
            if (roll < loot + fight)
                return BotMissionController.MissionType.Fight;
            return BotMissionController.MissionType.Quest;
        }

        #endregion
    }
}
