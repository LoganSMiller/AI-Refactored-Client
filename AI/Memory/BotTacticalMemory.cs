// <auto-generated>
//   This file is part of AI-Refactored, an open-source project focused on realistic AI behavior in Escape from Tarkov.
//   Licensed under the MIT License. See LICENSE in the repository root for more information.
//
//   THIS FILE IS SYSTEMATICALLY MANAGED.
//   Please follow strict StyleCop, ReSharper, and AI-Refactored code standards for all modifications.
// </auto-generated>

#nullable enable

namespace AIRefactored.AI.Memory
{
    using System;
    using System.Collections.Generic;
    using AIRefactored.AI.Core;
    using AIRefactored.Core;
    using UnityEngine;

    /// <summary>
    /// Stores recent enemy sightings and cleared safe zones.
    /// Helps bots avoid repeat danger and synchronize fallback intel.
    /// </summary>
    public sealed class BotTacticalMemory
    {
        private const float ClearedMemoryDuration = 10f;
        private const float GridSnapSize = 0.5f;
        private const float MaxMemoryTime = 14f;
        private const float PositionToleranceSqr = 0.25f;

        private readonly Dictionary<Vector3, float> ClearedSpots = new Dictionary<Vector3, float>(32, new Vector3EqualityComparer());
        private readonly Dictionary<string, SeenEnemyRecord> EnemyMemoryById = new Dictionary<string, SeenEnemyRecord>(4, StringComparer.OrdinalIgnoreCase);
        private readonly List<SeenEnemyRecord> EnemyMemoryList = new List<SeenEnemyRecord>(4);

        private BotComponentCache? _cache;

        /// <summary>
        /// Initializes the tactical memory system with bot context.
        /// </summary>
        /// <param name="cache">Reference to bot component cache.</param>
        public void Initialize(BotComponentCache cache)
        {
            this._cache = cache;
        }

        /// <summary>
        /// Clears memory that is too old to be reliable.
        /// </summary>
        public void CullExpired()
        {
            float now = Time.time;
            this.EnemyMemoryList.RemoveAll(memory => now - memory.TimeSeen > MaxMemoryTime);

            List<string> toRemove = new List<string>();
            foreach (KeyValuePair<string, SeenEnemyRecord> kvp in this.EnemyMemoryById)
            {
                if (now - kvp.Value.TimeSeen > MaxMemoryTime)
                {
                    toRemove.Add(kvp.Key);
                }
            }

            for (int i = 0; i < toRemove.Count; i++)
            {
                this.EnemyMemoryById.Remove(toRemove[i]);
            }
        }

        /// <summary>
        /// Returns all known enemy memories.
        /// </summary>
        public List<SeenEnemyRecord> GetAllMemory()
        {
            return this.EnemyMemoryList;
        }

        /// <summary>
        /// Gets the most recently seen enemy position, if any.
        /// </summary>
        public Vector3? GetRecentEnemyMemory()
        {
            float now = Time.time;
            SeenEnemyRecord? freshest = null;

            for (int i = 0; i < this.EnemyMemoryList.Count; i++)
            {
                SeenEnemyRecord mem = this.EnemyMemoryList[i];
                if (now - mem.TimeSeen <= MaxMemoryTime)
                {
                    if (!freshest.HasValue || mem.TimeSeen > freshest.Value.TimeSeen)
                    {
                        freshest = mem;
                    }
                }
            }

            return freshest?.Position;
        }

        /// <summary>
        /// Marks a position as cleared of threats.
        /// </summary>
        public void MarkCleared(Vector3 position)
        {
            this.ClearedSpots[SnapToGrid(position)] = Time.time;
        }

        /// <summary>
        /// Records the last known position of an enemy.
        /// </summary>
        public void RecordEnemyPosition(Vector3 position, string? tag = "Generic", string? enemyId = null)
        {
            if (this._cache == null || this._cache.IsBlinded || (this._cache.PanicHandler?.IsPanicking ?? false))
            {
                return;
            }

            float now = Time.time;
            Vector3 gridPos = SnapToGrid(position);

            string finalTag = "Generic";
            if (tag != null)
            {
                string trimmedTag = tag.Trim();
                if (!string.IsNullOrEmpty(trimmedTag))
                {
                    finalTag = trimmedTag;
                }
            }

            if (enemyId != null)
            {
                string trimmedId = enemyId.Trim();
                if (!string.IsNullOrEmpty(trimmedId))
                {
                    this.EnemyMemoryById[trimmedId] = new SeenEnemyRecord(gridPos, now, finalTag);
                }
            }

            for (int i = 0; i < this.EnemyMemoryList.Count; i++)
            {
                if ((gridPos - this.EnemyMemoryList[i].Position).sqrMagnitude < PositionToleranceSqr)
                {
                    this.EnemyMemoryList[i] = new SeenEnemyRecord(gridPos, now, finalTag);
                    return;
                }
            }

            this.EnemyMemoryList.Add(new SeenEnemyRecord(gridPos, now, finalTag));
        }

        /// <summary>
        /// Determines whether a position is considered unsafe.
        /// </summary>
        public bool IsZoneUnsafe(Vector3 position)
        {
            if (this._cache?.Bot == null)
            {
                return false;
            }

            string map = GameWorldHandler.GetCurrentMapName();
            Vector3 gridPos = SnapToGrid(position);
            float now = Time.time;

            for (int i = 0; i < this.EnemyMemoryList.Count; i++)
            {
                if ((gridPos - this.EnemyMemoryList[i].Position).sqrMagnitude < PositionToleranceSqr)
                {
                    return true;
                }
            }

            foreach (KeyValuePair<Vector3, float> kvp in this.ClearedSpots)
            {
                if ((kvp.Key - gridPos).sqrMagnitude < PositionToleranceSqr && now - kvp.Value < ClearedMemoryDuration)
                {
                    return true;
                }
            }

            return BotMemoryStore.IsPositionInDangerZone(map, position);
        }

        /// <summary>
        /// Checks if a zone was recently cleared.
        /// </summary>
        public bool WasRecentlyCleared(Vector3 position)
        {
            Vector3 gridPos = SnapToGrid(position);
            return this.ClearedSpots.TryGetValue(gridPos, out float lastTime) && Time.time - lastTime < ClearedMemoryDuration;
        }

        /// <summary>
        /// Resets all tactical memory.
        /// </summary>
        public void ResetMemory()
        {
            this.EnemyMemoryList.Clear();
            this.EnemyMemoryById.Clear();
            this.ClearedSpots.Clear();
        }

        /// <summary>
        /// Shares enemy memory with teammates.
        /// </summary>
        public void ShareMemoryWith(List<BotComponentCache> teammates)
        {
            for (int i = 0; i < this.EnemyMemoryList.Count; i++)
            {
                SeenEnemyRecord record = this.EnemyMemoryList[i];
                for (int j = 0; j < teammates.Count; j++)
                {
                    BotComponentCache mate = teammates[j];
                    if (mate?.Bot == null || mate.Bot == this._cache?.Bot)
                    {
                        continue;
                    }

                    string id = this._cache?.Bot?.Profile?.Id ?? "unknown";
                    mate.TacticalMemory?.SyncMemory(record.Position, "Echo:" + id);
                }
            }
        }

        /// <summary>
        /// Receives shared memory from another bot.
        /// </summary>
        public void SyncMemory(Vector3 position, string tag = "AllyEcho")
        {
            this.RecordEnemyPosition(position, tag);
        }

        private static Vector3 SnapToGrid(Vector3 pos)
        {
            return new Vector3(
                Mathf.Round(pos.x / GridSnapSize) * GridSnapSize,
                Mathf.Round(pos.y / GridSnapSize) * GridSnapSize,
                Mathf.Round(pos.z / GridSnapSize) * GridSnapSize);
        }

        /// <summary>
        /// Simple enemy memory record structure.
        /// </summary>
        public struct SeenEnemyRecord
        {
            public Vector3 Position;
            public float TimeSeen;
            public string Tag;

            public SeenEnemyRecord(Vector3 position, float time, string tag)
            {
                this.Position = position;
                this.TimeSeen = time;
                this.Tag = tag;
            }
        }

        private sealed class Vector3EqualityComparer : IEqualityComparer<Vector3>
        {
            public bool Equals(Vector3 a, Vector3 b)
            {
                return (a - b).sqrMagnitude < PositionToleranceSqr;
            }

            public int GetHashCode(Vector3 v)
            {
                unchecked
                {
                    int hash = 17;
                    hash = hash * 23 + Mathf.RoundToInt(v.x * 10f);
                    hash = hash * 23 + Mathf.RoundToInt(v.y * 10f);
                    hash = hash * 23 + Mathf.RoundToInt(v.z * 10f);
                    return hash;
                }
            }
        }
    }
}
