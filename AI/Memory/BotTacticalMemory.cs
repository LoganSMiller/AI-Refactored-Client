// <auto-generated>
//   AI-Refactored: BotTacticalMemory.cs (Ultra-Platinum++, Beyond Diamond, BotBrain Edition – June 2025, Supreme Expansion)
//   All expiry/timer logic must be ticked by BotBrain. No self-tick. No fallback disables ever.
//   Bulletproof error isolation. Squad memory, suppression, and danger logic fully resilient.
//   Fully pooled, squad-safe, and multiplayer/headless resilient.
//   MIT License.
// </auto-generated>

namespace AIRefactored.AI.Memory
{
    using System;
    using System.Collections.Generic;
    using AIRefactored.AI.Combat;
    using AIRefactored.AI.Core;
    using AIRefactored.Core;
    using AIRefactored.Pools;
    using BepInEx.Logging;
    using UnityEngine;

    /// <summary>
    /// Tactical enemy, suppression, and zone memory, bulletproof and BotBrain-driven.
    /// All expiry, squad, and sharing logic is called via BotBrain.Tick(). No disables, overlay-only.
    /// </summary>
    public sealed class BotTacticalMemory
    {
        #region Constants

        private const float ClearedMemoryDuration = 10f;
        private const float GridSnapSize = 0.5f;
        private const float MaxMemoryTime = 14f;
        private const float PositionToleranceSqr = 0.25f;
        private const float AnticipationEventWindow = 1.35f;
        private const float DangerZoneQueryRadius = 3.2f;
        private const float SuppressionMemoryDuration = 5.5f;

        #endregion

        #region Fields

        private static readonly ManualLogSource Logger = Plugin.LoggerInstance;

        private readonly Dictionary<Vector3, float> _clearedSpots = new Dictionary<Vector3, float>(32, new Vector3EqualityComparer());
        private readonly Dictionary<Vector3, float> _suppressionMemory = new Dictionary<Vector3, float>(16, new Vector3EqualityComparer());
        private readonly Dictionary<string, SeenEnemyRecord> _enemyMemoryById = new Dictionary<string, SeenEnemyRecord>(8, StringComparer.OrdinalIgnoreCase);
        private readonly List<SeenEnemyRecord> _enemyMemoryList = new List<SeenEnemyRecord>(8);

        private BotComponentCache _cache;
        private bool _extractionStarted;
        private float _lastAnticipationEvent = -99f;

        #endregion

        #region Initialization

        /// <summary>
        /// Initializes this tactical memory with the provided cache.
        /// </summary>
        public void Initialize(BotComponentCache cache)
        {
            try { _cache = cache; }
            catch (Exception ex) { Logger.LogError($"[BotTacticalMemory] Initialize failed: {ex}"); }
        }

        #endregion

        #region BotBrain-Tick Management

        /// <summary>
        /// Call once per BotBrain.Tick(). Handles expiry and cleanup of memory.
        /// </summary>
        public void Tick(float deltaTime)
        {
            CullExpired();
            CullClearedZones();
            CullSuppressionMemory();
        }

        private void CullExpired()
        {
            try
            {
                float now = Time.time;
                for (int i = _enemyMemoryList.Count - 1; i >= 0; i--)
                {
                    if (now - _enemyMemoryList[i].TimeSeen > MaxMemoryTime)
                        _enemyMemoryList.RemoveAt(i);
                }
                var expired = TempListPool.Rent<string>();
                foreach (var pair in _enemyMemoryById)
                {
                    if (now - pair.Value.TimeSeen > MaxMemoryTime)
                        expired.Add(pair.Key);
                }
                for (int i = 0; i < expired.Count; i++)
                    _enemyMemoryById.Remove(expired[i]);
                TempListPool.Return(expired);
            }
            catch (Exception ex)
            {
                Logger.LogError($"[BotTacticalMemory] CullExpired failed: {ex}");
            }
        }

        private void CullClearedZones()
        {
            try
            {
                float now = Time.time;
                var expired = TempListPool.Rent<Vector3>();
                foreach (var kv in _clearedSpots)
                {
                    if (now - kv.Value > ClearedMemoryDuration)
                        expired.Add(kv.Key);
                }
                for (int i = 0; i < expired.Count; i++)
                    _clearedSpots.Remove(expired[i]);
                TempListPool.Return(expired);
            }
            catch (Exception ex)
            {
                Logger.LogError($"[BotTacticalMemory] CullClearedZones failed: {ex}");
            }
        }

        private void CullSuppressionMemory()
        {
            try
            {
                float now = Time.time;
                var expired = TempListPool.Rent<Vector3>();
                foreach (var kv in _suppressionMemory)
                {
                    if (now - kv.Value > SuppressionMemoryDuration)
                        expired.Add(kv.Key);
                }
                for (int i = 0; i < expired.Count; i++)
                    _suppressionMemory.Remove(expired[i]);
                TempListPool.Return(expired);
            }
            catch (Exception ex)
            {
                Logger.LogError($"[BotTacticalMemory] CullSuppressionMemory failed: {ex}");
            }
        }

        #endregion

        #region Memory Management

        /// <summary>
        /// Clears all tactical memory for this bot.
        /// </summary>
        public void ClearAll()
        {
            try
            {
                _enemyMemoryList.Clear();
                _enemyMemoryById.Clear();
                _clearedSpots.Clear();
                _suppressionMemory.Clear();
                _extractionStarted = false;
                _lastAnticipationEvent = -99f;
            }
            catch (Exception ex)
            {
                Logger.LogError($"[BotTacticalMemory] ClearAll failed: {ex}");
            }
        }

        #endregion

        #region Enemy Recording

        /// <summary>
        /// Records a new enemy position into tactical memory. Snap-to-grid for pooled comparisons.
        /// </summary>
        public void RecordEnemyPosition(Vector3 position, string tag, string enemyId)
        {
            try
            {
                if (_cache == null || _cache.IsBlinded || (_cache.PanicHandler?.IsPanicking == true)) return;

                float now = Time.time;
                Vector3 gridPos = SnapToGrid(position);
                string finalTag = string.IsNullOrEmpty(tag) ? "Generic" : tag.Trim();

                if (!string.IsNullOrEmpty(enemyId))
                {
                    string cleanId = enemyId.Trim();
                    if (cleanId.Length > 0)
                        _enemyMemoryById[cleanId] = new SeenEnemyRecord(gridPos, now, finalTag);
                }

                // Replace or update existing memory (by grid)
                for (int i = 0; i < _enemyMemoryList.Count; i++)
                {
                    if ((gridPos - _enemyMemoryList[i].Position).sqrMagnitude < PositionToleranceSqr)
                    {
                        _enemyMemoryList[i] = new SeenEnemyRecord(gridPos, now, finalTag);
                        _lastAnticipationEvent = now;
                        return;
                    }
                }
                _enemyMemoryList.Add(new SeenEnemyRecord(gridPos, now, finalTag));
                _lastAnticipationEvent = now;
            }
            catch (Exception ex)
            {
                Logger.LogError($"[BotTacticalMemory] RecordEnemyPosition failed: {ex}");
            }
        }

        /// <summary>
        /// Records a suppression event at the given position for suppression memory overlays.
        /// </summary>
        public void RecordSuppressionEvent(Vector3 position, string sourceProfileId = "")
        {
            try
            {
                Vector3 gridPos = SnapToGrid(position);
                _suppressionMemory[gridPos] = Time.time;
                // Optionally could log sourceProfileId for analytics/future expansion.
            }
            catch (Exception ex)
            {
                Logger.LogError($"[BotTacticalMemory] RecordSuppressionEvent failed: {ex}");
            }
        }

        #endregion

        #region Enemy/Suppression Query

        /// <summary>
        /// Returns the most recently seen enemy position.
        /// </summary>
        public Vector3 GetRecentEnemyMemory()
        {
            try
            {
                float now = Time.time;
                float latest = -1f;
                Vector3 result = Vector3.zero;
                for (int i = 0; i < _enemyMemoryList.Count; i++)
                {
                    var record = _enemyMemoryList[i];
                    if (now - record.TimeSeen <= MaxMemoryTime && record.TimeSeen > latest)
                    {
                        latest = record.TimeSeen;
                        result = record.Position;
                    }
                }
                return result;
            }
            catch (Exception ex)
            {
                Logger.LogError($"[BotTacticalMemory] GetRecentEnemyMemory failed: {ex}");
                return Vector3.zero;
            }
        }

        /// <summary>
        /// Returns the ID of the most recently seen enemy.
        /// </summary>
        public string GetMostRecentEnemyId()
        {
            try
            {
                float now = Time.time;
                float latest = -1f;
                string result = string.Empty;
                foreach (var pair in _enemyMemoryById)
                {
                    if (now - pair.Value.TimeSeen <= MaxMemoryTime && pair.Value.TimeSeen > latest)
                    {
                        latest = pair.Value.TimeSeen;
                        result = pair.Key;
                    }
                }
                return result;
            }
            catch (Exception ex)
            {
                Logger.LogError($"[BotTacticalMemory] GetMostRecentEnemyId failed: {ex}");
                return string.Empty;
            }
        }

        /// <summary>
        /// Returns a reference to all currently held enemy records (read-only).
        /// </summary>
        public List<SeenEnemyRecord> GetAllMemory()
        {
            return _enemyMemoryList;
        }

        /// <summary>
        /// Returns true if this position was marked suppressed recently.
        /// </summary>
        public bool WasRecentlySuppressed(Vector3 position)
        {
            try
            {
                Vector3 grid = SnapToGrid(position);
                return _suppressionMemory.TryGetValue(grid, out float lastTime) && (Time.time - lastTime < SuppressionMemoryDuration);
            }
            catch (Exception ex)
            {
                Logger.LogError($"[BotTacticalMemory] WasRecentlySuppressed failed: {ex}");
                return false;
            }
        }

        /// <summary>
        /// Returns true if this position was marked cleared recently.
        /// </summary>
        public bool WasRecentlyCleared(Vector3 position)
        {
            try
            {
                Vector3 grid = SnapToGrid(position);
                return _clearedSpots.TryGetValue(grid, out float lastTime) && (Time.time - lastTime < ClearedMemoryDuration);
            }
            catch (Exception ex)
            {
                Logger.LogError($"[BotTacticalMemory] WasRecentlyCleared failed: {ex}");
                return false;
            }
        }

        /// <summary>
        /// Returns true if this position is currently unsafe due to enemy memory, suppression, cleared spots, or danger zone.
        /// </summary>
        public bool IsZoneUnsafe(Vector3 position)
        {
            try
            {
                if (_cache?.Bot?.Profile == null) return false;
                float now = Time.time;
                Vector3 grid = SnapToGrid(position);
                for (int i = 0; i < _enemyMemoryList.Count; i++)
                {
                    if ((grid - _enemyMemoryList[i].Position).sqrMagnitude < PositionToleranceSqr)
                        return true;
                }
                foreach (var kv in _clearedSpots)
                {
                    if ((kv.Key - grid).sqrMagnitude < PositionToleranceSqr && (now - kv.Value) < ClearedMemoryDuration)
                        return true;
                }
                foreach (var kv in _suppressionMemory)
                {
                    if ((kv.Key - grid).sqrMagnitude < PositionToleranceSqr && (now - kv.Value) < SuppressionMemoryDuration)
                        return true;
                }
                string mapId = GameWorldHandler.TryGetValidMapName();
                return mapId.Length > 0 && BotMemoryStore.IsPositionInDangerZone(mapId, position);
            }
            catch (Exception ex)
            {
                Logger.LogError($"[BotTacticalMemory] IsZoneUnsafe failed: {ex}");
                return false;
            }
        }

        /// <summary>
        /// Returns true if a recent enemy position/anticipation/fakeout event has occurred (for overlay arbitration).
        /// </summary>
        public bool HasRecentAnticipationEvent()
        {
            try { return (Time.time - _lastAnticipationEvent) < AnticipationEventWindow; }
            catch (Exception ex) { Logger.LogError($"[BotTacticalMemory] HasRecentAnticipationEvent failed: {ex}"); return false; }
        }

        #endregion

        #region Squad/Overlay Memory Sharing

        /// <summary>
        /// Records an ally-echoed enemy position into tactical memory (squad share).
        /// </summary>
        public void SyncMemory(Vector3 position)
        {
            try { RecordEnemyPosition(position, "AllyEcho", string.Empty); }
            catch (Exception ex) { Logger.LogError($"[BotTacticalMemory] SyncMemory failed: {ex}"); }
        }

        /// <summary>
        /// Shares this bot's tactical memory with the specified teammates. All logic is pooled, safe, and never disables.
        /// </summary>
        public void ShareMemoryWith(List<BotComponentCache> teammates)
        {
            try
            {
                if (teammates == null || teammates.Count == 0 || _cache?.Bot == null)
                    return;

                for (int i = 0; i < _enemyMemoryList.Count; i++)
                {
                    var record = _enemyMemoryList[i];
                    for (int j = 0; j < teammates.Count; j++)
                    {
                        var mate = teammates[j];
                        if (mate?.Bot != null && mate.Bot != _cache.Bot)
                            mate.TacticalMemory?.SyncMemory(record.Position);
                    }
                }
            }
            catch (Exception ex)
            {
                Logger.LogError($"[BotTacticalMemory] ShareMemoryWith failed: {ex}");
            }
        }

        /// <summary>
        /// Returns a pooled list of all squad-known recent enemy memory within the team.
        /// </summary>
        public static List<Vector3> GatherSquadEnemyMemory(List<BotComponentCache> squad, float maxAge = MaxMemoryTime)
        {
            var results = TempListPool.Rent<Vector3>();
            try
            {
                if (squad == null || squad.Count == 0) return results;
                float now = Time.time;
                for (int i = 0; i < squad.Count; i++)
                {
                    var mem = squad[i]?.TacticalMemory?._enemyMemoryList;
                    if (mem == null) continue;
                    for (int j = 0; j < mem.Count; j++)
                        if (now - mem[j].TimeSeen <= maxAge)
                            results.Add(mem[j].Position);
                }
                return results;
            }
            catch (Exception ex)
            {
                Logger.LogError($"[BotTacticalMemory] GatherSquadEnemyMemory failed: {ex}");
                return results;
            }
        }

        #endregion

        #region Tactical Evaluation

        /// <summary>
        /// Marks the provided position as cleared (temporarily safe).
        /// </summary>
        public void MarkCleared(Vector3 position)
        {
            try { _clearedSpots[SnapToGrid(position)] = Time.time; }
            catch (Exception ex) { Logger.LogError($"[BotTacticalMemory] MarkCleared failed: {ex}"); }
        }

        /// <summary>
        /// Marks this bot as starting extraction (forced).
        /// </summary>
        public void MarkForcedExtract()
        {
            try { _extractionStarted = true; }
            catch (Exception ex) { Logger.LogError($"[BotTacticalMemory] MarkForcedExtract failed: {ex}"); }
        }

        /// <summary>
        /// Returns true if bot is currently extracting.
        /// </summary>
        public bool IsExtracting()
        {
            try { return _extractionStarted; }
            catch (Exception ex) { Logger.LogError($"[BotTacticalMemory] IsExtracting failed: {ex}"); return false; }
        }

        #endregion

        #region Utilities

        private static Vector3 SnapToGrid(Vector3 pos)
        {
            return new Vector3(
                Mathf.Round(pos.x / GridSnapSize) * GridSnapSize,
                Mathf.Round(pos.y / GridSnapSize) * GridSnapSize,
                Mathf.Round(pos.z / GridSnapSize) * GridSnapSize);
        }

        #endregion

        #region Nested Types

        public struct SeenEnemyRecord
        {
            public Vector3 Position;
            public float TimeSeen;
            public string Tag;

            public SeenEnemyRecord(Vector3 position, float time, string tag)
            {
                Position = position;
                TimeSeen = time;
                Tag = tag;
            }
        }

        private sealed class Vector3EqualityComparer : IEqualityComparer<Vector3>
        {
            public bool Equals(Vector3 a, Vector3 b)
            {
                return (a - b).sqrMagnitude < PositionToleranceSqr;
            }

            public int GetHashCode(Vector3 v)
            {
                unchecked
                {
                    int hash = 17;
                    hash = (hash * 23) + Mathf.RoundToInt(v.x * 10f);
                    hash = (hash * 23) + Mathf.RoundToInt(v.y * 10f);
                    hash = (hash * 23) + Mathf.RoundToInt(v.z * 10f);
                    return hash;
                }
            }
        }

        #endregion
    }
}
