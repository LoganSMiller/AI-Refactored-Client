// <auto-generated>
//   This file is part of AI-Refactored, an open-source project focused on realistic AI behavior in Escape from Tarkov.
//   Licensed under the MIT License. See LICENSE in the repository root for more information.
//
//   THIS FILE IS SYSTEMATICALLY MANAGED.
//   Please follow strict StyleCop, ReSharper, and AI-Refactored code standards for all modifications.
// </auto-generated>

#nullable enable

namespace AIRefactored.AI.Memory
{
    using System;
    using System.Collections.Generic;
    using AIRefactored.AI.Combat;
    using AIRefactored.AI.Core;
    using AIRefactored.Core;
    using UnityEngine;

    /// <summary>
    /// Tracks enemy sightings and cleared tactical zones.
    /// Used to prevent over-investigation, support fallback, and enable squad memory sync.
    /// </summary>
    public sealed class BotTacticalMemory
    {
        #region Constants

        private const float ClearedMemoryDuration = 10.0f;
        private const float GridSnapSize = 0.5f;
        private const float MaxMemoryTime = 14.0f;
        private const float PositionToleranceSqr = 0.25f;

        #endregion

        #region Fields

        private readonly Dictionary<Vector3, float> _clearedSpots = new Dictionary<Vector3, float>(32, new Vector3EqualityComparer());
        private readonly Dictionary<string, SeenEnemyRecord> _enemyMemoryById = new Dictionary<string, SeenEnemyRecord>(4, StringComparer.OrdinalIgnoreCase);
        private readonly List<SeenEnemyRecord> _enemyMemoryList = new List<SeenEnemyRecord>(4);

        private BotComponentCache? _cache;
        private bool _extractionStarted;

        #endregion

        #region Initialization

        /// <summary>
        /// Injects bot memory references from the AI cache.
        /// </summary>
        /// <param name="cache">Bot's component cache.</param>
        public void Initialize(BotComponentCache cache)
        {
            this._cache = cache;
        }

        #endregion

        #region Memory Management

        /// <summary>
        /// Clears expired tactical memory entries.
        /// </summary>
        public void CullExpired()
        {
            float now = Time.time;

            for (int i = this._enemyMemoryList.Count - 1; i >= 0; i--)
            {
                if (now - this._enemyMemoryList[i].TimeSeen > MaxMemoryTime)
                {
                    this._enemyMemoryList.RemoveAt(i);
                }
            }

            List<string> toRemove = new List<string>();
            foreach (KeyValuePair<string, SeenEnemyRecord> kvp in this._enemyMemoryById)
            {
                if (now - kvp.Value.TimeSeen > MaxMemoryTime)
                {
                    toRemove.Add(kvp.Key);
                }
            }

            for (int i = 0; i < toRemove.Count; i++)
            {
                this._enemyMemoryById.Remove(toRemove[i]);
            }
        }

        /// <summary>
        /// Clears all enemy and zone memory instantly.
        /// </summary>
        public void ResetMemory()
        {
            this._enemyMemoryList.Clear();
            this._enemyMemoryById.Clear();
            this._clearedSpots.Clear();
            this._extractionStarted = false;
        }

        /// <summary>
        /// Clears memory structures (used during bot reset).
        /// </summary>
        public void ClearAll()
        {
            this._enemyMemoryList.Clear();
            this._enemyMemoryById.Clear();
            this._clearedSpots.Clear();
            this._extractionStarted = false;
        }

        #endregion

        #region Enemy Memory

        /// <summary>
        /// Records an enemy sighting in memory.
        /// </summary>
        /// <summary>
        /// Records an enemy sighting in memory.
        /// </summary>
        /// <param name="position">World position of the enemy.</param>
        /// <param name="tag">Optional tag (e.g. "Sniper", "Boss").</param>
        /// <param name="enemyId">Optional enemy identifier.</param>
        public void RecordEnemyPosition(Vector3 position, string? tag, string? enemyId)
        {
            if (this._cache == null)
            {
                return;
            }

            if (this._cache.IsBlinded)
            {
                return;
            }

            BotPanicHandler? panicHandler = this._cache.PanicHandler;
            if (panicHandler != null && panicHandler.IsPanicking)
            {
                return;
            }

            float now = Time.time;
            Vector3 gridPos = SnapToGrid(position);

            string finalTag = "Generic";
            if (tag != null)
            {
                string trimmedTag = tag.Trim();
                if (trimmedTag.Length > 0)
                {
                    finalTag = trimmedTag;
                }
            }

            if (enemyId != null)
            {
                string trimmedId = enemyId.Trim();
                if (trimmedId.Length > 0)
                {
                    if (this._enemyMemoryById.ContainsKey(trimmedId))
                    {
                        this._enemyMemoryById[trimmedId] = new SeenEnemyRecord(gridPos, now, finalTag);
                    }
                    else
                    {
                        this._enemyMemoryById.Add(trimmedId, new SeenEnemyRecord(gridPos, now, finalTag));
                    }
                }
            }

            for (int i = 0; i < this._enemyMemoryList.Count; i++)
            {
                if ((gridPos - this._enemyMemoryList[i].Position).sqrMagnitude < PositionToleranceSqr)
                {
                    this._enemyMemoryList[i] = new SeenEnemyRecord(gridPos, now, finalTag);
                    return;
                }
            }

            this._enemyMemoryList.Add(new SeenEnemyRecord(gridPos, now, finalTag));
        }

        /// <summary>
        /// Gets the freshest known enemy position in memory.
        /// </summary>
        public Vector3? GetRecentEnemyMemory()
        {
            float now = Time.time;
            SeenEnemyRecord? freshest = null;

            for (int i = 0; i < this._enemyMemoryList.Count; i++)
            {
                SeenEnemyRecord record = this._enemyMemoryList[i];
                if (now - record.TimeSeen <= MaxMemoryTime)
                {
                    if (!freshest.HasValue || record.TimeSeen > freshest.Value.TimeSeen)
                    {
                        freshest = record;
                    }
                }
            }

            return freshest?.Position;
        }

        /// <summary>
        /// Returns all known enemy memory entries.
        /// </summary>
        public List<SeenEnemyRecord> GetAllMemory()
        {
            return this._enemyMemoryList;
        }

        /// <summary>
        /// Adds a remote position to memory (e.g. ally ping).
        /// </summary>
        public void SyncMemory(Vector3 position, string tag = "AllyEcho")
        {
            this.RecordEnemyPosition(position, tag, null);
        }

        /// <summary>
        /// Shares enemy memory with allied bots in squad.
        /// </summary>
        public void ShareMemoryWith(List<BotComponentCache> teammates)
        {
            if (teammates == null || teammates.Count == 0)
            {
                return;
            }

            string selfId = this._cache?.Bot?.Profile?.Id ?? "unknown";

            for (int i = 0; i < this._enemyMemoryList.Count; i++)
            {
                SeenEnemyRecord record = this._enemyMemoryList[i];
                for (int j = 0; j < teammates.Count; j++)
                {
                    BotComponentCache mate = teammates[j];
                    if (mate?.Bot == null || mate.Bot == this._cache?.Bot)
                    {
                        continue;
                    }

                    mate.TacticalMemory?.SyncMemory(record.Position, "Echo:" + selfId);
                }
            }
        }

        #endregion

        #region Zone Memory

        /// <summary>
        /// Marks a position as recently cleared (safe).
        /// </summary>
        public void MarkCleared(Vector3 position)
        {
            this._clearedSpots[SnapToGrid(position)] = Time.time;
        }

        /// <summary>
        /// Returns true if a zone was recently cleared and safe.
        /// </summary>
        public bool WasRecentlyCleared(Vector3 position)
        {
            Vector3 gridPos = SnapToGrid(position);
            float lastTime;
            return this._clearedSpots.TryGetValue(gridPos, out lastTime)
                && Time.time - lastTime < ClearedMemoryDuration;
        }

        /// <summary>
        /// Returns true if the specified zone is dangerous or untrusted.
        /// </summary>
        public bool IsZoneUnsafe(Vector3 position)
        {
            if (this._cache?.Bot == null)
            {
                return false;
            }

            float now = Time.time;
            Vector3 gridPos = SnapToGrid(position);

            for (int i = 0; i < this._enemyMemoryList.Count; i++)
            {
                if ((gridPos - this._enemyMemoryList[i].Position).sqrMagnitude < PositionToleranceSqr)
                {
                    return true;
                }
            }

            foreach (KeyValuePair<Vector3, float> kvp in this._clearedSpots)
            {
                if ((kvp.Key - gridPos).sqrMagnitude < PositionToleranceSqr && now - kvp.Value < ClearedMemoryDuration)
                {
                    return true;
                }
            }

            string mapId = GameWorldHandler.GetCurrentMapName();
            return BotMemoryStore.IsPositionInDangerZone(mapId, position);
        }

        /// <summary>
        /// Marks that this bot has started extraction.
        /// Prevents reuse of mission memory and fallback queries.
        /// </summary>
        public void MarkExtractionStarted()
        {
            this._extractionStarted = true;
        }

        /// <summary>
        /// Returns true if this bot is currently exiting or has committed to extract.
        /// </summary>
        public bool IsExtracting()
        {
            return this._extractionStarted;
        }

        #endregion

        #region Utility

        private static Vector3 SnapToGrid(Vector3 pos)
        {
            return new Vector3(
                Mathf.Round(pos.x / GridSnapSize) * GridSnapSize,
                Mathf.Round(pos.y / GridSnapSize) * GridSnapSize,
                Mathf.Round(pos.z / GridSnapSize) * GridSnapSize);
        }

        #endregion

        #region Structs

        /// <summary>
        /// Record of a single enemy memory slot.
        /// </summary>
        public struct SeenEnemyRecord
        {
            public Vector3 Position;
            public float TimeSeen;
            public string Tag;

            public SeenEnemyRecord(Vector3 position, float time, string tag)
            {
                this.Position = position;
                this.TimeSeen = time;
                this.Tag = tag;
            }
        }

        private sealed class Vector3EqualityComparer : IEqualityComparer<Vector3>
        {
            public bool Equals(Vector3 a, Vector3 b)
            {
                return (a - b).sqrMagnitude < PositionToleranceSqr;
            }

            public int GetHashCode(Vector3 v)
            {
                unchecked
                {
                    int hash = 17;
                    hash = (hash * 23) + Mathf.RoundToInt(v.x * 10f);
                    hash = (hash * 23) + Mathf.RoundToInt(v.y * 10f);
                    hash = (hash * 23) + Mathf.RoundToInt(v.z * 10f);
                    return hash;
                }
            }
        }

        #endregion
    }
}
