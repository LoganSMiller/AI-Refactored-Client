// <auto-generated>
//   This file is part of AI-Refactored, an open-source project focused on realistic AI behavior in Escape from Tarkov.
//   Licensed under the MIT License. See LICENSE in the repository root for more information.
//
//   THIS FILE IS SYSTEMATICALLY MANAGED.
//   Please follow strict StyleCop, ReSharper, and AI-Refactored code standards for all modifications.
// </auto-generated>

namespace AIRefactored.AI.Memory
{
    using System.Collections.Generic;
    using AIRefactored.AI.Core;
    using AIRefactored.AI.Helpers;
    using AIRefactored.AI.Optimization;
    using AIRefactored.Core;
    using EFT;
    using UnityEngine;

    /// <summary>
    /// Tactical extensions for BotOwner memory and behavior.
    /// Provides fallback, search toggles, flanking, and auditory memory tracking.
    /// </summary>
    public static class BotMemoryExtensions
    {
        #region Constants

        private const float MinMoveThreshold = 0.5f;
        private const float FlankDotThreshold = 0.25f;
        private const float EnemyTooCloseSqr = 1.0f;
        private const float InvestigateRangeSqr = 625f;

        #endregion

        #region Fallback + Movement

        public static void ClearLastHeardSound(this BotOwner bot)
        {
            BotMemoryStore.ClearHeardSound(bot.ProfileId);
        }

        public static void FallbackTo(this BotOwner bot, Vector3 fallbackPosition)
        {
            if (fallbackPosition.sqrMagnitude < MinMoveThreshold)
            {
                return;
            }

            BotComponentCache cache = BotCacheUtility.GetCache(bot);
            if (cache.PanicHandler.IsPanicking)
            {
                return;
            }

            BotMovementHelper.SmoothMoveTo(bot, fallbackPosition);
        }

        public static void ForceMoveTo(this BotOwner bot, Vector3 position)
        {
            if (position.sqrMagnitude >= MinMoveThreshold)
            {
                BotMovementHelper.SmoothMoveTo(bot, position);
            }
        }

        #endregion

        #region Cover Reevaluation

        public static void ReevaluateCurrentCover(this BotOwner bot)
        {
            EnemyInfo goal = bot.Memory.GoalEnemy;
            if (goal == null || !goal.IsVisible)
            {
                return;
            }

            Vector3 toEnemy = goal.CurrPosition - bot.Position;
            float sqrDist = toEnemy.sqrMagnitude;

            if (sqrDist < EnemyTooCloseSqr)
            {
                return;
            }

            float angle = Vector3.Angle(bot.LookDirection, toEnemy.normalized);
            if (angle >= 20f || sqrDist >= InvestigateRangeSqr)
            {
                return;
            }

            Vector3 fallback = bot.Position - toEnemy.normalized * 5f;
            Vector3 destination = new Vector3(fallback.x, bot.Position.y, fallback.z);

            BotComponentCache cache = BotCacheUtility.GetCache(bot);
            if (cache.Pathing != null)
            {
                List<Vector3> path = BotCoverRetreatPlanner.GetCoverRetreatPath(bot, toEnemy, cache.Pathing);
                int lastIndex = path.Count - 1;
                if (lastIndex >= 0)
                {
                    Vector3 last = path[lastIndex];
                    destination = new Vector3(last.x, bot.Position.y, last.z);
                }
            }

            BotMovementHelper.SmoothMoveTo(bot, destination);

            if (!FikaHeadlessDetector.IsHeadless && bot.BotTalk != null)
            {
                bot.BotTalk.TrySay(EPhraseTrigger.OnLostVisual);
            }
        }

        #endregion

        #region Mode Transitions

        public static void SetCautiousSearchMode(this BotOwner bot)
        {
            bot.Memory.AttackImmediately = false;
            bot.Memory.IsPeace = false;
        }

        public static void SetCombatAggressionMode(this BotOwner bot)
        {
            bot.Memory.AttackImmediately = true;
            bot.Memory.IsPeace = false;
        }

        public static void SetPeaceMode(this BotOwner bot)
        {
            bot.Memory.AttackImmediately = false;
            bot.Memory.IsPeace = true;
            bot.Memory.CheckIsPeace();
        }

        #endregion

        #region Audio Detection

        public static void SetLastHeardSound(this BotOwner bot, Player source)
        {
            if (source.ProfileId == bot.ProfileId)
            {
                return;
            }

            if (!EFTPlayerUtil.IsValid(source))
            {
                return;
            }

            Vector3 sourcePos = EFTPlayerUtil.GetPosition(source);
            if (sourcePos.sqrMagnitude < 0.01f)
            {
                return;
            }

            IPlayer resolved = EFTPlayerUtil.AsSafeIPlayer(source);
            if (resolved == null)
            {
                return;
            }

            if (bot.BotsGroup != null && bot.BotsGroup.LastSoundsController != null)
            {
                bot.BotsGroup.LastSoundsController.AddNeutralSound(resolved, sourcePos);
            }

            BotMemoryStore.AddHeardSound(bot.ProfileId, sourcePos, Time.time);

            Vector3 cautiousAdvance = sourcePos + (bot.Position - sourcePos).normalized * 3f;
            BotMovementHelper.SmoothMoveTo(bot, cautiousAdvance);

            if (!FikaHeadlessDetector.IsHeadless && bot.BotTalk != null)
            {
                bot.BotTalk.TrySay(EPhraseTrigger.OnEnemyShot);
            }
        }

        #endregion

        #region Flanking Logic

        public static Vector3 TryGetFlankDirection(this BotOwner bot, out bool success)
        {
            success = false;

            EnemyInfo goal = bot.Memory.GoalEnemy;
            if (goal == null)
            {
                return Vector3.zero;
            }

            Vector3 toEnemy = goal.CurrPosition - bot.Position;
            if (toEnemy.sqrMagnitude < MinMoveThreshold)
            {
                return Vector3.zero;
            }

            Vector3 enemyDir = toEnemy.normalized;
            Vector3 botDir = bot.LookDirection.normalized;

            if (Vector3.Dot(botDir, enemyDir) < FlankDotThreshold)
            {
                return Vector3.zero;
            }

            success = true;
            return Vector3.Cross(enemyDir, Vector3.up);
        }

        #endregion
    }
}
