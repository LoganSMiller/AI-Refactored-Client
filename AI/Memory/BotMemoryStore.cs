// <auto-generated>
//   This file is part of AI-Refactored, an open-source project focused on realistic AI behavior in Escape from Tarkov.
//   Licensed under the MIT License. See LICENSE in the repository root for more information.
//
//   THIS FILE IS SYSTEMATICALLY MANAGED.
//   Please follow strict StyleCop, ReSharper, and AI-Refactored code standards for all modifications.
// </auto-generated>

#nullable enable

namespace AIRefactored.AI.Memory
{
    using System.Collections.Generic;
    using AIRefactored.Core;
    using EFT;
    using UnityEngine;

    /// <summary>
    /// Centralized memory system for bots: sound tracking, hits, and danger zones.
    /// Mimics tactical recall and perception over short-term windows.
    /// </summary>
    public static class BotMemoryStore
    {
        private const float DangerZoneTTL = 45f;
        private const float HitMemoryDuration = 10f;
        private const int MaxZones = 256;

        private static readonly Dictionary<string, HeardSound> HeardSounds = new Dictionary<string, HeardSound>(64);
        private static readonly Dictionary<string, LastHitInfo> LastHitSources = new Dictionary<string, LastHitInfo>(64);
        private static readonly List<DangerZone> Zones = new List<DangerZone>(64);

        public static void AddDangerZone(string? mapId, Vector3 position, DangerTriggerType type, float radius)
        {
            if (Zones.Count >= MaxZones)
            {
                Zones.RemoveAt(0);
            }

            string key = TryGetSafeKey(mapId, out string safeKey) ? safeKey : "unknown";
            Zones.Add(new DangerZone(safeKey, position, type, radius, Time.time));
        }

        public static void AddHeardSound(string? profileId, Vector3 position, float time)
        {
            if (TryGetSafeKey(profileId, out string key))
            {
                HeardSounds[key] = new HeardSound(position, time);
            }
        }

        public static void ClearAllHeardSounds()
        {
            HeardSounds.Clear();
        }

        public static void ClearHeardSound(string? profileId)
        {
            if (TryGetSafeKey(profileId, out string key))
            {
                HeardSounds.Remove(key);
            }
        }

        public static void ClearHitSources()
        {
            LastHitSources.Clear();
        }

        public static void ClearZones()
        {
            Zones.Clear();
        }

        public static List<Player> GetNearbyPlayers(Vector3 origin, float radius)
        {
            List<Player> result = new List<Player>(8);
            IReadOnlyList<Player> players = GameWorldHandler.GetAllAlivePlayers();

            for (int i = 0; i < players.Count; i++)
            {
                Player player = players[i];
                if (player == null || !IsRealPlayer(player))
                {
                    continue;
                }

                float dist = Vector3.Distance(origin, player.Transform.position);
                if (dist <= radius)
                {
                    result.Add(player);
                }
            }

            return result;
        }

        public static List<DangerZone> GetZonesForMap(string? mapId)
        {
            List<DangerZone> result = ListPool<DangerZone>.Rent();
            if (!TryGetSafeKey(mapId, out string map))
            {
                return result;
            }

            float now = Time.time;
            for (int i = 0; i < Zones.Count; i++)
            {
                DangerZone zone = Zones[i];
                if (zone.Map == map && now - zone.Timestamp <= DangerZoneTTL)
                {
                    result.Add(zone);
                }
            }

            return result;
        }

        public static bool IsPositionInDangerZone(string? mapId, Vector3 position)
        {
            if (!TryGetSafeKey(mapId, out string map))
            {
                return false;
            }

            float now = Time.time;
            for (int i = 0; i < Zones.Count; i++)
            {
                DangerZone zone = Zones[i];
                if (zone.Map == map && now - zone.Timestamp <= DangerZoneTTL)
                {
                    float sqrDist = (zone.Position - position).sqrMagnitude;
                    if (sqrDist <= zone.Radius * zone.Radius)
                    {
                        return true;
                    }
                }
            }

            return false;
        }

        public static void RegisterLastHitSource(string? victimProfileId, string? attackerProfileId)
        {
            if (TryGetSafeKey(victimProfileId, out string victim) &&
                TryGetSafeKey(attackerProfileId, out string attacker))
            {
                LastHitSources[victim] = new LastHitInfo(attacker, Time.time);
            }
        }

        public static bool TryGetHeardSound(string? profileId, out HeardSound sound)
        {
            sound = default;
            return TryGetSafeKey(profileId, out string key) && HeardSounds.TryGetValue(key, out sound);
        }

        public static bool WasRecentlyHitBy(string? victimProfileId, string? attackerProfileId)
        {
            if (!TryGetSafeKey(victimProfileId, out string victim) ||
                !TryGetSafeKey(attackerProfileId, out string attacker))
            {
                return false;
            }

            return LastHitSources.TryGetValue(victim, out LastHitInfo hit) &&
                   hit.AttackerId == attacker &&
                   Time.time - hit.Time <= HitMemoryDuration;
        }

        private static bool IsRealPlayer(Player player)
        {
            return player.AIData == null || !player.AIData.IsAI;
        }

        private static bool TryGetSafeKey(string? profileId, out string key)
        {
            if (profileId == null)
            {
                key = string.Empty;
                return false;
            }

            string trimmed = profileId.Trim();
            if (trimmed.Length == 0)
            {
                key = string.Empty;
                return false;
            }

            key = trimmed;
            return true;
        }

        /// <summary>
        /// A remembered danger zone on the map.
        /// </summary>
        public struct DangerZone
        {
            public string Map;
            public Vector3 Position;
            public DangerTriggerType Type;
            public float Radius;
            public float Timestamp;

            public DangerZone(string map, Vector3 position, DangerTriggerType type, float radius, float timestamp)
            {
                this.Map = map;
                this.Position = position;
                this.Type = type;
                this.Radius = radius;
                this.Timestamp = timestamp;
            }
        }

        /// <summary>
        /// A remembered heard sound and the time it was recorded.
        /// </summary>
        public struct HeardSound
        {
            public Vector3 Position;
            public float Time;

            public HeardSound(Vector3 position, float time)
            {
                this.Position = position;
                this.Time = time;
            }
        }

        /// <summary>
        /// Tracks who last hit a bot and when.
        /// </summary>
        public struct LastHitInfo
        {
            public string AttackerId;
            public float Time;

            public LastHitInfo(string attackerId, float time)
            {
                this.AttackerId = attackerId;
                this.Time = time;
            }
        }
    }

    /// <summary>
    /// The reason why a bot memorized a danger zone.
    /// </summary>
    public enum DangerTriggerType
    {
        Panic,
        Flash,
        Suppression,
        Grenade
    }

    /// <summary>
    /// Provides pooled list reuse for tactical memory use.
    /// </summary>
    internal static class ListPool<T>
    {
        private static readonly Stack<List<T>> Pool = new Stack<List<T>>(32);

        public static List<T> Rent()
        {
            return Pool.Count > 0 ? Pool.Pop() : new List<T>();
        }

        public static void Return(List<T>? list)
        {
            if (list == null)
            {
                return;
            }

            list.Clear();
            Pool.Push(list);
        }
    }
}
