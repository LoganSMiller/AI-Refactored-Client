// <auto-generated>
//   AI-Refactored: BotMemoryStore.cs (Ultra-Platinum++, Beyond Diamond, AIRefactored Edition – June 2025)
//   Squad-aware, atomic, pooled, and bulletproof tactical memory system. All logic is locally isolated and multiplayer/headless safe.
//   MIT License.
// </auto-generated>

namespace AIRefactored.AI.Memory
{
    using System;
    using System.Collections.Generic;
    using AIRefactored.Core;
    using AIRefactored.Pools;
    using BepInEx.Logging;
    using EFT;
    using UnityEngine;

    /// <summary>
    /// Centralized, atomic, bulletproof tactical memory for bots. 
    /// Tracks short-term audio, hits, and local danger zones for overlay/event logic.
    /// All failures are locally isolated; memory logic cannot break other subsystems or the mod.
    /// Arbitration/event-move overlay is handled externally.
    /// </summary>
    public static class BotMemoryStore
    {
        private const float DangerZoneTTL = 45f;
        private const float HitMemoryDuration = 10f;
        private const int MaxZones = 256;

        private static readonly ManualLogSource Logger = Plugin.LoggerInstance;

        private static readonly Dictionary<string, HeardSound> HeardSounds = new Dictionary<string, HeardSound>(64);
        private static readonly Dictionary<string, LastHitInfo> LastHitSources = new Dictionary<string, LastHitInfo>(64);
        private static readonly List<DangerZone> Zones = new List<DangerZone>(64);
        private static readonly Dictionary<string, List<DangerZone>> ZoneCaches = new Dictionary<string, List<DangerZone>>(64);
        private static readonly Dictionary<string, List<HeardSound>> ShortTermHeardSounds = new Dictionary<string, List<HeardSound>>(64);
        private static readonly Dictionary<string, float> LastFlankTimes = new Dictionary<string, float>(64);

        #region Danger Zones

        /// <summary>
        /// Adds a new danger zone for the given map. Truncates oldest if limit exceeded.
        /// </summary>
        public static void AddDangerZone(string mapId, Vector3 position, DangerTriggerType type, float radius)
        {
            try
            {
                if (!TryGetSafeKey(mapId, out string key)) key = "unknown";
                if (Zones.Count >= MaxZones)
                    Zones.RemoveAt(0);

                Zones.Add(new DangerZone(key, position, type, radius, Time.time));
            }
            catch (Exception ex)
            {
                Logger.LogError($"[BotMemoryStore] AddDangerZone failed: {ex}");
            }
        }

        /// <summary>
        /// Gets pooled list of current (not expired) danger zones for a map.
        /// </summary>
        public static List<DangerZone> GetZonesForMap(string mapId)
        {
            var result = TempListPool.Rent<DangerZone>();
            try
            {
                if (!TryGetSafeKey(mapId, out string key)) return result;

                if (!ZoneCaches.TryGetValue(key, out var cache))
                {
                    cache = TempListPool.Rent<DangerZone>();
                    ZoneCaches[key] = cache;
                }
                else
                {
                    cache.Clear();
                }

                float now = Time.time;
                for (int i = 0; i < Zones.Count; i++)
                {
                    DangerZone zone = Zones[i];
                    if (zone.Map == key && (now - zone.Timestamp) <= DangerZoneTTL)
                        cache.Add(zone);
                }

                result.AddRange(cache);
            }
            catch (Exception ex)
            {
                Logger.LogError($"[BotMemoryStore] GetZonesForMap failed: {ex}");
            }
            return result;
        }

        /// <summary>
        /// Returns true if the position is within any current danger zone for the given map.
        /// </summary>
        public static bool IsPositionInDangerZone(string mapId, Vector3 position)
        {
            try
            {
                if (!TryGetSafeKey(mapId, out string key)) return false;
                float now = Time.time;

                for (int i = 0; i < Zones.Count; i++)
                {
                    DangerZone zone = Zones[i];
                    if (zone.Map == key && (now - zone.Timestamp <= DangerZoneTTL))
                    {
                        if ((zone.Position - position).sqrMagnitude <= zone.Radius * zone.Radius)
                            return true;
                    }
                }
            }
            catch (Exception ex)
            {
                Logger.LogError($"[BotMemoryStore] IsPositionInDangerZone failed: {ex}");
            }
            return false;
        }

        /// <summary>
        /// Clears all danger zones and pooled caches.
        /// </summary>
        public static void ClearZones()
        {
            try
            {
                Zones.Clear();
                foreach (var kv in ZoneCaches)
                    kv.Value?.Clear();
                ZoneCaches.Clear();
            }
            catch (Exception ex)
            {
                Logger.LogError($"[BotMemoryStore] ClearZones failed: {ex}");
            }
        }

        #endregion

        #region Audio Memory

        /// <summary>
        /// Adds a heard sound to the bot's short-term memory.
        /// </summary>
        public static void AddHeardSound(string profileId, Vector3 position, float time)
        {
            try
            {
                if (!TryGetSafeKey(profileId, out string key)) return;

                if (!ShortTermHeardSounds.TryGetValue(key, out var list))
                {
                    list = TempListPool.Rent<HeardSound>();
                    ShortTermHeardSounds[key] = list;
                }
                list.Add(new HeardSound(position, time));
            }
            catch (Exception ex)
            {
                Logger.LogError($"[BotMemoryStore] AddHeardSound failed: {ex}");
            }
        }

        /// <summary>
        /// Tries to get the most recently heard sound for this bot.
        /// </summary>
        public static bool TryGetHeardSound(string profileId, out HeardSound sound)
        {
            sound = default;
            try
            {
                return TryGetSafeKey(profileId, out string key) && HeardSounds.TryGetValue(key, out sound);
            }
            catch (Exception ex)
            {
                Logger.LogError($"[BotMemoryStore] TryGetHeardSound failed: {ex}");
                return false;
            }
        }

        /// <summary>
        /// Clears short-term sound memory for this bot.
        /// </summary>
        public static void ClearHeardSound(string profileId)
        {
            try
            {
                if (!TryGetSafeKey(profileId, out string key)) return;

                HeardSounds.Remove(key);
                if (ShortTermHeardSounds.TryGetValue(key, out var list) && list != null)
                    list.Clear();
            }
            catch (Exception ex)
            {
                Logger.LogError($"[BotMemoryStore] ClearHeardSound failed: {ex}");
            }
        }

        /// <summary>
        /// Clears all heard sound memory for all bots.
        /// </summary>
        public static void ClearAllHeardSounds()
        {
            try
            {
                HeardSounds.Clear();
                foreach (var kv in ShortTermHeardSounds)
                    kv.Value?.Clear();
            }
            catch (Exception ex)
            {
                Logger.LogError($"[BotMemoryStore] ClearAllHeardSounds failed: {ex}");
            }
        }

        #endregion

        #region Hit Tracking

        /// <summary>
        /// Registers the most recent hit source (attacker) for a given bot.
        /// </summary>
        public static void RegisterLastHitSource(string victimProfileId, string attackerProfileId)
        {
            try
            {
                if (!TryGetSafeKey(victimProfileId, out string victim) || !TryGetSafeKey(attackerProfileId, out string attacker))
                    return;

                LastHitSources[victim] = new LastHitInfo(attacker, Time.time);
            }
            catch (Exception ex)
            {
                Logger.LogError($"[BotMemoryStore] RegisterLastHitSource failed: {ex}");
            }
        }

        /// <summary>
        /// Returns true if victim was recently hit by the given attacker.
        /// </summary>
        public static bool WasRecentlyHitBy(string victimProfileId, string attackerProfileId)
        {
            try
            {
                if (!TryGetSafeKey(victimProfileId, out string victim) || !TryGetSafeKey(attackerProfileId, out string attacker))
                    return false;

                return LastHitSources.TryGetValue(victim, out var hit) &&
                       hit.AttackerId == attacker &&
                       Time.time - hit.Time <= HitMemoryDuration;
            }
            catch (Exception ex)
            {
                Logger.LogError($"[BotMemoryStore] WasRecentlyHitBy failed: {ex}");
                return false;
            }
        }

        /// <summary>
        /// Clears all hit source memory.
        /// </summary>
        public static void ClearHitSources()
        {
            try
            {
                LastHitSources.Clear();
            }
            catch (Exception ex)
            {
                Logger.LogError($"[BotMemoryStore] ClearHitSources failed: {ex}");
            }
        }

        #endregion

        #region Flank Cooldown

        /// <summary>
        /// Sets the last time this bot attempted a flank (by profile).
        /// </summary>
        public static void SetLastFlankTime(string profileId)
        {
            try
            {
                if (TryGetSafeKey(profileId, out string key))
                    LastFlankTimes[key] = Time.time;
            }
            catch (Exception ex)
            {
                Logger.LogError($"[BotMemoryStore] SetLastFlankTime failed: {ex}");
            }
        }

        /// <summary>
        /// Returns true if the bot's flank cooldown has expired.
        /// </summary>
        public static bool CanFlankNow(string profileId, float cooldown)
        {
            try
            {
                return TryGetSafeKey(profileId, out string key) &&
                       (!LastFlankTimes.TryGetValue(key, out float last) || Time.time - last >= cooldown);
            }
            catch (Exception ex)
            {
                Logger.LogError($"[BotMemoryStore] CanFlankNow failed: {ex}");
                return false;
            }
        }

        /// <summary>
        /// Clears all flank cooldowns for all bots.
        /// </summary>
        public static void ClearFlankCooldowns()
        {
            try
            {
                LastFlankTimes.Clear();
            }
            catch (Exception ex)
            {
                Logger.LogError($"[BotMemoryStore] ClearFlankCooldowns failed: {ex}");
            }
        }

        #endregion

        #region Player Awareness

        /// <summary>
        /// Returns a pooled list of real (non-bot) players near a given position.
        /// </summary>
        public static List<Player> GetNearbyPlayers(Vector3 origin, float radius)
        {
            List<Player> result = TempListPool.Rent<Player>();
            List<Player> players = GameWorldHandler.GetAllAlivePlayers();
            try
            {
                float radiusSqr = radius * radius;
                for (int i = 0; i < players.Count; i++)
                {
                    var p = players[i];
                    if (p != null && IsRealPlayer(p))
                    {
                        Vector3 pos = EFTPlayerUtil.GetPosition(p);
                        float dx = pos.x - origin.x;
                        float dz = pos.z - origin.z;
                        if ((dx * dx + dz * dz) <= radiusSqr)
                            result.Add(p);
                    }
                }
            }
            catch (Exception ex)
            {
                Logger.LogError($"[BotMemoryStore] GetNearbyPlayers failed: {ex}");
            }
            finally
            {
                TempListPool.Return(players);
            }
            return result;
        }

        #endregion

        #region Helpers

        private static bool TryGetSafeKey(string id, out string key)
        {
            key = string.Empty;
            if (string.IsNullOrEmpty(id)) return false;
            key = id.Trim();
            return key.Length > 0;
        }

        private static bool IsRealPlayer(Player player)
        {
            return player != null && (player.AIData == null || !player.AIData.IsAI);
        }

        #endregion

        #region Structs

        public struct DangerZone
        {
            public string Map;
            public Vector3 Position;
            public DangerTriggerType Type;
            public float Radius;
            public float Timestamp;

            public DangerZone(string map, Vector3 position, DangerTriggerType type, float radius, float timestamp)
            {
                Map = map;
                Position = position;
                Type = type;
                Radius = radius;
                Timestamp = timestamp;
            }
        }

        public struct HeardSound
        {
            public Vector3 Position;
            public float Time;

            public HeardSound(Vector3 position, float time)
            {
                Position = position;
                Time = time;
            }
        }

        public struct LastHitInfo
        {
            public string AttackerId;
            public float Time;

            public LastHitInfo(string attackerId, float time)
            {
                AttackerId = attackerId;
                Time = time;
            }
        }

        #endregion
    }

    public enum DangerTriggerType
    {
        Panic,
        Flash,
        Suppression,
        Grenade
    }
}
