// <auto-generated>
//   This file is part of AI-Refactored, an open-source project focused on realistic AI behavior in Escape from Tarkov.
//   Licensed under the MIT License. See LICENSE in the repository root for more information.
//
//   THIS FILE IS SYSTEMATICALLY MANAGED.
//   Please follow strict StyleCop, ReSharper, and AI-Refactored code standards for all modifications.
// </auto-generated>

namespace AIRefactored.AI.Memory
{
    using System.Collections.Generic;
    using AIRefactored.Core;
    using AIRefactored.Pools;
    using EFT;
    using UnityEngine;

    /// <summary>
    /// Centralized tactical memory for bots. Tracks short-term audio, hits, and local danger zones.
    /// </summary>
    public static class BotMemoryStore
    {
        private const float DangerZoneTTL = 45f;
        private const float HitMemoryDuration = 10f;
        private const int MaxZones = 256;

        private static readonly Dictionary<string, HeardSound> HeardSounds = new Dictionary<string, HeardSound>(64);
        private static readonly Dictionary<string, LastHitInfo> LastHitSources = new Dictionary<string, LastHitInfo>(64);
        private static readonly List<DangerZone> Zones = new List<DangerZone>(64);
        private static readonly Dictionary<string, List<DangerZone>> ZoneCaches = new Dictionary<string, List<DangerZone>>(64);
        private static readonly Dictionary<string, List<HeardSound>> ShortTermHeardSounds = new Dictionary<string, List<HeardSound>>(64);
        private static readonly Dictionary<string, float> LastFlankTimes = new Dictionary<string, float>(64);

        #region Danger Zones

        public static void AddDangerZone(string mapId, Vector3 position, DangerTriggerType type, float radius)
        {
            string key;
            if (!TryGetSafeKey(mapId, out key))
            {
                key = "unknown";
            }

            if (Zones.Count >= MaxZones)
            {
                Zones.RemoveAt(0);
            }

            Zones.Add(new DangerZone(key, position, type, radius, Time.time));
        }

        public static List<DangerZone> GetZonesForMap(string mapId)
        {
            var result = TempListPool.Rent<DangerZone>();

            string key;
            if (!TryGetSafeKey(mapId, out key))
            {
                return result;
            }

            List<DangerZone> cache;
            if (!ZoneCaches.TryGetValue(key, out cache))
            {
                cache = TempListPool.Rent<DangerZone>();
                ZoneCaches[key] = cache;
            }
            else
            {
                cache.Clear();
            }

            float now = Time.time;
            for (int i = 0; i < Zones.Count; i++)
            {
                DangerZone zone = Zones[i];
                if (zone.Map == key && now - zone.Timestamp <= DangerZoneTTL)
                {
                    cache.Add(zone);
                }
            }

            result.AddRange(cache);
            return result;
        }

        public static bool IsPositionInDangerZone(string mapId, Vector3 position)
        {
            string key;
            if (!TryGetSafeKey(mapId, out key))
            {
                return false;
            }

            float now = Time.time;
            for (int i = 0; i < Zones.Count; i++)
            {
                DangerZone zone = Zones[i];
                if (zone.Map != key || now - zone.Timestamp > DangerZoneTTL)
                {
                    continue;
                }

                if ((zone.Position - position).sqrMagnitude <= zone.Radius * zone.Radius)
                {
                    return true;
                }
            }

            return false;
        }

        public static void ClearZones()
        {
            Zones.Clear();
            ZoneCaches.Clear();
        }

        #endregion

        #region Audio Memory

        public static void AddHeardSound(string profileId, Vector3 position, float time)
        {
            string key;
            if (!TryGetSafeKey(profileId, out key))
            {
                return;
            }

            List<HeardSound> list;
            if (!ShortTermHeardSounds.TryGetValue(key, out list))
            {
                list = TempListPool.Rent<HeardSound>();
                ShortTermHeardSounds[key] = list;
            }

            list.Add(new HeardSound(position, time));
        }

        public static bool TryGetHeardSound(string profileId, out HeardSound sound)
        {
            sound = default(HeardSound);
            string key;
            return TryGetSafeKey(profileId, out key) && HeardSounds.TryGetValue(key, out sound);
        }

        public static void ClearHeardSound(string profileId)
        {
            string key;
            if (!TryGetSafeKey(profileId, out key))
            {
                return;
            }

            HeardSounds.Remove(key);

            List<HeardSound> list;
            if (ShortTermHeardSounds.TryGetValue(key, out list))
            {
                list.Clear();
            }
        }

        public static void ClearAllHeardSounds()
        {
            HeardSounds.Clear();
            foreach (var entry in ShortTermHeardSounds)
            {
                entry.Value.Clear();
            }
        }

        #endregion

        #region Hit Tracking

        public static void RegisterLastHitSource(string victimProfileId, string attackerProfileId)
        {
            string victim;
            string attacker;
            if (!TryGetSafeKey(victimProfileId, out victim) || !TryGetSafeKey(attackerProfileId, out attacker))
            {
                return;
            }

            LastHitSources[victim] = new LastHitInfo(attacker, Time.time);
        }

        public static bool WasRecentlyHitBy(string victimProfileId, string attackerProfileId)
        {
            string victim;
            string attacker;
            if (!TryGetSafeKey(victimProfileId, out victim) || !TryGetSafeKey(attackerProfileId, out attacker))
            {
                return false;
            }

            LastHitInfo hit;
            return LastHitSources.TryGetValue(victim, out hit) && hit.AttackerId == attacker && (Time.time - hit.Time <= HitMemoryDuration);
        }

        public static void ClearHitSources()
        {
            LastHitSources.Clear();
        }

        #endregion

        #region Flank Cooldown

        public static void SetLastFlankTime(string profileId)
        {
            string key;
            if (TryGetSafeKey(profileId, out key))
            {
                LastFlankTimes[key] = Time.time;
            }
        }

        public static bool CanFlankNow(string profileId, float cooldown)
        {
            string key;
            if (!TryGetSafeKey(profileId, out key))
            {
                return false;
            }

            float last;
            return !LastFlankTimes.TryGetValue(key, out last) || (Time.time - last >= cooldown);
        }

        public static void ClearFlankCooldowns()
        {
            LastFlankTimes.Clear();
        }

        #endregion

        #region Nearby Player Query

        public static List<Player> GetNearbyPlayers(Vector3 origin, float radius)
        {
            var result = TempListPool.Rent<Player>();
            List<Player> players = GameWorldHandler.GetAllAlivePlayers();
            float rangeSqr = radius * radius;

            for (int i = 0; i < players.Count; i++)
            {
                Player p = players[i];
                if (p != null && IsRealPlayer(p))
                {
                    if ((p.Transform.position - origin).sqrMagnitude <= rangeSqr)
                    {
                        result.Add(p);
                    }
                }
            }

            return result;
        }

        #endregion

        #region Helpers

        private static bool TryGetSafeKey(string id, out string key)
        {
            key = string.Empty;
            if (string.IsNullOrEmpty(id))
            {
                return false;
            }

            key = id.Trim();
            return key.Length > 0;
        }

        private static bool IsRealPlayer(Player player)
        {
            return player != null && (player.AIData == null || !player.AIData.IsAI);
        }

        #endregion

        #region Data Types

        public struct DangerZone
        {
            public string Map;
            public Vector3 Position;
            public DangerTriggerType Type;
            public float Radius;
            public float Timestamp;

            public DangerZone(string map, Vector3 position, DangerTriggerType type, float radius, float timestamp)
            {
                Map = map;
                Position = position;
                Type = type;
                Radius = radius;
                Timestamp = timestamp;
            }
        }

        public struct HeardSound
        {
            public Vector3 Position;
            public float Time;

            public HeardSound(Vector3 position, float time)
            {
                Position = position;
                Time = time;
            }
        }

        public struct LastHitInfo
        {
            public string AttackerId;
            public float Time;

            public LastHitInfo(string attackerId, float time)
            {
                AttackerId = attackerId;
                Time = time;
            }
        }

        #endregion
    }

    /// <summary>
    /// Classifies the cause of danger zone memory.
    /// </summary>
    public enum DangerTriggerType
    {
        Panic,
        Flash,
        Suppression,
        Grenade
    }
}
