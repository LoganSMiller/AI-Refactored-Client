// <auto-generated>
//   AI-Refactored: BotLootDecisionSystem.cs (Beyond Diamond Edition)
//   Human-realistic, squad-coordinated, value/personality-based loot selection and arbitration.
//   All logic 100% managed by BotBrain. Bulletproof: Errors are always local, never break squad/AIRefactored.
//   MIT License.
// </auto-generated>

namespace AIRefactored.AI.Looting
{
    using System;
    using System.Collections.Generic;
    using AIRefactored.AI.Core;
    using AIRefactored.AI.Groups;
    using AIRefactored.Pools;
    using BepInEx.Logging;
    using EFT;
    using EFT.Interactive;
    using EFT.InventoryLogic;
    using UnityEngine;

    /// <summary>
    /// Human-level looting decision system with squad arbitration, group comms, memory, greed/impatience, and bulletproof error containment.
    /// </summary>
    public sealed class BotLootDecisionSystem
    {
        #region Constants

        private const float MaxLootDistance = 22f;
        private const float HighValueThreshold = 25000f;
        private const float LootCooldownTime = 14f;
        private const float GroupClaimCooldown = 17f;
        private const float SquadLootBlockRadius = 4.2f;
        private const float MinValueDeltaForSnatch = 8000f;
        private const int MaxRecentLooted = 32;
        private const float SquadVoiceCooldown = 4.5f;

        #endregion

        #region Fields

        private BotComponentCache _cache;
        private BotOwner _bot;
        private BotGroupComms _groupComms;
        private float _nextLootTime;
        private float _lastSquadClaimTime;
        private float _lastSquadVoiceTime;
        private readonly LinkedList<string> _recentLooted = new LinkedList<string>();
        private static ManualLogSource Logger => Plugin.LoggerInstance;

        // Squad claim state
        private readonly Dictionary<string, float> _squadLootClaims = new Dictionary<string, float>(16);
        private string _currentSquadClaimId;
        private float _currentSquadClaimUntil;
        private bool _isActive = true;

        #endregion

        #region Initialization

        public void Initialize(BotComponentCache cache)
        {
            if (cache == null || cache.Bot == null)
            {
                _isActive = false;
                Logger.LogError("[BotLootDecisionSystem] Initialization failed: cache or bot is null. Disabling looting logic for this bot.");
                return;
            }

            _cache = cache;
            _bot = cache.Bot;
            _groupComms = cache.GroupComms;
            _isActive = true;
        }

        #endregion

        #region Public Methods

        /// <summary>
        /// Unified per-frame tick for claim expiry and cleanup. Always called by BotBrain.
        /// </summary>
        public void Tick(float deltaTime)
        {
            if (!_isActive) return;
            try
            {
                float now = Time.time;
                // Remove expired squad claims
                var expired = TempListPool.Rent<string>();
                foreach (var kv in _squadLootClaims)
                {
                    if (now >= kv.Value)
                        expired.Add(kv.Key);
                }
                for (int i = 0; i < expired.Count; i++)
                    _squadLootClaims.Remove(expired[i]);
                TempListPool.Return(expired);

                // Prune oldest from local memory
                while (_recentLooted.Count > MaxRecentLooted)
                    _recentLooted.RemoveFirst();
            }
            catch (Exception ex)
            {
                Logger.LogError($"[BotLootDecisionSystem] Tick() failed: {ex}");
            }
        }

        /// <summary>
        /// Should this bot attempt to loot now? Considers panic, squad, recent threats, squad claims, value, impatience, memory, etc.
        /// </summary>
        public bool ShouldLootNow()
        {
            if (!_isActive || _bot == null || _bot.IsDead)
                return false;
            if (Time.time < _nextLootTime)
                return false;

            try
            {
                // Panic, recent threat, or squad combat disables looting
                if (_cache.PanicHandler != null && _cache.PanicHandler.IsPanicking)
                    return false;
                if (_bot.Memory != null && _bot.Memory.GoalEnemy != null)
                    return false;
                if (_bot.EnemiesController != null && _bot.EnemiesController.EnemyInfos != null && _bot.EnemiesController.EnemyInfos.Count > 0)
                    return false;

                // Nearby squadmate in combat or looting same container disables (unless personality overrides)
                if (_bot.BotsGroup != null && _bot.BotsGroup.MembersCount > 1)
                {
                    for (int i = 0; i < _bot.BotsGroup.MembersCount; i++)
                    {
                        var mate = _bot.BotsGroup.Member(i);
                        if (mate == null || mate == _bot || mate.IsDead) continue;
                        float dist = Vector3.Distance(_bot.Position, mate.Position);
                        if (mate.Memory != null && mate.Memory.GoalEnemy != null && dist < 16f)
                            return false;

                        if (IsSquadmateLootingSameContainer(mate, out string lootedId) && dist < SquadLootBlockRadius)
                        {
                            var profile = _cache.PersonalityProfile ?? BotPersonalityProfile.Default;
                            if (profile.Greed > 0.73f && UnityEngine.Random.value < 0.21f)
                            {
                                SaySquadLootVoice(EPhraseTrigger.OnFirstContact);
                                continue;
                            }
                            if (profile.AggressionLevel > 0.65f && UnityEngine.Random.value < 0.13f)
                            {
                                SaySquadLootVoice(EPhraseTrigger.LootGeneric);
                                continue;
                            }
                            SaySquadLootVoice(EPhraseTrigger.HoldPosition);
                            return false;
                        }
                    }
                }

                // Only loot if a valuable container is nearby (personality can bias threshold lower)
                float threshold = Mathf.Lerp(HighValueThreshold * 0.77f, HighValueThreshold * 1.12f, _cache.PersonalityProfile?.Greed ?? 0.5f);
                return _cache.LootScanner != null && _cache.LootScanner.TotalLootValue >= threshold;
            }
            catch (Exception ex)
            {
                _isActive = false;
                Logger.LogError($"[BotLootDecisionSystem] ShouldLootNow() failed: {ex}");
                return false;
            }
        }

        /// <summary>
        /// Returns the best loot destination considering squad, memory, cooldown, value, safety, and personality.
        /// </summary>
        public Vector3 GetLootDestination()
        {
            if (!_isActive || _cache == null || _cache.LootScanner == null || _bot == null)
                return Vector3.zero;

            try
            {
                float bestValue = 0f;
                Vector3 bestPoint = Vector3.zero;
                string bestId = null;
                float closestDist = float.MaxValue;

                List<LootableContainer> containers = LootRegistry.GetAllContainers();
                if (containers == null)
                    return Vector3.zero;

                var profile = _cache.PersonalityProfile ?? BotPersonalityProfile.Default;
                float greedBias = Mathf.Lerp(0.75f, 1.15f, profile.Greed);

                for (int i = 0; i < containers.Count; i++)
                {
                    LootableContainer container = containers[i];
                    if (container == null || !container.enabled || container.transform == null)
                        continue;

                    string lootId = container.Id;
                    if (string.IsNullOrWhiteSpace(lootId) || WasRecentlyLooted(lootId))
                        continue;

                    if (IsContainerClaimedBySquad(lootId))
                        continue;

                    Vector3 pos = container.transform.position;
                    float dist = Vector3.Distance(_bot.Position, pos);
                    if (dist > MaxLootDistance)
                        continue;

                    float value = EstimateValue(container) * greedBias;

                    // Squad arbitration: steal if value is much higher than squad claim and personality allows
                    if (_squadLootClaims.TryGetValue(lootId, out float claimUntil) && Time.time < claimUntil)
                    {
                        float claimValue = value - MinValueDeltaForSnatch;
                        if (profile.Greed > 0.83f && value > claimValue && UnityEngine.Random.value < 0.18f)
                        {
                            SaySquadLootVoice(EPhraseTrigger.OnEnemyConversation);
                            ReleaseContainerClaim(lootId);
                        }
                        else
                        {
                            continue;
                        }
                    }

                    // Prefer closer container if values are similar
                    if (value > bestValue || (Mathf.Approximately(value, bestValue) && dist < closestDist))
                    {
                        bestValue = value;
                        bestPoint = pos;
                        bestId = lootId;
                        closestDist = dist;
                    }
                }

                if (bestValue > 0f && bestId != null)
                {
                    ClaimContainerForSquad(bestId);
                    return bestPoint;
                }

                return Vector3.zero;
            }
            catch (Exception ex)
            {
                _isActive = false;
                Logger.LogError($"[BotLootDecisionSystem] GetLootDestination() failed: {ex}");
                return Vector3.zero;
            }
        }

        /// <summary>
        /// Mark this container as looted and set internal/squad cooldowns.
        /// </summary>
        public void MarkLooted(string lootId)
        {
            if (!_isActive || string.IsNullOrWhiteSpace(lootId))
                return;

            try
            {
                string id = lootId.Trim();
                if (_recentLooted.Count >= MaxRecentLooted)
                    _recentLooted.RemoveFirst();
                _recentLooted.AddLast(id);
                _nextLootTime = Time.time + LootCooldownTime;
                ReleaseContainerClaim(id);
            }
            catch (Exception ex)
            {
                _isActive = false;
                Logger.LogError($"[BotLootDecisionSystem] MarkLooted() failed: {ex}");
            }
        }

        /// <summary>
        /// Checks if this bot has recently looted the given container.
        /// </summary>
        public bool WasRecentlyLooted(string lootId)
        {
            if (!_isActive || string.IsNullOrWhiteSpace(lootId))
                return false;

            try
            {
                string id = lootId.Trim();
                foreach (var entry in _recentLooted)
                {
                    if (entry == id)
                        return true;
                }
                return false;
            }
            catch (Exception ex)
            {
                _isActive = false;
                Logger.LogError($"[BotLootDecisionSystem] WasRecentlyLooted() failed: {ex}");
                return false;
            }
        }

        #endregion

        #region Squad/Group Arbitration

        private void ClaimContainerForSquad(string lootId)
        {
            if (string.IsNullOrWhiteSpace(lootId))
                return;
            _squadLootClaims[lootId] = Time.time + GroupClaimCooldown;
            _currentSquadClaimId = lootId;
            _currentSquadClaimUntil = Time.time + GroupClaimCooldown;
            SaySquadLootVoice(EPhraseTrigger.LootGeneric);
            _lastSquadClaimTime = Time.time;
        }

        private void ReleaseContainerClaim(string lootId)
        {
            if (string.IsNullOrWhiteSpace(lootId))
                return;
            _squadLootClaims.Remove(lootId);
            if (_currentSquadClaimId == lootId)
                _currentSquadClaimId = null;
            SaySquadLootVoice(EPhraseTrigger.LootGeneric);
        }

        private bool IsContainerClaimedBySquad(string lootId)
        {
            if (string.IsNullOrWhiteSpace(lootId))
                return false;
            float until;
            return _squadLootClaims.TryGetValue(lootId, out until) && Time.time < until;
        }

        private bool IsSquadmateLootingSameContainer(BotOwner mate, out string lootedId)
        {
            lootedId = null;
            if (mate == null || mate.IsDead)
                return false;

            var mateCache = mate.GetComponent<BotComponentCache>();
            if (mateCache?.LootDecisionSystem == null)
                return false;

            foreach (var kv in mateCache.LootDecisionSystem._squadLootClaims)
            {
                if (Time.time < kv.Value)
                {
                    lootedId = kv.Key;
                    return true;
                }
            }
            return false;
        }

        /// <summary>
        /// Squad-voiced phrase for loot arbitration, respects cooldown to avoid spam.
        /// </summary>
        private void SaySquadLootVoice(EPhraseTrigger phrase)
        {
            if (_groupComms == null)
                return;
            if (Time.time - _lastSquadVoiceTime > SquadVoiceCooldown)
            {
                _groupComms.Say(phrase);
                _lastSquadVoiceTime = Time.time;
            }
        }

        #endregion

        #region Value & Danger Estimation

        private static float EstimateValue(LootableContainer container)
        {
            if (container == null || container.ItemOwner == null || container.ItemOwner.RootItem == null)
                return 0f;

            float total = 0f;
            List<Item> items = null;

            try
            {
                items = TempListPool.Rent<Item>();
                container.ItemOwner.RootItem.GetAllItemsNonAlloc(items);

                for (int i = 0; i < items.Count; i++)
                {
                    Item item = items[i];
                    if (item != null && item.Template != null && item.Template.CreditsPrice > 0f)
                        total += item.Template.CreditsPrice;
                }
            }
            catch (Exception ex)
            {
                Logger.LogError($"[BotLootDecisionSystem] EstimateValue() failed: {ex}");
                return 0f;
            }
            finally
            {
                if (items != null)
                    TempListPool.Return(items);
            }

            return total;
        }

        #endregion
    }
}
