// <auto-generated>
//   AI-Refactored: DeadBodyContainerCache.cs (Supreme Arbitration+++, Max Realism, June 2025)
//   Tracks all LootableContainer instances for player corpses, keyed by EFT ProfileId. 
//   Bulletproof, pooled, race-safe, zero-alloc, overlay/event/teardown ready, squad/loot/corpse/sync-safe.
//   MIT License.
// </auto-generated>

namespace AIRefactored.AI.Looting
{
    using System;
    using System.Collections.Generic;
    using AIRefactored.Core;
    using AIRefactored.Pools;
    using BepInEx.Logging;
    using EFT;
    using EFT.Interactive;
    using UnityEngine;

    /// <summary>
    /// Caches all dead body LootableContainer references by EFT ProfileId.
    /// Bulletproof: No logic can break or affect other systems. 
    /// Pooled APIs, full diagnostics, no double-register, world/teardown/overlay safe.
    /// </summary>
    public static class DeadBodyContainerCache
    {
        #region Fields

        // ProfileId → Container
        private static readonly Dictionary<string, LootableContainer> ProfileToContainer = new Dictionary<string, LootableContainer>(128);
        // Container → ProfileId (for reverse lookup and robust removal)
        private static readonly Dictionary<LootableContainer, string> ContainerToProfile = new Dictionary<LootableContainer, string>(128);
        private static readonly HashSet<LootableContainer> RegisteredContainers = new HashSet<LootableContainer>();
        private static readonly ManualLogSource Logger = Plugin.LoggerInstance;

        #endregion

        #region Lifecycle

        /// <summary>
        /// Clears the entire cache (call on world/raid end/teardown). Bulletproof.
        /// </summary>
        public static void Clear()
        {
            try
            {
                ProfileToContainer.Clear();
                ContainerToProfile.Clear();
                RegisteredContainers.Clear();
            }
            catch (Exception ex)
            {
                Logger.LogError($"[DeadBodyContainerCache] Clear() failed: {ex}");
            }
        }

        #endregion

        #region Registration

        /// <summary>
        /// Registers a corpse container for a valid EFT.Player. Never throws or overwrites. Idempotent.
        /// </summary>
        public static void Register(Player player, LootableContainer container)
        {
            try
            {
                if (!EFTPlayerUtil.IsValid(player) || container == null)
                    return;
                Register(player.ProfileId, container);
            }
            catch (Exception ex)
            {
                Logger.LogError($"[DeadBodyContainerCache] Register(Player) failed: {ex}");
            }
        }

        /// <summary>
        /// Registers a corpse container for a known EFT ProfileId. No double-register, never throws or overwrites.
        /// </summary>
        public static void Register(string profileId, LootableContainer container)
        {
            try
            {
                if (!TryGetKey(profileId, out string key) || container == null)
                    return;
                if (ProfileToContainer.ContainsKey(key) || RegisteredContainers.Contains(container))
                    return;

                ProfileToContainer.Add(key, container);
                ContainerToProfile[container] = key;
                RegisteredContainers.Add(container);
            }
            catch (Exception ex)
            {
                Logger.LogError($"[DeadBodyContainerCache] Register(profileId) failed: {ex}");
            }
        }

        /// <summary>
        /// Removes a corpse container by ProfileId (e.g. for corpse despawn). Idempotent and safe.
        /// </summary>
        public static void Remove(string profileId)
        {
            try
            {
                if (!TryGetKey(profileId, out string key)) return;
                if (ProfileToContainer.TryGetValue(key, out var container))
                {
                    RegisteredContainers.Remove(container);
                    ContainerToProfile.Remove(container);
                    ProfileToContainer.Remove(key);
                }
            }
            catch (Exception ex)
            {
                Logger.LogError($"[DeadBodyContainerCache] Remove(profileId) failed: {ex}");
            }
        }

        /// <summary>
        /// Removes a corpse container by container reference (e.g. destroyed/despawned). Idempotent and safe.
        /// </summary>
        public static void Remove(LootableContainer container)
        {
            try
            {
                if (container == null) return;
                if (ContainerToProfile.TryGetValue(container, out var key))
                {
                    ProfileToContainer.Remove(key);
                    RegisteredContainers.Remove(container);
                    ContainerToProfile.Remove(container);
                }
            }
            catch (Exception ex)
            {
                Logger.LogError($"[DeadBodyContainerCache] Remove(container) failed: {ex}");
            }
        }

        #endregion

        #region Lookup APIs

        /// <summary>
        /// Returns true if a container is cached for the specified profileId. Never throws.
        /// </summary>
        public static bool Contains(string profileId)
        {
            try
            {
                return TryGetKey(profileId, out string key) && ProfileToContainer.ContainsKey(key);
            }
            catch (Exception ex)
            {
                Logger.LogError($"[DeadBodyContainerCache] Contains('{profileId}') failed: {ex}");
                return false;
            }
        }

        /// <summary>
        /// Gets a cached corpse container by profileId, or null if not present.
        /// </summary>
        public static LootableContainer Get(string profileId)
        {
            try
            {
                if (!TryGetKey(profileId, out string key)) return null;
                return ProfileToContainer.TryGetValue(key, out var container) ? container : null;
            }
            catch (Exception ex)
            {
                Logger.LogError($"[DeadBodyContainerCache] Get('{profileId}') failed: {ex}");
                return null;
            }
        }

        /// <summary>
        /// Gets the profileId for a given registered corpse container, or null.
        /// </summary>
        public static string GetProfileId(LootableContainer container)
        {
            try
            {
                if (container == null) return null;
                return ContainerToProfile.TryGetValue(container, out var id) ? id : null;
            }
            catch (Exception ex)
            {
                Logger.LogError($"[DeadBodyContainerCache] GetProfileId(container) failed: {ex}");
                return null;
            }
        }

        #endregion

        #region Squad/AI APIs

        /// <summary>
        /// Returns a pooled list of all cached profileIds. Must TempListPool.Return() after use.
        /// </summary>
        public static List<string> GetAllProfileIds()
        {
            var list = TempListPool.Rent<string>();
            try
            {
                foreach (var kv in ProfileToContainer)
                    if (!string.IsNullOrEmpty(kv.Key))
                        list.Add(kv.Key);
            }
            catch (Exception ex)
            {
                Logger.LogError($"[DeadBodyContainerCache] GetAllProfileIds() failed: {ex}");
            }
            return list;
        }

        /// <summary>
        /// Returns a pooled list of all currently cached corpse containers. Must TempListPool.Return() after use.
        /// </summary>
        public static List<LootableContainer> GetAllContainers()
        {
            var list = TempListPool.Rent<LootableContainer>();
            try
            {
                foreach (var c in RegisteredContainers)
                    if (c != null)
                        list.Add(c);
            }
            catch (Exception ex)
            {
                Logger.LogError($"[DeadBodyContainerCache] GetAllContainers() failed: {ex}");
            }
            return list;
        }

        /// <summary>
        /// Returns a pooled list of all valid corpse containers within radius of pos. Must TempListPool.Return() after use.
        /// </summary>
        public static List<LootableContainer> GetNearbyContainers(Vector3 pos, float radius)
        {
            var list = TempListPool.Rent<LootableContainer>();
            float r2 = radius * radius;
            try
            {
                foreach (var c in RegisteredContainers)
                {
                    if (c == null || c.transform == null) continue;
                    if ((c.transform.position - pos).sqrMagnitude <= r2)
                        list.Add(c);
                }
            }
            catch (Exception ex)
            {
                Logger.LogError($"[DeadBodyContainerCache] GetNearbyContainers() failed: {ex}");
            }
            return list;
        }

        /// <summary>
        /// Returns the current number of cached corpse containers (diagnostic).
        /// </summary>
        public static int GetCount()
        {
            try
            {
                return RegisteredContainers.Count;
            }
            catch (Exception ex)
            {
                Logger.LogError($"[DeadBodyContainerCache] GetCount() failed: {ex}");
                return -1;
            }
        }

        #endregion

        #region Diagnostics & Audit

        /// <summary>
        /// Audits the cache for nulls, dups, and invalid state (bulletproof).
        /// </summary>
        public static void AuditCache()
        {
            try
            {
                int total = ProfileToContainer.Count;
                int nullProfile = 0, nullContainer = 0, dups = 0;
                var seen = new HashSet<LootableContainer>();
                foreach (var kv in ProfileToContainer)
                {
                    if (string.IsNullOrEmpty(kv.Key)) nullProfile++;
                    if (kv.Value == null) nullContainer++;
                    else if (!seen.Add(kv.Value)) dups++;
                }
                Logger.LogInfo($"[DeadBodyContainerCache] Audit: total={total}, nullProfileId={nullProfile}, nullContainer={nullContainer}, dupContainer={dups}");
            }
            catch (Exception ex)
            {
                Logger.LogError($"[DeadBodyContainerCache] AuditCache() failed: {ex}");
            }
        }

        #endregion

        #region Internal

        /// <summary>
        /// Validates and normalizes profileId as a key.
        /// </summary>
        private static bool TryGetKey(string profileId, out string key)
        {
            key = string.Empty;
            if (string.IsNullOrWhiteSpace(profileId))
                return false;
            key = profileId.Trim();
            return key.Length > 0;
        }

        #endregion
    }
}
