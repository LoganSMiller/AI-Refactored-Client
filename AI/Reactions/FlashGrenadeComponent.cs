// <auto-generated>
//   AI-Refactored: FlashGrenadeComponent.cs (Ultra-Platinum++ Arbitration, Beyond Diamond Realism, June 2025)
//   Overlay-only blindness/suppression—never disables/moves/ticks. Bulletproof, pooled, arbitration/event-safe.
//   All logic null-guarded, pooled, SPT/FIKA/headless/client parity. No allocations in hot path.
//   MIT License.
// </auto-generated>

namespace AIRefactored.AI.Reactions
{
    using System;
    using System.Collections.Generic;
    using AIRefactored.AI.Core;
    using AIRefactored.AI.Helpers;
    using AIRefactored.Core;
    using EFT;
    using UnityEngine;

    /// <summary>
    /// Handles bot flashbang/flashlight blindness overlays and suppression effects.
    /// Overlay/event-only—never disables/moves. Arbitration and bulletproof null-guards.
    /// </summary>
    public sealed class FlashGrenadeComponent
    {
        #region Constants

        private const float BaseBlindDuration = 4.5f;
        private const float MaxFlashDistance = 28f;
        private const float DirectFlashAngle = 35f;
        private const float MaxCloseFlashAngle = 15f;
        private const float MaxCloseFlashDistance = 4.5f;
        private const float MinBlindDuration = 2.0f;
        private const float BlindSpeechThreshold = 0.5f;

        #endregion

        #region Fields

        private BotOwner _bot;
        private BotComponentCache _cache;
        private bool _isBlinded;
        private float _lastFlashTime = -999f;
        private float _nextOverlayTime = 0f;
        private bool _failed;

        #endregion

        #region Initialization

        /// <summary>
        /// Attaches and initializes the component for a bot.
        /// </summary>
        public void Initialize(BotComponentCache cache)
        {
            try
            {
                if (cache == null || cache.Bot == null)
                    throw new ArgumentNullException(nameof(cache));
                _cache = cache;
                _bot = cache.Bot;
                _isBlinded = false;
                _lastFlashTime = -999f;
                _nextOverlayTime = 0f;
                _failed = false;
            }
            catch (Exception ex)
            {
                _bot = null;
                _cache = null;
                _failed = true;
                Plugin.LoggerInstance.LogError($"[FlashGrenadeComponent] Initialize exception: {ex}");
            }
        }

        #endregion

        #region Overlay/Event API

        /// <summary>
        /// True if bot is currently blinded (overlay only).
        /// </summary>
        public bool IsFlashed() => !_failed && _isBlinded;

        /// <summary>
        /// Instantly overlays blind state, simulates flash effect and suppression, event-only.
        /// </summary>
        public void ForceBlind(float duration = BaseBlindDuration, Vector3? source = null)
        {
            if (_failed || _bot == null || _bot.IsDead)
                return;
            try
            {
                _lastFlashTime = Time.time;
                _isBlinded = true;
                _nextOverlayTime = Time.time + MinBlindDuration;
                if (source.HasValue)
                {
                    Player player = EFTPlayerUtil.ResolvePlayer(_bot);
                    if (player != null)
                        BotSuppressionHelper.TrySuppressBot(player, source.Value);
                }

                TrySayBlind();
            }
            catch (Exception ex)
            {
                _failed = true;
                Plugin.LoggerInstance.LogError($"[FlashGrenadeComponent] ForceBlind exception: {ex}");
            }
        }

        /// <summary>
        /// Overlay/event-tick by BotBrain. Only overlays blind state—never disables/moves bot.
        /// </summary>
        public void Tick(float time)
        {
            if (_failed || _cache == null || _bot == null || _bot.IsDead)
                return;

            try
            {
                Player player = EFTPlayerUtil.ResolvePlayer(_bot);
                if (player == null || !player.IsAI || player.IsYourPlayer)
                    return;

                // Arbitration: never overlap with other overlays (patrol, fallback, suppression, etc)
                if (!BotOverlayManager.CanIssueMove(_bot, BotOverlayType.Panic))
                    return;

                CheckFlashlightExposure();

                float recovery = GetBlindRecoveryTime();
                if (_isBlinded && (time - _lastFlashTime) > recovery)
                    _isBlinded = false;

                // Overlay: register arbitration end for blindness overlays
                if (!_isBlinded)
                    BotOverlayManager.RegisterMove(_bot, BotOverlayType.Panic);
            }
            catch (Exception ex)
            {
                _failed = true;
                Plugin.LoggerInstance.LogError($"[FlashGrenadeComponent] Tick exception: {ex}");
            }
        }

        #endregion

        #region Internal Overlay Logic

        /// <summary>
        /// Checks all flashlights for direct eye exposure. If triggered, overlays blind/suppression.
        /// </summary>
        private void CheckFlashlightExposure()
        {
            try
            {
                if (_cache == null || _bot == null)
                    return;

                Transform head = BotCacheUtility.Head(_cache);
                if (head == null)
                    return;

                Vector3 eyePos = head.position + Vector3.up * 0.22f;
                IReadOnlyList<Vector3> sources = FlashlightRegistry.GetLastKnownFlashlightPositions();
                if (sources == null || sources.Count == 0)
                    return;

                for (int i = 0; i < sources.Count; i++)
                {
                    Vector3 lightPos = sources[i];
                    Vector3 toEye = eyePos - lightPos;
                    if (toEye.sqrMagnitude > MaxFlashDistance * MaxFlashDistance) continue;

                    float angle = Vector3.Angle(toEye.normalized, head.forward);
                    if (angle > DirectFlashAngle) continue;

                    if (Physics.Raycast(lightPos, toEye.normalized, out RaycastHit hit, toEye.magnitude + 0.1f, AIRefactoredLayerMasks.LineOfSightMask))
                    {
                        if (ReferenceEquals(hit.transform, head) || ReferenceEquals(hit.collider.transform, head))
                        {
                            TriggerBlind(lightPos);
                            return;
                        }
                    }
                    else if (angle < MaxCloseFlashAngle && toEye.magnitude < MaxCloseFlashDistance)
                    {
                        TriggerBlind(lightPos);
                        return;
                    }
                }
            }
            catch (Exception ex)
            {
                _failed = true;
                Plugin.LoggerInstance.LogError($"[FlashGrenadeComponent] CheckFlashlightExposure exception: {ex}");
            }
        }

        /// <summary>
        /// Overlays blind/suppression (event-based, never disables/moves).
        /// </summary>
        private void TriggerBlind(Vector3 source)
        {
            _lastFlashTime = Time.time;
            _isBlinded = true;
            _nextOverlayTime = Time.time + MinBlindDuration;

            Player player = EFTPlayerUtil.ResolvePlayer(_bot);
            if (player != null)
                BotSuppressionHelper.TrySuppressBot(player, source);

            TrySayBlind();
        }

        /// <summary>
        /// Triggers blinded/flash speech overlay only if not already played for current event.
        /// </summary>
        private void TrySayBlind()
        {
            if (_cache?.Bot?.BotTalk != null && _isBlinded)
            {
                // Only say blind/flash speech if above threshold and not spammed
                if ((_lastFlashTime > 0f) && (Time.time - _lastFlashTime < 0.4f))
                    _cache.Bot.BotTalk.TrySay(EPhraseTrigger.OnBeingHurt);
            }
        }

        /// <summary>
        /// Dynamic recovery time based on bot composure (personality).
        /// </summary>
        private float GetBlindRecoveryTime()
        {
            float composure = 1f;
            try
            {
                if (_cache != null && _cache.PanicHandler != null)
                    composure = Mathf.Clamp01(_cache.PanicHandler.GetComposureLevel());
            }
            catch { composure = 1f; }
            // Higher composure = faster recovery
            return Mathf.Lerp(MinBlindDuration, BaseBlindDuration, 1f - composure);
        }

        #endregion
    }
}
