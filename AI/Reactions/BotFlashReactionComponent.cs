// <auto-generated>
//   This file is part of AI-Refactored, an open-source project focused on realistic AI behavior in Escape from Tarkov.
//   Licensed under the MIT License. See LICENSE in the repository root for more information.
//
//   THIS FILE IS SYSTEMATICALLY MANAGED.
//   Please follow strict StyleCop, ReSharper, and AI-Refactored code standards for all modifications.
// </auto-generated>

#nullable enable

namespace AIRefactored.AI.Reactions
{
    using AIRefactored.AI.Combat;
    using AIRefactored.AI.Core;
    using AIRefactored.AI.Helpers;
    using AIRefactored.AI.Optimization;
    using AIRefactored.Core;
    using EFT;
    using UnityEngine;

    /// <summary>
    /// Handles bot reactions to intense light exposure (e.g., flashlights or flashbangs).
    /// Applies suppression, triggers scored fallback movement, and panic if threshold reached.
    /// </summary>
    public sealed class BotFlashReactionComponent
    {
        #region Constants

        private const float FallbackDistance = 5f;
        private const float FallbackJitter = 1.25f;
        private const float MaxSuppressionDuration = 5.0f;
        private const float MinSuppressionDuration = 1.0f;
        private const float ReactionCooldown = 0.5f;
        private const float TriggerIntensityThreshold = 0.35f;

        #endregion

        #region Fields

        private BotComponentCache? _cache;
        private float _lastTriggerTime = -1f;
        private float _suppressedUntil = -1f;

        #endregion

        #region Public API

        /// <summary>
        /// Links this flash reaction handler to the active bot's shared component cache.
        /// </summary>
        /// <param name="cache">The component cache containing bot references.</param>
        public void Initialize(BotComponentCache cache)
        {
            this._cache = cache;
        }

        /// <summary>
        /// Returns true if the bot is still suppressed from a flash reaction.
        /// </summary>
        /// <returns>True if suppression is still active; otherwise, false.</returns>
        public bool IsSuppressed()
        {
            return Time.time < this._suppressedUntil;
        }

        /// <summary>
        /// Called every frame from BotBrain. Updates suppression state and performs exposure checks.
        /// </summary>
        /// <param name="time">The current time in seconds.</param>
        public void Tick(float time)
        {
            if (this._cache == null || this._cache.Bot == null)
            {
                return;
            }

            if (time >= this._suppressedUntil)
            {
                this._suppressedUntil = -1f;
            }

            Transform? head = BotCacheUtility.Head(this._cache);
            if (head == null)
            {
                return;
            }

            for (int i = 0; i < FlashlightRegistry.GetLastKnownFlashlightPositions().Count; i++)
            {
                Light? light;
                if (FlashlightRegistry.IsExposingBot(head, out light) && light != null)
                {
                    float score = FlashLightUtils.CalculateFlashScore(light.transform, head, 20f);
                    if (score >= TriggerIntensityThreshold)
                    {
                        this.TriggerSuppression(score);
                        break;
                    }
                }
            }
        }

        /// <summary>
        /// Triggers suppression, fallback, and panic if flash conditions are met.
        /// </summary>
        /// <param name="strength">The intensity of the flash (0.0 to 1.0).</param>
        public void TriggerSuppression(float strength = 0.6f)
        {
            if (this._cache == null)
            {
                return;
            }

            BotOwner? bot = this._cache.Bot;
            if (bot == null || bot.IsDead)
            {
                return;
            }

            Player? eftPlayer = EFTPlayerUtil.ResolvePlayer(bot);
            if (eftPlayer == null || !eftPlayer.IsAI || eftPlayer.IsYourPlayer)
            {
                return;
            }

            float now = Time.time;
            if (now - this._lastTriggerTime < ReactionCooldown)
            {
                return;
            }

            this._lastTriggerTime = now;

            float composure = this._cache.PanicHandler != null
                ? this._cache.PanicHandler.GetComposureLevel()
                : 1f;

            float scaled = Mathf.Clamp01(strength * composure);
            float duration = Mathf.Lerp(MinSuppressionDuration, MaxSuppressionDuration, scaled);
            this._suppressedUntil = now + duration;

            TriggerFallback(bot);
            TriggerPanic(this._cache);
        }

        #endregion

        #region Private Methods

        private static void TriggerFallback(BotOwner bot)
        {
            Vector3 threatDirection = bot.LookDirection;
            Vector3? scoredRetreat = HybridFallbackResolver.GetBestRetreatPoint(bot, threatDirection);

            if (scoredRetreat.HasValue)
            {
                BotMovementHelper.SmoothMoveTo(bot, scoredRetreat.Value);
                return;
            }

            Vector3 forward = bot.LookDirection;
            Vector3 lateral = new Vector3(-forward.x, 0f, -forward.z).normalized;
            Vector3 fallback = bot.Position + lateral * FallbackDistance + Random.insideUnitSphere * FallbackJitter;
            fallback.y = bot.Position.y;

            BotMovementHelper.SmoothMoveTo(bot, fallback);
        }

        private static void TriggerPanic(BotComponentCache? cache)
        {
            if (cache == null)
            {
                return;
            }

            BotPanicHandler? panic;
            if (BotPanicUtility.TryGetPanicComponent(cache, out panic) && panic != null)
            {
                panic.TriggerPanic();
            }
        }

        #endregion
    }
}
