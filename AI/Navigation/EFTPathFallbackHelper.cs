// <auto-generated>
//   Part of AI-Refactored: Realistic AI for Escape from Tarkov.
//   Licensed under MIT. SYSTEMATICALLY MANAGED: Bulletproof native path/tactical/fallback logic.
// </auto-generated>

namespace AIRefactored.AI.Navigation
{
    using System;
    using System.Collections.Generic;
    using AIRefactored.Core;
    using EFT;
    using UnityEngine;

    /// <summary>
    /// Centralizes all EFT-native path/segment/fallback and tactical helpers for bot navigation.
    /// Uses real BotMover and PathControllerClass internals—never reflection or dynamic.
    /// </summary>
    public static class EFTPathFallbackHelper
    {
        #region Core Navigation & Fallback

        /// <summary>
        /// Attempts to resolve a safe next movement target for the given bot,
        /// using EFT's internal path and fallback logic.
        /// Returns true if a valid movement target is found.
        /// </summary>
        public static bool TryGetSafeTarget(BotOwner bot, out Vector3 target)
        {
            target = Vector3.zero;
            if (bot == null || bot.Mover == null)
                return false;

            var mover = bot.Mover;
            var pathController = mover._pathController;

            if (IsPathValid(pathController))
            {
                Vector3 pt = pathController.LastTargetPoint(1.0f);
                if (IsValid(pt))
                {
                    target = pt;
                    return true;
                }
            }

            // Fallback to registry
            if (NavPointRegistry.IsReady && !NavPointRegistry.IsEmpty)
            {
                Vector3 navPoint = NavPointRegistry.GetClosestPosition(bot.Position);
                if (IsValid(navPoint))
                {
                    target = navPoint;
                    return true;
                }
            }

            return false;
        }

        /// <summary>
        /// Gets the current full path as an array of Vector3 waypoints.
        /// Returns null if unavailable.
        /// </summary>
        public static Vector3[] GetCurrentPathPoints(BotOwner bot, int maxPoints = 16)
        {
            if (bot == null || bot.Mover == null)
                return null;

            var pathController = bot.Mover._pathController;
            if (IsPathValid(pathController))
            {
                return pathController.GetWayPoints(maxPoints);
            }
            return null;
        }

        /// <summary>
        /// Gets the current path corners/waypoints from a specific index onward.
        /// Returns null if unavailable.
        /// </summary>
        public static List<Vector3> GetCornersFromIndex(BotOwner bot, int index)
        {
            if (bot == null || bot.Mover == null)
                return null;

            var pathController = bot.Mover._pathController;
            if (IsPathValid(pathController))
            {
                return pathController.GetCornersFromIndex(index);
            }
            return null;
        }

        /// <summary>
        /// Returns the index and position of the first point farther than the given distance.
        /// Returns null if not found.
        /// </summary>
        public static Vector3? FindPointFartherThan(BotOwner bot, float dist, out int index)
        {
            index = 0;
            if (bot == null || bot.Mover == null)
                return null;

            var pathController = bot.Mover._pathController;
            if (IsPathValid(pathController))
            {
                return pathController.FindPointFarThan(dist, out index);
            }
            return null;
        }

        /// <summary>
        /// Returns the current "corner" (next turn) on the active path, if available.
        /// </summary>
        public static bool TryGetCurrentCorner(BotOwner bot, out Vector3 corner)
        {
            corner = Vector3.zero;
            if (bot == null || bot.Mover == null)
                return false;

            var pathController = bot.Mover._pathController;
            if (IsPathValid(pathController))
            {
                corner = pathController.CurrentCorner();
                return IsValid(corner);
            }
            return false;
        }

        /// <summary>
        /// Returns the previous "corner" (last turn) on the path, if available.
        /// </summary>
        public static bool TryGetPrevCorner(BotOwner bot, out Vector3 prevCorner)
        {
            prevCorner = Vector3.zero;
            if (bot == null || bot.Mover == null)
                return false;

            var pathController = bot.Mover._pathController;
            if (IsPathValid(pathController))
            {
                prevCorner = pathController.PrevCorner;
                return IsValid(prevCorner);
            }
            return false;
        }

        /// <summary>
        /// Checks if the given point is on the current path, within maxDist.
        /// </summary>
        public static bool IsPointOnCurrentPath(BotOwner bot, Vector3 point, float maxDist)
        {
            if (bot == null || bot.Mover == null)
                return false;

            var pathController = bot.Mover._pathController;
            if (IsPathValid(pathController))
            {
                return pathController.IsPointOnCurrentWay(point, maxDist);
            }
            return false;
        }

        /// <summary>
        /// Returns the current remaining distance to the destination, if available.
        /// </summary>
        public static float GetRemainingDist(BotOwner bot)
        {
            if (bot == null || bot.Mover == null)
                return float.MaxValue;

            var pathController = bot.Mover._pathController;
            if (IsPathValid(pathController))
                return pathController.PlayerRemainingDist;

            return float.MaxValue;
        }

        /// <summary>
        /// Attempts to retrieve a static fallback point if all navigation fails.
        /// </summary>
        public static Vector3 GetFallbackNavPoint(Vector3 fromPosition)
        {
            return FallbackNavPointProvider.GetSafePoint(fromPosition);
        }

        #endregion

        #region Tactical / Advanced Helpers

        /// <summary>
        /// Returns squad-safe path points not occupied by squadmates (prevents clumping/collision).
        /// </summary>
        public static List<Vector3> GetSquadSafePathPoints(BotOwner bot, int maxPoints = 8, float safeRadius = 1.0f)
        {
            var result = new List<Vector3>(maxPoints);

            if (bot == null || bot.Mover == null || bot.BotsGroup == null)
                return result;

            var pathController = bot.Mover._pathController;
            if (!IsPathValid(pathController))
                return result;

            Vector3[] waypoints = pathController.GetWayPoints(maxPoints);
            if (waypoints == null || waypoints.Length == 0)
                return result;

            int members = bot.BotsGroup.MembersCount;
            for (int i = 0; i < waypoints.Length; i++)
            {
                bool safe = true;
                Vector3 candidate = waypoints[i];
                for (int m = 0; m < members; m++)
                {
                    BotOwner mate = bot.BotsGroup.Member(m);
                    if (mate != null && mate != bot && (mate.Position - candidate).sqrMagnitude < safeRadius * safeRadius)
                    {
                        safe = false;
                        break;
                    }
                }
                if (safe)
                    result.Add(candidate);
            }

            return result;
        }

        /// <summary>
        /// Picks a tactical retreat point on the path not visible to known enemies.
        /// </summary>
        public static bool TryGetTacticalRetreatPoint(BotOwner bot, List<Vector3> knownEnemyPositions, out Vector3 retreatPoint, int lookaheadPoints = 8, float minEnemyLOSAngle = 90f)
        {
            retreatPoint = Vector3.zero;
            if (bot == null || bot.Mover == null || knownEnemyPositions == null || knownEnemyPositions.Count == 0)
                return false;

            var pathController = bot.Mover._pathController;
            if (!IsPathValid(pathController))
                return false;

            Vector3[] waypoints = pathController.GetWayPoints(lookaheadPoints);
            if (waypoints == null || waypoints.Length == 0)
                return false;

            Vector3 botPos = bot.Position;
            for (int i = waypoints.Length - 1; i >= 0; i--)
            {
                Vector3 point = waypoints[i];
                bool covered = true;
                foreach (var enemyPos in knownEnemyPositions)
                {
                    Vector3 toPoint = (point - enemyPos).normalized;
                    Vector3 toBot = (botPos - enemyPos).normalized;
                    float angle = Vector3.Angle(toPoint, toBot);
                    if (angle < minEnemyLOSAngle)
                    {
                        covered = false;
                        break;
                    }
                }
                if (covered)
                {
                    retreatPoint = point;
                    return true;
                }
            }
            return false;
        }

        /// <summary>
        /// Finds the best flank segment (two points) with maximum distance from enemy LOS.
        /// </summary>
        public static bool TryGetBestFlankSegment(BotOwner bot, List<Vector3> knownEnemyPositions, out List<Vector3> flankSegment, int maxLookahead = 8, float minCoverDist = 2.0f)
        {
            flankSegment = null;
            if (bot == null || bot.Mover == null || knownEnemyPositions == null || knownEnemyPositions.Count == 0)
                return false;

            var pathController = bot.Mover._pathController;
            if (!IsPathValid(pathController))
                return false;

            List<Vector3> bestFlank = null;
            float bestScore = float.MinValue;
            Vector3[] waypoints = pathController.GetWayPoints(maxLookahead);

            for (int i = 0; i < waypoints.Length - 1; i++)
            {
                Vector3 a = waypoints[i];
                Vector3 b = waypoints[i + 1];
                float minDistToEnemies = float.MaxValue;
                foreach (var enemy in knownEnemyPositions)
                {
                    float dist = DistanceToSegment(enemy, a, b);
                    if (dist < minDistToEnemies)
                        minDistToEnemies = dist;
                }
                if (minDistToEnemies > minCoverDist && minDistToEnemies > bestScore)
                {
                    bestScore = minDistToEnemies;
                    bestFlank = new List<Vector3> { a, b };
                }
            }

            if (bestFlank != null)
            {
                flankSegment = bestFlank;
                return true;
            }

            return false;
        }

        /// <summary>
        /// Checks if any upcoming path segment will cross or expose the bot to any known enemy.
        /// </summary>
        public static bool WillCrossEnemyLOS(BotOwner bot, List<Vector3> knownEnemyPositions, int lookahead = 5, float exposureThreshold = 5f)
        {
            if (bot == null || bot.Mover == null || knownEnemyPositions == null || knownEnemyPositions.Count == 0)
                return false;

            var pathController = bot.Mover._pathController;
            if (!IsPathValid(pathController))
                return false;

            Vector3[] waypoints = pathController.GetWayPoints(lookahead);
            if (waypoints == null || waypoints.Length < 2)
                return false;

            for (int i = 0; i < waypoints.Length - 1; i++)
            {
                Vector3 a = waypoints[i];
                Vector3 b = waypoints[i + 1];
                foreach (var enemy in knownEnemyPositions)
                {
                    if (DistanceToSegment(enemy, a, b) < exposureThreshold)
                        return true;
                }
            }
            return false;
        }

        /// <summary>
        /// Utility: Distance from a point to a segment [A,B].
        /// </summary>
        private static float DistanceToSegment(Vector3 p, Vector3 a, Vector3 b)
        {
            Vector3 ab = b - a;
            Vector3 ap = p - a;
            float t = Vector3.Dot(ap, ab) / ab.sqrMagnitude;
            t = Mathf.Clamp01(t);
            Vector3 closest = a + ab * t;
            return (p - closest).magnitude;
        }

        #endregion

        #region Internal Validation

        /// <summary>
        /// Checks if a path controller is valid.
        /// </summary>
        private static bool IsPathValid(PathControllerClass pathController)
        {
            return pathController != null
                && pathController.HavePath
                && pathController.CurPath != null
                && pathController.CurPath.Length > 0;
        }

        /// <summary>
        /// Checks if a Vector3 is valid for navigation.
        /// </summary>
        private static bool IsValid(Vector3 pt)
        {
            return !float.IsNaN(pt.x) && !float.IsNaN(pt.y) && !float.IsNaN(pt.z)
                && !float.IsInfinity(pt.x) && !float.IsInfinity(pt.y) && !float.IsInfinity(pt.z)
                && Mathf.Abs(pt.x) < 10000f && Mathf.Abs(pt.y) < 10000f && Mathf.Abs(pt.z) < 10000f;
        }

        #endregion
    }
}
