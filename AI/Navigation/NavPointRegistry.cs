// <auto-generated>
//   This file is part of AI-Refactored, an open-source project focused on realistic AI behavior in Escape from Tarkov.
//   Licensed under the MIT License. See LICENSE in the repository root for more information.
//
//   THIS FILE IS SYSTEMATICALLY MANAGED.
//   Please follow strict StyleCop, ReSharper, and AI-Refactored code standards for all modifications.
// </auto-generated>

namespace AIRefactored.AI.Navigation
{
    using System;
    using System.Collections.Generic;
    using AIRefactored.AI.Core;
    using AIRefactored.Core;
    using AIRefactored.Pools;
    using AIRefactored.Runtime;
    using BepInEx.Logging;
    using Unity.AI.Navigation;
    using UnityEngine;

    /// <summary>
    /// Registry and spatial query system for navigation points, supporting zone tags and cover scoring.
    /// </summary>
    public static class NavPointRegistry
    {
        private static readonly List<NavPoint> Points = new List<NavPoint>(512);
        private static readonly HashSet<Vector3> Unique = new HashSet<Vector3>();
        private static QuadtreeNavGrid _quadtree;
        private static bool _useQuadtree;

        private static ManualLogSource Logger => Plugin.LoggerInstance;

        public static int Count => Points.Count;

        public static void Initialize()
        {
            Points.Clear();
            Unique.Clear();
            _quadtree = null;
            _useQuadtree = false;
            Logger.LogDebug("[NavPointRegistry] Initialized.");
        }

        public static void Clear()
        {
            Points.Clear();
            Unique.Clear();
            _quadtree = null;
        }

        public static void EnableSpatialIndexing(bool enable)
        {
            _useQuadtree = enable;
            _quadtree = enable ? BuildQuadtree() : null;
        }

        public static void RegisterAll(string mapId)
        {
            Initialize();

            if (!GameWorldHandler.IsLocalHost() && !FikaHeadlessDetector.IsHeadless)
            {
                Logger.LogDebug("[NavPointRegistry] Skipped RegisterAll — not host.");
                return;
            }

            Logger.LogDebug("[NavPointRegistry] Registering nav points for map: " + mapId);

            NavMeshSurface surface = GameObject.FindObjectOfType<NavMeshSurface>();
            if (surface == null)
            {
                Logger.LogWarning("[NavPointRegistry] No NavMeshSurface found.");
                return;
            }

            NavPointBootstrapper.RegisterAll(mapId);
        }

        public static void Register(Vector3 pos, bool isCover = false, string tag = "generic", float elevation = 0f, bool isIndoor = false, bool isJumpable = false, float coverAngle = 0f)
        {
            if (!Unique.Add(pos))
            {
                return;
            }

            Points.Add(new NavPoint(
                pos,
                isCover,
                tag,
                elevation,
                isIndoor,
                isJumpable,
                coverAngle,
                "Unknown",
                GetElevationBand(elevation)));

            if (_useQuadtree && _quadtree != null)
            {
                _quadtree.Insert(pos);
            }
        }

        public static void RefreshPointsAround(Vector3 center, float radius)
        {
            float radiusSq = radius * radius;

            for (int i = 0; i < Points.Count; i++)
            {
                NavPoint point = Points[i];
                if ((point.WorldPos - center).sqrMagnitude > radiusSq)
                {
                    continue;
                }

                bool isIndoor = Physics.Raycast(point.WorldPos + Vector3.up * 1.4f, Vector3.up, 12f);
                Points[i] = new NavPoint(
                    point.WorldPos,
                    point.IsCover,
                    point.Tag,
                    point.Elevation,
                    isIndoor,
                    point.IsJumpable,
                    point.CoverAngle,
                    "Unknown",
                    GetElevationBand(point.Elevation));
            }

            Logger.LogDebug("[NavPointRegistry] Refreshed nav points near: " + center.ToString("F1"));
        }

        public static bool IsRegistered(Vector3 pos) => Unique.Contains(pos);
        public static bool IsCoverPoint(Vector3 pos) => TryGetPoint(pos, out var p) && p.IsCover;
        public static bool IsIndoor(Vector3 pos) => TryGetPoint(pos, out var p) && p.IsIndoor;
        public static bool IsJumpable(Vector3 pos) => TryGetPoint(pos, out var p) && p.IsJumpable;
        public static float GetCoverAngle(Vector3 pos) => TryGetPoint(pos, out var p) ? p.CoverAngle : 0f;
        public static float GetElevation(Vector3 pos) => TryGetPoint(pos, out var p) ? p.Elevation : 0f;
        public static string GetTag(Vector3 pos) => TryGetPoint(pos, out var p) ? p.Tag : "untagged";
        public static string GetZone(Vector3 pos) => TryGetPoint(pos, out var p) ? p.Zone : "unassigned";
        public static string GetElevationBand(Vector3 pos) => TryGetPoint(pos, out var p) ? p.ElevationBand : "unknown";

        public static List<Vector3> GetAllPositions()
        {
            List<Vector3> result = TempListPool.Rent<Vector3>();
            for (int i = 0; i < Points.Count; i++)
            {
                result.Add(Points[i].WorldPos);
            }

            return result;
        }

        public static List<Vector3> QueryNearby(Vector3 origin, float radius, Predicate<Vector3> filter = null, bool coverOnly = false)
        {
            List<Vector3> result = TempListPool.Rent<Vector3>();
            float radiusSq = radius * radius;

            if (_useQuadtree && _quadtree != null)
            {
                List<Vector3> raw = _quadtree.QueryRaw(origin, radius, filter);
                for (int i = 0; i < raw.Count; i++)
                {
                    if (TryGetPoint(raw[i], out var nav) && (!coverOnly || nav.IsCover))
                    {
                        result.Add(raw[i]);
                    }
                }

                return result;
            }

            for (int i = 0; i < Points.Count; i++)
            {
                var p = Points[i];
                if ((p.WorldPos - origin).sqrMagnitude > radiusSq || (coverOnly && !p.IsCover))
                {
                    continue;
                }

                if (filter == null || filter(p.WorldPos))
                {
                    result.Add(p.WorldPos);
                }
            }

            return result;
        }

        public static List<NavPointData> QueryNearby(Vector3 origin, float radius, Predicate<NavPointData> filter = null)
        {
            List<NavPointData> result = TempListPool.Rent<NavPointData>();
            float radiusSq = radius * radius;

            for (int i = 0; i < Points.Count; i++)
            {
                var p = Points[i];
                if ((p.WorldPos - origin).sqrMagnitude > radiusSq)
                {
                    continue;
                }

                var data = new NavPointData(
                    p.WorldPos,
                    p.IsCover,
                    p.Tag,
                    p.Elevation,
                    p.IsIndoor,
                    p.IsJumpable,
                    p.CoverAngle,
                    p.Zone,
                    p.ElevationBand);

                if (filter == null || filter(data))
                {
                    result.Add(data);
                }
            }

            return result;
        }

        private static bool TryGetPoint(Vector3 pos, out NavPoint point)
        {
            for (int i = 0; i < Points.Count; i++)
            {
                if (Points[i].WorldPos == pos)
                {
                    point = Points[i];
                    return true;
                }
            }

            point = default(NavPoint);
            return false;
        }

        private static string GetElevationBand(float elevation)
        {
            if (elevation < 2f) return "Low";
            if (elevation < 7f) return "Mid";
            return "High";
        }

        private static QuadtreeNavGrid BuildQuadtree()
        {
            if (Points.Count == 0)
            {
                return null;
            }

            float minX = float.MaxValue;
            float maxX = float.MinValue;
            float minZ = float.MaxValue;
            float maxZ = float.MinValue;

            for (int i = 0; i < Points.Count; i++)
            {
                Vector3 pos = Points[i].WorldPos;
                if (pos.x < minX) minX = pos.x;
                if (pos.x > maxX) maxX = pos.x;
                if (pos.z < minZ) minZ = pos.z;
                if (pos.z > maxZ) maxZ = pos.z;
            }

            Vector2 center = new Vector2((minX + maxX) * 0.5f, (minZ + maxZ) * 0.5f);
            float size = Mathf.Max(maxX - minX, maxZ - minZ) + 20f;

            var tree = new QuadtreeNavGrid(center, size);
            for (int i = 0; i < Points.Count; i++)
            {
                tree.Insert(Points[i].WorldPos);
            }

            Logger.LogDebug("[NavPointRegistry] Quadtree built for " + Points.Count + " points.");
            return tree;
        }

        private sealed class NavPoint
        {
            public NavPoint(Vector3 pos, bool isCover, string tag, float elevation, bool isIndoor, bool isJumpable, float coverAngle, string zone, string elevationBand)
            {
                this.WorldPos = pos;
                this.IsCover = isCover;
                this.Tag = tag;
                this.Elevation = elevation;
                this.IsIndoor = isIndoor;
                this.IsJumpable = isJumpable;
                this.CoverAngle = coverAngle;
                this.Zone = zone;
                this.ElevationBand = elevationBand;
            }

            public Vector3 WorldPos { get; }
            public bool IsCover { get; }
            public string Tag { get; }
            public float Elevation { get; }
            public bool IsIndoor { get; }
            public bool IsJumpable { get; }
            public float CoverAngle { get; }
            public string Zone { get; }
            public string ElevationBand { get; }
        }
    }
}
