// <auto-generated>
//   This file is part of AI-Refactored, an open-source project focused on realistic AI behavior in Escape from Tarkov.
//   Licensed under the MIT License. See LICENSE in the repository root for more information.
//
//   THIS FILE IS SYSTEMATICALLY MANAGED.
//   Please follow strict StyleCop, ReSharper, and AI-Refactored code standards for all modifications.
// </auto-generated>

#nullable enable

namespace AIRefactored.AI.Navigation
{
    using System;
    using System.Collections.Generic;
    using AIRefactored.Runtime;
    using BepInEx.Logging;
    using EFT.Game.Spawning;
    using UnityEngine;

    /// <summary>
    /// Central registry for tactical navigation points with metadata.
    /// Supports cover tagging, elevation bands, indoor/outdoor classification, zone detection,
    /// jumpability flags, cover orientation, and fast quadtree spatial indexing.
    /// </summary>
    public static class NavPointRegistry
    {
        #region Fields

        private static readonly List<NavPoint> _points = new List<NavPoint>(512);
        private static readonly HashSet<Vector3> _unique = new HashSet<Vector3>();
        private static QuadtreeNavGrid? _quadtree;
        private static IZones? _zones;
        private static bool _useQuadtree;

        #endregion

        #region Properties

        private static ManualLogSource Logger => AIRefactoredController.Logger;

        /// <summary>
        /// Gets the number of registered navigation points.
        /// </summary>
        public static int Count => _points.Count;

        #endregion

        #region Public API

        /// <summary>
        /// Clears the registry of all navigation points and resets indexing.
        /// </summary>
        public static void Clear()
        {
            _points.Clear();
            _unique.Clear();
            _quadtree = null;
        }

        /// <summary>
        /// Enables or disables quadtree spatial indexing for faster lookups.
        /// </summary>
        public static void EnableSpatialIndexing(bool enable)
        {
            _useQuadtree = enable;

            if (enable)
            {
                InitializeSpatialIndex();
            }
            else
            {
                _quadtree = null;
            }
        }

        /// <summary>
        /// Initializes the zone system for tagging nav points.
        /// </summary>
        public static void InitializeZoneSystem(IZones zones)
        {
            _zones = zones;
        }

        /// <summary>
        /// Registers a navigation point in the global tactical registry.
        /// </summary>
        public static void Register(
            Vector3 pos,
            bool isCover = false,
            string tag = "generic",
            float elevation = 0f,
            bool isIndoor = false,
            bool isJumpable = false,
            float coverAngle = 0f)
        {
            if (_unique.Contains(pos))
            {
                return;
            }

            string zoneName = GetNearestZone(pos);
            string elevationBand = GetElevationBand(elevation);

            NavPoint point = new NavPoint(
                pos,
                isCover,
                tag,
                elevation,
                isIndoor,
                isJumpable,
                coverAngle,
                zoneName,
                elevationBand);

            _points.Add(point);
            _unique.Add(pos);

            if (_useQuadtree && _quadtree != null)
            {
                _quadtree.Insert(pos);
            }
        }

        /// <summary>
        /// Builds a quadtree from registered points for faster spatial queries.
        /// </summary>
        public static void InitializeSpatialIndex()
        {
            if (!_useQuadtree || _points.Count == 0)
            {
                return;
            }

            float minX = float.MaxValue;
            float maxX = float.MinValue;
            float minZ = float.MaxValue;
            float maxZ = float.MinValue;

            for (int i = 0; i < _points.Count; i++)
            {
                Vector3 pos = _points[i].WorldPos;
                minX = Mathf.Min(minX, pos.x);
                maxX = Mathf.Max(maxX, pos.x);
                minZ = Mathf.Min(minZ, pos.z);
                maxZ = Mathf.Max(maxZ, pos.z);
            }

            float padding = 10f;
            Vector2 center = new Vector2((minX + maxX) * 0.5f, (minZ + maxZ) * 0.5f);
            float size = Mathf.Max(maxX - minX, maxZ - minZ) + (padding * 2f);

            _quadtree = new QuadtreeNavGrid(center, size);

            for (int i = 0; i < _points.Count; i++)
            {
                _quadtree.Insert(_points[i].WorldPos);
            }

            Logger.LogInfo($"[NavPointRegistry] Built quadtree for {Count} nav points. Size: {size:F1} at {center}");
        }

        /// <summary>
        /// Returns all registered world positions.
        /// </summary>
        public static List<Vector3> GetAllPositions()
        {
            List<Vector3> result = new List<Vector3>(_points.Count);

            for (int i = 0; i < _points.Count; i++)
            {
                result.Add(_points[i].WorldPos);
            }

            return result;
        }

        /// <summary>
        /// Returns a filtered list of nearby positions.
        /// </summary>
        public static List<Vector3> QueryNearby(Vector3 origin, float radius, Predicate<Vector3>? filter = null, bool coverOnly = false)
        {
            List<Vector3> result = new List<Vector3>(16);
            float radiusSq = radius * radius;

            if (_useQuadtree && _quadtree != null)
            {
                List<Vector3> raw = _quadtree.QueryRaw(origin, radius, filter);

                for (int i = 0; i < raw.Count; i++)
                {
                    NavPoint? nav;
                    if (TryGetPoint(raw[i], out nav) && nav != null && (!coverOnly || nav.IsCover))
                    {
                        result.Add(raw[i]);
                    }
                }

                return result;
            }

            for (int i = 0; i < _points.Count; i++)
            {
                NavPoint p = _points[i];

                if ((p.WorldPos - origin).sqrMagnitude > radiusSq)
                {
                    continue;
                }

                if (coverOnly && !p.IsCover)
                {
                    continue;
                }

                if (filter == null || filter(p.WorldPos))
                {
                    result.Add(p.WorldPos);
                }
            }

            return result;
        }

        /// <summary>
        /// Returns full nav point metadata within radius.
        /// </summary>
        public static List<NavPointData> QueryNearby(Vector3 origin, float radius, Predicate<NavPointData>? filter = null)
        {
            List<NavPointData> result = new List<NavPointData>(16);
            float radiusSq = radius * radius;

            for (int i = 0; i < _points.Count; i++)
            {
                NavPoint p = _points[i];

                if ((p.WorldPos - origin).sqrMagnitude > radiusSq)
                {
                    continue;
                }

                NavPointData data = new NavPointData(
                    p.WorldPos,
                    p.IsCover,
                    p.Tag,
                    p.Elevation,
                    p.IsIndoor,
                    p.IsJumpable,
                    p.CoverAngle,
                    p.Zone,
                    p.ElevationBand);

                if (filter == null || filter(data))
                {
                    result.Add(data);
                }
            }

            return result;
        }

        /// <summary>
        /// Registers all points for a map by invoking bootstrapper.
        /// </summary>
        public static void RegisterAll(string mapId)
        {
            Clear();

            Logger.LogInfo($"[NavPointRegistry] Registering all nav points for map '{mapId}'...");

            if (GameObject.FindObjectOfType<Unity.AI.Navigation.NavMeshSurface>() == null)
            {
                Logger.LogWarning("[NavPointRegistry] No NavMeshSurface found in scene.");
                return;
            }

            if (_zones == null)
            {
                Logger.LogWarning("[NavPointRegistry] No IZones system assigned — zone tagging will be limited.");
            }

            NavPointBootstrapper.RegisterAll(mapId);
        }

        /// <summary>
        /// Gets cover angle at a world position if registered.
        /// </summary>
        public static float GetCoverAngle(Vector3 pos)
        {
            NavPoint? p;
            return TryGetPoint(pos, out p) && p != null ? p.CoverAngle : 0f;
        }

        public static float GetElevation(Vector3 pos)
        {
            NavPoint? p;
            return TryGetPoint(pos, out p) && p != null ? p.Elevation : 0f;
        }

        public static string GetElevationBand(Vector3 pos)
        {
            NavPoint? p;
            return TryGetPoint(pos, out p) && p != null && p.ElevationBand != null
                       ? p.ElevationBand
                       : "unknown";
        }

        public static string GetTag(Vector3 pos)
        {
            NavPoint? p;
            return TryGetPoint(pos, out p) && p != null && p.Tag != null
                       ? p.Tag
                       : "untagged";
        }

        public static string GetZone(Vector3 pos)
        {
            NavPoint? p;
            return TryGetPoint(pos, out p) && p != null && p.Zone != null
                       ? p.Zone
                       : "unassigned";
        }

        public static bool IsCoverPoint(Vector3 pos)
        {
            NavPoint? p;
            return TryGetPoint(pos, out p) && p != null && p.IsCover;
        }

        public static bool IsIndoor(Vector3 pos)
        {
            NavPoint? p;
            return TryGetPoint(pos, out p) && p != null && p.IsIndoor;
        }

        public static bool IsJumpable(Vector3 pos)
        {
            NavPoint? p;
            return TryGetPoint(pos, out p) && p != null && p.IsJumpable;
        }

        public static bool IsRegistered(Vector3 pos)
        {
            return _unique.Contains(pos);
        }

        #endregion

        #region Helpers

        private static bool TryGetPoint(Vector3 pos, out NavPoint? point)
        {
            for (int i = 0; i < _points.Count; i++)
            {
                if (_points[i].WorldPos == pos)
                {
                    point = _points[i];
                    return true;
                }
            }

            point = null;
            return false;
        }

        private static string GetNearestZone(Vector3 pos)
        {
            if (_zones == null)
            {
                return "Unknown";
            }

            string best = "Unknown";
            float bestDist = float.MaxValue;

            foreach (string zone in _zones.ZoneNames())
            {
                ISpawnPoint[] spawns = _zones.ZoneSpawnPoints(zone);

                for (int i = 0; i < spawns.Length; i++)
                {
                    float dist = Vector3.Distance(pos, spawns[i].Position);
                    if (dist < bestDist)
                    {
                        bestDist = dist;
                        best = zone;
                    }
                }
            }

            return best;
        }

        private static string GetElevationBand(float elevation)
        {
            if (elevation < 2f)
            {
                return "Low";
            }

            if (elevation < 7f)
            {
                return "Mid";
            }

            return "High";
        }

        #endregion

        #region Types

        private sealed class NavPoint
        {
            public NavPoint(Vector3 pos, bool isCover, string tag, float elevation, bool isIndoor, bool isJumpable, float coverAngle, string zone, string elevationBand)
            {
                this.WorldPos = pos;
                this.IsCover = isCover;
                this.Tag = tag;
                this.Elevation = elevation;
                this.IsIndoor = isIndoor;
                this.IsJumpable = isJumpable;
                this.CoverAngle = coverAngle;
                this.Zone = zone;
                this.ElevationBand = elevationBand;
            }

            public Vector3 WorldPos { get; }

            public bool IsCover { get; }

            public string Tag { get; }

            public float Elevation { get; }

            public bool IsIndoor { get; }

            public bool IsJumpable { get; }

            public float CoverAngle { get; }

            public string Zone { get; }

            public string ElevationBand { get; }
        }

        #endregion
    }
}
