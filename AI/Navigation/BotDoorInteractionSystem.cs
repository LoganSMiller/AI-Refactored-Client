// <auto-generated>
//   AI-Refactored: BotDoorInteractionSystem.cs (Overlay-Only Ultra-Realism, June 2025)
//   Overlay/event-driven only. Never blocks, halts, or issues movement. Squad/anticipation/humanized overlays only.
//   No tick-move, pause, teleport, or disable. Bulletproof, pooled, multiplayer/headless safe. MIT License.
// </auto-generated>

namespace AIRefactored.AI.Navigation
{
    using System;
    using AIRefactored.AI.Core;
    using AIRefactored.Core;
    using BepInEx.Logging;
    using EFT;
    using EFT.Interactive;
    using UnityEngine;

    /// <summary>
    /// Overlay-only: handles door interactions as event/intents.
    /// Never blocks pathfinding or disables bot movement/squad flow.
    /// Bulletproof: event-only overlays, humanized anticipation, squad-safe, error-guarded.
    /// </summary>
    public sealed class BotDoorInteractionSystem
    {
        #region Constants

        private const float DoorRetryCooldown = 2.6f;
        private const float DoorCheckInterval = 0.41f;
        private const float DoorCastRange = 1.85f;
        private const float DoorCastRadius = 0.45f;
        private const float HesitateChance = 0.12f;
        private const float HesitateMinDelay = 0.16f;
        private const float HesitateMaxDelay = 0.53f;
        private const float SquadWaitRadius = 2.1f;
        private const float PanicFastDelay = 0.04f;
        private const float StealthExtraWait = 0.23f;
        private const float RareGiveUpChance = 0.04f;
        private const float MaxStaleDoorTime = 5.0f;
        private const float ClusteredSquadDelay = 0.27f; // extra delay for crowd at doors

        #endregion

        #region Fields

        private readonly BotOwner _bot;
        private readonly ManualLogSource _log;
        private float _lastDoorCheckTime;
        private float _nextRetryTime;
        private float _doorStateSinceTime;
        private Door _currentDoor;
        private float _hesitateUntil;
        private float _giveUpUntil;
        private bool _hasGivenUp;
        private int _squadCrowdCount;

        #endregion

        #region Properties

        /// <summary>
        /// True if a door is currently overlay-blocked (never disables real movement).
        /// </summary>
        public bool IsBlockedByDoor { get; private set; }

        #endregion

        #region Constructor

        public BotDoorInteractionSystem(BotOwner bot)
        {
            if (bot == null)
                throw new ArgumentNullException(nameof(bot), "[BotDoorInteractionSystem] BotOwner was null.");
            _bot = bot;
            _log = Plugin.LoggerInstance;
            Reset();
        }

        #endregion

        #region Public API

        /// <summary>
        /// Called by BotBrain. Overlay/event-driven door intent only (never disables/blocks/tick-pauses).
        /// </summary>
        public void Tick(float time)
        {
            try
            {
                if (_bot == null || _bot.IsDead)
                    return;

                Player player = EFTPlayerUtil.ResolvePlayer(_bot);
                if (!EFTPlayerUtil.IsValid(player) || !player.IsAI || player.CurrentManagedState == null)
                    return;

                if (time < _lastDoorCheckTime + DoorCheckInterval)
                    return;
                _lastDoorCheckTime = time;

                // Overlay give-up period: never disables, just overlays "not now"
                if (_hasGivenUp && time < _giveUpUntil)
                {
                    MarkBlocked(_currentDoor, time);
                    return;
                }
                if (_hasGivenUp && time >= _giveUpUntil)
                    ClearGiveUp();

                // If current door is stale, clear it
                if (_currentDoor != null && time - _doorStateSinceTime > MaxStaleDoorTime)
                    ClearDoorState();

                Vector3 origin = _bot.Position + Vector3.up * 1.18f;
                Vector3 forward = _bot.LookDirection;
                if (!Physics.SphereCast(origin, DoorCastRadius, forward, out RaycastHit hit, DoorCastRange, AIRefactoredLayerMasks.Interactive))
                {
                    ClearDoorState();
                    return;
                }

                Door door = hit.collider?.GetComponentInParent<Door>();
                if (door == null || !door.enabled || !door.Operatable)
                {
                    ClearDoorState();
                    return;
                }

                float doorDist = Vector3.Distance(EFTPlayerUtil.GetPosition(_bot), door.transform.position);
                if (doorDist > DoorCastRange)
                {
                    ClearDoorState();
                    return;
                }

                EDoorState state = door.DoorState;
                if ((state & EDoorState.Open) != 0 || (state & EDoorState.Breaching) != 0)
                {
                    ClearDoorState();
                    return;
                }

                // Door in interaction or bot is waiting for retry or for squad
                if (state == EDoorState.Interacting || time < _nextRetryTime || ShouldWaitForSquad(door, out _squadCrowdCount))
                {
                    // If clustered, overlay a bit more anticipation delay
                    if (_squadCrowdCount > 2 && _hesitateUntil < time)
                        _hesitateUntil = time + ClusteredSquadDelay;
                    MarkBlocked(door, time);
                    return;
                }

                var cache = _bot.GetComponent<BotComponentCache>();
                var profile = cache?.PersonalityProfile;
                float hesitation = 0f;

                // Humanization/anticipation overlays:
                if (cache?.PanicHandler?.IsPanicking == true)
                    hesitation = PanicFastDelay;
                else if (profile != null && (profile.Personality == PersonalityType.Stalker || profile.Caution > 0.7f))
                    hesitation = UnityEngine.Random.Range(HesitateMinDelay, HesitateMaxDelay) + StealthExtraWait;
                else if (_squadCrowdCount > 2)
                    hesitation = ClusteredSquadDelay;
                else if (UnityEngine.Random.value < HesitateChance)
                    hesitation = UnityEngine.Random.Range(HesitateMinDelay, HesitateMaxDelay);

                if (_hesitateUntil < time)
                    _hesitateUntil = time + hesitation;
                if (_hesitateUntil > time)
                {
                    MarkBlocked(door, time);
                    return;
                }

                // Humanized rare give up overlay (never disables/pauses for long)
                if (UnityEngine.Random.value < RareGiveUpChance)
                {
                    _hasGivenUp = true;
                    _giveUpUntil = time + DoorRetryCooldown + UnityEngine.Random.Range(0.4f, 1.8f);
                    MarkBlocked(door, time);
                    return;
                }

                // Do not interact if crouched/prone
                float pose = _bot.GetPlayer?.MovementContext?.PoseLevel ?? 100f;
                if (pose < 40f)
                {
                    MarkBlocked(door, time);
                    return;
                }

                // Overlay-only: Issue door interaction intent. Never disables/blocks/halt.
                try
                {
                    EInteractionType interactionType = GetBestInteractionType(state);
                    player.CurrentManagedState.StartDoorInteraction(door, new InteractionResult(interactionType), null);

                    // Overlay-only: Optionally squad comms/voice overlays for realism (not movement-affecting)
                    if (cache?.GroupComms != null && _squadCrowdCount > 2 && UnityEngine.Random.value < 0.13f)
                        cache.GroupComms.Say(EPhraseTrigger.FollowMe);
                }
                catch (Exception ex)
                {
                    _log.LogError("[BotDoorInteraction] Door interaction failed: " + ex);
                }

                _nextRetryTime = time + DoorRetryCooldown;
                _currentDoor = door;
                _doorStateSinceTime = time;
                IsBlockedByDoor = true;
            }
            catch (Exception ex)
            {
                _log.LogError("[BotDoorInteraction] Tick Exception: " + ex);
                ClearDoorState();
            }
        }

        /// <summary>
        /// Returns true if a door is overlay-blocking at the given position (never disables movement).
        /// </summary>
        public bool IsDoorBlocking(Vector3 position)
        {
            try
            {
                if (_currentDoor == null || !_currentDoor.enabled)
                    return false;
                return Vector3.Distance(_currentDoor.transform.position, position) < DoorCastRange &&
                       (_currentDoor.DoorState & EDoorState.Open) == 0;
            }
            catch { return false; }
        }

        /// <summary>
        /// Reset overlay state (e.g., on raid end or overlay reset).
        /// </summary>
        public void Reset()
        {
            _currentDoor = null;
            IsBlockedByDoor = false;
            _nextRetryTime = 0f;
            _lastDoorCheckTime = 0f;
            _hesitateUntil = 0f;
            _giveUpUntil = 0f;
            _hasGivenUp = false;
            _doorStateSinceTime = 0f;
            _squadCrowdCount = 0;
        }

        #endregion

        #region Internal Helpers

        private void ClearDoorState()
        {
            _currentDoor = null;
            IsBlockedByDoor = false;
            _hesitateUntil = 0f;
            _doorStateSinceTime = 0f;
            _squadCrowdCount = 0;
        }

        private void ClearGiveUp()
        {
            _hasGivenUp = false;
            _giveUpUntil = 0f;
        }

        private void MarkBlocked(Door door, float now)
        {
            if (door == null || Vector3.Distance(EFTPlayerUtil.GetPosition(_bot), door.transform.position) > DoorCastRange)
                return;
            _currentDoor = door;
            IsBlockedByDoor = true;
            _doorStateSinceTime = now;
        }

        /// <summary>
        /// Returns true if the bot should hesitate for squadmates at the door.
        /// Outputs crowd count for overlay logic.
        /// </summary>
        private bool ShouldWaitForSquad(Door door, out int crowdCount)
        {
            crowdCount = 0;
            try
            {
                if (_bot?.BotsGroup == null || _bot.BotsGroup.MembersCount <= 1)
                    return false;
                int nearby = 0;
                for (int i = 0; i < _bot.BotsGroup.MembersCount; i++)
                {
                    var mate = _bot.BotsGroup.Member(i);
                    if (mate == null || mate.IsDead || mate == _bot)
                        continue;
                    if (Vector3.Distance(door.transform.position, mate.Position) < SquadWaitRadius)
                        nearby++;
                }
                crowdCount = nearby;
                // If more than 2 bots crowding the door, wait for better flow
                return nearby > 2;
            }
            catch { crowdCount = 0; return false; }
        }

        private static EInteractionType GetBestInteractionType(EDoorState state)
        {
            if ((state & EDoorState.Shut) != 0 || state == EDoorState.None)
                return EInteractionType.Open;
            if ((state & EDoorState.Open) != 0)
                return EInteractionType.Close;
            return EInteractionType.Open;
        }

        #endregion
    }
}
