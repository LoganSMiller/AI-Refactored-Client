// <auto-generated>
//   AI-Refactored: BotDoorInteractionSystem.cs (Supreme Arbitration Overlay/Event, Ultra-Realism, Beyond Diamond Edition – June 2025)
//   Overlay/event-driven only. Never blocks, halts, or issues movement. Human-like anticipation, squad safety, pooling, and bulletproof null-guarding.
//   Zero tick-move, teleport, pause, or disable. Fully arbitration/event-only, pooled, error-guarded, and multiplayer/headless safe. MIT License.
// </auto-generated>

namespace AIRefactored.AI.Navigation
{
    using System;
    using AIRefactored.AI.Core;
    using AIRefactored.Core;
    using BepInEx.Logging;
    using EFT;
    using EFT.Interactive;
    using UnityEngine;

    /// <summary>
    /// Overlay-only: handles door interactions as event/intents.
    /// Never blocks pathfinding or disables bot movement/squad flow.
    /// Max realism: event-only overlays, squad anticipation, full error containment, zero allocation in hot path.
    /// </summary>
    public sealed class BotDoorInteractionSystem
    {
        #region Constants

        private const float DoorRetryCooldown = 2.5f;          // Time before retry after a failed or paused attempt
        private const float DoorCheckInterval = 0.38f;         // Door scan interval (prevents spam, simulates scan)
        private const float DoorCastRange = 1.92f;             // Max interact range (as in EFT, slightly expanded for jitter)
        private const float DoorCastRadius = 0.44f;            // Sphere radius for door raycast
        private const float HesitateChance = 0.10f;            // Random chance for human-like hesitation
        private const float HesitateMinDelay = 0.17f;          // Min hesitation overlay (humanized delay)
        private const float HesitateMaxDelay = 0.48f;          // Max hesitation overlay
        private const float SquadWaitRadius = 2.24f;           // Range to count squadmates as "at the door"
        private const float PanicFastDelay = 0.035f;           // If panicking, tiny hesitation (adrenaline logic)
        private const float StealthExtraWait = 0.23f;          // Extra wait for high-caution or stealth bots
        private const float RareGiveUpChance = 0.035f;         // Bots occasionally "give up" briefly on stuck doors
        private const float MaxStaleDoorTime = 4.8f;           // Max seconds to keep a stale door as current
        private const float ClusteredSquadDelay = 0.28f;       // Extra delay when more than 2 squad at door
        private const float DoorLOSAngle = 68f;                // Field of view angle for door interaction (cone check)
        private const float DoorUnblockDist = 0.41f;           // If bot is pushed past this, clear blocked state

        #endregion

        #region Fields

        private readonly BotOwner _bot;
        private readonly ManualLogSource _log;
        private float _lastDoorCheckTime;
        private float _nextRetryTime;
        private float _doorStateSinceTime;
        private Door _currentDoor;
        private float _hesitateUntil;
        private float _giveUpUntil;
        private bool _hasGivenUp;
        private int _squadCrowdCount;

        #endregion

        #region Properties

        /// <summary>
        /// True if a door is currently overlay-blocked (never disables real movement).
        /// </summary>
        public bool IsBlockedByDoor { get; private set; }

        /// <summary>
        /// The currently tracked door, if any (null if none in interaction range).
        /// </summary>
        public Door CurrentDoor => _currentDoor;

        #endregion

        #region Constructor

        public BotDoorInteractionSystem(BotOwner bot)
        {
            if (bot == null)
                throw new ArgumentNullException(nameof(bot), "[BotDoorInteractionSystem] BotOwner was null.");
            _bot = bot;
            _log = Plugin.LoggerInstance;
            Reset();
        }

        #endregion

        #region Public API

        /// <summary>
        /// Called by BotBrain as overlay/event intent only (never disables/blocks/tick-pauses).
        /// </summary>
        public void Tick(float now)
        {
            try
            {
                if (_bot == null || _bot.IsDead)
                    return;

                Player player = EFTPlayerUtil.ResolvePlayer(_bot);
                if (!EFTPlayerUtil.IsValid(player) || !player.IsAI || player.CurrentManagedState == null)
                    return;

                // Arbitration: Only event/overlay-driven, never tick-move or parallel
                if (now < _lastDoorCheckTime + DoorCheckInterval)
                    return;
                _lastDoorCheckTime = now;

                // Give-up overlay (never disables, just "overlays" not now)
                if (_hasGivenUp && now < _giveUpUntil)
                {
                    MarkBlocked(_currentDoor, now);
                    return;
                }
                if (_hasGivenUp && now >= _giveUpUntil)
                    ClearGiveUp();

                // Clear stale/trapped doors
                if (_currentDoor != null && now - _doorStateSinceTime > MaxStaleDoorTime)
                    ClearDoorState();

                // Raycast cone (FOV) check for more human realism
                Vector3 origin = _bot.Position + Vector3.up * 1.15f;
                Vector3 forward = _bot.LookDirection.normalized;
                if (!Physics.SphereCast(origin, DoorCastRadius, forward, out RaycastHit hit, DoorCastRange, AIRefactoredLayerMasks.Interactive))
                {
                    ClearDoorState();
                    return;
                }

                Door door = hit.collider?.GetComponentInParent<Door>();
                if (door == null || !door.enabled || !door.Operatable)
                {
                    ClearDoorState();
                    return;
                }

                // LOS: Must be "facing" the door (simulate player cone, no wall-pierce)
                Vector3 toDoor = (door.transform.position - origin).normalized;
                if (Vector3.Angle(forward, toDoor) > DoorLOSAngle)
                {
                    ClearDoorState();
                    return;
                }

                float doorDist = Vector3.Distance(EFTPlayerUtil.GetPosition(_bot), door.transform.position);
                if (doorDist > DoorCastRange)
                {
                    ClearDoorState();
                    return;
                }

                EDoorState state = door.DoorState;
                if ((state & EDoorState.Open) != 0 || (state & EDoorState.Breaching) != 0)
                {
                    ClearDoorState();
                    return;
                }

                // Door in interaction, retry lockout, or squad wait overlays
                if (state == EDoorState.Interacting || now < _nextRetryTime || ShouldWaitForSquad(door, out _squadCrowdCount))
                {
                    if (_squadCrowdCount > 2 && _hesitateUntil < now)
                        _hesitateUntil = now + ClusteredSquadDelay;
                    MarkBlocked(door, now);
                    return;
                }

                var cache = _bot.GetComponent<BotComponentCache>();
                var profile = cache?.PersonalityProfile;
                float hesitation = 0f;

                // Realistic overlays: panic/stealth/personality/squad/jitter
                if (cache?.PanicHandler?.IsPanicking == true)
                    hesitation = PanicFastDelay;
                else if (profile != null && (profile.Personality == PersonalityType.Stalker || profile.Caution > 0.72f))
                    hesitation = UnityEngine.Random.Range(HesitateMinDelay, HesitateMaxDelay) + StealthExtraWait;
                else if (_squadCrowdCount > 2)
                    hesitation = ClusteredSquadDelay;
                else if (UnityEngine.Random.value < HesitateChance)
                    hesitation = UnityEngine.Random.Range(HesitateMinDelay, HesitateMaxDelay);

                // Overlay hesitate/anticipation (never disables real logic, overlays event only)
                if (_hesitateUntil < now)
                    _hesitateUntil = now + hesitation;
                if (_hesitateUntil > now)
                {
                    MarkBlocked(door, now);
                    return;
                }

                // Rare human-like give up (brief random cooldown, never disables)
                if (UnityEngine.Random.value < RareGiveUpChance)
                {
                    _hasGivenUp = true;
                    _giveUpUntil = now + DoorRetryCooldown + UnityEngine.Random.Range(0.35f, 1.8f);
                    MarkBlocked(door, now);
                    return;
                }

                // Real player can't open door crouched/prone (simulate)
                float pose = _bot.GetPlayer?.MovementContext?.PoseLevel ?? 100f;
                if (pose < 40f)
                {
                    MarkBlocked(door, now);
                    return;
                }

                // Max realism: check for teammate right in the doorway (avoid overlap/insta-open)
                if (_squadCrowdCount > 0 && IsSquadBlockingDoor(door))
                {
                    _hesitateUntil = now + UnityEngine.Random.Range(0.15f, 0.41f);
                    MarkBlocked(door, now);
                    return;
                }

                // Ultra-realism: only interact if not already interacting, not paused, not blocked
                if (player.CurrentManagedState is DoorInteractionStateClass)
                {
                    MarkBlocked(door, now);
                    return;
                }

                // Overlay-only: Issue door interaction intent. Event-only, never disables or pauses.
                try
                {
                    EInteractionType interactionType = GetBestInteractionType(state);
                    player.CurrentManagedState.StartDoorInteraction(door, new InteractionResult(interactionType), null);

                    // Realistic: squad comms overlay (cover me/follow me/going in) if crowded
                    if (cache?.GroupComms != null && _squadCrowdCount > 2 && UnityEngine.Random.value < 0.17f)
                        cache.GroupComms.Say(EPhraseTrigger.FollowMe);
                }
                catch (Exception ex)
                {
                    _log.LogError("[BotDoorInteraction] Door interaction failed: " + ex);
                }

                _nextRetryTime = now + DoorRetryCooldown;
                _currentDoor = door;
                _doorStateSinceTime = now;
                IsBlockedByDoor = true;
            }
            catch (Exception ex)
            {
                _log.LogError("[BotDoorInteraction] Tick Exception: " + ex);
                ClearDoorState();
            }
        }

        /// <summary>
        /// Returns true if a door is overlay-blocking at the given position (never disables movement).
        /// </summary>
        public bool IsDoorBlocking(Vector3 position)
        {
            try
            {
                if (_currentDoor == null || !_currentDoor.enabled)
                    return false;
                return Vector3.Distance(_currentDoor.transform.position, position) < DoorCastRange &&
                       (_currentDoor.DoorState & EDoorState.Open) == 0;
            }
            catch { return false; }
        }

        /// <summary>
        /// Reset overlay state (e.g., on raid end or overlay reset).
        /// </summary>
        public void Reset()
        {
            _currentDoor = null;
            IsBlockedByDoor = false;
            _nextRetryTime = 0f;
            _lastDoorCheckTime = 0f;
            _hesitateUntil = 0f;
            _giveUpUntil = 0f;
            _hasGivenUp = false;
            _doorStateSinceTime = 0f;
            _squadCrowdCount = 0;
        }

        #endregion

        #region Internal Helpers

        private void ClearDoorState()
        {
            _currentDoor = null;
            IsBlockedByDoor = false;
            _hesitateUntil = 0f;
            _doorStateSinceTime = 0f;
            _squadCrowdCount = 0;
        }

        private void ClearGiveUp()
        {
            _hasGivenUp = false;
            _giveUpUntil = 0f;
        }

        private void MarkBlocked(Door door, float now)
        {
            if (door == null || Vector3.Distance(EFTPlayerUtil.GetPosition(_bot), door.transform.position) > DoorCastRange)
                return;
            _currentDoor = door;
            IsBlockedByDoor = true;
            _doorStateSinceTime = now;
        }

        /// <summary>
        /// Returns true if the bot should hesitate for squadmates at the door.
        /// Outputs crowd count for overlay logic.
        /// </summary>
        private bool ShouldWaitForSquad(Door door, out int crowdCount)
        {
            crowdCount = 0;
            try
            {
                if (_bot?.BotsGroup == null || _bot.BotsGroup.MembersCount <= 1)
                    return false;
                int nearby = 0;
                for (int i = 0; i < _bot.BotsGroup.MembersCount; i++)
                {
                    var mate = _bot.BotsGroup.Member(i);
                    if (mate == null || mate.IsDead || mate == _bot)
                        continue;
                    // Count squad within radius and roughly facing door
                    Vector3 dir = (door.transform.position - mate.Position).normalized;
                    if (Vector3.Distance(door.transform.position, mate.Position) < SquadWaitRadius &&
                        Vector3.Dot(mate.LookDirection.normalized, dir) > 0.54f)
                        nearby++;
                }
                crowdCount = nearby;
                return nearby > 2;
            }
            catch { crowdCount = 0; return false; }
        }

        /// <summary>
        /// Returns true if any squadmate is blocking the door itself (ultra-anti-collision realism).
        /// </summary>
        private bool IsSquadBlockingDoor(Door door)
        {
            try
            {
                if (_bot?.BotsGroup == null || _bot.BotsGroup.MembersCount <= 1)
                    return false;
                for (int i = 0; i < _bot.BotsGroup.MembersCount; i++)
                {
                    var mate = _bot.BotsGroup.Member(i);
                    if (mate == null || mate.IsDead || mate == _bot)
                        continue;
                    if (Vector3.Distance(door.transform.position, mate.Position) < DoorUnblockDist)
                        return true;
                }
            }
            catch { }
            return false;
        }

        private static EInteractionType GetBestInteractionType(EDoorState state)
        {
            // Maximally accurate: only open if shut, only close if open, never do nothing.
            if ((state & EDoorState.Shut) != 0 || state == EDoorState.None)
                return EInteractionType.Open;
            if ((state & EDoorState.Open) != 0)
                return EInteractionType.Close;
            return EInteractionType.Open;
        }

        #endregion
    }
}
