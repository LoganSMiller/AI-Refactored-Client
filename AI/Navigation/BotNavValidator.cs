// <auto-generated>
//   This file is part of AI-Refactored, an open-source project focused on realistic AI behavior in Escape from Tarkov.
//   Licensed under the MIT License. See LICENSE in the repository root for more information.
//
//   THIS FILE IS SYSTEMATICALLY MANAGED.
//   Please follow strict StyleCop, ReSharper, and AI-Refactored code standards for all modifications.
// </auto-generated>

namespace AIRefactored.AI.Navigation
{
    using AIRefactored.Core;
    using AIRefactored.Runtime;
    using BepInEx.Logging;
    using Comfort.Common;
    using EFT;
    using UnityEngine;

    /// <summary>
    /// Validates bot navigation state at runtime. If nav data is invalid or missing,
    /// attempts fallback assignment or safely aborts further pathing logic.
    /// </summary>
    public static class BotNavValidator
    {
        #region Fields

        private static readonly ManualLogSource Logger = Plugin.LoggerInstance;

        #endregion

        #region Public API

        /// <summary>
        /// Validates whether the bot has valid nav system backing and positioning.
        /// If not, attempts fallback assignment or returns false.
        /// </summary>
        /// <param name="botOwner">The BotOwner to validate.</param>
        /// <param name="context">Calling context for debug logging.</param>
        /// <returns>True if valid nav state exists and fallback is not required, otherwise false.</returns>
        public static bool Validate(BotOwner botOwner, string context)
        {
            if (botOwner == null)
            {
                Logger.LogWarning("[BotNavValidator] ❌ Null BotOwner in context: " + context);
                return false;
            }

            if (botOwner.Transform == null || botOwner.GetPlayer == null || botOwner.IsDead)
            {
                Logger.LogWarning("[BotNavValidator] ❌ Invalid bot state — dead or missing transform — context: " + context);
                return false;
            }

            Vector3 position = botOwner.Position;
            if (!IsValidPosition(position))
            {
                Logger.LogWarning("[BotNavValidator] ❌ Bot has invalid position (zero or NaN) — context: " + context);
                return false;
            }

            // If registry isn't ready, still try to assign nearest fallback point
            if (!NavPointRegistry.IsReady)
            {
                Logger.LogWarning("[BotNavValidator] ⚠ NavPointRegistry not ready — bot: " + GetBotName(botOwner) + ", context: " + context);

                Vector3 fallback = NavPointRegistry.GetClosestPosition(position);
                if (IsValidPosition(fallback) && botOwner.Mover != null && !botOwner.Mover.IsMoving)
                {
                    botOwner.Mover.GoToPoint(
                        fallback,
                        slowAtTheEnd: true,
                        reachDist: 1.0f,
                        getUpWithCheck: false,
                        mustHaveWay: true,
                        onlyShortTrie: false,
                        force: true);

                    Logger.LogWarning("[BotNavValidator] ✅ Closest-point fallback assigned due to unready registry — position: " + fallback.ToString("F1"));
                    return true;
                }

                return false;
            }

            // Registry is ready — use normal nav point logic
            Vector3 closest = NavPointRegistry.GetClosestPosition(position);
            if (!IsValidPosition(closest))
            {
                Logger.LogWarning("[BotNavValidator] ❌ Closest nav point fallback is invalid — bot: " + GetBotName(botOwner) + ", context: " + context);
                return false;
            }

            if (botOwner.Mover != null && !botOwner.Mover.IsMoving)
            {
                botOwner.Mover.GoToPoint(
                    closest,
                    slowAtTheEnd: true,
                    reachDist: 1.0f,
                    getUpWithCheck: false,
                    mustHaveWay: true,
                    onlyShortTrie: false,
                    force: true);

                Logger.LogDebug("[BotNavValidator] ✅ Assigned closest nav point as fallback for bot: " + GetBotName(botOwner));
            }

            return true;
        }

        #endregion

        #region Helpers

        private static bool IsValidPosition(Vector3 position)
        {
            return position != Vector3.zero &&
                   !float.IsNaN(position.x) &&
                   !float.IsNaN(position.y) &&
                   !float.IsNaN(position.z);
        }

        private static string GetBotName(BotOwner botOwner)
        {
            if (botOwner.Profile != null &&
                botOwner.Profile.Info != null &&
                !string.IsNullOrEmpty(botOwner.Profile.Info.Nickname))
            {
                return botOwner.Profile.Info.Nickname;
            }

            return "Unnamed";
        }

        #endregion
    }
}
