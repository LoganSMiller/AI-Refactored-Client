// <auto-generated>
//   Part of AI-Refactored: Realistic AI for Escape from Tarkov.
//   SYSTEMATICALLY MANAGED: Strictly uses EFT internal navigation. No custom nav fallback.
//   All movement/tactical queries rely only on PathControllerClass and BotMover.
//   Bulletproof: All null/invalid states handled locally. No fallback. No vanilla AI handoff.
// </auto-generated>

namespace AIRefactored.AI.Navigation
{
    using EFT;
    using UnityEngine;
    using BepInEx.Logging;

    /// <summary>
    /// Canonical wrapper for all AIRefactored navigation queries.
    /// Strictly uses EFT's internal navigation: BotMover and PathControllerClass.
    /// All failures are locally isolated; never triggers fallback or vanilla handoff.
    /// </summary>
    public static class BotNavHelper
    {
        private static readonly ManualLogSource Logger = Plugin.LoggerInstance;

        /// <summary>
        /// Attempts to resolve the next safe movement target using EFT's internal path system.
        /// Returns true if a valid target point is available.
        /// </summary>
        public static bool TryGetSafeTarget(BotOwner bot, out Vector3 target)
        {
            target = Vector3.zero;
            if (!HasPath(bot))
                return false;

            Vector3 pt = Vector3.zero;
            try { pt = bot.Mover._pathController.LastTargetPoint(1.0f); } catch { }
            if (!IsValid(pt) || pt.y < -2.5f)
                return false;

            target = pt;
            return true;
        }

        /// <summary>
        /// Gets the current EFT path waypoints as a Vector3 array (null if unavailable).
        /// Ensures every point is valid and not far out of world bounds.
        /// </summary>
        public static Vector3[] GetCurrentPathPoints(BotOwner bot, int maxPoints = 16)
        {
            if (!HasPath(bot))
                return null;

            Vector3[] points = null;
            try { points = bot.Mover._pathController.GetWayPoints(maxPoints); }
            catch { return null; }

            if (points == null || points.Length == 0)
                return null;

            for (int i = 0; i < points.Length; i++)
            {
                if (!IsValid(points[i]) || points[i].y < -2.5f)
                    return null;
            }

            return points;
        }

        /// <summary>
        /// Gets the current "corner" (next turn) on the active path, if available.
        /// Adds micro-random jitter for realism. Zero vector if unavailable.
        /// </summary>
        public static bool TryGetCurrentCorner(BotOwner bot, out Vector3 corner)
        {
            corner = Vector3.zero;
            if (!HasPath(bot))
                return false;

            Vector3 c = Vector3.zero;
            try { c = bot.Mover.CurrentCornerPoint; }
            catch { return false; }

            if (!IsValid(c) || c.y < -2.5f)
                return false;

            float jitter = 0.048f;
            corner = c + new Vector3(
                UnityEngine.Random.Range(-jitter, jitter),
                0f,
                UnityEngine.Random.Range(-jitter, jitter)
            );
            return true;
        }

        /// <summary>
        /// Gets the remaining distance to the destination, or float.MaxValue if unavailable.
        /// Always clamps result to [0, 9999].
        /// </summary>
        public static float GetRemainingDistance(BotOwner bot)
        {
            try
            {
                return HasPath(bot)
                    ? Mathf.Clamp(bot.Mover.DistDestination, 0f, 9999f)
                    : float.MaxValue;
            }
            catch { return float.MaxValue; }
        }

        /// <summary>
        /// Returns true if a given point is on the bot's current path within maxDist.
        /// </summary>
        public static bool IsPointOnCurrentPath(BotOwner bot, Vector3 point, float maxDist)
        {
            return HasPath(bot) && bot.Mover.IsPointOnCurrentWay(point, maxDist);
        }

        /// <summary>
        /// Returns true if the bot has a valid path controller with an active path.
        /// </summary>
        public static bool HasPath(BotOwner bot)
        {
            return bot?.Mover != null && IsPathValid(bot.Mover._pathController);
        }

        /// <summary>
        /// Returns the currently requested destination if available and valid, else Vector3.zero.
        /// Handles nullable TargetPoint.
        /// </summary>
        public static Vector3 GetCurrentDestination(BotOwner bot)
        {
            if (!HasPath(bot))
                return Vector3.zero;
            try
            {
                var tp = bot.Mover.TargetPoint;
                Vector3 dest = tp.HasValue ? tp.Value : Vector3.zero;
                if (!IsValid(dest) || dest.y < -2.5f)
                    return Vector3.zero;
                return dest;
            }
            catch { return Vector3.zero; }
        }

        /// <summary>
        /// Gets the current navigation state (path valid, at goal, path blocked).
        /// Blocked state is taken from BotMover.Blocked property.
        /// </summary>
        public static BotNavState GetNavState(BotOwner bot)
        {
            if (bot == null || bot.Mover == null)
                return BotNavState.Invalid;
            var pc = bot.Mover._pathController;
            if (!IsPathValid(pc))
                return BotNavState.NoPath;
            if (IsAtDestination(bot))
                return BotNavState.AtGoal;
            if (bot.Mover.Blocked)
                return BotNavState.Blocked;
            return BotNavState.Active;
        }

        /// <summary>
        /// Returns true if the bot is very close to the path end/destination (within 1.05m).
        /// </summary>
        public static bool IsAtDestination(BotOwner bot)
        {
            if (!HasPath(bot))
                return false;
            Vector3 dest = GetCurrentDestination(bot);
            return dest != Vector3.zero && Vector3.Distance(bot.Position, dest) < 1.05f;
        }

        /// <summary>
        /// Returns a formation/spacing-aware group target for squad follow logic.
        /// - If leader is not valid, fallback to bot's current position.
        /// - Spacing: Ensures bots don't clump, stays behind/in offset to leader.
        /// - Weight: 0=stay at bot, 1=fully at leader+offset.
        /// </summary>
        public static Vector3 GetGroupFormationTarget(BotOwner self, BotOwner leader, float weight, float spacing)
        {
            if (self == null || leader == null)
                return Vector3.zero;

            Vector3 myPos = self.Position;
            Vector3 leaderPos = leader.Position;

            // Basic direction for offset
            Vector3 dir = (myPos - leaderPos).normalized;
            if (dir == Vector3.zero)
                dir = Random.onUnitSphere; // fallback for perfect overlap

            // Stagger spacing to prevent overlapping exactly
            float stagger = spacing * (1.0f + UnityEngine.Random.Range(-0.25f, 0.25f));
            Vector3 offset = dir * stagger;

            // Formation blend
            Vector3 formationTarget = Vector3.Lerp(myPos, leaderPos + offset, Mathf.Clamp01(weight));

            // Navmesh validation can be added if required by gameplay
            return formationTarget;
        }

        #region Internal Helpers

        /// <summary>
        /// Returns true if the given PathControllerClass instance is valid and has an active path.
        /// </summary>
        private static bool IsPathValid(PathControllerClass pathController)
        {
            return pathController != null &&
                   pathController.HavePath &&
                   pathController.CurPath != null &&
                   pathController.CurPath.Length > 0;
        }

        /// <summary>
        /// Returns true if the provided Vector3 is a valid, non-NaN, non-infinite, in-bounds point.
        /// </summary>
        private static bool IsValid(Vector3 pt)
        {
            return !float.IsNaN(pt.x) && !float.IsNaN(pt.y) && !float.IsNaN(pt.z) &&
                   !float.IsInfinity(pt.x) && !float.IsInfinity(pt.y) && !float.IsInfinity(pt.z) &&
                   Mathf.Abs(pt.x) < 10000f && Mathf.Abs(pt.y) < 10000f && Mathf.Abs(pt.z) < 10000f;
        }

        #endregion

        #region Nav State Enum

        /// <summary>
        /// Enumerates nav/path states for robust flow handling.
        /// </summary>
        public enum BotNavState
        {
            Invalid,
            NoPath,
            Active,
            Blocked,
            AtGoal
        }

        #endregion
    }
}
