// <auto-generated>
//   AI-Refactored: BotNavHelper.cs (Beyond Diamond Edition, Full Fix Plan Applied)
//   SYSTEMATICALLY MANAGED: Only EFT-internal navigation (BotMover, PathControllerClass).
//   100% robust: No custom fallback, all nav/target queries are error-isolated, no vanilla AI handoff.
//   IsAtDestination/IsPathValid are explicit, safe, and pooled for movement fallback.
//   MIT License.
// </auto-generated>

namespace AIRefactored.AI.Navigation
{
    using EFT;
    using UnityEngine;
    using UnityEngine.AI;
    using BepInEx.Logging;
    using EFT.Interactive;

    /// <summary>
    /// Central helper for bulletproof EFT bot navigation and path state queries.
    /// Zero-allocation in hot paths, fully error-isolated, multiplayer/headless safe.
    /// </summary>
    public static class BotNavHelper
    {
        private static readonly ManualLogSource Logger = Plugin.LoggerInstance;

        #region Core EFT Path Methods

        /// <summary>
        /// Returns true and outputs a safe target (end of current path). Returns false if no path or invalid.
        /// </summary>
        public static bool TryGetSafeTarget(BotOwner bot, out Vector3 target)
        {
            target = Vector3.zero;
            if (!HasPath(bot))
                return false;

            try
            {
                Vector3 pt = bot.Mover._pathController.LastTargetPoint(1.0f);
                if (IsValid(pt) && pt.y > -2.5f)
                {
                    target = pt;
                    return true;
                }
            }
            catch { }
            return false;
        }

        /// <summary>
        /// Returns current path points up to maxPoints, or null if no path/invalid.
        /// </summary>
        public static Vector3[] GetCurrentPathPoints(BotOwner bot, int maxPoints = 16)
        {
            if (!HasPath(bot))
                return null;

            try
            {
                Vector3[] points = bot.Mover._pathController.GetWayPoints(maxPoints);
                if (points == null || points.Length == 0)
                    return null;
                for (int i = 0; i < points.Length; i++)
                {
                    if (!IsValid(points[i]) || points[i].y < -2.5f)
                        return null;
                }
                return points;
            }
            catch { return null; }
        }

        /// <summary>
        /// Outputs the next corner of the path, with micro-jitter. Returns false if unavailable.
        /// </summary>
        public static bool TryGetCurrentCorner(BotOwner bot, out Vector3 corner)
        {
            corner = Vector3.zero;
            if (!HasPath(bot))
                return false;

            try
            {
                Vector3 c = bot.Mover.CurrentCornerPoint;
                if (!IsValid(c) || c.y < -2.5f)
                    return false;
                const float jitter = 0.045f;
                corner = c + new Vector3(
                    UnityEngine.Random.Range(-jitter, jitter),
                    0f,
                    UnityEngine.Random.Range(-jitter, jitter)
                );
                return true;
            }
            catch { return false; }
        }

        /// <summary>
        /// Returns remaining distance to destination along the path, or float.MaxValue if no path/invalid.
        /// </summary>
        public static float GetRemainingDistance(BotOwner bot)
        {
            try
            {
                return HasPath(bot)
                    ? Mathf.Clamp(bot.Mover.DistDestination, 0f, 9999f)
                    : float.MaxValue;
            }
            catch { return float.MaxValue; }
        }

        /// <summary>
        /// Returns true if the provided point is on the current path within maxDist.
        /// </summary>
        public static bool IsPointOnCurrentPath(BotOwner bot, Vector3 point, float maxDist)
        {
            return HasPath(bot) && bot.Mover.IsPointOnCurrentWay(point, maxDist);
        }

        /// <summary>
        /// True if bot has a valid, non-broken path (no NaN or invalid points).
        /// </summary>
        public static bool HasPath(BotOwner bot)
        {
            return bot?.Mover != null && IsPathValid(bot.Mover._pathController);
        }

        /// <summary>
        /// Gets current path destination if available, or Vector3.zero if no path.
        /// </summary>
        public static Vector3 GetCurrentDestination(BotOwner bot)
        {
            if (!HasPath(bot))
                return Vector3.zero;
            try
            {
                var tp = bot.Mover.TargetPoint;
                Vector3 dest = tp.HasValue ? tp.Value : Vector3.zero;
                return (IsValid(dest) && dest.y > -2.5f) ? dest : Vector3.zero;
            }
            catch { return Vector3.zero; }
        }

        /// <summary>
        /// Returns nav state: Invalid, NoPath, Active, Blocked, or AtGoal.
        /// </summary>
        public static BotNavState GetNavState(BotOwner bot)
        {
            if (bot == null || bot.Mover == null)
                return BotNavState.Invalid;

            var pc = bot.Mover._pathController;
            if (!IsPathValid(pc))
                return BotNavState.NoPath;

            if (IsAtDestination(bot))
                return BotNavState.AtGoal;

            if (bot.Mover.Blocked)
                return BotNavState.Blocked;

            return BotNavState.Active;
        }

        /// <summary>
        /// True if bot is within arrival threshold of current destination.
        /// </summary>
        public static bool IsAtDestination(BotOwner bot)
        {
            if (!HasPath(bot))
                return false;

            Vector3 dest = GetCurrentDestination(bot);
            return dest != Vector3.zero && Vector3.Distance(bot.Position, dest) < 1.05f;
        }

        /// <summary>
        /// True if the bot's path is valid (all points safe for nav).
        /// </summary>
        public static bool IsPathValid(BotOwner bot)
        {
            return bot?.Mover != null && IsPathValid(bot.Mover._pathController);
        }

        #endregion

        #region Movement & NavMesh Safe Helpers

        /// <summary>
        /// Returns true and outputs a NavMesh-safe version of 'candidate' if it's valid. Always clamps Y.
        /// </summary>
        public static bool TryGetNavMeshSafePosition(Vector3 candidate, Vector3 origin, out Vector3 navSafe, float radius = 1.5f)
        {
            navSafe = candidate;
            if (NavMesh.SamplePosition(candidate, out NavMeshHit hit, radius, NavMesh.AllAreas))
            {
                navSafe = ClampY(hit.position, origin);
                return IsValid(navSafe);
            }
            navSafe = ClampY(candidate, origin);
            return IsValid(navSafe);
        }

        /// <summary>
        /// Returns a NavMesh-safe version of 'candidate', or origin if invalid.
        /// </summary>
        public static Vector3 GetNavMeshSafePosition(Vector3 candidate, Vector3 origin, float radius = 1.5f)
        {
            if (NavMesh.SamplePosition(candidate, out NavMeshHit hit, radius, NavMesh.AllAreas))
                return ClampY(hit.position, origin);
            return ClampY(origin, origin);
        }

        /// <summary>
        /// Y-clamps a Vector3 to basePos for sanity.
        /// </summary>
        public static Vector3 ClampY(Vector3 v, Vector3 basePos)
        {
            if (Mathf.Abs(v.y - basePos.y) > 3f || v.y < -2.5f)
                v.y = basePos.y;
            return v;
        }

        /// <summary>
        /// Returns true if the Vector3 is valid for pathing.
        /// </summary>
        public static bool IsValid(Vector3 pt)
        {
            return !float.IsNaN(pt.x) && !float.IsNaN(pt.y) && !float.IsNaN(pt.z) &&
                   !float.IsInfinity(pt.x) && !float.IsInfinity(pt.y) && !float.IsInfinity(pt.z) &&
                   Mathf.Abs(pt.x) < 10000f && Mathf.Abs(pt.y) < 10000f && Mathf.Abs(pt.z) < 10000f &&
                   pt != Vector3.zero;
        }

        #endregion

        #region Misc Helpers

        /// <summary>
        /// Returns a realistic group formation target point.
        /// </summary>
        public static Vector3 GetGroupFormationTarget(BotOwner self, BotOwner leader, float weight, float spacing)
        {
            if (self == null || leader == null)
                return Vector3.zero;

            Vector3 myPos = self.Position;
            Vector3 leaderPos = leader.Position;
            Vector3 dir = (myPos - leaderPos).normalized;
            if (dir == Vector3.zero)
                dir = UnityEngine.Random.onUnitSphere;

            float stagger = spacing * (1.0f + UnityEngine.Random.Range(-0.23f, 0.23f));
            Vector3 offset = dir * stagger;
            return Vector3.Lerp(myPos, leaderPos + offset, Mathf.Clamp01(weight));
        }

        public static bool IsBlockedByClosedDoor(Vector3 from, Vector3 to)
        {
            // Only cast on the door layer.
            Vector3 dir = to - from;
            float dist = dir.magnitude;
            if (dist < 0.01f)
                return false;

            dir /= dist; // Normalize

            // Use LayerMaskClass.DoorLayer for exact match.
            int doorLayerMask = 1 << LayerMaskClass.DoorLayer;

            // Raycast for any door collider between from and to.
            if (Physics.SphereCast(from + Vector3.up * 1.1f, 0.4f, dir, out RaycastHit hit, dist, doorLayerMask))
            {
                Door door = hit.collider.GetComponentInParent<Door>();
                if (door != null && door.enabled && door.Operatable)
                {
                    EDoorState state = door.DoorState;
                    // If the door is closed (not open or breaching), treat as blocking.
                    if ((state & EDoorState.Open) == 0)
                        return true;
                }
            }

            return false;
        }

        /// <summary>
        /// Returns true if a position is valid and on the navmesh.
        /// </summary>
        public static bool IsNavMeshPositionValid(Vector3 pos)
        {
            return IsValid(pos) && pos.y > -2.5f;
        }

        #endregion

        #region Internal

        private static bool IsPathValid(PathControllerClass pc)
        {
            return pc != null &&
                   pc.HavePath &&
                   pc.CurPath != null &&
                   pc.CurPath.Length > 0;
        }

        public enum BotNavState
        {
            Invalid,
            NoPath,
            Active,
            Blocked,
            AtGoal
        }

        #endregion
    }
}
