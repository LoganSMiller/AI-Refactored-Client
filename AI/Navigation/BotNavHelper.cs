// <auto-generated>
//   AI-Refactored: BotNavHelper.cs (Supreme Overlay/Event-Only, Infinite-Introspective, Ultra-Realism, Squad+Group, June 2025)
//   Overlay/event-only: exposes all EFT-internal nav/path/squad/environment state for overlays/intents, anti-stuck, fallback, and planning systems.
//   All logic is zero-alloc in hot paths, ultra-pooled, anti-NaN/Inf, multiplayer/headless/Squad parity, and futureproof. MIT License.
// </auto-generated>

namespace AIRefactored.AI.Navigation
{
    using EFT;
    using UnityEngine;
    using UnityEngine.AI;
    using BepInEx.Logging;
    using EFT.Interactive;
    using AIRefactored.Pools;
    using AIRefactored.Core;
    using System.Collections.Generic;

    /// <summary>
    /// Overlay/event-only: exposes all navigation, squad, formation, path, and environmental meta-state for overlays/intents and planners.
    /// Never issues movement. Bulletproof, pooled, squad-aware, anti-alloc, multiplayer/headless safe. Expansion-ready for all AIRefactored overlays.
    /// </summary>
    public static class BotNavHelper
    {
        private static readonly ManualLogSource Logger = Plugin.LoggerInstance;

        #region Path/Navigation Introspection

        public static bool HasPath(BotOwner bot)
        {
            var mover = bot?.Mover;
            var pc = mover?._pathController;
            return mover != null && IsPathValid(pc);
        }

        private static bool IsPathValid(object pc)
        {
            if (pc == null) return false;
            var curPathProp = pc.GetType().GetProperty("CurPath");
            var havePathProp = pc.GetType().GetProperty("HavePath");
            if (curPathProp == null || havePathProp == null) return false;
            var curPath = curPathProp.GetValue(pc) as System.Array;
            bool havePath = (bool)havePathProp.GetValue(pc);
            return havePath && curPath != null && curPath.Length > 0;
        }

        /// <summary>
        /// Returns pooled list of path points (never returns null, must TempListPool.Return after use).
        /// </summary>
        public static List<Vector3> GetCurrentPathPoints(BotOwner bot, int maxPoints = 16)
        {
            var tempList = TempListPool.Rent<Vector3>(maxPoints);
            if (!HasPath(bot)) return tempList;
            try
            {
                var pc = bot.Mover?._pathController;
                if (pc == null) return tempList;
                Vector3[] pts = pc.GetWayPoints(maxPoints);
                if (pts == null || pts.Length == 0) return tempList;
                for (int i = 0; i < pts.Length; i++)
                    if (IsValid(pts[i]))
                        tempList.Add(pts[i]);
            }
            catch { }
            return tempList;
        }

        public static bool TryGetSafeTarget(BotOwner bot, out Vector3 target)
        {
            target = Vector3.zero;
            if (!HasPath(bot)) return false;
            try
            {
                var pc = bot.Mover?._pathController;
                if (pc == null) return false;
                Vector3 pt = pc.LastTargetPoint(1.0f);
                if (IsValid(pt) && pt.y > -2.5f)
                {
                    target = pt;
                    return true;
                }
            }
            catch { }
            return false;
        }

        public static bool TryGetCurrentCorner(BotOwner bot, out Vector3 corner, bool jitter = true)
        {
            corner = Vector3.zero;
            if (!HasPath(bot)) return false;
            try
            {
                Vector3 c = bot.Mover.CurrentCornerPoint;
                if (!IsValid(c) || c.y < -2.5f) return false;
                if (jitter)
                {
                    const float j = 0.048f;
                    corner = c + new Vector3(
                        UnityEngine.Random.Range(-j, j),
                        0f,
                        UnityEngine.Random.Range(-j, j)
                    );
                }
                else corner = c;
                return true;
            }
            catch { return false; }
        }

        public static Vector3 GetCurrentDestination(BotOwner bot)
        {
            if (!HasPath(bot)) return Vector3.zero;
            try
            {
                var tp = bot.Mover.TargetPoint;
                Vector3 dest = tp.HasValue ? tp.Value : Vector3.zero;
                return (IsValid(dest) && dest.y > -2.5f) ? dest : Vector3.zero;
            }
            catch { return Vector3.zero; }
        }

        public static float GetRemainingDistance(BotOwner bot)
        {
            try
            {
                return HasPath(bot) ? Mathf.Clamp(bot.Mover.DistDestination, 0f, 10000f) : float.MaxValue;
            }
            catch { return float.MaxValue; }
        }

        public static Vector3 GetCurrentPathDirection(BotOwner bot)
        {
            var pts = GetCurrentPathPoints(bot, 2);
            if (pts == null || pts.Count < 2) { TempListPool.Return(pts); return Vector3.zero; }
            Vector3 dir = pts[1] - pts[0]; dir.y = 0f;
            TempListPool.Return(pts);
            return dir.sqrMagnitude > 0.001f ? dir.normalized : Vector3.zero;
        }

        public static bool IsPointOnCurrentPath(BotOwner bot, Vector3 point, float maxDist)
        {
            return HasPath(bot) && bot.Mover.IsPointOnCurrentWay(point, maxDist);
        }

        public static bool IsAtDestination(BotOwner bot, float tolerance = 1.09f)
        {
            if (!HasPath(bot)) return false;
            Vector3 dest = GetCurrentDestination(bot);
            return dest != Vector3.zero && Vector3.Distance(bot.Position, dest) < tolerance;
        }

        public static BotNavState GetNavState(BotOwner bot)
        {
            if (bot == null || bot.Mover == null) return BotNavState.Invalid;
            var pc = bot.Mover._pathController;
            if (!IsPathValid(pc)) return BotNavState.NoPath;
            if (IsAtDestination(bot)) return BotNavState.AtGoal;
            if (bot.Mover.Blocked) return BotNavState.Blocked;
            return BotNavState.Active;
        }

        #endregion

        #region NavMesh/Cover/Environment Sampling

        public static bool IsNavMeshPositionValid(Vector3 pos, float radius = 1.0f)
        {
            if (!IsValid(pos)) return false;
            if (NavMesh.SamplePosition(pos, out NavMeshHit hit, radius, NavMesh.AllAreas))
                return hit.mask != 0 && IsValid(hit.position);
            return false;
        }

        public static bool IsWalkable(Vector3 pos, float radius = 1.0f)
        {
            return IsNavMeshPositionValid(pos, radius);
        }

        public static bool IsNearNavMeshEdge(BotOwner bot, float threshold = 0.69f)
        {
            if (bot == null) return false;
            if (NavMesh.FindClosestEdge(bot.Position, out NavMeshHit hit, NavMesh.AllAreas))
                return hit.distance < threshold;
            return false;
        }

        public static float GetDistanceToNavMeshEdge(Vector3 pos, float searchRadius = 2.6f)
        {
            if (NavMesh.FindClosestEdge(pos, out NavMeshHit hit, NavMesh.AllAreas))
                return hit.distance;
            return float.MaxValue;
        }

        public static int GetNavMeshAreaMask(Vector3 pos, float radius = 1.5f)
        {
            if (NavMesh.SamplePosition(pos, out NavMeshHit hit, radius, NavMesh.AllAreas))
                return hit.mask;
            return 0;
        }

        public static bool IsNavMeshOutdoor(Vector3 pos, float radius = 1.5f)
        {
            int mask = GetNavMeshAreaMask(pos, radius);
            return (mask & (1 << 3)) != 0;
        }

        public static bool IsNavMeshCover(Vector3 pos, float radius = 1.0f)
        {
            int mask = GetNavMeshAreaMask(pos, radius);
            return (mask & (1 << 4)) != 0;
        }

        public static Vector3 GetNavMeshNormal(BotOwner bot, float radius = 2.0f)
        {
            if (bot == null) return Vector3.up;
            if (NavMesh.SamplePosition(bot.Position, out NavMeshHit hit, radius, NavMesh.AllAreas))
                return hit.normal.normalized;
            return Vector3.up;
        }

        public static bool TryGetNavMeshSafePosition(Vector3 candidate, Vector3 origin, out Vector3 navSafe, float radius = 1.5f)
        {
            navSafe = candidate;
            if (NavMesh.SamplePosition(candidate, out NavMeshHit hit, radius, NavMesh.AllAreas))
            {
                navSafe = ClampY(hit.position, origin);
                return IsValid(navSafe);
            }
            navSafe = ClampY(candidate, origin);
            return IsValid(navSafe);
        }

        public static Vector3 GetNavMeshSafePosition(Vector3 candidate, Vector3 origin, float radius = 1.5f)
        {
            if (NavMesh.SamplePosition(candidate, out NavMeshHit hit, radius, NavMesh.AllAreas))
                return ClampY(hit.position, origin);
            return ClampY(origin, origin);
        }

        public static Vector3 ClampY(Vector3 v, Vector3 basePos)
        {
            if (Mathf.Abs(v.y - basePos.y) > 3f || v.y < -2.5f)
                v.y = basePos.y;
            return v;
        }

        public static bool IsValid(Vector3 pt)
        {
            return !float.IsNaN(pt.x) && !float.IsNaN(pt.y) && !float.IsNaN(pt.z) &&
                   !float.IsInfinity(pt.x) && !float.IsInfinity(pt.y) && !float.IsInfinity(pt.z) &&
                   Mathf.Abs(pt.x) < 10000f && Mathf.Abs(pt.y) < 10000f && Mathf.Abs(pt.z) < 10000f &&
                   pt != Vector3.zero;
        }

        public static Vector3 GetOverlayWorldNormal(Vector3 pos)
        {
            if (NavMesh.SamplePosition(pos, out NavMeshHit hit, 1.2f, NavMesh.AllAreas))
                return hit.normal.normalized;
            return Vector3.up;
        }

        #endregion

        #region Squad/Group/Formation/Collision Overlays

        public static Vector3 GetGroupFormationTarget(BotOwner self, BotOwner leader, float weight, float spacing)
        {
            if (self == null || leader == null)
                return Vector3.zero;

            Vector3 myPos = self.Position;
            Vector3 leaderPos = leader.Position;
            Vector3 dir = (myPos - leaderPos).normalized;
            if (dir == Vector3.zero)
                dir = UnityEngine.Random.onUnitSphere;

            float stagger = spacing * (1.0f + UnityEngine.Random.Range(-0.22f, 0.22f));
            Vector3 offset = dir * stagger;
            return Vector3.Lerp(myPos, leaderPos + offset, Mathf.Clamp01(weight));
        }

        public static bool IsBlockedByClosedDoor(Vector3 from, Vector3 to)
        {
            Vector3 dir = to - from;
            float dist = dir.magnitude;
            if (dist < 0.01f) return false;

            dir /= dist;
            if (Physics.SphereCast(from + Vector3.up * 1.1f, 0.4f, dir, out RaycastHit hit, dist, AIRefactoredLayerMasks.CoverColliderMask))
            {
                Door door = hit.collider.GetComponentInParent<Door>();
                if (door != null && door.enabled && door.Operatable)
                {
                    EDoorState state = door.DoorState;
                    if ((state & EDoorState.Open) == 0)
                        return true;
                }
            }
            return false;
        }

        public static bool IsBlockedBySquad(BotOwner self, Vector3 pos, float radius = 0.65f)
        {
            if (self?.BotsGroup == null) return false;
            int n = self.BotsGroup.MembersCount;
            for (int i = 0; i < n; i++)
            {
                var mate = self.BotsGroup.Member(i);
                if (mate == null || mate.IsDead || mate == self) continue;
                if (Vector3.Distance(mate.Position, pos) < radius)
                    return true;
            }
            return false;
        }

        public static List<Vector3> GetSquadPositions(BotOwner self)
        {
            var list = TempListPool.Rent<Vector3>(self?.BotsGroup?.MembersCount ?? 2);
            if (self?.BotsGroup == null) return list;
            int n = self.BotsGroup.MembersCount;
            for (int i = 0; i < n; i++)
            {
                var mate = self.BotsGroup.Member(i);
                if (mate == null || mate.IsDead) continue;
                list.Add(mate.Position);
            }
            return list;
        }

        public static bool IsClearOfObstacles(BotOwner self, Vector3 pos, float squadRadius = 0.75f)
        {
            return !IsBlockedBySquad(self, pos, squadRadius) &&
                   IsNavMeshPositionValid(pos) &&
                   !Physics.CheckSphere(pos, 0.33f, AIRefactoredLayerMasks.CoverColliderMask);
        }

        #endregion

        #region Path Meta/Diagnostics/Debug

        public static float GetXZDistanceToGoal(BotOwner bot)
        {
            Vector3 goal = GetCurrentDestination(bot);
            Vector3 p = bot?.Position ?? Vector3.zero;
            Vector2 a = new Vector2(p.x, p.z);
            Vector2 b = new Vector2(goal.x, goal.z);
            return Vector2.Distance(a, b);
        }

        public static string GetNavStateString(BotOwner bot)
        {
            try
            {
                var nav = GetNavState(bot);
                var mover = bot?.Mover;
                var pc = mover?._pathController;
                return $"State:{nav} Path:{(pc != null && (bool)pc.GetType().GetProperty("HavePath")?.GetValue(pc) ? "Y" : "N")} Blocked:{(mover?.Blocked == true ? "Y" : "N")}";
            }
            catch { return "Invalid"; }
        }

        #endregion

        #region Types

        public enum BotNavState
        {
            Invalid,
            NoPath,
            Active,
            Blocked,
            AtGoal
        }

        #endregion
    }
}
