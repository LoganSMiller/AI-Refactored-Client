// <auto-generated>
//   This file is part of AI-Refactored, an open-source project focused on realistic AI behavior in Escape from Tarkov.
//   Licensed under the MIT License. See LICENSE in the repository root for more information.
//
//   THIS FILE IS SYSTEMATICALLY MANAGED.
//   Please follow strict StyleCop, ReSharper, and AI-Refactored code standards for all modifications.
// </auto-generated>

#nullable enable

namespace AIRefactored.AI.Navigation
{
    using System;
    using System.Collections.Generic;
    using UnityEngine;

    /// <summary>
    /// Spatial grid-based indexing for NavPointData.
    /// Used to accelerate nearby queries over large maps.
    /// </summary>
    public class SpatialNavGrid
    {
        private readonly float _cellSize;
        private readonly Dictionary<Vector2Int, List<NavPointData>> _grid;

        /// <summary>
        /// Initializes a new instance of the <see cref="SpatialNavGrid"/> class.
        /// </summary>
        /// <param name="cellSize">Grid cell size, defaults to 10 world units.</param>
        public SpatialNavGrid(float cellSize = 10f)
        {
            _cellSize = Mathf.Max(1f, cellSize);
            _grid = new Dictionary<Vector2Int, List<NavPointData>>(256);
        }

        /// <summary>
        /// Clears the entire spatial index.
        /// </summary>
        public void Clear()
        {
            _grid.Clear();
        }

        /// <summary>
        /// Returns all navigation points within the given radius of a position.
        /// Optionally filter by predicate.
        /// </summary>
        /// <param name="position">World-space position to search from.</param>
        /// <param name="radius">Search radius in world units.</param>
        /// <param name="filter">Optional filter predicate.</param>
        /// <returns>List of matching NavPointData objects.</returns>
        public List<NavPointData> Query(Vector3 position, float radius, Predicate<NavPointData>? filter = null)
        {
            float radiusSq = radius * radius;
            Vector2Int minCell = WorldToCell(position - Vector3.one * radius);
            Vector2Int maxCell = WorldToCell(position + Vector3.one * radius);

            List<NavPointData> result = new List<NavPointData>();

            for (int x = minCell.x; x <= maxCell.x; x++)
            {
                for (int y = minCell.y; y <= maxCell.y; y++)
                {
                    Vector2Int cell = new Vector2Int(x, y);
                    List<NavPointData>? list;

                    if (!_grid.TryGetValue(cell, out list) || list == null)
                    {
                        continue;
                    }

                    for (int i = 0; i < list.Count; i++)
                    {
                        NavPointData point = list[i];
                        float distSq = (point.Position - position).sqrMagnitude;

                        if (distSq <= radiusSq && (filter == null || filter(point)))
                        {
                            result.Add(point);
                        }
                    }
                }
            }

            return result;
        }

        /// <summary>
        /// Adds a navigation point into the appropriate spatial cell.
        /// </summary>
        /// <param name="point">The navigation point to register.</param>
        public void Register(NavPointData point)
        {
            Vector2Int cell = WorldToCell(point.Position);
            List<NavPointData>? list;

            if (!_grid.TryGetValue(cell, out list) || list == null)
            {
                list = new List<NavPointData>(8);
                _grid[cell] = list;
            }

            if (!list.Contains(point))
            {
                list.Add(point);
            }
        }

        /// <summary>
        /// Converts a world position to a spatial grid cell.
        /// </summary>
        /// <param name="pos">World-space position.</param>
        /// <returns>Grid cell coordinates.</returns>
        private Vector2Int WorldToCell(Vector3 pos)
        {
            int x = Mathf.FloorToInt(pos.x / _cellSize);
            int z = Mathf.FloorToInt(pos.z / _cellSize);
            return new Vector2Int(x, z);
        }
    }
}
