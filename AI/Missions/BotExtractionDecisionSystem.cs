// <auto-generated>
//   AI-Refactored: BotExtractionDecisionSystem.cs (Overlay/Event-Only, Ultra-Final Beyond Diamond Edition, June 2025)
//   Ultimate realism: All extraction is intent/overlay only, path-based, no teleport, no disables, 100% robust.
//   No direct or per-frame movement. All failures locally isolated. SPT/FIKA/headless safe. 
//   MIT License.
// </auto-generated>

namespace AIRefactored.AI.Missions
{
    using System;
    using EFT;
    using EFT.HealthSystem;
    using EFT.Interactive;
    using AIRefactored.AI.Core;
    using AIRefactored.AI.Helpers;
    using AIRefactored.AI.Navigation;
    using AIRefactored.Core;
    using AIRefactored.Runtime;
    using UnityEngine;
    using BepInEx.Logging;

    /// <summary>
    /// Handles human-like, bulletproof extraction/retreat for bots, squad- and context-aware.
    /// All logic is event/intent only: emits extraction intent, never issues direct moves. 
    /// All failures are locally isolated, path-based, no disables or teleportation. FIKA/SPT/headless safe.
    /// </summary>
    public sealed class BotExtractionDecisionSystem
    {
        #region Constants

        private const int MaxStuckRetries = 3;
        private const float MaxSearchDistance = 85f;
        private const float MinRaidTimeBeforeExtraction = 60f;
        private const float ExtractionCoolDown = 3f;

        #endregion

        #region Fields

        private readonly BotOwner _bot;
        private readonly BotComponentCache _cache;
        private readonly BotPersonalityProfile _profile;
        private readonly ManualLogSource _log;

        private float _lastMoveUpdateTime;
        private Vector3 _lastPosition;
        private int _stuckRetryCount;
        private bool _hasExtracted;
        private float _lastExtractDecisionTime;

        /// <summary>
        /// The current extraction intent target (overlay only, for dispatcher/overlay to pick up).
        /// </summary>
        public Vector3 ExtractionIntentTarget { get; private set; } = Vector3.zero;

        #endregion

        #region Constructor

        public BotExtractionDecisionSystem(BotOwner bot, BotComponentCache cache, BotPersonalityProfile profile)
        {
            if (!EFTPlayerUtil.IsValidBotOwner(bot))
                throw new ArgumentException("[BotExtractionDecisionSystem] Invalid BotOwner.");

            _bot = bot;
            _cache = cache ?? throw new ArgumentNullException(nameof(cache));
            _profile = profile ?? throw new ArgumentNullException(nameof(profile));
            _log = Plugin.LoggerInstance;

            _lastPosition = EFTPlayerUtil.GetPosition(_bot);
            _lastMoveUpdateTime = Time.time;
            _stuckRetryCount = 0;
            _hasExtracted = false;
            _lastExtractDecisionTime = -100f;
        }

        #endregion

        #region Tick Logic

        /// <summary>
        /// Main per-tick extraction logic. Emits extraction intent only (overlay/event), no direct movement.
        /// </summary>
        public void Tick(float now)
        {
            if (_hasExtracted || !EFTPlayerUtil.IsValidBotOwner(_bot))
                return;

            try
            {
                if (now - _lastExtractDecisionTime < ExtractionCoolDown)
                    return;

                if (ShouldExtract(now))
                {
                    _lastExtractDecisionTime = now;
                    ExtractionIntentTarget = FindExtractionIntentTarget();
                    _hasExtracted = ExtractionIntentTarget != Vector3.zero;
                    // The overlay/dispatcher must pick up ExtractionIntentTarget and route real moves.
                    _cache?.TacticalMemory?.MarkForcedExtract();
                }
            }
            catch (Exception ex)
            {
                _log.LogError($"[BotExtractionDecisionSystem] Tick failed: {ex}");
            }
        }

        #endregion

        #region Decision Logic

        /// <summary>
        /// Returns true if this bot should extract at the current time. 
        /// </summary>
        public bool ShouldExtract(float now)
        {
            try
            {
                if (_bot.IsDead || !EFTPlayerUtil.IsValidBotOwner(_bot))
                    return false;

                if (Time.timeSinceLevelLoad < MinRaidTimeBeforeExtraction)
                    return false;

                float composure = _cache?.PanicHandler?.GetComposureLevel() ?? 1f;
                float panicThreshold = Mathf.Lerp(0.35f, 0.15f, _profile.Caution);
                if (composure < panicThreshold)
                    return true;

                float lootValue = _cache?.LootScanner?.TotalLootValue ?? 0f;
                float lootThreshold = Mathf.Lerp(85000f, 50000f, _profile.Greed);
                if (lootValue >= lootThreshold)
                    return true;

                if (HasSquadWiped())
                    return true;

                float radius = Mathf.Lerp(35f, 60f, 1f - _profile.Cohesion);
                if (IsBotIsolated(radius))
                    return true;

                float stuckDelay = Mathf.Lerp(8f, 18f, 1f - _profile.Caution);
                if (IsBotStuck(now, stuckDelay))
                {
                    _stuckRetryCount++;
                    if (_stuckRetryCount >= MaxStuckRetries)
                        return true;
                }

                return false;
            }
            catch (Exception ex)
            {
                _log.LogError($"[BotExtractionDecisionSystem] ShouldExtract failed: {ex}");
                return false;
            }
        }

        #endregion

        #region Overlay Extraction Intent Logic

        /// <summary>
        /// Finds the best extraction point (overlay intent only, never moves directly).
        /// </summary>
        private Vector3 FindExtractionIntentTarget()
        {
            try
            {
                if (TryFindNearbyExfil(out Vector3 exfilTarget) && BotNavHelper.IsNavMeshPositionValid(exfilTarget))
                {
                    // Overlay/event: Only set intent, never move directly.
                    return BotMovementHelper.ApplyMicroDrift(exfilTarget, _bot.ProfileId, Time.frameCount, _profile);
                }

                if (BotNavHelper.TryGetSafeTarget(_bot, out Vector3 fallback) && BotNavHelper.IsNavMeshPositionValid(fallback))
                {
                    return BotMovementHelper.ApplyMicroDrift(fallback, _bot.ProfileId, Time.frameCount, _profile);
                }
            }
            catch (Exception ex)
            {
                _log.LogError($"[BotExtractionDecisionSystem] FindExtractionIntentTarget failed: {ex}");
            }

            return Vector3.zero;
        }

        #endregion

        #region Private Helpers

        /// <summary>
        /// Returns true if the bot has not moved sufficiently within a given timeout (stuck detection).
        /// </summary>
        private bool IsBotStuck(float now, float timeout)
        {
            Vector3 currentPos = EFTPlayerUtil.GetPosition(_bot);
            float moved = (currentPos - _lastPosition).sqrMagnitude;

            if (moved > 0.35f)
            {
                _lastPosition = currentPos;
                _lastMoveUpdateTime = now;
                _stuckRetryCount = 0;
                return false;
            }

            return (now - _lastMoveUpdateTime) >= timeout;
        }

        /// <summary>
        /// Returns true if all squadmates are dead (wiped).
        /// </summary>
        private bool HasSquadWiped()
        {
            BotsGroup group = _bot.BotsGroup;
            if (group == null || group.MembersCount <= 1) return false;

            for (int i = 0; i < group.MembersCount; i++)
            {
                BotOwner mate = group.Member(i);
                if (mate != null && mate != _bot && !mate.IsDead)
                    return false;
            }
            return true;
        }

        /// <summary>
        /// Returns true if bot is outside of squad cohesion radius.
        /// </summary>
        private bool IsBotIsolated(float radius)
        {
            BotsGroup group = _bot.BotsGroup;
            if (group == null || group.MembersCount <= 1) return true;

            Vector3 pos = EFTPlayerUtil.GetPosition(_bot);
            float radiusSqr = radius * radius;

            for (int i = 0; i < group.MembersCount; i++)
            {
                BotOwner mate = group.Member(i);
                if (mate != null && mate != _bot && !mate.IsDead)
                {
                    Vector3 matePos = EFTPlayerUtil.GetPosition(mate);
                    if ((matePos - pos).sqrMagnitude < radiusSqr)
                        return false;
                }
            }
            return true;
        }

        /// <summary>
        /// Attempts to find a nearby, valid exfiltration point within range.
        /// </summary>
        private bool TryFindNearbyExfil(out Vector3 exfil)
        {
            exfil = Vector3.zero;
            ExfiltrationPoint[] points = UnityEngine.Object.FindObjectsOfType<ExfiltrationPoint>();
            Vector3 botPos = EFTPlayerUtil.GetPosition(_bot);
            float bestDist = MaxSearchDistance * MaxSearchDistance + 1f;
            bool found = false;

            for (int i = 0; i < points.Length; i++)
            {
                ExfiltrationPoint p = points[i];
                if (p == null || !p.enabled) continue;

                float dist = (p.transform.position - botPos).sqrMagnitude;
                if (dist <= MaxSearchDistance * MaxSearchDistance && dist < bestDist)
                {
                    exfil = p.transform.position;
                    bestDist = dist;
                    found = true;
                }
            }
            return found && BotNavHelper.IsNavMeshPositionValid(exfil);
        }

        #endregion
    }
}
