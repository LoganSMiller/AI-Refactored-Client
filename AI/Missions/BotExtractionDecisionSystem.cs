// <auto-generated>
//   This file is part of AI-Refactored, an open-source project focused on realistic AI behavior in Escape from Tarkov.
//   Licensed under the MIT License. See LICENSE in the repository root for more information.
//
//   THIS FILE IS SYSTEMATICALLY MANAGED.
//   Please follow strict StyleCop, ReSharper, and AI-Refactored code standards for all modifications.
// </auto-generated>

namespace AIRefactored.AI.Missions
{
    using System;
    using AIRefactored.AI.Core;
    using AIRefactored.AI.Helpers;
    using AIRefactored.Core;
    using AIRefactored.Runtime;
    using BepInEx.Logging;
    using EFT;
    using UnityEngine;

    /// <summary>
    /// Decides when a bot should attempt early extraction based on panic, loot value, squad status, isolation, or mobility state.
    /// Decision thresholds scale based on bot personality.
    /// </summary>
    public sealed class BotExtractionDecisionSystem
    {
        private readonly BotOwner _bot;
        private readonly BotComponentCache _cache;
        private readonly ManualLogSource _log;
        private readonly BotPersonalityProfile _profile;

        private float _lastMoveUpdate;
        private Vector3 _lastPos;
        private int _stuckChecks;
        private bool _extracted;

        private const int MaxStuckRetries = 3;

        public BotExtractionDecisionSystem(BotOwner bot, BotComponentCache cache, BotPersonalityProfile profile)
        {
            if (bot == null || cache == null || profile == null)
            {
                throw new ArgumentException("[BotExtractionDecisionSystem] Constructor received null reference.");
            }

            _bot = bot;
            _cache = cache;
            _profile = profile;
            _log = Plugin.LoggerInstance;

            _lastPos = bot.Position;
            _lastMoveUpdate = Time.time;
            _stuckChecks = 0;
        }

        public void Tick(float time)
        {
            if (_extracted)
            {
                return;
            }

            if (ShouldExtract(time))
            {
                TriggerExtraction();
                _extracted = true;
            }
        }

        public bool ShouldExtract(float now)
        {
            if (_bot.IsDead || _bot.GetPlayer == null || !_bot.GetPlayer.HealthController.IsAlive)
            {
                return false;
            }

            float composure = _cache.PanicHandler.GetComposureLevel();
            float panicThreshold = Mathf.Lerp(0.35f, 0.15f, _profile.Caution);

            if (composure < panicThreshold)
            {
                _log.LogDebug("[ExtractDecision] Panic threshold met: " + _bot.name + " (" + composure.ToString("F2") + ")");
                return true;
            }

            float lootValue = _cache.LootScanner.TotalLootValue;
            float lootThreshold = Mathf.Lerp(85000f, 50000f, _profile.Greed);

            if (lootValue >= lootThreshold)
            {
                _log.LogDebug("[ExtractDecision] Loot threshold met: " + _bot.name + " (" + lootValue.ToString("F0") + ")");
                return true;
            }

            if (HasSquadWiped())
            {
                _log.LogDebug("[ExtractDecision] Squad wiped: " + _bot.name);
                return true;
            }

            float cohesionDist = Mathf.Lerp(35f, 60f, 1f - _profile.Cohesion);
            if (IsBotIsolated(cohesionDist))
            {
                _log.LogDebug("[ExtractDecision] Bot is isolated: " + _bot.name);
                return true;
            }

            float stuckTimeout = Mathf.Lerp(8f, 18f, 1f - _profile.Caution);
            if (IsBotStuck(now, stuckTimeout))
            {
                _stuckChecks++;
                if (_stuckChecks >= MaxStuckRetries)
                {
                    _log.LogDebug("[ExtractDecision] Bot failed recovery after " + _stuckChecks + " attempts: " + _bot.name);
                    return true;
                }

                _log.LogDebug("[ExtractDecision] Bot stuck detected — retrying (" + _stuckChecks + "): " + _bot.name);
                BotMovementHelper.ForceFallbackMove(_bot);
            }

            return false;
        }

        public void TriggerExtraction()
        {
            Player player = _bot.GetPlayer;

            if (_bot.IsDead || player == null || !_bot.HealthController.IsAlive || _bot.BotState != EBotState.Active)
            {
                _log.LogWarning("[ExtractDecision] Invalid bot state for extraction: " + _bot.name);
                return;
            }

            _cache.TacticalMemory.MarkExtractionStarted();
            BotMovementHelper.SmoothMoveToSafeExit(_bot);
            _log.LogInfo("[ExtractDecision] ✅ Extraction triggered for: " + _bot.name);
        }

        private bool IsBotStuck(float now, float threshold)
        {
            float dist = (_bot.Position - _lastPos).sqrMagnitude;
            if (dist > 0.4f)
            {
                _lastPos = _bot.Position;
                _lastMoveUpdate = now;
                _stuckChecks = 0;
                return false;
            }

            return now - _lastMoveUpdate >= threshold;
        }

        private bool HasSquadWiped()
        {
            BotsGroup group = _bot.BotsGroup;
            if (group == null)
            {
                return true;
            }

            for (int i = 0; i < group.MembersCount; i++)
            {
                BotOwner mate = group.Member(i);
                if (mate != null && mate != _bot && !mate.IsDead)
                {
                    return false;
                }
            }

            return true;
        }

        private bool IsBotIsolated(float radius)
        {
            BotsGroup group = _bot.BotsGroup;
            if (group == null)
            {
                return true;
            }

            Vector3 pos = _bot.Position;
            float radiusSqr = radius * radius;

            for (int i = 0; i < group.MembersCount; i++)
            {
                BotOwner mate = group.Member(i);
                if (mate != null && mate != _bot && !mate.IsDead)
                {
                    float dSqr = (mate.Position - pos).sqrMagnitude;
                    if (dSqr < radiusSqr)
                    {
                        return false;
                    }
                }
            }

            return true;
        }
    }
}
