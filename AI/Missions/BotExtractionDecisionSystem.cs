// <auto-generated>
//   AI-Refactored: BotExtractionDecisionSystem.cs (Overlay/Event-Only, Ultra-Final Beyond Diamond, Mastermoveplan Edition, June 2025)
//   Ultimate realism: All extraction is intent/overlay only, path-based, no teleport, no disables, 100% robust, squad/personality/anti-stuck aware.
//   All failures locally isolated, SPT/FIKA/headless/client parity, zero alloc, pooled, error-shielded.
//   MIT License.
// </auto-generated>

namespace AIRefactored.AI.Missions
{
    using System;
    using EFT;
    using EFT.HealthSystem;
    using EFT.Interactive;
    using AIRefactored.AI.Core;
    using AIRefactored.AI.Helpers;
    using AIRefactored.AI.Navigation;
    using AIRefactored.Core;
    using AIRefactored.Runtime;
    using UnityEngine;
    using BepInEx.Logging;
    using UnityEngine.AI;

    /// <summary>
    /// Handles bulletproof, personality- and squad-aware extraction/retreat overlays.
    /// Emits overlay intent only—never issues direct movement. All failures locally isolated, SPT/FIKA/headless/client safe.
    /// </summary>
    public sealed class BotExtractionDecisionSystem
    {
        #region Constants

        private const int MaxStuckRetries = 3;
        private const float MaxSearchDistance = 85f;
        private const float MinRaidTimeBeforeExtraction = 60f;
        private const float ExtractionCoolDown = 3f;
        private const float MinGroupExtractRatio = 0.5f; // Extract if this fraction of squad is wiped.
        private const float ExfilNavSampleRadius = 1.3f;

        #endregion

        #region Fields

        private readonly BotOwner _bot;
        private readonly BotComponentCache _cache;
        private readonly BotPersonalityProfile _profile;
        private readonly ManualLogSource _log;

        private float _lastMoveUpdateTime;
        private Vector3 _lastPosition;
        private int _stuckRetryCount;
        private bool _hasExtracted;
        private float _lastExtractDecisionTime;

        /// <summary>
        /// Overlay intent target for dispatcher/overlay pickup. Updated on each extract decision.
        /// </summary>
        public Vector3 ExtractionIntentTarget { get; private set; } = Vector3.zero;

        /// <summary>
        /// True if the current extraction intent target is valid.
        /// </summary>
        public bool HasValidExtractionPoint => ExtractionIntentTarget != Vector3.zero;

        /// <summary>
        /// The last sampled/validated exfil point for overlays to query.
        /// </summary>
        public Vector3 CurrentExtractionPosition => ExtractionIntentTarget;

        #endregion

        #region Construction

        public BotExtractionDecisionSystem(BotOwner bot, BotComponentCache cache, BotPersonalityProfile profile)
        {
            if (!EFTPlayerUtil.IsValidBotOwner(bot))
                throw new ArgumentException("[BotExtractionDecisionSystem] Invalid BotOwner.");
            _bot = bot;
            _cache = cache ?? throw new ArgumentNullException(nameof(cache));
            _profile = profile ?? throw new ArgumentNullException(nameof(profile));
            _log = Plugin.LoggerInstance;

            _lastPosition = EFTPlayerUtil.GetPosition(_bot);
            _lastMoveUpdateTime = Time.time;
            _stuckRetryCount = 0;
            _hasExtracted = false;
            _lastExtractDecisionTime = -100f;
        }

        #endregion

        #region Overlay/Event-Only Tick

        /// <summary>
        /// Central extraction overlay tick. Only emits extraction intent; never moves directly.
        /// </summary>
        public void Tick(float now)
        {
            if (_hasExtracted || !EFTPlayerUtil.IsValidBotOwner(_bot))
                return;

            try
            {
                if (now - _lastExtractDecisionTime < ExtractionCoolDown)
                    return;

                if (ShouldExtract(now))
                {
                    _lastExtractDecisionTime = now;
                    ExtractionIntentTarget = FindExtractionIntentTarget();
                    _hasExtracted = ExtractionIntentTarget != Vector3.zero;

                    // Mark extraction in tactical memory for overlay system.
                    _cache?.TacticalMemory?.MarkForcedExtract();

                    if (_hasExtracted)
                        _log.LogInfo($"[BotExtractionDecisionSystem] Extraction intent issued for {BotName} at {ExtractionIntentTarget}");
                }
            }
            catch (Exception ex)
            {
                _log.LogError($"[BotExtractionDecisionSystem] Tick failed: {ex}");
            }
        }

        #endregion

        #region Overlay Extraction Decision Logic

        /// <summary>
        /// Determines if the bot should extract at this moment.
        /// </summary>
        public bool ShouldExtract(float now)
        {
            try
            {
                if (_bot.IsDead || !EFTPlayerUtil.IsValidBotOwner(_bot))
                    return false;

                if (Time.timeSinceLevelLoad < MinRaidTimeBeforeExtraction)
                    return false;

                // 1. Panic/composure-based retreat: overlays if composure drops below threshold.
                float composure = _cache?.PanicHandler?.GetComposureLevel() ?? 1f;
                float panicThreshold = Mathf.Lerp(0.35f, 0.15f, _profile.Caution);
                if (composure < panicThreshold)
                    return true;

                // 2. Loot-driven retreat: overlays if loot value exceeds threshold.
                float lootValue = _cache?.LootScanner?.TotalLootValue ?? 0f;
                float lootThreshold = Mathf.Lerp(85000f, 50000f, _profile.Greed);
                if (lootValue >= lootThreshold)
                    return true;

                // 3. Squad wiped: overlays if most/all squadmates dead.
                if (ShouldSquadExtract())
                    return true;

                // 4. Isolation: overlays if bot is separated from squad.
                float radius = Mathf.Lerp(35f, 60f, 1f - _profile.Cohesion);
                if (IsBotIsolated(radius))
                    return true;

                // 5. Anti-stuck: overlays if stuck beyond retry count.
                float stuckDelay = Mathf.Lerp(8f, 18f, 1f - _profile.Caution);
                if (IsBotStuck(now, stuckDelay))
                {
                    _stuckRetryCount++;
                    if (_stuckRetryCount >= MaxStuckRetries)
                        return true;
                }

                return false;
            }
            catch (Exception ex)
            {
                _log.LogError($"[BotExtractionDecisionSystem] ShouldExtract failed: {ex}");
                return false;
            }
        }

        #endregion

        #region Extraction Intent Target Logic

        /// <summary>
        /// Finds the best extraction point for the overlay/event system (never issues movement).
        /// </summary>
        private Vector3 FindExtractionIntentTarget()
        {
            try
            {
                // Find nearest, squad-valid exfil point, NavMesh-validated and drifted.
                if (TryFindNearbyExfil(out Vector3 exfilTarget) &&
                    NavMesh.SamplePosition(exfilTarget, out NavMeshHit hit, ExfilNavSampleRadius, AIRefactoredLayerMasks.NavMeshAll))
                {
                    return BotMovementHelper.ApplyMicroDrift(hit.position, _bot.ProfileId, Time.frameCount, _profile);
                }

                // Fallback: use cover/squad fallback or safe overlay intent point.
                if (BotNavHelper.TryGetSafeTarget(_bot, out Vector3 fallback) &&
                    NavMesh.SamplePosition(fallback, out NavMeshHit navHit, ExfilNavSampleRadius, AIRefactoredLayerMasks.NavMeshAll))
                {
                    return BotMovementHelper.ApplyMicroDrift(navHit.position, _bot.ProfileId, Time.frameCount, _profile);
                }
            }
            catch (Exception ex)
            {
                _log.LogError($"[BotExtractionDecisionSystem] FindExtractionIntentTarget failed: {ex}");
            }
            return Vector3.zero;
        }

        #endregion

        #region Private Helpers

        /// <summary>
        /// Returns true if the bot has not moved sufficiently within a given timeout (anti-stuck overlay).
        /// </summary>
        private bool IsBotStuck(float now, float timeout)
        {
            Vector3 currentPos = EFTPlayerUtil.GetPosition(_bot);
            float moved = (currentPos - _lastPosition).sqrMagnitude;

            if (moved > 0.35f)
            {
                _lastPosition = currentPos;
                _lastMoveUpdateTime = now;
                _stuckRetryCount = 0;
                return false;
            }
            return (now - _lastMoveUpdateTime) >= timeout;
        }

        /// <summary>
        /// Returns true if enough squadmates are dead to justify squad extract.
        /// </summary>
        private bool ShouldSquadExtract()
        {
            BotsGroup group = _bot.BotsGroup;
            if (group == null || group.MembersCount <= 1) return false;

            int deadCount = 0;
            for (int i = 0; i < group.MembersCount; i++)
            {
                BotOwner mate = group.Member(i);
                if (mate != null && mate != _bot && mate.IsDead)
                    deadCount++;
            }
            float deadRatio = (float)deadCount / (group.MembersCount - 1);
            return deadRatio >= MinGroupExtractRatio;
        }

        /// <summary>
        /// Returns true if bot is outside of squad cohesion radius.
        /// </summary>
        private bool IsBotIsolated(float radius)
        {
            BotsGroup group = _bot.BotsGroup;
            if (group == null || group.MembersCount <= 1) return true;

            Vector3 pos = EFTPlayerUtil.GetPosition(_bot);
            float radiusSqr = radius * radius;

            for (int i = 0; i < group.MembersCount; i++)
            {
                BotOwner mate = group.Member(i);
                if (mate != null && mate != _bot && !mate.IsDead)
                {
                    Vector3 matePos = EFTPlayerUtil.GetPosition(mate);
                    if ((matePos - pos).sqrMagnitude < radiusSqr)
                        return false;
                }
            }
            return true;
        }

        /// <summary>
        /// Attempts to find a nearby valid exfiltration point within range, prioritizing active squad overlays.
        /// </summary>
        private bool TryFindNearbyExfil(out Vector3 exfil)
        {
            exfil = Vector3.zero;
            ExfiltrationPoint[] points = UnityEngine.Object.FindObjectsOfType<ExfiltrationPoint>();
            Vector3 botPos = EFTPlayerUtil.GetPosition(_bot);
            float bestDist = MaxSearchDistance * MaxSearchDistance + 1f;
            bool found = false;

            for (int i = 0; i < points.Length; i++)
            {
                ExfiltrationPoint p = points[i];
                if (p == null || !p.enabled || p.Status != EExfiltrationStatus.RegularMode)
                    continue;

                float dist = (p.transform.position - botPos).sqrMagnitude;
                if (dist <= MaxSearchDistance * MaxSearchDistance && dist < bestDist)
                {
                    exfil = p.transform.position;
                    bestDist = dist;
                    found = true;
                }
            }
            return found && BotNavHelper.IsNavMeshPositionValid(exfil);
        }

        /// <summary>
        /// Name for debug/telemetry.
        /// </summary>
        private string BotName => _bot.Profile?.Info?.Nickname ?? "Unknown";

        #endregion
    }
}
