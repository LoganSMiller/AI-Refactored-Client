// <auto-generated>
//   This file is part of AI-Refactored, an open-source project focused on realistic AI behavior in Escape from Tarkov.
//   Licensed under the MIT License. See LICENSE in the repository root for more information.
//
//   THIS FILE IS SYSTEMATICALLY MANAGED.
//   Please follow strict StyleCop, ReSharper, and AI-Refactored code standards for all modifications.
// </auto-generated>

namespace AIRefactored.AI.Missions
{
    using System;
    using AIRefactored.AI.Core;
    using AIRefactored.AI.Helpers;
    using AIRefactored.Core;
    using AIRefactored.Runtime;
    using BepInEx.Logging;
    using EFT;
    using UnityEngine;

    /// <summary>
    /// Decides when a bot should attempt early extraction based on panic, loot value, squad status, isolation, or mobility state.
    /// Decision thresholds scale based on bot personality.
    /// </summary>
    public sealed class BotExtractionDecisionSystem
    {
        private readonly BotOwner _bot;
        private readonly BotComponentCache _cache;
        private readonly ManualLogSource _log;
        private readonly BotPersonalityProfile _profile;

        private float _lastPositionUpdateTime;
        private Vector3 _lastPosition;
        private bool _hasExtracted;

        public BotExtractionDecisionSystem(BotOwner bot, BotComponentCache cache, BotPersonalityProfile profile)
        {
            if (bot == null || cache == null || profile == null)
            {
                throw new ArgumentException("[BotExtractionDecisionSystem] Constructor received null reference.");
            }

            _bot = bot;
            _cache = cache;
            _profile = profile;
            _log = Plugin.LoggerInstance;
            _lastPosition = bot.Position;
            _lastPositionUpdateTime = Time.time;
        }

        public void Tick(float time)
        {
            if (_hasExtracted)
            {
                return;
            }

            if (ShouldExtract())
            {
                TriggerExtraction();
                _hasExtracted = true;
            }
        }

        public bool ShouldExtract()
        {
            if (_bot.IsDead || _bot.GetPlayer == null || !_bot.GetPlayer.HealthController.IsAlive)
            {
                return false;
            }

            float composure = _cache.PanicHandler.GetComposureLevel();
            float panicThreshold = Mathf.Lerp(0.4f, 0.1f, _profile.Caution);
            if (composure < panicThreshold)
            {
                _log.LogDebug("[ExtractDecision] Panic threshold met: " + _bot.name + " (" + composure.ToString("F2") + ")");
                return true;
            }

            float lootValue = _cache.LootScanner.TotalLootValue;
            float lootThreshold = Mathf.Lerp(75000f, 50000f, _profile.Greed);
            if (lootValue >= lootThreshold)
            {
                _log.LogDebug("[ExtractDecision] Loot threshold met: " + _bot.name + " (" + lootValue.ToString("F0") + ")");
                return true;
            }

            if (HasSquadWiped(_bot))
            {
                _log.LogDebug("[ExtractDecision] Squad wiped: " + _bot.name);
                return true;
            }

            float isolationRadius = Mathf.Lerp(30f, 60f, 1f - _profile.Cohesion);
            if (IsBotIsolated(_bot, isolationRadius))
            {
                _log.LogDebug("[ExtractDecision] Bot is isolated: " + _bot.name);
                return true;
            }

            float stuckTime = Mathf.Lerp(6f, 18f, 1f - _profile.Caution);
            if (IsBotStuck(stuckTime))
            {
                _log.LogDebug("[ExtractDecision] Bot is stuck: " + _bot.name);
                return true;
            }

            return false;
        }

        public void TriggerExtraction()
        {
            Player player = _bot.GetPlayer;

            if (_bot.IsDead || player == null || !_bot.HealthController.IsAlive || _bot.BotState != EBotState.Active)
            {
                _log.LogWarning("[ExtractDecision] Invalid bot state for extraction: " + _bot.name);
                return;
            }

            _cache.TacticalMemory.MarkExtractionStarted();
            BotMovementHelper.SmoothMoveToSafeExit(_bot);
            _log.LogInfo("[ExtractDecision] Extraction triggered for: " + _bot.name);
        }

        private bool IsBotStuck(float threshold)
        {
            float now = Time.time;
            Vector3 currentPos = _bot.Position;

            if ((currentPos - _lastPosition).sqrMagnitude > 0.5f)
            {
                _lastPosition = currentPos;
                _lastPositionUpdateTime = now;
                return false;
            }

            return now - _lastPositionUpdateTime >= threshold;
        }

        private static bool HasSquadWiped(BotOwner bot)
        {
            BotsGroup group = bot.BotsGroup;
            if (group == null)
            {
                return true;
            }

            for (int i = 0; i < group.MembersCount; i++)
            {
                BotOwner mate = group.Member(i);
                if (mate != null && mate != bot && !mate.IsDead)
                {
                    return false;
                }
            }

            return true;
        }

        private static bool IsBotIsolated(BotOwner bot, float threshold)
        {
            BotsGroup group = bot.BotsGroup;
            if (group == null)
            {
                return true;
            }

            Vector3 botPos = bot.Position;
            float thresholdSqr = threshold * threshold;

            for (int i = 0; i < group.MembersCount; i++)
            {
                BotOwner mate = group.Member(i);
                if (mate != null && mate != bot && !mate.IsDead)
                {
                    float distSqr = (mate.Position - botPos).sqrMagnitude;
                    if (distSqr < thresholdSqr)
                    {
                        return false;
                    }
                }
            }

            return true;
        }
    }
}
