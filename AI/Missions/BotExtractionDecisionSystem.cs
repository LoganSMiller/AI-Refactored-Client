// <auto-generated>
//   AI-Refactored: BotExtractionDecisionSystem.cs (Beyond Diamond, Realism Pass)
//   Bulletproof, human-like extraction logic. All failures locally isolated.
//   No fallback disables, never breaks AI or triggers fallback AI. SPT/FIKA/headless safe.
//   MIT License.
// </auto-generated>

namespace AIRefactored.AI.Missions
{
    using System;
    using EFT;
    using EFT.HealthSystem;
    using EFT.Interactive;
    using AIRefactored.AI.Core;
    using AIRefactored.AI.Helpers;
    using AIRefactored.Core;
    using AIRefactored.Runtime;
    using UnityEngine;
    using BepInEx.Logging;
    using AIRefactored.AI.Navigation;

    /// <summary>
    /// Drives human-realistic extraction decisions for AI bots.
    /// All logic is path-based, pooled, error-isolated, and project-valid.
    /// Extraction is squad-aware, panic/loot/health-driven, and never disables parent AI.
    /// </summary>
    public sealed class BotExtractionDecisionSystem
    {
        #region Constants

        private const int MaxStuckRetries = 3;
        private const float MaxSearchDistance = 85f;

        #endregion

        #region Fields

        private readonly BotOwner _bot;
        private readonly BotComponentCache _cache;
        private readonly BotPersonalityProfile _profile;
        private readonly ManualLogSource _log;

        private float _lastMoveUpdateTime;
        private Vector3 _lastPosition;
        private int _stuckRetryCount;
        private bool _hasExtracted;

        #endregion

        #region Constructor

        /// <summary>
        /// Initializes a new extraction decision system for a given bot.
        /// </summary>
        public BotExtractionDecisionSystem(BotOwner bot, BotComponentCache cache, BotPersonalityProfile profile)
        {
            if (!EFTPlayerUtil.IsValidBotOwner(bot))
                throw new ArgumentException("[BotExtractionDecisionSystem] Invalid BotOwner.");
            _bot = bot;
            _cache = cache ?? throw new ArgumentNullException(nameof(cache));
            _profile = profile ?? throw new ArgumentNullException(nameof(profile));
            _log = Plugin.LoggerInstance;

            _lastPosition = _bot.Position;
            _lastMoveUpdateTime = Time.time;
            _stuckRetryCount = 0;
            _hasExtracted = false;
        }

        #endregion

        #region Public Methods

        /// <summary>
        /// Main per-frame extraction logic. Called by BotBrain tick.
        /// </summary>
        public void Tick(float time)
        {
            try
            {
                if (_hasExtracted)
                    return;

                if (ShouldExtract(time))
                {
                    TriggerExtraction();
                    _hasExtracted = true;
                }
            }
            catch (Exception ex)
            {
                _log.LogError($"[BotExtractionDecisionSystem] Tick failed: {ex}");
            }
        }

        /// <summary>
        /// Decides whether the bot should attempt extraction, based on health, loot, squad, and panic.
        /// </summary>
        public bool ShouldExtract(float now)
        {
            try
            {
                if (_bot.IsDead || _bot.GetPlayer == null || !_bot.GetPlayer.IsAI) return false;
                if (_bot.GetPlayer.HealthController == null || !_bot.GetPlayer.HealthController.IsAlive) return false;

                // 1. Panic/composure check
                float composure = _cache?.PanicHandler?.GetComposureLevel() ?? 1f;
                float panicThreshold = Mathf.Lerp(0.35f, 0.15f, _profile.Caution);
                if (composure < panicThreshold)
                {
                    _log.LogDebug("[ExtractDecision] Panic threshold triggered → " + (_bot.Profile?.Info?.Nickname ?? _bot.name));
                    return true;
                }

                // 2. Loot value threshold (personality-based greed)
                float lootValue = _cache?.LootScanner?.TotalLootValue ?? 0f;
                float lootThreshold = Mathf.Lerp(85000f, 50000f, _profile.Greed);
                if (lootValue >= lootThreshold)
                {
                    _log.LogDebug("[ExtractDecision] Loot threshold met → " + (_bot.Profile?.Info?.Nickname ?? _bot.name) + $" ({lootValue:F0})");
                    return true;
                }

                // 3. Squad wiped out
                if (HasSquadWiped())
                {
                    _log.LogDebug("[ExtractDecision] Squad wiped → " + (_bot.Profile?.Info?.Nickname ?? _bot.name));
                    return true;
                }

                // 4. Isolated beyond cohesion
                float cohesionRadius = Mathf.Lerp(35f, 60f, 1f - _profile.Cohesion);
                if (IsBotIsolated(cohesionRadius))
                {
                    _log.LogDebug("[ExtractDecision] Bot is isolated → " + (_bot.Profile?.Info?.Nickname ?? _bot.name));
                    return true;
                }

                // 5. Stuck movement (multiple retries)
                float stuckTimeout = Mathf.Lerp(8f, 18f, 1f - _profile.Caution);
                if (IsBotStuck(now, stuckTimeout))
                {
                    _stuckRetryCount++;
                    if (_stuckRetryCount >= MaxStuckRetries)
                    {
                        _log.LogDebug("[ExtractDecision] Movement failure x" + _stuckRetryCount + " → " + (_bot.Profile?.Info?.Nickname ?? _bot.name));
                        return true;
                    }
                    BotMovementHelper.ForceFallbackMove(_bot);
                }

                return false;
            }
            catch (Exception ex)
            {
                _log.LogError($"[BotExtractionDecisionSystem] ShouldExtract failed: {ex}");
                return false;
            }
        }

        /// <summary>
        /// Attempts to extract the bot using realistic, path-based movement.
        /// </summary>
        public void TriggerExtraction()
        {
            try
            {
                if (_bot.IsDead || _bot.GetPlayer == null || !_bot.GetPlayer.IsAI ||
                    _bot.GetPlayer.HealthController == null || !_bot.GetPlayer.HealthController.IsAlive)
                {
                    _log.LogWarning("[ExtractDecision] ❌ Extraction aborted — invalid state for " + (_bot.Profile?.Info?.Nickname ?? _bot.name));
                    return;
                }

                // Mark tactical memory for squad awareness.
                _cache?.TacticalMemory?.MarkExtractionStarted();

                Vector3 exfilTarget;
                if (TryFindNearbyExfil(out exfilTarget))
                {
                    // Move toward the nearest valid extraction point (path-based only).
                    _bot.Mover?.GoToPoint(exfilTarget, true, 1f);
                    if (BotNavHelper.TryGetSafeTarget(_bot, out Vector3 safeTarget))
                    {
                        BotMovementHelper.SmoothMoveTo(_bot, safeTarget, true);
                        _log.LogDebug("[ExtractDecision] ✅ Extraction initiated (exfil found) for: " + (_bot.Profile?.Info?.Nickname ?? _bot.name));
                        return;
                    }
                }
                else
                {
                    // Fallback: move forward (never teleport).
                    Vector3 forwardTarget = _bot.Position + _bot.LookDirection.normalized * 6f;
                    _bot.Mover?.GoToPoint(forwardTarget, true, 1f);

                    if (BotNavHelper.TryGetSafeTarget(_bot, out Vector3 safeFallback))
                    {
                        BotMovementHelper.SmoothMoveTo(_bot, safeFallback, true);
                        _log.LogDebug("[ExtractDecision] ✅ Extraction initiated (fallback forward) for: " + (_bot.Profile?.Info?.Nickname ?? _bot.name));
                    }
                }
            }
            catch (Exception ex)
            {
                _log.LogError($"[BotExtractionDecisionSystem] TriggerExtraction failed: {ex}");
            }
        }

        #endregion

        #region Private Helpers

        /// <summary>
        /// Returns true if the bot is stuck for longer than threshold seconds.
        /// </summary>
        private bool IsBotStuck(float now, float threshold)
        {
            float moved = (_bot.Position - _lastPosition).sqrMagnitude;
            if (moved > 0.35f)
            {
                _lastPosition = _bot.Position;
                _lastMoveUpdateTime = now;
                _stuckRetryCount = 0;
                return false;
            }
            return now - _lastMoveUpdateTime >= threshold;
        }

        /// <summary>
        /// Returns true if all other squad members are dead or absent.
        /// </summary>
        private bool HasSquadWiped()
        {
            BotsGroup group = _bot.BotsGroup;
            if (group == null || group.MembersCount <= 1) return false;

            for (int i = 0; i < group.MembersCount; i++)
            {
                BotOwner mate = group.Member(i);
                if (mate != null && mate != _bot && !mate.IsDead)
                    return false;
            }
            return true;
        }

        /// <summary>
        /// Returns true if bot is too far from all living squadmates.
        /// </summary>
        private bool IsBotIsolated(float radius)
        {
            BotsGroup group = _bot.BotsGroup;
            if (group == null || group.MembersCount <= 1) return true;

            Vector3 pos = _bot.Position;
            float radiusSqr = radius * radius;

            for (int i = 0; i < group.MembersCount; i++)
            {
                BotOwner mate = group.Member(i);
                if (mate != null && mate != _bot && !mate.IsDead)
                {
                    if ((mate.Position - pos).sqrMagnitude < radiusSqr)
                        return false;
                }
            }
            return true;
        }

        /// <summary>
        /// Finds the nearest valid extraction point.
        /// </summary>
        private bool TryFindNearbyExfil(out Vector3 exfil)
        {
            exfil = Vector3.zero;
            ExfiltrationPoint[] points = UnityEngine.Object.FindObjectsOfType<ExfiltrationPoint>();
            Vector3 pos = _bot.Position;
            float bestDist = MaxSearchDistance * MaxSearchDistance + 1f;
            bool found = false;

            for (int i = 0; i < points.Length; i++)
            {
                ExfiltrationPoint point = points[i];
                if (point == null || !point.enabled)
                    continue;

                float dist = (point.transform.position - pos).sqrMagnitude;
                if (dist <= MaxSearchDistance * MaxSearchDistance && dist < bestDist)
                {
                    exfil = point.transform.position;
                    bestDist = dist;
                    found = true;
                }
            }
            return found;
        }

        #endregion
    }
}
