// <auto-generated>
//   This file is part of AI-Refactored, an open-source project focused on realistic AI behavior in Escape from Tarkov.
//   Licensed under the MIT License. See LICENSE in the repository root for more information.
//
//   THIS FILE IS SYSTEMATICALLY MANAGED.
//   Please follow strict StyleCop, ReSharper, and AI-Refactored code standards for all modifications.
// </auto-generated>

namespace AIRefactored.AI.Missions
{
    using System;
    using AIRefactored.AI.Core;
    using AIRefactored.AI.Helpers;
    using AIRefactored.Core;
    using AIRefactored.Runtime;
    using BepInEx.Logging;
    using EFT;
    using UnityEngine;

    /// <summary>
    /// Decides when a bot should attempt early extraction based on panic, loot value, squad status, isolation, or mobility state.
    /// Decision thresholds scale based on bot personality.
    /// </summary>
    public sealed class BotExtractionDecisionSystem
    {
        #region Fields

        private readonly BotOwner _bot;
        private readonly BotComponentCache _cache;
        private readonly ManualLogSource _log;
        private readonly BotPersonalityProfile _profile;

        private float _lastPositionUpdateTime;
        private Vector3 _lastPosition;
        private bool _hasExtracted;

        #endregion

        #region Constructor

        public BotExtractionDecisionSystem(BotOwner bot, BotComponentCache cache, BotPersonalityProfile profile)
        {
            if (bot == null || cache == null)
            {
                throw new ArgumentException("BotExtractionDecisionSystem: bot or cache is null.");
            }

            _bot = bot;
            _cache = cache;
            _profile = profile;
            _log = Plugin.LoggerInstance;
            _lastPosition = bot.Position;
            _lastPositionUpdateTime = Time.time;
        }

        #endregion

        #region Public Methods

        public void Tick(float time)
        {
            if (_hasExtracted)
            {
                return;
            }

            if (ShouldExtract())
            {
                TriggerExtraction();
                _hasExtracted = true;
            }
        }

        public bool ShouldExtract()
        {
            Player player = _bot.GetPlayer;
            if (_bot.IsDead || player == null || !player.HealthController.IsAlive)
            {
                return false;
            }

            float panic = _cache.PanicHandler.GetComposureLevel();
            float panicThreshold = Mathf.Lerp(0.4f, 0.1f, _profile.Caution);
            if (panic < panicThreshold)
            {
                _log.LogDebug("[ExtractDecision] " + _bot.name + " extracting: panic=" + panic.ToString("F2"));
                return true;
            }

            float loot = _cache.LootScanner.TotalLootValue;
            float greedThreshold = Mathf.Lerp(75000f, 50000f, _profile.Greed);
            if (loot >= greedThreshold)
            {
                _log.LogDebug("[ExtractDecision] " + _bot.name + " extracting: lootValue=" + loot.ToString("F0"));
                return true;
            }

            if (HasSquadWiped(_bot))
            {
                _log.LogDebug("[ExtractDecision] " + _bot.name + " extracting: squad wiped");
                return true;
            }

            float isolationDist = Mathf.Lerp(30f, 60f, 1f - _profile.Cohesion);
            if (IsBotIsolated(_bot, isolationDist))
            {
                _log.LogDebug("[ExtractDecision] " + _bot.name + " extracting: isolated");
                return true;
            }

            float stuckThreshold = Mathf.Lerp(6f, 18f, 1f - _profile.Caution);
            if (IsBotStuck(stuckThreshold))
            {
                _log.LogDebug("[ExtractDecision] " + _bot.name + " extracting: stuck");
                return true;
            }

            return false;
        }

        public void TriggerExtraction()
        {
            Player player = _bot.GetPlayer;

            if (_bot.IsDead || _bot.BotState != EBotState.Active || player == null || !player.HealthController.IsAlive)
            {
                _log.LogWarning("[ExtractDecision] Cannot extract: " + _bot.name + " is dead or not active.");
                return;
            }

            _cache.TacticalMemory.MarkExtractionStarted();
            BotMovementHelper.SmoothMoveToSafeExit(_bot);
            _log.LogInfo("[ExtractDecision] " + _bot.name + " extraction triggered.");
        }

        #endregion

        #region Private Helpers

        private bool IsBotStuck(float threshold)
        {
            float now = Time.time;
            Vector3 current = _bot.Position;

            if ((current - _lastPosition).sqrMagnitude > 0.5f)
            {
                _lastPosition = current;
                _lastPositionUpdateTime = now;
                return false;
            }

            return now - _lastPositionUpdateTime >= threshold;
        }

        private static bool HasSquadWiped(BotOwner bot)
        {
            BotsGroup group = bot.BotsGroup;
            if (group == null)
            {
                return true;
            }

            for (int i = 0; i < group.MembersCount; i++)
            {
                BotOwner mate = group.Member(i);
                if (mate != null && mate != bot && !mate.IsDead)
                {
                    return false;
                }
            }

            return true;
        }

        private static bool IsBotIsolated(BotOwner bot, float threshold)
        {
            BotsGroup group = bot.BotsGroup;
            if (group == null)
            {
                return true;
            }

            float thresholdSqr = threshold * threshold;
            Vector3 selfPos = bot.Position;

            for (int i = 0; i < group.MembersCount; i++)
            {
                BotOwner mate = group.Member(i);
                if (mate != null && mate != bot && !mate.IsDead)
                {
                    if ((mate.Position - selfPos).sqrMagnitude < thresholdSqr)
                    {
                        return false;
                    }
                }
            }

            return true;
        }

        #endregion
    }
}
