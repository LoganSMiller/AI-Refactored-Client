// <auto-generated>
//   This file is part of AI-Refactored, an open-source project focused on realistic AI behavior in Escape from Tarkov.
//   Licensed under the MIT License. See LICENSE in the repository root for more information.
//
//   THIS FILE IS SYSTEMATICALLY MANAGED.
//   Please follow strict StyleCop, ReSharper, and AI-Refactored code standards for all modifications.
// </auto-generated>

#nullable enable

namespace AIRefactored.AI.Missions
{
    using System;
    using AIRefactored.AI.Core;
    using AIRefactored.AI.Helpers;
    using AIRefactored.Core;
    using AIRefactored.Runtime;
    using BepInEx.Logging;
    using EFT;
    using UnityEngine;

    /// <summary>
    /// Decides when a bot should attempt early extraction based on loot value, panic, squad state, isolation, and mobility.
    /// Fully scales thresholds based on personality traits.
    /// </summary>
    public sealed class BotExtractionDecisionSystem
    {
        #region Fields

        private readonly BotOwner _bot;
        private readonly BotComponentCache _cache;
        private readonly ManualLogSource _log;
        private readonly BotPersonalityProfile _profile;

        private float _lastPositionUpdateTime;
        private Vector3 _lastPosition;
        private bool _hasExtracted;

        #endregion

        #region Constructor

        public BotExtractionDecisionSystem(BotOwner bot, BotComponentCache cache, BotPersonalityProfile profile)
        {
            this._bot = bot ?? throw new ArgumentNullException(nameof(bot));
            this._cache = cache ?? throw new ArgumentNullException(nameof(cache));
            this._profile = profile ?? new BotPersonalityProfile();
            this._log = AIRefactoredController.Logger;
            this._lastPosition = bot.Position;
            this._lastPositionUpdateTime = Time.time;
        }

        #endregion

        #region Public Methods

        public void Tick(float time)
        {
            if (this._hasExtracted)
            {
                return;
            }

            if (this.ShouldExtract())
            {
                this.TriggerExtraction();
                this._hasExtracted = true;
            }
        }

        public bool ShouldExtract()
        {
            if (this._bot.IsDead || this._bot.GetPlayer == null || !this._bot.GetPlayer.HealthController.IsAlive)
            {
                return false;
            }

            float panic = this._cache.PanicHandler?.GetComposureLevel() ?? 1f;
            float panicThreshold = Mathf.Lerp(0.4f, 0.1f, this._profile.Caution); // Cautious bots extract earlier

            if (panic < panicThreshold)
            {
                this._log.LogDebug($"[ExtractDecision] {this._bot.name} extracting: panic={panic:F2}");
                return true;
            }

            float loot = this._cache.LootScanner?.TotalLootValue ?? 0f;
            float greedFactor = Mathf.Lerp(75000f, 50000f, this._profile.Greed); // Greedy bots extract with more

            if (loot >= greedFactor)
            {
                this._log.LogDebug($"[ExtractDecision] {this._bot.name} extracting: lootValue={loot}");
                return true;
            }

            if (HasSquadWiped(this._bot))
            {
                this._log.LogDebug($"[ExtractDecision] {this._bot.name} extracting: squad wiped");
                return true;
            }

            float isolationDistance = Mathf.Lerp(30f, 60f, 1f - this._profile.Cohesion);
            if (IsBotIsolated(this._bot, isolationDistance))
            {
                this._log.LogDebug($"[ExtractDecision] {this._bot.name} extracting: isolated");
                return true;
            }

            float stuckTime = Mathf.Lerp(6f, 18f, 1f - this._profile.Caution);
            if (IsBotStuck(stuckTime))
            {
                this._log.LogDebug($"[ExtractDecision] {this._bot.name} extracting: stuck");
                return true;
            }

            return false;
        }

        public void TriggerExtraction()
        {
            if (this._bot == null || this._cache == null)
            {
                this._log.LogWarning("[ExtractDecision] Failed to trigger extraction: bot or cache is null.");
                return;
            }

            if (this._bot.IsDead ||
                this._bot.BotState != EBotState.Active ||
                this._bot.GetPlayer == null ||
                !this._bot.GetPlayer.HealthController.IsAlive)
            {
                this._log.LogWarning($"[ExtractDecision] Cannot extract: {this._bot.name} is dead or not in Active state.");
                return;
            }

            this._cache.TacticalMemory?.MarkExtractionStarted();
            BotMovementHelper.SmoothMoveToSafeExit(this._bot);
            this._log.LogInfo($"[ExtractDecision] {this._bot.name} extraction triggered.");
        }

        #endregion

        #region Private Helpers

        private bool IsBotStuck(float threshold)
        {
            float now = Time.time;
            Vector3 currentPos = this._bot.Position;

            if ((currentPos - this._lastPosition).sqrMagnitude > 0.5f)
            {
                this._lastPosition = currentPos;
                this._lastPositionUpdateTime = now;
                return false;
            }

            return now - this._lastPositionUpdateTime >= threshold;
        }

        private static bool HasSquadWiped(BotOwner bot)
        {
            BotsGroup? group = bot.BotsGroup;
            if (group == null)
            {
                return true;
            }

            for (int i = 0; i < group.MembersCount; i++)
            {
                BotOwner? mate = group.Member(i);
                if (mate != null && mate != bot && !mate.IsDead)
                {
                    return false;
                }
            }

            return true;
        }

        private static bool IsBotIsolated(BotOwner bot, float threshold)
        {
            BotsGroup? group = bot.BotsGroup;
            if (group == null)
            {
                return true;
            }

            float minDistSqr = threshold * threshold;

            for (int i = 0; i < group.MembersCount; i++)
            {
                BotOwner? mate = group.Member(i);
                if (mate != null && mate != bot && !mate.IsDead)
                {
                    if ((mate.Position - bot.Position).sqrMagnitude < minDistSqr)
                    {
                        return false;
                    }
                }
            }

            return true;
        }

        #endregion
    }
}
