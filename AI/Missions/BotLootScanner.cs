// <auto-generated>
//   AI-Refactored: BotLootScanner.cs (Supreme Arbitration, Beyond Diamond+, BotBrain Edition – June 2025)
//   Squad-aware, human-realistic, pooled and bulletproof loot scanning and arbitration.
//   100% BotBrain tick-driven. Never self-ticks. All errors locally isolated.
//   All overlays/event-only, headless/SPT/FIKA/client safe, squad arbitration ready.
//   MIT License.
// </auto-generated>

namespace AIRefactored.AI.Looting
{
    using System;
    using System.Collections.Generic;
    using AIRefactored.AI.Core;
    using AIRefactored.Core;
    using AIRefactored.Pools;
    using EFT;
    using EFT.Interactive;
    using EFT.InventoryLogic;
    using UnityEngine;

    /// <summary>
    /// Squad-aware, arbitration-driven, pooled, and bulletproof loot scanning for AI-Refactored bots.
    /// 100% BotBrain tick-driven; overlays/event-only; full multiplayer/headless/Squad/Overlay/Pooling safety.
    /// </summary>
    public sealed class BotLootScanner
    {
        #region Fields

        private BotComponentCache _cache;
        private BotOwner _bot;
        private BotPersonalityProfile _personality;

        // Nearby pooled loot containers and temp value buffer
        private readonly List<LootableContainer> _nearbyContainers = new List<LootableContainer>(18);
        private readonly List<Item> _tempItems = new List<Item>(40);

        // Last chosen/claimed container for this bot (arbitration)
        private LootableContainer _lastTargetContainer;
        private float _lastTargetValue;
        private string _lastTargetId;
        private float _lastTargetUpdateTime;

        // Squad claim arbitration (claim/cooldown)
        private string _squadLootClaimId;
        private Vector3 _squadLootTarget;
        private float _squadLootClaimTime;

        // State and API
        public float TotalLootValue { get; private set; }
        public LootableContainer CurrentTargetContainer { get; private set; }
        public string LastSquadLootClaimId => _squadLootClaimId;

        #endregion

        #region Initialization

        /// <summary>
        /// Initializes the scanner for the bot and cache. Pooled, zero-allocation.
        /// </summary>
        public void Initialize(BotComponentCache cache)
        {
            _cache = cache;
            _bot = cache?.Bot;
            _personality = cache?.PersonalityProfile ?? BotPersonalityProfile.Default;
            _nearbyContainers.Clear();
            _squadLootClaimId = null;
            _squadLootTarget = Vector3.zero;
            _squadLootClaimTime = -100f;
            _lastTargetContainer = null;
            _lastTargetValue = 0f;
            _lastTargetId = null;
            _lastTargetUpdateTime = -100f;
            TotalLootValue = 0f;
            CurrentTargetContainer = null;
        }

        #endregion

        #region BotBrain Tick API

        /// <summary>
        /// Ticks scanning and loot arbitration logic. Only safe to call from BotBrain.
        /// Bulletproof, squad/event/overlay/multiplayer safe.
        /// </summary>
        public void Tick(float deltaTime)
        {
            try
            {
                if (_bot == null || _bot.IsDead) return;

                ScanNearbyContainers();
                EvaluateBestLoot();

                // Arbitration: update squad loot claim if needed.
                if (CurrentTargetContainer != null && CurrentTargetContainer.transform != null)
                {
                    RegisterSquadLootTarget(CurrentTargetContainer.transform.position);
                }
            }
            catch (Exception ex)
            {
                Plugin.LoggerInstance.LogError($"[BotLootScanner] Tick failed: {ex}");
            }
        }

        #endregion

        #region Squad Arbitration Logic

        /// <summary>
        /// Register or update this bot's squad-shared loot claim (location only, arbitration/event only).
        /// </summary>
        public void RegisterSquadLootTarget(Vector3 worldPos)
        {
            float bestDist = 64f;
            string bestId = null;
            LootableContainer best = null;

            for (int i = 0; i < _nearbyContainers.Count; i++)
            {
                LootableContainer c = _nearbyContainers[i];
                if (c == null || !c.enabled || c.transform == null) continue;
                float d = Vector3.Distance(worldPos, c.transform.position);
                if (d < bestDist)
                {
                    bestDist = d;
                    bestId = c.Id;
                    best = c;
                }
            }

            if (best != null)
            {
                _squadLootClaimId = bestId;
                _squadLootTarget = best.transform.position;
                _squadLootClaimTime = Time.time;
            }
        }

        /// <summary>
        /// Returns the current valid squad-claimed loot ID (or null).
        /// </summary>
        public string GetSquadClaimedLootId()
        {
            if (!string.IsNullOrEmpty(_squadLootClaimId) && (Time.time - _squadLootClaimTime) < 14f)
                return _squadLootClaimId;
            return null;
        }

        /// <summary>
        /// Returns squad-claimed loot position, or Vector3.zero.
        /// </summary>
        public Vector3 GetSquadClaimedLootPosition()
        {
            if (!string.IsNullOrEmpty(_squadLootClaimId) && (Time.time - _squadLootClaimTime) < 14f)
                return _squadLootTarget;
            return Vector3.zero;
        }

        #endregion

        #region Scanning and Value Evaluation

        /// <summary>
        /// Scans all loot containers within loot radius, zero-alloc, fills _nearbyContainers.
        /// </summary>
        private void ScanNearbyContainers()
        {
            _nearbyContainers.Clear();
            TotalLootValue = 0f;

            var all = LootRegistry.GetAllContainers();
            if (all == null) return;
            Vector3 myPos = EFTPlayerUtil.GetPosition(_bot);

            for (int i = 0; i < all.Count; i++)
            {
                LootableContainer c = all[i];
                if (c == null || !c.enabled || c.transform == null) continue;
                float dist = Vector3.Distance(myPos, c.transform.position);
                if (dist < 22f)
                    _nearbyContainers.Add(c);
            }
        }

        /// <summary>
        /// Evaluates and arbitrates best loot for squad, greed, value, and contest.
        /// Updates CurrentTargetContainer and TotalLootValue.
        /// </summary>
        private void EvaluateBestLoot()
        {
            CurrentTargetContainer = null;
            _lastTargetValue = 0f;
            _lastTargetId = null;
            _lastTargetUpdateTime = Time.time;

            float bestValue = 0f;
            float bestDist = 99f;
            string squadClaim = GetSquadClaimedLootId();
            Vector3 botPos = EFTPlayerUtil.GetPosition(_bot);

            float greedBias = Mathf.Lerp(0.80f, 1.18f, _personality.Greed);

            for (int i = 0; i < _nearbyContainers.Count; i++)
            {
                LootableContainer c = _nearbyContainers[i];
                if (c == null || !c.enabled || c.transform == null) continue;
                if (!string.IsNullOrEmpty(squadClaim) && c.Id != squadClaim) continue;

                float value = EstimateValue(c) * greedBias;
                float dist = Vector3.Distance(botPos, c.transform.position);
                if (value > bestValue || (Mathf.Approximately(value, bestValue) && dist < bestDist))
                {
                    bestValue = value;
                    bestDist = dist;
                    CurrentTargetContainer = c;
                    _lastTargetId = c.Id;
                }
            }

            _lastTargetContainer = CurrentTargetContainer;
            _lastTargetValue = bestValue;
            TotalLootValue = bestValue;
        }

        /// <summary>
        /// Estimates the total value of all items in the container. Uses pooled lists, zero disables.
        /// </summary>
        private float EstimateValue(LootableContainer container)
        {
            if (container == null || container.ItemOwner == null || container.ItemOwner.RootItem == null)
                return 0f;
            float total = 0f;
            _tempItems.Clear();
            try
            {
                container.ItemOwner.RootItem.GetAllItemsNonAlloc(_tempItems);
                for (int i = 0; i < _tempItems.Count; i++)
                {
                    Item item = _tempItems[i];
                    if (item?.Template?.CreditsPrice > 0f)
                        total += item.Template.CreditsPrice;
                }
            }
            catch (Exception ex)
            {
                Plugin.LoggerInstance.LogError($"[BotLootScanner] EstimateValue failed: {ex}");
            }
            _tempItems.Clear();
            return total;
        }

        /// <summary>
        /// Returns the best available loot point for overlays or arbitration (or bot position if none).
        /// </summary>
        public Vector3 GetBestLootPoint()
        {
            if (CurrentTargetContainer != null && CurrentTargetContainer.transform != null)
                return CurrentTargetContainer.transform.position;
            return EFTPlayerUtil.GetPosition(_bot);
        }

        #endregion

        #region Expanded Utility / Teardown

        /// <summary>
        /// Clears all internal state and pooled buffers (call on teardown).
        /// </summary>
        public void Teardown()
        {
            _nearbyContainers.Clear();
            _tempItems.Clear();
            _lastTargetContainer = null;
            _lastTargetId = null;
            CurrentTargetContainer = null;
            _squadLootClaimId = null;
            _squadLootTarget = Vector3.zero;
        }

        #endregion
    }
}
