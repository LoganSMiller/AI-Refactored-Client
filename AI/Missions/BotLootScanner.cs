// <auto-generated>
//   AI-Refactored: BotLootScanner.cs (Beyond Diamond, BotBrain Edition)
//   Squad-aware, human-realistic, pooled and bulletproof loot scanning and arbitration.
//   100% BotBrain tick-driven. Never self-ticks. All errors locally isolated.
//   MIT License.
// </auto-generated>

namespace AIRefactored.AI.Looting
{
    using System;
    using System.Collections.Generic;
    using AIRefactored.AI.Core;
    using AIRefactored.Pools;
    using EFT;
    using EFT.Interactive;
    using EFT.InventoryLogic;
    using UnityEngine;

    /// <summary>
    /// Scans, caches, and prioritizes nearby loot containers and items.
    /// Fully squad-aware: supports squad-claimed loot arbitration, dynamic priorities, and pooled zero-allocation queries.
    /// All errors locally isolated; no method ever disables parent/bot. Only ticked by BotBrain.
    /// </summary>
    public sealed class BotLootScanner
    {
        #region Fields

        private BotComponentCache _cache;
        private BotOwner _bot;

        private readonly List<LootableContainer> _nearbyContainers = new List<LootableContainer>(16);
        private readonly List<Item> _tempItems = new List<Item>(32);
        private string _squadLootClaimId;
        private Vector3 _squadLootTarget;
        private float _squadLootClaimTime;

        public float TotalLootValue { get; private set; }
        public LootableContainer CurrentTargetContainer { get; private set; }

        #endregion

        #region Initialization

        /// <summary>
        /// Called on bot init; wires up cache and bot references.
        /// </summary>
        public void Initialize(BotComponentCache cache)
        {
            _cache = cache;
            _bot = cache?.Bot;
            _nearbyContainers.Clear();
            _squadLootClaimId = null;
            _squadLootTarget = Vector3.zero;
            _squadLootClaimTime = -99f;
        }

        #endregion

        #region BotBrain Tick Only

        /// <summary>
        /// Ticked by BotBrain at the logic tick rate. Scans and evaluates loot every tick.
        /// </summary>
        public void Tick(float deltaTime)
        {
            try
            {
                if (_bot == null || _bot.IsDead)
                    return;

                ScanNearbyContainers();
                EvaluateBestLoot();
            }
            catch { /* Always locally isolated. */ }
        }

        #endregion

        #region Squad Arbitration

        /// <summary>
        /// Registers a squad-coordinated loot target claim.
        /// </summary>
        public void RegisterSquadLootTarget(Vector3 worldPos)
        {
            // Find closest container to this position and claim for arbitration.
            float bestDist = 99f;
            string bestId = null;
            LootableContainer best = null;

            for (int i = 0; i < _nearbyContainers.Count; i++)
            {
                LootableContainer c = _nearbyContainers[i];
                if (c == null || !c.enabled || c.transform == null)
                    continue;
                float d = Vector3.Distance(worldPos, c.transform.position);
                if (d < bestDist)
                {
                    bestDist = d;
                    bestId = c.Id;
                    best = c;
                }
            }

            if (best != null)
            {
                _squadLootClaimId = bestId;
                _squadLootTarget = best.transform.position;
                _squadLootClaimTime = Time.time;
            }
        }

        public string GetSquadClaimedLootId()
        {
            // Returns the current squad-claimed loot id if valid (within 12s).
            if (_squadLootClaimId != null && (Time.time - _squadLootClaimTime) < 12f)
                return _squadLootClaimId;
            return null;
        }

        public Vector3 GetSquadClaimedLootPosition()
        {
            if (!string.IsNullOrEmpty(_squadLootClaimId) && (Time.time - _squadLootClaimTime) < 12f)
                return _squadLootTarget;
            return Vector3.zero;
        }

        #endregion

        #region Internal: Scanning/Evaluation

        private void ScanNearbyContainers()
        {
            _nearbyContainers.Clear();
            TotalLootValue = 0f;

            List<LootableContainer> all = LootRegistry.GetAllContainers();
            if (all == null) return;

            Vector3 myPos = _bot.Position;
            for (int i = 0; i < all.Count; i++)
            {
                LootableContainer c = all[i];
                if (c == null || !c.enabled || c.transform == null) continue;
                float dist = Vector3.Distance(myPos, c.transform.position);
                if (dist < 22f) // Max loot distance
                {
                    _nearbyContainers.Add(c);
                }
            }
        }

        private void EvaluateBestLoot()
        {
            CurrentTargetContainer = null;
            float bestValue = 0f;
            float bestDist = 99f;
            string squadClaim = GetSquadClaimedLootId();

            var profile = _cache?.PersonalityProfile ?? BotPersonalityProfile.Default;
            float greedBias = Mathf.Lerp(0.75f, 1.15f, profile.Greed);

            for (int i = 0; i < _nearbyContainers.Count; i++)
            {
                LootableContainer c = _nearbyContainers[i];
                if (c == null || !c.enabled || c.transform == null)
                    continue;
                // Skip if squad claim exists and this isn't it.
                if (!string.IsNullOrEmpty(squadClaim) && c.Id != squadClaim)
                    continue;
                // Estimate value
                float value = EstimateValue(c) * greedBias;
                float dist = Vector3.Distance(_bot.Position, c.transform.position);
                if (value > bestValue || (Mathf.Approximately(value, bestValue) && dist < bestDist))
                {
                    bestValue = value;
                    bestDist = dist;
                    CurrentTargetContainer = c;
                }
            }

            TotalLootValue = bestValue;
        }

        private float EstimateValue(LootableContainer container)
        {
            if (container == null || container.ItemOwner == null || container.ItemOwner.RootItem == null)
                return 0f;
            float total = 0f;
            _tempItems.Clear();
            try
            {
                container.ItemOwner.RootItem.GetAllItemsNonAlloc(_tempItems);
                for (int i = 0; i < _tempItems.Count; i++)
                {
                    Item item = _tempItems[i];
                    if (item != null && item.Template != null && item.Template.CreditsPrice > 0f)
                        total += item.Template.CreditsPrice;
                }
            }
            catch { }
            _tempItems.Clear();
            return total;
        }

        /// <summary>
        /// Returns the best available loot point for this bot (or Vector3.zero if none found).
        /// Always returns the center position of the most desirable container, squad arbitration aware.
        /// </summary>
        public Vector3 GetBestLootPoint()
        {
            // Ensure we use the latest scan/evaluation.
            if (CurrentTargetContainer != null && CurrentTargetContainer.transform != null)
                return CurrentTargetContainer.transform.position;
            return _bot != null ? _bot.Position : Vector3.zero;
        }

        #endregion
    }
}
