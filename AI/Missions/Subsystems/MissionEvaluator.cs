// <auto-generated>
//   This file is part of AI-Refactored, an open-source project focused on realistic AI behavior in Escape from Tarkov.
//   Licensed under the MIT License. See LICENSE in the repository root for more information.
//
//   THIS FILE IS SYSTEMATICALLY MANAGED.
//   Please follow strict StyleCop, ReSharper, and AI-Refactored code standards for all modifications.
// </auto-generated>

#nullable enable

namespace AIRefactored.AI.Missions.Subsystems
{
    using System;
    using System.Collections.Generic;
    using AIRefactored.AI.Core;
    using AIRefactored.AI.Groups;
    using AIRefactored.AI.Helpers;
    using AIRefactored.AI.Optimization;
    using AIRefactored.Core;
    using AIRefactored.Runtime;
    using BepInEx.Logging;
    using EFT;
    using EFT.Interactive;
    using EFT.InventoryLogic;
    using UnityEngine;

    /// <summary>
    /// Evaluates combat, squad alignment, loot threshold, and stuck logic
    /// to guide mission reassessment and fallback behavior.
    /// </summary>
    public sealed class MissionEvaluator
    {
        private const int LootItemCountThreshold = 40;
        private const float SquadCohesionRange = 10f;
        private const float StuckCooldown = 30f;
        private const float StuckDuration = 25f;

        private static readonly ManualLogSource Logger = AIRefactoredController.Logger;
        private static readonly List<BotOwner> TeammateBuffer = new List<BotOwner>(16);
        private static readonly List<Item> ItemBuffer = new List<Item>(64);

        private readonly BotOwner _bot;
        private readonly BotComponentCache _cache;
        private readonly BotGroupSyncCoordinator? _group;
        private readonly BotPersonalityProfile _profile;

        private int _fallbackAttempts;
        private float _lastMoveTime;
        private float _stuckSince;
        private Vector3 _lastPos;

        /// <summary>
        /// Initializes a new instance of the <see cref="MissionEvaluator"/> class.
        /// </summary>
        /// <param name="bot">Bot owner reference.</param>
        /// <param name="cache">Bot component cache reference.</param>
        public MissionEvaluator(BotOwner bot, BotComponentCache cache)
        {
            this._bot = bot ?? throw new ArgumentNullException(nameof(bot));
            this._cache = cache ?? throw new ArgumentNullException(nameof(cache));
            this._profile = BotRegistry.Get(bot.Profile.Id);
            this._group = BotCacheUtility.GetGroupSync(cache);
            this._lastPos = bot.Position;
            this._lastMoveTime = Time.time;
        }

        /// <summary>
        /// Checks if the bot's group is sufficiently cohesive.
        /// </summary>
        public bool IsGroupAligned()
        {
            if (this._group == null)
            {
                return true;
            }

            TeammateBuffer.Clear();
            TeammateBuffer.AddRange(this._group.GetTeammates());

            int near = 0;
            for (int i = 0; i < TeammateBuffer.Count; i++)
            {
                BotOwner mate = TeammateBuffer[i];
                if (mate != null && Vector3.Distance(mate.Position, this._bot.Position) < SquadCohesionRange)
                {
                    near++;
                }
            }

            int required = Mathf.CeilToInt(TeammateBuffer.Count * 0.6f);
            return near >= required;
        }

        /// <summary>
        /// Determines whether the bot should extract early based on loot and caution level.
        /// </summary>
        public bool ShouldExtractEarly()
        {
            float threshold = this._profile.RetreatThreshold;
            Item? backpack = this._bot.GetPlayer?.Inventory?.Equipment?.GetSlot(EquipmentSlot.Backpack)?.ContainedItem;
            if (backpack == null)
            {
                return false;
            }

            ItemBuffer.Clear();
            ItemBuffer.AddRange(backpack.GetAllItems());

            int count = 0;
            for (int i = 0; i < ItemBuffer.Count; i++)
            {
                if (ItemBuffer[i] != null)
                {
                    count++;
                }
            }

            float fullness = (float)count / LootItemCountThreshold;
            return fullness >= threshold && this._profile.Caution > 0.6f && !this._profile.IsFrenzied;
        }

        /// <summary>
        /// Attempts to navigate the bot toward an extraction point.
        /// </summary>
        public void TryExtract()
        {
            try
            {
                ExfiltrationPoint? closest = null;
                float minDist = float.MaxValue;

                ExfiltrationPoint[] allPoints = GameObject.FindObjectsOfType<ExfiltrationPoint>();
                for (int i = 0; i < allPoints.Length; i++)
                {
                    ExfiltrationPoint point = allPoints[i];
                    if (point == null || point.Status != EExfiltrationStatus.RegularMode)
                    {
                        continue;
                    }

                    float dist = Vector3.Distance(this._bot.Position, point.transform.position);
                    if (dist < minDist)
                    {
                        minDist = dist;
                        closest = point;
                    }
                }

                if (closest != null)
                {
                    BotMovementHelper.SmoothMoveTo(this._bot, closest.transform.position);
                    this.Say(EPhraseTrigger.ExitLocated);
                }
            }
            catch (Exception ex)
            {
                Logger.LogWarning($"[MissionEvaluator] Extraction failed: {ex.Message}");
            }
        }

        /// <summary>
        /// Updates stuck detection and attempts fallback movement if necessary.
        /// </summary>
        public void UpdateStuckCheck(float time)
        {
            float moved = Vector3.Distance(this._bot.Position, this._lastPos);
            if (moved > 0.3f)
            {
                this._lastPos = this._bot.Position;
                this._lastMoveTime = time;
                this._fallbackAttempts = 0;
                return;
            }

            if (time - this._lastMoveTime > StuckDuration && time - this._stuckSince > StuckCooldown && this._fallbackAttempts < 2)
            {
                this._stuckSince = time;
                this._fallbackAttempts++;

                Vector3 lookDirection = this._bot.LookDirection;
                Vector3? fallback = HybridFallbackResolver.GetBestRetreatPoint(this._bot, lookDirection);
                if (fallback.HasValue)
                {
                    string nickname = this._bot.Profile?.Info?.Nickname ?? "Unknown";
                    Logger.LogInfo($"[MissionEvaluator] {nickname} fallback #{this._fallbackAttempts} → {fallback.Value}");
                    BotMovementHelper.SmoothMoveTo(this._bot, fallback.Value);
                }
            }
        }

        private void Say(EPhraseTrigger phrase)
        {
            try
            {
                if (!FikaHeadlessDetector.IsHeadless)
                {
                    this._bot.GetPlayer?.Say(phrase);
                }
            }
            catch (Exception ex)
            {
                Logger.LogWarning($"[MissionEvaluator] VO failed: {ex.Message}");
            }
        }
    }
}
