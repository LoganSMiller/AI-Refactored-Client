// <auto-generated>
//   This file is part of AI-Refactored, an open-source project focused on realistic AI behavior in Escape from Tarkov.
//   Licensed under the MIT License. See LICENSE in the repository root for more information.
//
//   THIS FILE IS SYSTEMATICALLY MANAGED.
//   Please follow strict StyleCop, ReSharper, and AI-Refactored code standards for all modifications.
// </auto-generated>

#nullable enable

namespace AIRefactored.AI.Missions
{
    using System;
    using AIRefactored.AI.Core;
    using AIRefactored.AI.Groups;
    using AIRefactored.AI.Missions.Subsystems;
    using AIRefactored.Runtime;
    using BepInEx.Logging;
    using EFT;
    using UnityEngine;
    using Random = UnityEngine.Random;

    /// <summary>
    /// Central runtime mission handler.
    /// Coordinates bot objectives, mission switching, fallback, and extraction.
    /// Modularized into subsystems for maintainability and realism.
    /// </summary>
    public sealed class BotMissionController
    {
        #region Constants

        private const float GroupRejoinTimeout = 20f;
        private const float LootSyncDistance = 7f;

        #endregion

        #region Fields

        private static readonly ManualLogSource Logger = AIRefactoredController.Logger;

        private readonly BotOwner _bot;
        private readonly BotComponentCache _cache;
        private readonly MissionEvaluator _evaluator;
        private readonly ObjectiveController _objectives;
        private readonly MissionSwitcher _switcher;
        private readonly MissionVoiceCoordinator _voice;
        private readonly BotExtractionDecisionSystem _extraction;

        private bool _forcedMission;
        private bool _inCombatPause;
        private float _groupWaitStart = -1f;
        private float _lastCombatTime;
        private float _lastUpdate;

        private MissionType _missionType;

        #endregion

        #region Enums

        /// <summary>
        /// Defines major mission modes the bot can follow.
        /// </summary>
        public enum MissionType
        {
            Loot,
            Fight,
            Quest
        }

        #endregion

        #region Constructor

        /// <summary>
        /// Constructs and initializes the bot mission controller.
        /// </summary>
        public BotMissionController(BotOwner bot, BotComponentCache cache)
        {
            this._bot = bot ?? throw new ArgumentNullException(nameof(bot));
            this._cache = cache ?? throw new ArgumentNullException(nameof(cache));

            this._switcher = new MissionSwitcher(bot, cache);
            this._objectives = new ObjectiveController(bot, cache);
            this._evaluator = new MissionEvaluator(bot, cache);
            this._voice = new MissionVoiceCoordinator(bot);
            this._extraction = new BotExtractionDecisionSystem(bot, cache, cache.AIRefactoredBotOwner?.PersonalityProfile ?? new BotPersonalityProfile());

            GroupMissionCoordinator.RegisterFromBot(bot);
            this._missionType = GroupMissionCoordinator.GetMissionForGroup(bot);

            this._objectives.SetInitialObjective(this._missionType);
            this._cache.AIRefactoredBotOwner?.SetMissionController(this);

            Logger.LogDebug($"[BotMissionController] Assigned mission: {this._missionType} for bot {bot.Profile?.Info?.Nickname ?? "Unknown"}");
        }

        #endregion

        #region Public Methods

        /// <summary>
        /// Assigns a forced mission mode, disabling automatic switching.
        /// </summary>
        public void SetForcedMission(MissionType mission)
        {
            this._missionType = mission;
            this._forcedMission = true;
        }

        /// <summary>
        /// Updates the mission logic each frame.
        /// </summary>
        public void Tick(float time)
        {
            if (this._bot.IsDead ||
                this._bot.GetPlayer == null ||
                this._bot.GetPlayer.HealthController == null ||
                !this._bot.GetPlayer.HealthController.IsAlive)
            {
                return;
            }

            if (this._cache.IsBlinded || (this._cache.PanicHandler?.IsPanicking ?? false))
            {
                return;
            }

            this._evaluator.UpdateStuckCheck(time);

            if (!this._forcedMission)
            {
                this._switcher.Evaluate(
                    ref this._missionType,
                    time,
                    this.SwitchToFight,
                    this._objectives.ResumeQuesting,
                    this._evaluator.IsGroupAligned);
            }

            if (this._cache.Combat?.IsInCombatState() == true)
            {
                this._lastCombatTime = time;

                if (this._missionType == MissionType.Quest)
                {
                    this._inCombatPause = true;
                }
            }

            if (this._inCombatPause && time - this._lastCombatTime > 4f)
            {
                this._inCombatPause = false;
                this._objectives.ResumeQuesting();
            }

            this._extraction.Tick(time);

            if (!this._evaluator.IsGroupAligned() && this._missionType != MissionType.Fight)
            {
                if (this._groupWaitStart < 0f)
                {
                    this._groupWaitStart = time;
                }

                if (time - this._groupWaitStart < GroupRejoinTimeout)
                {
                    return;
                }

                this._groupWaitStart = -1f;
            }
            else
            {
                this._groupWaitStart = -1f;
            }

            if (time - this._lastUpdate > this.GetCooldown())
            {
                this._objectives.OnObjectiveReached(this._missionType);
                this._lastUpdate = time;
            }

            if (!this._inCombatPause &&
                Vector3.Distance(this._bot.Position, this._objectives.CurrentObjective) < LootSyncDistance)
            {
                this.OnObjectiveReached();
            }
        }

        #endregion

        #region Private Methods

        private void OnObjectiveReached()
        {
            if (this._missionType == MissionType.Loot &&
                this._cache.LootScanner != null &&
                this._cache.GroupBehavior?.GroupSync != null)
            {
                Vector3 myPos = this._bot.Position;

                // Broadcast loot to squad
                this._cache.GroupBehavior.GroupSync.BroadcastLootPoint(myPos);

                // Cancel if fallback/danger active
                Vector3? fallback = this._cache.GroupBehavior.GroupSync.GetSharedFallbackTarget();
                if (fallback.HasValue && Vector3.Distance(myPos, fallback.Value) > 4f)
                {
                    Logger.LogDebug("[BotMissionController] Loot canceled — squad fallback active.");
                    return;
                }

                this._cache.Movement?.EnterLootingMode();
                this._cache.PoseController?.LockCrouchPose();

                this._cache.LootScanner.TryLootNearby();
                this._cache.DeadBodyScanner?.TryLootNearby();

                this._cache.Movement?.ExitLootingMode();
                this._voice.OnLoot();
            }

            this._objectives.OnObjectiveReached(this._missionType);
        }

        private void SwitchToFight()
        {
            this._missionType = MissionType.Fight;
            this._objectives.SetInitialObjective(this._missionType);
            this._voice.OnMissionSwitch();

            if (this._bot.Profile?.Info?.GroupId != null)
            {
                GroupMissionCoordinator.ForceMissionForGroup(this._bot.Profile.Info.GroupId, MissionType.Fight);
            }
        }

        private float GetCooldown()
        {
            return 10f + Random.Range(0f, 5f);
        }

        #endregion
    }
}
