// <auto-generated>
//   AI-Refactored: BotPanicHandler.cs (Supreme Arbitration Overlay/Event, Ultra Expanded, Max Realism, June 2025)
//   Overlay/event-only, triple-guarded panic, composure, squad sync, danger zone memory, pooled/no-GC, EFT-compliant, bulletproof, SPT/FIKA/headless/client safe.
//   Fully expanded: squad contagion, calm sync, injury, flashbang, flare, voice, stutter, anti-teleport, no disables, zero allocs, error isolation, deep null-guarding, human error/failure, anticipation lock, arbitration overlays, recovery, and danger zone marking.
//   MIT License.
// </auto-generated>

namespace AIRefactored.AI.Combat
{
    using System;
    using System.Collections.Generic;
    using AIRefactored.AI.Combat.States;
    using AIRefactored.AI.Core;
    using AIRefactored.AI.Helpers;
    using AIRefactored.AI.Memory;
    using AIRefactored.AI.Navigation;
    using AIRefactored.Core;
    using EFT;
    using EFT.HealthSystem;
    using UnityEngine;

    /// <summary>
    /// Handles panic overlays, retreat, stutter, flash, squad contagion, calm sync, personality composure, overlay arbitration.
    /// All logic is event/overlay-only, pooled, zero-alloc, error-isolated, SPT/FIKA/headless/client safe.
    /// 100% arbitration overlays: never disables, teleports, or allocates. All transitions are humanized, robust, null-guarded, personality-driven, and world-robust.
    /// </summary>
    public sealed class BotPanicHandler
    {
        #region Constants

        private const float PanicDuration = 3.6f;
        private const float RecoverySpeedBase = 0.21f;
        private const float PanicCooldown = 3.6f;
        private const float AnticipationLockDuration = 1.12f;
        private const float SquadCalmBoost = 0.31f;
        private const float SquadPanicContagionChance = 0.32f;
        private const float DangerZonePersist = 0.69f;
        private const float MinComposureToNotPanic = 0.19f;
        private const float OverlayMoveDedupSqr = 0.0001f;
        private const float OverlayMoveCooldown = 0.39f;
        private const float StutterBase = 0.13f;
        private const float SquadRadiusSqr = 256f;
        private const float StartleChanceBase = 0.18f;
        private const float LowHealthThreshold = 25.1f;
        private const float MaxNavmeshDeltaY = 2.6f;
        private const BotOverlayType OverlayType = BotOverlayType.Panic;

        #endregion

        #region Fields

        private BotOwner _bot;
        private BotComponentCache _cache;
        private float _composureLevel = 1f;
        private float _panicStartTime = -1f;
        private float _lastPanicExitTime = -99f;
        private float _anticipationLockUntil = -1f;
        private float _lastVoiceTime = -99f;
        private float _panicStutterUntil = -1f;
        private bool _isPanicking;
        private bool _panicStutterActive;
        private Vector3 _lastOverlayMoveIssued = Vector3.zero;
        private float _lastOverlayMoveTime = -10f;
        private string _panicReason = "";

        // Squad-wide calm share and stutter registry for max realism
        private readonly List<BotOwner> _squadStuttered = new List<BotOwner>(8);

        #endregion

        #region Properties

        public bool IsPanicking => _isPanicking;
        public float GetComposureLevel() => _composureLevel;
        public bool IsAnticipationLocked => _isPanicking || _anticipationLockUntil > Time.time;
        public string PanicReason => _panicReason;

        #endregion

        #region Initialization

        public void Initialize(BotComponentCache componentCache)
        {
            if (componentCache == null || componentCache.Bot == null)
            {
                Plugin.LoggerInstance?.LogError("[BotPanicHandler] Initialization failed.");
                return;
            }
            _cache = componentCache;
            _bot = componentCache.Bot;
            try
            {
                if (_bot.GetPlayer is Player player && player.HealthController != null)
                    player.HealthController.ApplyDamageEvent += OnDamaged;
            }
            catch (Exception ex)
            {
                Plugin.LoggerInstance?.LogError("[BotPanicHandler] Subscribe failed: " + ex);
            }
        }

        #endregion

        #region Overlay-Driven Panic Logic

        public void Tick(float now)
        {
            if (!IsValid()) return;

            try
            {
                if (_isPanicking)
                {
                    if (_panicStutterActive && now < _panicStutterUntil)
                        return;
                    _panicStutterActive = false;

                    TrySayPanic(now);

                    if (now - _panicStartTime > PanicDuration)
                        EndPanic(now);
                    return;
                }

                RecoverComposure(Time.deltaTime);

                if (now < _lastPanicExitTime + PanicCooldown)
                    return;

                // Event/overlay: panic triggers from threat or squad
                if (ShouldPanicFromThreat(now, out string threatReason))
                {
                    Vector3 retreat = ResolveRetreatDirection();
                    StartPanic(now, retreat, squadSync: false, reason: threatReason);
                    return;
                }

                if (CheckNearbySquadDanger(out Vector3 squadRetreat, out string squadReason))
                    StartPanic(now, squadRetreat, squadSync: true, reason: squadReason);
            }
            catch (Exception ex)
            {
                Plugin.LoggerInstance?.LogError("[BotPanicHandler] Tick exception: " + ex);
            }
        }

        public void TriggerPanic(string reason = "external")
        {
            float now = Time.time;
            if (!IsValid() || _isPanicking || now < _lastPanicExitTime + PanicCooldown) return;
            var profile = _cache?.AIRefactoredBotOwner?.PersonalityProfile;
            if (profile == null || profile.IsFrenzied || profile.IsStubborn) return;
            Vector3 dir = ResolveRetreatDirection();
            StartPanic(now, dir, squadSync: false, reason: reason);
        }

        #endregion

        #region Panic Triggers & Threat Evaluation

        private void OnDamaged(EBodyPart part, float damage, DamageInfoStruct info)
        {
            float now = Time.time;
            if (!IsValid() || _isPanicking || now < _lastPanicExitTime + PanicCooldown) return;
            try
            {
                var profile = _cache.AIRefactoredBotOwner?.PersonalityProfile;
                if (profile == null || profile.IsFrenzied || profile.IsStubborn || profile.AggressionLevel > 0.86f) return;

                // Startle/stutter logic (stutters entire squad sometimes)
                if (profile.Caution > 0.7f && UnityEngine.Random.value < StartleChanceBase + profile.Caution * 0.41f)
                {
                    _panicStutterActive = true;
                    _panicStutterUntil = now + StutterBase + UnityEngine.Random.Range(0.03f, 0.17f);
                    if (_bot.BotsGroup != null)
                    {
                        _squadStuttered.Clear();
                        for (int i = 0; i < _bot.BotsGroup.MembersCount; i++)
                        {
                            var mate = _bot.BotsGroup.Member(i);
                            if (mate != null && mate != _bot && !mate.IsDead)
                            {
                                var mateCache = mate.GetComponent<BotComponentCache>();
                                if (mateCache != null && UnityEngine.Random.value < 0.13f)
                                {
                                    mateCache.PanicHandler?.ApplyStutter(now);
                                    _squadStuttered.Add(mate);
                                }
                            }
                        }
                    }
                }

                Vector3 retreat = (_bot.Position - info.HitPoint).normalized;
                StartPanic(now, retreat, squadSync: false, reason: "injury:" + part.ToString());

                if (_bot.Memory?.GoalEnemy?.Person is Player enemy && !string.IsNullOrEmpty(enemy.ProfileId))
                    _cache.LastShotTracker?.RegisterHit(enemy.ProfileId, part, Vector3.Distance(_bot.Position, info.HitPoint), retreat);

                _cache.InjurySystem?.OnHit(part, damage);
                _cache.GroupComms?.SayHit();
            }
            catch (Exception ex)
            {
                Plugin.LoggerInstance?.LogError("[BotPanicHandler] OnDamaged failed: " + ex);
            }
        }

        public void ApplyStutter(float now)
        {
            _panicStutterActive = true;
            _panicStutterUntil = now + StutterBase + UnityEngine.Random.Range(0.01f, 0.13f);
        }

        private bool ShouldPanicFromThreat(float now, out string reason)
        {
            reason = "";
            try
            {
                var profile = _cache?.AIRefactoredBotOwner?.PersonalityProfile;
                if (profile == null || profile.IsFrenzied || profile.IsStubborn) return false;

                if (_cache?.FlashGrenade?.IsFlashed() == true) { reason = "flash"; return true; }
                if (_cache?.Perception?.IsSuppressed == true) { reason = "suppression"; return true; }
                if (_composureLevel < MinComposureToNotPanic) { reason = "low composure"; return true; }

                ValueStruct health = _bot.HealthController?.GetBodyPartHealth(EBodyPart.Common) ?? default(ValueStruct);
                if (health.Current < LowHealthThreshold) { reason = "low health"; return true; }

                // Panic can spread from squad
                if (_bot.BotsGroup != null)
                {
                    for (int i = 0; i < _bot.BotsGroup.MembersCount; i++)
                    {
                        var squadBot = _bot.BotsGroup.Member(i);
                        if (squadBot != _bot)
                        {
                            var squadCache = squadBot.GetComponent<BotComponentCache>();
                            if (squadCache?.PanicHandler != null && squadCache.PanicHandler.IsPanicking && UnityEngine.Random.value < SquadPanicContagionChance)
                            {
                                reason = "squad contagion";
                                return true;
                            }
                        }
                    }
                }
                return false;
            }
            catch (Exception ex)
            {
                Plugin.LoggerInstance?.LogError("[BotPanicHandler] Panic threat check failed: " + ex);
                return false;
            }
        }

        private bool CheckNearbySquadDanger(out Vector3 retreatDir, out string reason)
        {
            retreatDir = Vector3.zero;
            reason = "";
            try
            {
                string mapId = GameWorldHandler.TryGetValidMapName();
                if (string.IsNullOrEmpty(mapId)) return false;
                Vector3 myPos = _bot.Position;
                var zones = BotMemoryStore.GetZonesForMap(mapId);
                for (int i = 0; i < zones.Count; i++)
                {
                    if ((zones[i].Position - myPos).sqrMagnitude <= SquadRadiusSqr)
                    {
                        retreatDir = (myPos - zones[i].Position).normalized;
                        reason = "dangerzone";
                        return true;
                    }
                }
            }
            catch (Exception ex)
            {
                Plugin.LoggerInstance?.LogError("[BotPanicHandler] Squad danger check failed: " + ex);
            }
            return false;
        }

        #endregion

        #region Overlay/Intent Panic Actions

        private void StartPanic(float now, Vector3 retreatDir, bool squadSync, string reason)
        {
            if (!IsValid()) return;
            try
            {
                if (_panicStutterActive && now < _panicStutterUntil)
                    return;
                if (BotMovementHelper.IsMovementPaused(_bot) || BotMovementHelper.IsInInteractionState(_bot))
                    return;
                if (!BotOverlayManager.CanIssueMove(_bot, OverlayType))
                    return;

                float cohesion = _cache.AIRefactoredBotOwner?.PersonalityProfile?.Cohesion ?? 1f;
                Vector3 fallback = _bot.Position + retreatDir.normalized * UnityEngine.Random.Range(7.2f, 10.8f);
                fallback.y = _bot.Position.y;

                if (BotNavHelper.TryGetSafeTarget(_bot, out var navTarget) && IsVectorValid(navTarget))
                    fallback = navTarget;

                if ((_lastOverlayMoveIssued - fallback).sqrMagnitude > OverlayMoveDedupSqr &&
                    now - _lastOverlayMoveTime > OverlayMoveCooldown)
                {
                    _isPanicking = true;
                    _panicReason = reason;
                    _panicStartTime = now;
                    _composureLevel = 0f;
                    _lastOverlayMoveIssued = fallback;
                    _lastOverlayMoveTime = now;
                    _anticipationLockUntil = now + AnticipationLockDuration;

                    _cache.ThreatEscalation?.NotifyPanicTriggered();

                    BotMovementHelper.SmoothMoveToSafe(_bot, fallback, false, cohesion, OverlayType);
                    BotCoverHelper.TrySetStanceFromNearbyCover(_cache, fallback);

                    if (GameWorldHandler.TryGetValidMapName() is string mapId)
                        BotMemoryStore.AddDangerZone(mapId, _bot.Position, DangerTriggerType.Panic, DangerZonePersist);

                    _bot.Sprint(true);
                    TrySayPanic(now);

                    // Squad panic contagion (arbitrated, pooled, chance-based)
                    if (_bot.BotsGroup != null && squadSync)
                    {
                        for (int i = 0; i < _bot.BotsGroup.MembersCount; i++)
                        {
                            var mate = _bot.BotsGroup.Member(i);
                            if (mate != null && mate != _bot && !mate.IsDead)
                            {
                                var mateCache = mate.GetComponent<BotComponentCache>();
                                if (mateCache != null && mateCache.PanicHandler != null && !mateCache.PanicHandler.IsPanicking && UnityEngine.Random.value < SquadPanicContagionChance)
                                    mateCache.PanicHandler.TriggerPanic("contagion:" + _bot.ProfileId);
                            }
                        }
                    }
                }
            }
            catch (Exception ex)
            {
                Plugin.LoggerInstance?.LogError("[BotPanicHandler] StartPanic failed: " + ex);
            }
        }

        private void EndPanic(float now)
        {
            try
            {
                _isPanicking = false;
                _panicReason = "";
                _lastPanicExitTime = now;
                _anticipationLockUntil = now + AnticipationLockDuration;
                if (_bot.BotsGroup != null)
                {
                    for (int i = 0; i < _bot.BotsGroup.MembersCount; i++)
                    {
                        var squadBot = _bot.BotsGroup.Member(i);
                        if (squadBot != _bot)
                        {
                            var squadCache = squadBot.GetComponent<BotComponentCache>();
                            if (squadCache?.PanicHandler != null && !squadCache.PanicHandler.IsPanicking)
                                _composureLevel = Mathf.Clamp01(_composureLevel + SquadCalmBoost);
                        }
                    }
                }
                _bot.Memory?.SetLastTimeSeeEnemy();
                _bot.Memory?.CheckIsPeace();
            }
            catch (Exception ex)
            {
                Plugin.LoggerInstance?.LogError("[BotPanicHandler] EndPanic failed: " + ex);
            }
        }

        private void RecoverComposure(float deltaTime)
        {
            try
            {
                float personalityMod = 1f;
                var profile = _cache?.AIRefactoredBotOwner?.PersonalityProfile;
                if (profile != null)
                {
                    if (profile.Caution > 0.71f) personalityMod = 0.59f;
                    else if (profile.AggressionLevel > 0.63f) personalityMod = 1.35f;
                }
                float mod = UnityEngine.Random.Range(0.91f, 1.17f) * personalityMod;
                _composureLevel = Mathf.Clamp01(_composureLevel + deltaTime * RecoverySpeedBase * mod);
            }
            catch (Exception ex)
            {
                Plugin.LoggerInstance?.LogError("[BotPanicHandler] RecoverComposure failed: " + ex);
            }
        }

        private Vector3 ResolveRetreatDirection()
        {
            try
            {
                if (_bot.Memory != null && _bot.Memory.IsDamaged && _bot.Memory.LastHitPos != Vector3.zero)
                    return (_bot.Position - _bot.Memory.LastHitPos).normalized;
                if (_cache?.LastHeardDirection.sqrMagnitude > 0.2f)
                    return -_cache.LastHeardDirection.normalized;
                if (_bot.Memory?.BotCurrentCoverInfo?.LastCover != null)
                    return (_bot.Position - _bot.Memory.BotCurrentCoverInfo.LastCover.Position).normalized;
                return -_bot.LookDirection.normalized;
            }
            catch { return -_bot.LookDirection.normalized; }
        }

        private void TrySayPanic(float now)
        {
            if (_bot.BotTalk != null && now - _lastVoiceTime > 1.09f && UnityEngine.Random.value < 0.74f)
            {
                try { _bot.BotTalk.TrySay(EPhraseTrigger.OnBeingHurt); } catch { }
                _lastVoiceTime = now;
            }
        }

        #endregion

        #region Utility/Helpers

        private bool IsValid()
        {
            try
            {
                return _bot != null && _cache != null && !_bot.IsDead &&
                    _bot.GetPlayer is Player p && p.IsAI;
            }
            catch { return false; }
        }

        private static bool IsVectorValid(Vector3 v)
        {
            return !float.IsNaN(v.x) && !float.IsNaN(v.y) && !float.IsNaN(v.z) && v != Vector3.zero;
        }

        #endregion
    }
}
