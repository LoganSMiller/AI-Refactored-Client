// <auto-generated>
//   This file is part of AI-Refactored, an open-source project focused on realistic AI behavior in Escape from Tarkov.
//   Licensed under the MIT License. See LICENSE in the repository root for more information.
//
//   THIS FILE IS SYSTEMATICALLY MANAGED.
//   Please follow strict StyleCop, ReSharper, and AI-Refactored code standards for all modifications.
// </auto-generated>

#nullable enable

namespace AIRefactored.AI.Combat
{
    using System;
    using AIRefactored.AI.Core;
    using AIRefactored.AI.Helpers;
    using AIRefactored.AI.Memory;
    using AIRefactored.AI.Optimization;
    using AIRefactored.Core;
    using EFT;
    using EFT.HealthSystem;
    using UnityEngine;

    /// <summary>
    /// Handles bot suppression, flash, injury, and squad danger panic behavior.
    /// Manages composure, retreat direction, danger zones, and voice triggers.
    /// </summary>
    public sealed class BotPanicHandler
    {
        #region Fields

        private const float PanicCooldown = 5.0f;
        private const float PanicDuration = 3.5f;
        private const float RecoverySpeed = 0.2f;
        private const float SquadRadiusSqr = 225f;

        private BotOwner? _bot;
        private BotComponentCache? _cache;
        private float _composureLevel = 1f;
        private bool _isPanicking;
        private float _panicStartTime = -1f;
        private float _lastPanicExitTime = -99f;

        #endregion

        #region Properties

        /// <summary>
        /// Gets a value indicating whether the bot is currently panicking.
        /// </summary>
        public bool IsPanicking => _isPanicking;

        /// <summary>
        /// Gets the current composure level (0-1).
        /// </summary>
        public float GetComposureLevel() => _composureLevel;

        #endregion

        #region Public Methods

        /// <summary>
        /// Initializes the panic handler with required dependencies.
        /// </summary>
        /// <param name="componentCache">The bot's component cache.</param>
        public void Initialize(BotComponentCache componentCache)
        {
            _cache = componentCache ?? throw new ArgumentNullException(nameof(componentCache));
            _bot = componentCache.Bot ?? throw new ArgumentNullException(nameof(componentCache.Bot));

            var player = _bot.GetPlayer;
            if (player != null)
            {
                var health = player.HealthController;
                if (health != null)
                {
                    health.ApplyDamageEvent += OnDamaged;
                }
            }
        }

        /// <summary>
        /// Updates the panic state each frame.
        /// </summary>
        /// <param name="time">The current game time.</param>
        public void Tick(float time)
        {
            if (!IsValid())
            {
                return;
            }

            if (_isPanicking)
            {
                if ((time - _panicStartTime) > PanicDuration)
                {
                    EndPanic(time);
                }

                return;
            }

            RecoverComposure(Time.deltaTime);

            if (time <= (_lastPanicExitTime + PanicCooldown))
            {
                return;
            }

            if (ShouldPanicFromThreat())
            {
                var botRef = _bot;
                if (botRef == null)
                {
                    return;
                }

                var lookDir = botRef.LookDirection;
                StartPanic(time, -lookDir.normalized);
            }
            else if (CheckNearbySquadDanger(out var retreatDir))
            {
                StartPanic(time, retreatDir);
            }
        }

        /// <summary>
        /// Forces the bot to enter a panic state if conditions allow it.
        /// </summary>
        public void TriggerPanic()
        {
            var botRef = _bot;
            var cacheRef = _cache;

            if (botRef == null || cacheRef == null || botRef.IsDead)
            {
                return;
            }

            var player = botRef.GetPlayer;
            if (player == null || !player.IsAI)
            {
                return;
            }

            if (_isPanicking || Time.time < (_lastPanicExitTime + PanicCooldown))
            {
                return;
            }

            var profile = cacheRef.AIRefactoredBotOwner?.PersonalityProfile;
            if (profile == null || profile.IsFrenzied || profile.IsStubborn)
            {
                return;
            }

            var lookDir = botRef.LookDirection;
            StartPanic(Time.time, -lookDir.normalized);
        }

        #endregion

        #region Private Methods

        private bool IsValid()
        {
            var botRef = _bot;
            if (botRef == null || _cache == null || botRef.IsDead)
            {
                return false;
            }

            var player = botRef.GetPlayer;
            return player != null && player.IsAI;
        }

        private void OnDamaged(EBodyPart part, float damage, DamageInfoStruct info)
        {
            if (!IsValid() || _isPanicking || Time.time < (_lastPanicExitTime + PanicCooldown))
            {
                return;
            }

            var botRef = _bot;
            var cacheRef = _cache;

            if (botRef == null || cacheRef == null)
            {
                return;
            }

            var profile = cacheRef.AIRefactoredBotOwner?.PersonalityProfile;
            if (profile == null || profile.IsFrenzied || profile.IsStubborn || profile.AggressionLevel > 0.8f)
            {
                return;
            }

            var retreatDir = (botRef.Position - info.HitPoint).normalized;
            StartPanic(Time.time, retreatDir);

            var enemy = botRef.Memory?.GoalEnemy?.Person;
            if (enemy is IPlayer source)
            {
                cacheRef.LastShotTracker?.RegisterHitBy(source);
            }

            cacheRef.InjurySystem?.OnHit(part, damage);
            cacheRef.GroupComms?.SayHit();
        }


        private bool ShouldPanicFromThreat()
        {
            var botRef = _bot;
            var cacheRef = _cache;

            if (botRef == null || cacheRef == null)
            {
                return false;
            }

            var profile = cacheRef.AIRefactoredBotOwner?.PersonalityProfile;
            if (profile == null || profile.IsFrenzied || profile.IsStubborn)
            {
                return false;
            }

            if (cacheRef.FlashGrenade?.IsFlashed() == true)
            {
                return true;
            }

            var commonHealth = botRef.HealthController.GetBodyPartHealth(EBodyPart.Common);
            return commonHealth.Current < 25f;
        }

        private void RecoverComposure(float deltaTime)
        {
            _composureLevel = Mathf.Clamp01(_composureLevel + (deltaTime * RecoverySpeed));
        }

        private void StartPanic(float now, Vector3 retreatDir)
        {
            if (!IsValid())
            {
                return;
            }

            var botRef = _bot;
            var cacheRef = _cache;

            if (botRef == null || cacheRef == null)
            {
                return;
            }

            _isPanicking = true;
            _panicStartTime = now;
            _composureLevel = 0f;

            var cohesion = cacheRef.AIRefactoredBotOwner?.PersonalityProfile?.Cohesion ?? 1f;
            var fallback = botRef.Position + (retreatDir.normalized * 8f);

            if (cacheRef.Pathing != null)
            {
                var path = BotCoverRetreatPlanner.GetCoverRetreatPath(botRef, retreatDir, cacheRef.Pathing);
                if (path.Count > 0)
                {
                    fallback = (Vector3.Distance(path[0], botRef.Position) < 1f && path.Count > 1) ? path[1] : path[0];
                }
            }

            BotMovementHelper.SmoothMoveTo(botRef, fallback, false, cohesion);
            BotCoverHelper.TrySetStanceFromNearbyCover(cacheRef, fallback);

            BotMemoryStore.AddDangerZone(
                GameWorldHandler.GetCurrentMapName(),
                botRef.Position,
                DangerTriggerType.Panic,
                0.6f);

            botRef.Sprint(true);
            botRef.BotTalk?.TrySay(EPhraseTrigger.OnBeingHurt);
        }


        private void EndPanic(float now)
        {
            _isPanicking = false;
            _lastPanicExitTime = now;

            var botRef = _bot;
            botRef?.Memory?.SetLastTimeSeeEnemy();
            botRef?.Memory?.CheckIsPeace();
        }

        private bool CheckNearbySquadDanger(out Vector3 retreatDir)
        {
            retreatDir = Vector3.zero;
            var botRef = _bot;

            if (botRef == null || botRef.Profile?.Info?.GroupId == null)
            {
                return false;
            }

            var zones = BotMemoryStore.GetZonesForMap(GameWorldHandler.GetCurrentMapName());
            var myPos = botRef.Position;

            foreach (var zone in zones)
            {
                if ((zone.Position - myPos).sqrMagnitude <= SquadRadiusSqr)
                {
                    retreatDir = (myPos - zone.Position).normalized;
                    return true;
                }
            }

            return false;
        }

        #endregion
    }
}
