// <auto-generated>
//   This file is part of AI-Refactored, an open-source project focused on realistic AI behavior in Escape from Tarkov.
//   Licensed under the MIT License. See LICENSE in the repository root for more information.
//
//   THIS FILE IS SYSTEMATICALLY MANAGED.
//   All fallback logic is removed: bot panic logic is always eligible, self-recovering, and never disables the bot.
// </auto-generated>

namespace AIRefactored.AI.Combat
{
    using System;
    using AIRefactored.AI.Core;
    using AIRefactored.AI.Helpers;
    using AIRefactored.AI.Memory;
    using AIRefactored.AI.Navigation;
    using AIRefactored.Core;
    using EFT;
    using EFT.HealthSystem;
    using UnityEngine;

    /// <summary>
    /// Handles bot suppression, flash, injury, and squad danger panic behavior.
    /// Manages composure, retreat direction, danger zones, and voice triggers.
    /// All failures are isolated; panic logic never disables itself, never triggers fallback logic.
    /// </summary>
    public sealed class BotPanicHandler
    {
        private const float PanicCooldown = 5f;
        private const float PanicDuration = 3.5f;
        private const float RecoverySpeed = 0.21f;
        private const float SquadRadiusSqr = 225f;
        private const float LowHealthThreshold = 25f;
        private const float MinHumanDelay = 0.05f;
        private const float MaxHumanDelay = 0.12f;

        private BotOwner _bot;
        private BotComponentCache _cache;

        private float _composureLevel = 1f;
        private float _panicStartTime = -1f;
        private float _lastPanicExitTime = -99f;
        private bool _isPanicking;
        private float _lastVoiceTime = -99f;

        public bool IsPanicking => _isPanicking;

        public float GetComposureLevel() => _composureLevel;

        public void Initialize(BotComponentCache componentCache)
        {
            if (componentCache == null || componentCache.Bot == null)
            {
                Plugin.LoggerInstance?.LogError("[BotPanicHandler] Cannot initialize with null BotComponentCache or Bot.");
                return;
            }

            _cache = componentCache;
            _bot = componentCache.Bot;

            try
            {
                if (_bot.GetPlayer is Player player && player.HealthController != null)
                {
                    player.HealthController.ApplyDamageEvent += OnDamaged;
                }
            }
            catch (Exception ex)
            {
                Plugin.LoggerInstance?.LogError("[BotPanicHandler] Exception subscribing to ApplyDamageEvent: " + ex);
            }
        }

        public void Tick(float time)
        {
            if (!IsValid()) return;

            try
            {
                // Add slight human micro-delay for realism
                if (UnityEngine.Random.value < 0.04f)
                    return;

                if (_isPanicking)
                {
                    // Flinch, heavy breathing, "frozen" moment
                    if (time - _panicStartTime > PanicDuration)
                        EndPanic(time);
                    else if (!FikaHeadlessDetector.IsHeadless && _bot.BotTalk != null && time - _lastVoiceTime > 1.5f && UnityEngine.Random.value < 0.38f)
                    {
                        _lastVoiceTime = time;
                        try { _bot.BotTalk.TrySay(EPhraseTrigger.OnBeingHurt); } catch { }
                    }
                    return;
                }

                RecoverComposure(Time.deltaTime);

                if (time <= _lastPanicExitTime + PanicCooldown)
                    return;

                // Multiple triggers: composure loss, threat, nearby panic, or sudden injury/flash
                if (ShouldPanicFromThreat())
                {
                    Vector3 retreat = -_bot.LookDirection.normalized;
                    TryStartPanic(time, retreat);
                    return;
                }

                if (CheckNearbySquadDanger(out Vector3 squadDir))
                {
                    TryStartPanic(time, squadDir);
                }
            }
            catch (Exception ex)
            {
                Plugin.LoggerInstance?.LogError("[BotPanicHandler] Exception in Tick: " + ex);
            }
        }

        public void TriggerPanic()
        {
            if (!IsValid() || _isPanicking || Time.time < _lastPanicExitTime + PanicCooldown)
                return;

            try
            {
                var profile = _cache.AIRefactoredBotOwner?.PersonalityProfile;
                if (profile == null || profile.IsFrenzied || profile.IsStubborn)
                    return;

                Vector3 retreatDir = -_bot.LookDirection.normalized;
                TryStartPanic(Time.time, retreatDir);
            }
            catch (Exception ex)
            {
                Plugin.LoggerInstance?.LogError("[BotPanicHandler] Exception in TriggerPanic: " + ex);
            }
        }

        private void OnDamaged(EBodyPart part, float damage, DamageInfoStruct info)
        {
            if (!IsValid() || _isPanicking || Time.time < _lastPanicExitTime + PanicCooldown)
                return;

            try
            {
                var profile = _cache.AIRefactoredBotOwner?.PersonalityProfile;
                if (profile == null || profile.IsFrenzied || profile.IsStubborn || profile.AggressionLevel > 0.8f)
                    return;

                Vector3 retreatDir = (_bot.Position - info.HitPoint).normalized;
                TryStartPanic(Time.time, retreatDir);

                if (_bot.Memory?.GoalEnemy?.Person is Player enemy && !string.IsNullOrEmpty(enemy.ProfileId))
                    _cache.LastShotTracker?.RegisterHit(enemy.ProfileId, part, Vector3.Distance(_bot.Position, info.HitPoint), retreatDir);

                _cache.InjurySystem?.OnHit(part, damage);
                _cache.GroupComms?.SayHit();
            }
            catch (Exception ex)
            {
                Plugin.LoggerInstance?.LogError("[BotPanicHandler] Exception in OnDamaged: " + ex);
            }
        }

        private bool ShouldPanicFromThreat()
        {
            try
            {
                var profile = _cache.AIRefactoredBotOwner?.PersonalityProfile;
                if (profile == null || profile.IsFrenzied || profile.IsStubborn)
                    return false;

                // Flash, very low health, or extremely low composure can all panic a bot
                if (_cache.FlashGrenade?.IsFlashed() == true)
                    return true;

                if (_composureLevel < 0.18f)
                    return true;

                if (_bot.HealthController == null)
                    return false;

                ValueStruct health = _bot.HealthController.GetBodyPartHealth(EBodyPart.Common);
                if (health.Current < LowHealthThreshold)
                    return true;

                return false;
            }
            catch (Exception ex)
            {
                Plugin.LoggerInstance?.LogError("[BotPanicHandler] Exception in ShouldPanicFromThreat: " + ex);
                return false;
            }
        }

        private void RecoverComposure(float deltaTime)
        {
            try
            {
                // Human-like: recovery is slightly randomized per frame for organic feel
                float mod = UnityEngine.Random.Range(0.93f, 1.11f);
                _composureLevel = Mathf.Clamp01(_composureLevel + deltaTime * RecoverySpeed * mod);
            }
            catch (Exception ex)
            {
                Plugin.LoggerInstance?.LogError("[BotPanicHandler] Exception in RecoverComposure: " + ex);
            }
        }

        private void TryStartPanic(float now, Vector3 retreatDir)
        {
            if (!IsValid()) return;

            try
            {
                _isPanicking = true;
                _panicStartTime = now;
                _composureLevel = 0f;

                _cache.Escalation?.NotifyPanicTriggered();

                float cohesion = _cache.AIRefactoredBotOwner?.PersonalityProfile?.Cohesion ?? 1f;

                Vector3 fallback = _bot.Position + retreatDir.normalized * UnityEngine.Random.Range(7.5f, 10.5f);
                fallback += UnityEngine.Random.insideUnitSphere * 0.55f;
                fallback.y = _bot.Position.y;

                if (BotNavHelper.TryGetSafeTarget(_bot, out var navTarget) && IsVectorValid(navTarget))
                    fallback = navTarget;

                if (_bot.Mover != null)
                {
                    BotMovementHelper.SmoothMoveTo(_bot, fallback, false, cohesion);
                    BotCoverHelper.TrySetStanceFromNearbyCover(_cache, fallback);
                }

                if (GameWorldHandler.TryGetValidMapName() is string mapId)
                    BotMemoryStore.AddDangerZone(mapId, _bot.Position, DangerTriggerType.Panic, 0.6f);

                _bot.Sprint(true);

                if (!FikaHeadlessDetector.IsHeadless && _bot.BotTalk != null)
                {
                    if (Time.time - _lastVoiceTime > 1.2f && UnityEngine.Random.value < 0.65f)
                    {
                        try { _bot.BotTalk.TrySay(EPhraseTrigger.OnBeingHurt); }
                        catch { }
                        _lastVoiceTime = Time.time;
                    }
                }
            }
            catch (Exception ex)
            {
                Plugin.LoggerInstance?.LogError("[BotPanicHandler] Exception in TryStartPanic: " + ex);
            }
        }

        private void EndPanic(float now)
        {
            try
            {
                _isPanicking = false;
                _lastPanicExitTime = now;

                if (_bot.Memory != null)
                {
                    _bot.Memory.SetLastTimeSeeEnemy();
                    _bot.Memory.CheckIsPeace();
                }
            }
            catch (Exception ex)
            {
                Plugin.LoggerInstance?.LogError("[BotPanicHandler] Exception in EndPanic: " + ex);
            }
        }

        private bool CheckNearbySquadDanger(out Vector3 retreatDir)
        {
            retreatDir = Vector3.zero;

            try
            {
                if (_bot.Profile?.Info?.GroupId == null)
                    return false;

                string mapId = GameWorldHandler.TryGetValidMapName();
                if (string.IsNullOrEmpty(mapId))
                    return false;

                Vector3 myPos = _bot.Position;
                var zones = BotMemoryStore.GetZonesForMap(mapId);

                for (int i = 0; i < zones.Count; i++)
                {
                    if ((zones[i].Position - myPos).sqrMagnitude <= SquadRadiusSqr)
                    {
                        retreatDir = (myPos - zones[i].Position).normalized;
                        return true;
                    }
                }
            }
            catch (Exception ex)
            {
                Plugin.LoggerInstance?.LogError("[BotPanicHandler] Exception in CheckNearbySquadDanger: " + ex);
            }

            return false;
        }

        private bool IsValid()
        {
            try
            {
                return _bot != null &&
                       _cache != null &&
                       !_bot.IsDead &&
                       _bot.GetPlayer is Player p &&
                       p.IsAI;
            }
            catch
            {
                return false;
            }
        }

        private static bool IsVectorValid(Vector3 v)
        {
            return !float.IsNaN(v.x) && !float.IsNaN(v.y) && !float.IsNaN(v.z);
        }
    }
}
