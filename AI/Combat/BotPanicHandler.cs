// <auto-generated>
//   This file is part of AI-Refactored, an open-source project focused on realistic AI behavior in Escape from Tarkov.
//   Licensed under the MIT License. See LICENSE in the repository root for more information.
//
//   THIS FILE IS SYSTEMATICALLY MANAGED.
//   Please follow strict StyleCop, ReSharper, and AI-Refactored code standards for all modifications.
// </auto-generated>

namespace AIRefactored.AI.Combat
{
    using System;
    using AIRefactored.AI.Core;
    using AIRefactored.AI.Helpers;
    using AIRefactored.AI.Memory;
    using AIRefactored.AI.Optimization;
    using AIRefactored.Core;
    using EFT;
    using EFT.HealthSystem;
    using UnityEngine;

    /// <summary>
    /// Handles bot suppression, flash, injury, and squad danger panic behavior.
    /// Manages composure, retreat direction, danger zones, and voice triggers.
    /// </summary>
    public sealed class BotPanicHandler
    {
        #region Constants

        private const float PanicCooldown = 5f;
        private const float PanicDuration = 3.5f;
        private const float RecoverySpeed = 0.2f;
        private const float SquadRadiusSqr = 225f;
        private const float LowHealthThreshold = 25f;

        #endregion

        #region Fields

        private BotOwner _bot;
        private BotComponentCache _cache;
        private float _composureLevel = 1f;
        private bool _isPanicking;
        private float _panicStartTime = -1f;
        private float _lastPanicExitTime = -99f;

        #endregion

        #region Properties

        /// <summary>
        /// Gets whether the bot is currently panicking.
        /// </summary>
        public bool IsPanicking => this._isPanicking;

        #endregion

        #region Public Methods

        /// <summary>
        /// Returns the current bot composure level (0 to 1).
        /// </summary>
        public float GetComposureLevel()
        {
            return this._composureLevel;
        }

        /// <summary>
        /// Initializes the panic handler using a validated bot cache.
        /// </summary>
        public void Initialize(BotComponentCache componentCache)
        {
            if (componentCache == null || componentCache.Bot == null)
                throw new InvalidOperationException("[BotPanicHandler] Cannot initialize with null BotComponentCache or Bot.");

            this._cache = componentCache;
            this._bot = componentCache.Bot;

            EFT.Player player = this._bot.GetPlayer;
            if (player != null && player.HealthController != null)
                player.HealthController.ApplyDamageEvent += this.OnDamaged;
        }

        /// <summary>
        /// Updates panic state and checks for panic triggers.
        /// </summary>
        public void Tick(float time)
        {
            if (!this.IsValid())
                return;

            if (this._isPanicking)
            {
                if (time - this._panicStartTime > PanicDuration)
                    this.EndPanic(time);

                return;
            }

            this.RecoverComposure(Time.deltaTime);

            if (time <= this._lastPanicExitTime + PanicCooldown)
                return;

            if (this.ShouldPanicFromThreat())
            {
                Vector3 retreat = -this._bot.LookDirection.normalized;
                this.TryStartPanic(time, retreat);
            }
            else if (this.CheckNearbySquadDanger(out Vector3 squadDir))
            {
                this.TryStartPanic(time, squadDir);
            }
        }

        /// <summary>
        /// Force panic based on external logic (e.g., hearing something dangerous).
        /// </summary>
        public void TriggerPanic()
        {
            if (!this.IsValid() || this._isPanicking || Time.time < this._lastPanicExitTime + PanicCooldown)
                return;

            BotPersonalityProfile profile = this._cache?.AIRefactoredBotOwner?.PersonalityProfile;
            if (profile == null || profile.IsFrenzied || profile.IsStubborn)
                return;

            Vector3 retreatDir = -this._bot.LookDirection.normalized;
            this.TryStartPanic(Time.time, retreatDir);
        }

        #endregion

        #region Private Methods

        private void OnDamaged(EBodyPart part, float damage, DamageInfoStruct info)
        {
            if (!this.IsValid() || this._isPanicking || Time.time < this._lastPanicExitTime + PanicCooldown)
                return;

            BotPersonalityProfile profile = this._cache?.AIRefactoredBotOwner?.PersonalityProfile;
            if (profile == null || profile.IsFrenzied || profile.IsStubborn || profile.AggressionLevel > 0.8f)
                return;

            Vector3 retreatDir = (this._bot.Position - info.HitPoint).normalized;
            this.TryStartPanic(Time.time, retreatDir);

            IPlayer enemy = this._bot.Memory?.GoalEnemy?.Person;
            if (enemy != null)
                this._cache.LastShotTracker?.RegisterHitBy(enemy);

            this._cache.InjurySystem?.OnHit(part, damage);
            this._cache.GroupComms?.SayHit();
        }

        private bool ShouldPanicFromThreat()
        {
            BotPersonalityProfile profile = this._cache?.AIRefactoredBotOwner?.PersonalityProfile;
            if (profile == null || profile.IsFrenzied || profile.IsStubborn)
                return false;

            if (this._cache.FlashGrenade?.IsFlashed() == true)
                return true;

            ValueStruct health = this._bot?.HealthController?.GetBodyPartHealth(EBodyPart.Common) ?? default(ValueStruct);
            return health.Current < LowHealthThreshold;
        }

        private void RecoverComposure(float deltaTime)
        {
            this._composureLevel = Mathf.Clamp01(this._composureLevel + deltaTime * RecoverySpeed);
        }

        private void TryStartPanic(float now, Vector3 retreatDir)
        {
            if (!this.IsValid())
                return;

            this._isPanicking = true;
            this._panicStartTime = now;
            this._composureLevel = 0f;

            this._cache.Escalation?.NotifyPanicTriggered();

            float cohesion = this._cache.AIRefactoredBotOwner?.PersonalityProfile?.Cohesion ?? 1f;
            Vector3 fallback = this._bot.Position + retreatDir.normalized * 8f;

            if (this._cache.Pathing != null)
            {
                var path = BotCoverRetreatPlanner.GetCoverRetreatPath(this._bot, retreatDir, this._cache.Pathing);
                if (path.Count > 0)
                    fallback = (Vector3.Distance(path[0], this._bot.Position) < 1f && path.Count > 1) ? path[1] : path[0];
            }

            BotMovementHelper.SmoothMoveTo(this._bot, fallback, false, cohesion);
            BotCoverHelper.TrySetStanceFromNearbyCover(this._cache, fallback);

            string mapId = GameWorldHandler.TryGetValidMapName();
            if (mapId != null && mapId.Length > 0)
                BotMemoryStore.AddDangerZone(mapId, this._bot.Position, DangerTriggerType.Panic, 0.6f);

            this._bot.Sprint(true);

            if (!FikaHeadlessDetector.IsHeadless && this._bot.BotTalk != null)
                this._bot.BotTalk.TrySay(EPhraseTrigger.OnBeingHurt);
        }

        private void EndPanic(float now)
        {
            this._isPanicking = false;
            this._lastPanicExitTime = now;

            if (this._bot?.Memory != null)
            {
                this._bot.Memory.SetLastTimeSeeEnemy();
                this._bot.Memory.CheckIsPeace();
            }
        }

        private bool CheckNearbySquadDanger(out Vector3 retreatDir)
        {
            retreatDir = Vector3.zero;

            if (this._bot?.Profile?.Info?.GroupId == null)
                return false;

            string mapId = GameWorldHandler.TryGetValidMapName();
            if (mapId == null || mapId.Length == 0)
                return false;

            Vector3 myPos = this._bot.Position;
            var zones = BotMemoryStore.GetZonesForMap(mapId);
            for (int i = 0; i < zones.Count; i++)
            {
                if ((zones[i].Position - myPos).sqrMagnitude <= SquadRadiusSqr)
                {
                    retreatDir = (myPos - zones[i].Position).normalized;
                    return true;
                }
            }

            return false;
        }

        private bool IsValid()
        {
            return this._bot != null &&
                   this._cache != null &&
                   !this._bot.IsDead &&
                   this._bot.GetPlayer is EFT.Player player &&
                   player.IsAI;
        }

        #endregion
    }
}
