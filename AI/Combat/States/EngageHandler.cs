// <auto-generated>
//   This file is part of AI-Refactored, an open-source project focused on realistic AI behavior in Escape from Tarkov.
//   Licensed under the MIT License. See LICENSE in the repository root for more information.
//
//   THIS FILE IS SYSTEMATICALLY MANAGED.
//   Please follow strict StyleCop, ReSharper, and AI-Refactored code standards for all modifications.
// </auto-generated>

namespace AIRefactored.AI.Combat.States
{
    using System;
    using AIRefactored.AI.Core;
    using AIRefactored.AI.Helpers;
    using EFT;
    using UnityEngine;

    /// <summary>
    /// Guides tactical movement toward enemy's last known location.
    /// Supports cautious advancement and squad-aware pathing.
    /// </summary>
    public sealed class EngageHandler
    {
        #region Constants

        private const float DefaultEngagementRange = 25.0f;

        #endregion

        #region Fields

        private readonly BotOwner _bot;
        private readonly BotComponentCache _cache;
        private readonly float _fallbackRange;

        #endregion

        #region Constructor

        /// <summary>
        /// Initializes a new instance of the <see cref="EngageHandler"/> class.
        /// </summary>
        /// <param name="cache">BotComponentCache to bind with this handler.</param>
        public EngageHandler(BotComponentCache cache)
        {
            if (cache == null)
            {
                throw new ArgumentNullException(nameof(cache));
            }

            BotOwner bot = cache.Bot;
            if (bot == null)
            {
                throw new InvalidOperationException("[EngageHandler] Initialization failed: BotOwner is null.");
            }

            _bot = bot;
            _cache = cache;

            float range = cache.PersonalityProfile != null ? cache.PersonalityProfile.EngagementRange : 0f;
            _fallbackRange = range > 0f ? range : DefaultEngagementRange;
        }

        #endregion

        #region Public Methods

        /// <summary>
        /// Determines if bot should enter or remain in Engage state.
        /// </summary>
        public bool ShallUseNow()
        {
            Vector3 enemyPos;
            CombatStateMachine combat = _cache.Combat;

            return combat != null &&
                   TryGetLastKnownEnemy(combat, out enemyPos) &&
                   !IsWithinRange(enemyPos);
        }

        /// <summary>
        /// Returns true if the bot is close enough to switch from engage to attack.
        /// </summary>
        public bool CanAttack()
        {
            Vector3 enemyPos;
            CombatStateMachine combat = _cache.Combat;

            return combat != null &&
                   TryGetLastKnownEnemy(combat, out enemyPos) &&
                   IsWithinRange(enemyPos);
        }

        /// <summary>
        /// Ticks the engage behavior, advancing toward the enemy's last known position.
        /// </summary>
        public void Tick()
        {
            Vector3 enemyPos;
            CombatStateMachine combat = _cache.Combat;

            if (combat == null || !TryGetLastKnownEnemy(combat, out enemyPos))
            {
                return;
            }

            Vector3 destination = _cache.SquadPath != null
                ? _cache.SquadPath.ApplyOffsetTo(enemyPos)
                : enemyPos;

            if (float.IsNaN(destination.x) || float.IsNaN(destination.y) || float.IsNaN(destination.z))
            {
                return;
            }

            BotMovementHelper.SmoothMoveTo(_bot, destination);
            combat.TrySetStanceFromNearbyCover(destination);
        }

        /// <summary>
        /// Returns true if bot is actively engaging based on memory, not vision.
        /// </summary>
        public bool IsEngaging()
        {
            Vector3 enemyPos;
            CombatStateMachine combat = _cache.Combat;

            return combat != null &&
                   TryGetLastKnownEnemy(combat, out enemyPos) &&
                   !IsWithinRange(enemyPos);
        }

        #endregion

        #region Private Methods

        private bool TryGetLastKnownEnemy(CombatStateMachine combat, out Vector3 result)
        {
            result = combat.LastKnownEnemyPos;
            return result != Vector3.zero;
        }

        private bool IsWithinRange(Vector3 enemyPos)
        {
            float distance = Vector3.Distance(_bot.Position, enemyPos);
            return distance < _fallbackRange;
        }

        #endregion
    }
}
