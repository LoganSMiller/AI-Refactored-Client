// <auto-generated>
//   AI-Refactored: EngageHandler.cs (Supreme Arbitration Overlay/Event Edition, Beyond Diamond, June 2025, Max Realism)
//   Overlay/event-only, triple-guarded, anti-parallel, anti-clump, squad/personality/stance overlays. No teleport, no direct move, never disables, never tick-move.
//   Pooled, bulletproof, event-driven, SPT/FIKA/headless/client parity. MIT License.
// </auto-generated>

namespace AIRefactored.AI.Combat.States
{
    using System;
    using AIRefactored.AI.Core;
    using AIRefactored.AI.Helpers;
    using AIRefactored.AI.Navigation;
    using AIRefactored.Core;
    using EFT;
    using UnityEngine;
    using UnityEngine.AI;

    /// <summary>
    /// Drives overlay/event-only, squad/personality/anti-parallel overlays for approach to last known enemy.
    /// All movement triple-guarded (arbitration, navmesh/y, dedup), anti-parallel, anti-clump. Bulletproof and pooled.
    /// </summary>
    public sealed class EngageHandler
    {
        #region Constants

        private const float DefaultEngagementRange = 25f;
        private const float MinAdvanceDelay = 0.07f;
        private const float MaxAdvanceDelay = 0.19f;
        private const float MaxNavSampleRadius = 1.65f;
        private const float MaxAdvanceDistance = 16.2f;
        private const float MinAdvanceDistance = 0.13f;
        private const float AdvanceSmoothing = 4.6f;
        private const float IdleScanPauseMin = 0.19f;
        private const float IdleScanPauseMax = 0.51f;
        private const float GiveUpDistance = 1.24f;
        private const float LookScanVariance = 0.41f;
        private const float AnticipationPauseMin = 0.09f;
        private const float AnticipationPauseMax = 0.18f;
        private const float GiveUpChanceBase = 0.29f;
        private const float OverlayMoveDedupSqr = 0.00012f;
        private const float OverlayMoveCooldown = 0.45f;
        private const float MaxNavmeshDeltaY = 3.2f;
        private const float SquadSpread = 1.01f;
        private const float AntiClumpRadius = 1.65f;
        private const float MicroJitterDrift = 0.25f;
        private const float OvershootMax = 0.12f;
        private const float VoiceEngageChance = 0.09f;
        private const BotOverlayType OverlayType = BotOverlayType.Engage;

        #endregion

        #region Fields

        private readonly BotOwner _bot;
        private readonly BotComponentCache _cache;
        private readonly float _fallbackRange;
        private float _lastAdvanceTime;
        private Vector3 _lastMoveDir;
        private float _lastIdlePause;
        private float _idlePauseUntil;
        private bool _hasGivenUp;
        private bool _hasArrived;
        private float _anticipateUntil;
        private float _giveUpUntil;
        private Vector3 _lastIssuedMove;
        private float _lastMoveTime;

        #endregion

        #region Construction & Reset

        public EngageHandler(BotComponentCache cache)
        {
            _cache = cache;
            _bot = cache?.Bot;
            float profileRange = cache?.PersonalityProfile?.EngagementRange ?? 0f;
            _fallbackRange = profileRange > 0f ? profileRange : DefaultEngagementRange;
            Clear();
        }

        public void Clear()
        {
            _lastAdvanceTime = -1000f;
            _lastMoveDir = Vector3.zero;
            _lastIdlePause = 0f;
            _idlePauseUntil = 0f;
            _hasGivenUp = false;
            _hasArrived = false;
            _anticipateUntil = 0f;
            _giveUpUntil = 0f;
            _lastIssuedMove = Vector3.zero;
            _lastMoveTime = -10f;
        }

        #endregion

        #region Engagement State

        public bool ShallUseNow()
        {
            return IsCombatCapable() && TryGetLastKnownEnemy(out Vector3 pos) && !IsWithinRange(pos) && !_hasGivenUp;
        }

        public bool CanAttack()
        {
            return IsCombatCapable() && TryGetLastKnownEnemy(out Vector3 pos) && IsWithinRange(pos) && !_hasGivenUp;
        }

        public bool IsEngaging()
        {
            return IsCombatCapable() && TryGetLastKnownEnemy(out Vector3 pos) && !IsWithinRange(pos) && !_hasGivenUp;
        }

        #endregion

        #region Overlay Engagement Logic

        /// <summary>
        /// Overlay/event-only, triple-guarded, anti-clump, anti-parallel, squad/role/personality safe engage overlay move.
        /// </summary>
        public void Tick()
        {
            if (!IsCombatCapable() || _hasGivenUp)
                return;

            try
            {
                if (!TryGetLastKnownEnemy(out Vector3 enemyPos))
                    return;

                float now = Time.time;
                if (!BotOverlayManager.CanIssueMove(_bot, OverlayType))
                    return;
                if (_anticipateUntil > now)
                    return;
                if (BotMovementHelper.IsMovementPaused(_bot) || BotMovementHelper.IsInInteractionState(_bot))
                    return;
                float hesitation = UnityEngine.Random.Range(MinAdvanceDelay, MaxAdvanceDelay);
                if (now - _lastAdvanceTime < hesitation)
                    return;

                float distToTarget = (_bot.Position - enemyPos).magnitude;

                // Idle scan, personality-based give-up/idle
                if (distToTarget < GiveUpDistance)
                {
                    if (!_hasArrived)
                    {
                        _hasArrived = true;
                        float giveUpChance = GiveUpChanceBase + (_cache.PersonalityProfile?.Caution ?? 0.07f);
                        if (UnityEngine.Random.value < giveUpChance)
                        {
                            _hasGivenUp = true;
                            _giveUpUntil = now + UnityEngine.Random.Range(2.2f, 5.2f);
                            if (_bot.BotTalk != null)
                            {
                                try { _bot.BotTalk.TrySay(EPhraseTrigger.Clear); } catch { }
                            }
                        }
                    }
                    if (_idlePauseUntil < now)
                    {
                        _lastIdlePause = UnityEngine.Random.Range(IdleScanPauseMin, IdleScanPauseMax);
                        _idlePauseUntil = now + _lastIdlePause;
                        if (UnityEngine.Random.value < 0.67f)
                            SmoothIdleLookScan();
                        if (_cache.PoseController != null && UnityEngine.Random.value < 0.51f)
                        {
                            if (UnityEngine.Random.value < 0.5f)
                                _cache.PoseController.Crouch();
                            else
                                _cache.PoseController.Stand();
                        }
                    }
                    if (_hasGivenUp && now > _giveUpUntil)
                        _hasGivenUp = false;
                    return;
                }

                _hasArrived = false;
                _lastAdvanceTime = now;

                // Overlay path/offsets, anti-parallel/anti-clump overlays
                Vector3 destination = GetAdjustedAdvanceTarget(enemyPos);
                destination = ApplySquadAntiClump(_bot, destination);
                Vector3 navSafeDest = GetNavMeshSafeDestination(_bot.Position, destination);

                if (!BotNavHelper.IsNavMeshPositionValid(navSafeDest))
                    return;

                float advanceSqr = (navSafeDest - _bot.Position).sqrMagnitude;
                if (_bot.Mover == null || advanceSqr >= MaxAdvanceDistance * MaxAdvanceDistance || advanceSqr < MinAdvanceDistance * MinAdvanceDistance)
                    return;

                Vector3 moveDir = navSafeDest - _bot.Position;
                moveDir.y = 0f;
                if (moveDir.sqrMagnitude < 0.01f)
                    return;

                // Dedup/cooldown/anticipation guard
                if ((_lastIssuedMove - navSafeDest).sqrMagnitude < OverlayMoveDedupSqr)
                    return;
                if ((now - _lastMoveTime) < OverlayMoveCooldown)
                    return;

                if (_lastMoveDir == Vector3.zero)
                    _lastMoveDir = moveDir.normalized;
                float blendT = Mathf.Clamp01(Time.deltaTime * AdvanceSmoothing);
                Vector3 blended = Vector3.Lerp(_lastMoveDir, moveDir.normalized, blendT).normalized;
                _lastMoveDir = blended;

                float cohesion = Mathf.Clamp(_cache.PersonalityProfile?.Cohesion ?? 1f, 0.7f, 1.3f);

                // Post-NavMesh micro-jitter and drift (never before).
                Vector3 humanizedTarget = (_cache.Perception?.IsSuppressed ?? false)
                    ? navSafeDest
                    : BotMovementHelper.ApplyMicroDrift(navSafeDest, _bot.ProfileId, Time.frameCount, _cache.PersonalityProfile);

                if (UnityEngine.Random.value < 0.26f)
                    humanizedTarget += UnityEngine.Random.insideUnitSphere * MicroJitterDrift;

                BotMovementHelper.SmoothMoveToSafe(_bot, humanizedTarget, false, cohesion, OverlayType);
                BotOverlayManager.RegisterMove(_bot, OverlayType);

                _lastIssuedMove = humanizedTarget;
                _lastMoveTime = now;

                ApplyEngagementStance(advanceSqr, navSafeDest);

                if (_bot.BotTalk != null && UnityEngine.Random.value < VoiceEngageChance)
                {
                    try { _bot.BotTalk.TrySay(EPhraseTrigger.GoForward); } catch { }
                }

                // Overlay anticipation/fakeout lock for abrupt direction/turn.
                if ((_lastMoveDir - moveDir.normalized).sqrMagnitude > 0.22f)
                    _anticipateUntil = now + UnityEngine.Random.Range(AnticipationPauseMin, AnticipationPauseMax);

            }
            catch (Exception ex)
            {
                Plugin.LoggerInstance.LogError($"[EngageHandler] Tick error: {ex}");
            }
        }

        #endregion

        #region Utility

        private bool IsCombatCapable()
        {
            return _bot != null && _cache != null && _cache.Combat != null;
        }

        private bool TryGetLastKnownEnemy(out Vector3 result)
        {
            result = _cache?.Combat?.LastKnownEnemyPos ?? Vector3.zero;
            return result != Vector3.zero;
        }

        private bool IsWithinRange(Vector3 enemyPos)
        {
            return (_bot.Position - enemyPos).sqrMagnitude < _fallbackRange * _fallbackRange;
        }

        private Vector3 GetAdjustedAdvanceTarget(Vector3 baseTarget)
        {
            if (_cache.SquadPath != null)
            {
                try { return _cache.SquadPath.ApplyOffsetTo(baseTarget); }
                catch { return baseTarget; }
            }
            Vector3 offsetDir = Vector3.Cross(Vector3.up, _bot.LookDirection.normalized);
            float soloOffset = UnityEngine.Random.Range(-LookScanVariance, LookScanVariance);
            return baseTarget + offsetDir * soloOffset;
        }

        /// <summary>
        /// Applies a post-NavMesh anti-clump drift for squad overlays.
        /// </summary>
        private static Vector3 ApplySquadAntiClump(BotOwner bot, Vector3 dest)
        {
            if (bot?.BotsGroup == null || bot.BotsGroup.MembersCount <= 1) return dest;
            int idx = GetSquadIndex(bot);
            Vector3 perp = Vector3.Cross(Vector3.up, bot.LookDirection.normalized);
            float squadOffset = SquadSpread * (idx - (bot.BotsGroup.MembersCount / 2f));
            dest += perp * squadOffset;
            for (int i = 0; i < bot.BotsGroup.MembersCount; i++)
            {
                var mate = bot.BotsGroup.Member(i);
                if (mate == null || mate == bot) continue;
                if ((dest - mate.Position).magnitude < AntiClumpRadius)
                    dest += UnityEngine.Random.insideUnitSphere * MicroJitterDrift;
            }
            return dest;
        }

        private static Vector3 GetNavMeshSafeDestination(Vector3 origin, Vector3 candidate)
        {
            if (NavMesh.SamplePosition(candidate, out var hit, MaxNavSampleRadius, NavMesh.AllAreas))
            {
                float dist = (hit.position - origin).magnitude;
                if (dist < 0.08f || dist > MaxAdvanceDistance)
                    return origin;
                Vector3 clamped = ClampY(hit.position, origin);
                return IsValid(clamped) ? clamped : origin;
            }
            return origin;
        }

        private static Vector3 ClampY(Vector3 v, Vector3 basePos)
        {
            if (Mathf.Abs(v.y - basePos.y) > MaxNavmeshDeltaY || v.y < -2.5f)
                v.y = basePos.y;
            return v;
        }

        private static bool IsValid(Vector3 v)
        {
            return !float.IsNaN(v.x) && !float.IsNaN(v.y) && !float.IsNaN(v.z)
                && v != Vector3.zero && v.y > -2.5f && Mathf.Abs(v.y) < 1000f;
        }

        private static int GetSquadIndex(BotOwner bot)
        {
            if (bot?.BotsGroup == null) return -1;
            for (int i = 0; i < bot.BotsGroup.MembersCount; i++)
                if (bot.BotsGroup.Member(i) == bot) return i;
            return -1;
        }

        private void ApplyEngagementStance(float advanceSqr, Vector3 moveTarget)
        {
            var pose = _cache?.PoseController;
            if (pose == null) return;
            if (advanceSqr < 9.0f || _cache.PersonalityProfile?.Caution > 0.25f)
                pose.Crouch();
            else if (_cache.PersonalityProfile?.AggressionLevel > 0.7f)
                pose.Stand();
            else
                pose.TrySetStanceFromNearbyCover(moveTarget);
        }

        private void SmoothIdleLookScan()
        {
            if (_bot == null || _bot.Transform == null || _bot.IsDead)
                return;
            Vector3 offset = UnityEngine.Random.insideUnitSphere * 1.6f;
            offset.y = 0f;
            Vector3 lookTarget = _bot.Position + _bot.LookDirection.normalized * 2.9f + offset;
            BotMovementHelper.SmoothLookTo(_bot, lookTarget, 2.9f + UnityEngine.Random.value * 1.7f);
        }

        #endregion
    }
}
