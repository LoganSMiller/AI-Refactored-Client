// <auto-generated>
//   This file is part of AI-Refactored, an open-source project focused on realistic AI behavior in Escape from Tarkov.
//   Licensed under the MIT License. See LICENSE in the repository root for more information.
//
//   THIS FILE IS SYSTEMATICALLY MANAGED.
//   Bulletproof: All errors are locally isolated, never disables itself, never triggers fallback AI.
//   Anti-teleport: All movement is smooth, validated, and strictly path-based.
// </auto-generated>

namespace AIRefactored.AI.Combat.States
{
    using System;
    using AIRefactored.AI.Core;
    using AIRefactored.AI.Helpers;
    using AIRefactored.AI.Navigation;
    using AIRefactored.Core;
    using EFT;
    using UnityEngine;

    /// <summary>
    /// Guides tactical movement toward enemy's last known location.
    /// Supports cautious advancement and squad-aware pathing.
    /// All movement is path-based only—teleportation is strictly forbidden.
    /// Bulletproof: all failures are isolated; never disables itself or squadmates.
    /// </summary>
    public sealed class EngageHandler
    {
        #region Constants

        private const float DefaultEngagementRange = 25.0f;
        private const float MinAdvanceDelay = 0.05f;
        private const float MaxAdvanceDelay = 0.15f;
        private const float MaxNavSampleRadius = 1.5f;
        private const float MaxAdvanceDistance = 16.0f;

        #endregion

        #region Fields

        private readonly BotOwner _bot;
        private readonly BotComponentCache _cache;
        private readonly float _fallbackRange;
        private float _lastAdvanceTime;

        #endregion

        #region Constructor

        public EngageHandler(BotComponentCache cache)
        {
            _cache = cache;
            _bot = cache?.Bot;
            float profileRange = cache?.PersonalityProfile?.EngagementRange ?? 0f;
            _fallbackRange = profileRange > 0f ? profileRange : DefaultEngagementRange;
            _lastAdvanceTime = -1000f;
        }

        #endregion

        #region Public API

        /// <summary>
        /// Should the bot begin tactical engagement movement (not yet in attack range)?
        /// </summary>
        public bool ShallUseNow()
        {
            return IsCombatCapable() && TryGetLastKnownEnemy(out Vector3 pos) && !IsWithinRange(pos);
        }

        /// <summary>
        /// Can the bot attack (in optimal range and position)?
        /// </summary>
        public bool CanAttack()
        {
            return IsCombatCapable() && TryGetLastKnownEnemy(out Vector3 pos) && IsWithinRange(pos);
        }

        /// <summary>
        /// Is the bot actively engaging (closing distance but not yet attacking)?
        /// </summary>
        public bool IsEngaging()
        {
            return IsCombatCapable() && TryGetLastKnownEnemy(out Vector3 pos) && !IsWithinRange(pos);
        }

        /// <summary>
        /// Ticks the engage logic. Handles path-based, anti-teleport approach toward enemy's last known location.
        /// </summary>
        public void Tick()
        {
            if (!IsCombatCapable())
                return;

            try
            {
                if (!TryGetLastKnownEnemy(out Vector3 enemyPos))
                    return;

                float now = Time.time;
                float hesitation = UnityEngine.Random.Range(MinAdvanceDelay, MaxAdvanceDelay);
                if (now - _lastAdvanceTime < hesitation)
                    return;

                _lastAdvanceTime = now;

                Vector3 destination = enemyPos;

                if (_cache.SquadPath != null)
                {
                    try { destination = _cache.SquadPath.ApplyOffsetTo(enemyPos); }
                    catch { destination = enemyPos; }
                }

                // Human-like micro-adjust, but strictly path-based
                destination += UnityEngine.Random.insideUnitSphere * 0.25f;
                destination.y = enemyPos.y;

                // NavMesh validate—no teleportation, never off-mesh, never direct set
                Vector3 safeDest = GetNavMeshSafeDestination(_bot.Position, destination);

                if (!IsValid(safeDest))
                    return;

                if (_bot.Mover != null && (safeDest - _bot.Position).sqrMagnitude < (MaxAdvanceDistance * MaxAdvanceDistance))
                {
                    BotMovementHelper.SmoothMoveTo(_bot, safeDest); // always path-based, never teleports
                    _cache.PoseController?.TrySetStanceFromNearbyCover(safeDest);
                }
                else
                {
                    Plugin.LoggerInstance.LogError("[EngageHandler] BotMover missing or invalid advance distance.");
                }
            }
            catch (Exception ex)
            {
                Plugin.LoggerInstance.LogError($"[EngageHandler] Tick error: {ex}");
            }
        }

        #endregion

        #region Internal Helpers

        private bool IsCombatCapable()
        {
            return _bot != null && _cache != null && _cache.Combat != null;
        }

        private bool TryGetLastKnownEnemy(out Vector3 result)
        {
            result = _cache?.Combat?.LastKnownEnemyPos ?? Vector3.zero;
            return IsValid(result) && result != Vector3.zero;
        }

        private bool IsWithinRange(Vector3 enemyPos)
        {
            return (_bot.Position - enemyPos).sqrMagnitude < (_fallbackRange * _fallbackRange);
        }

        private static bool IsValid(Vector3 pos)
        {
            return !float.IsNaN(pos.x) && !float.IsNaN(pos.y) && !float.IsNaN(pos.z) && pos != Vector3.zero;
        }

        /// <summary>
        /// Ensures a destination is always pathable, never a direct or teleport destination.
        /// </summary>
        private static Vector3 GetNavMeshSafeDestination(Vector3 current, Vector3 candidate)
        {
            UnityEngine.AI.NavMeshHit navHit;
            if (UnityEngine.AI.NavMesh.SamplePosition(candidate, out navHit, MaxNavSampleRadius, UnityEngine.AI.NavMesh.AllAreas))
            {
                // Prevent snap/teleport by capping allowed move distance
                float dist = (navHit.position - current).magnitude;
                if (dist < 0.08f || dist > MaxAdvanceDistance)
                    return current;
                return navHit.position;
            }
            // Fallback: never move if not valid
            return current;
        }

        #endregion
    }
}
