// <auto-generated>
//   AI-Refactored: InvestigateHandler.cs (Beyond Diamond – Hard Realism Edition, Anti-Jitter, Resettable)
//   All investigation is path-based, anticipation-rich, robust, squad/personality/memory-aware, error-isolated.
//   Explicit state clear/give up/anti-jitter. No disables, no fallback AI. 
// </auto-generated>

namespace AIRefactored.AI.Combat.States
{
    using System;
    using AIRefactored.AI.Core;
    using AIRefactored.AI.Helpers;
    using AIRefactored.AI.Memory;
    using AIRefactored.AI.Navigation;
    using AIRefactored.Core;
    using EFT;
    using UnityEngine;
    using UnityEngine.AI;

    /// <summary>
    /// Handles deeply realistic investigation: squad-aware, anticipation-rich, memory/context-driven, dynamic.
    /// All moves are path-based, smooth, anticipation/hesitation layered, and error-isolated.
    /// State is always resettable and anti-jittered. Never disables itself or triggers fallback AI.
    /// </summary>
    public sealed class InvestigateHandler
    {
        #region Constants

        private const float InvestigateCooldown = 10f;
        private const float ScanRadius = 4f;
        private const float SoundReactTime = 1f;
        private const float MaxInvestigateTime = 15f;
        private const float ExitDelayBuffer = 1.25f;
        private const float ActiveWindow = 5f;
        private const float MinCaution = 0.3f;
        private const float MinHumanDelay = 0.07f;
        private const float MaxHumanDelay = 0.18f;
        private const float RandomSweepDistance = 0.65f;
        private const float NavMeshSampleRadius = 1.2f;
        private const float SquadSpread = 0.9f;
        private const float LookScanVariance = 0.28f;
        private const float IdleLookIntervalMin = 0.65f;
        private const float IdleLookIntervalMax = 1.15f;
        private const float GiveUpChanceBase = 0.13f;
        private const float AllClearVoiceChance = 0.25f;

        #endregion

        #region Fields

        private readonly BotOwner _bot;
        private readonly BotComponentCache _cache;
        private readonly BotTacticalMemory _memory;
        private float _lastInvestigateTime = -1000f;
        private float _nextIdleScanTime = -1000f;
        private bool _hasGivenUp = false;
        private bool _hasArrived = false;

        #endregion

        #region Constructor

        public InvestigateHandler(BotComponentCache cache)
        {
            _cache = cache;
            _bot = cache?.Bot;
            _memory = cache?.TacticalMemory;
        }

        #endregion

        #region Public API

        /// <summary>
        /// Resets internal state for a fresh investigation session.
        /// </summary>
        public void Clear()
        {
            _hasGivenUp = false;
            _hasArrived = false;
            _lastInvestigateTime = -1000f;
            _nextIdleScanTime = -1000f;
        }

        /// <summary>
        /// Picks an investigation target (visual > memory > squad > fallback), NavMesh and squad-safe, humanized.
        /// </summary>
        public Vector3 GetInvestigateTarget(Vector3 visualLastKnown)
        {
            try
            {
                Vector3 result = Vector3.zero;
                // Priority: visual > memory > squad > fallback
                if (IsVectorValid(visualLastKnown))
                    result = GetNavMeshSafeTarget(visualLastKnown);
                else if (TryGetMemoryEnemyPosition(out Vector3 memory))
                    result = GetNavMeshSafeTarget(memory);
                else if (TryGetSquadMemory(out Vector3 squadMemory))
                    result = GetNavMeshSafeTarget(squadMemory);
                else
                    result = GetSafeNearbyPosition();

                // Squad anti-cluster
                if (_cache?.SquadPath != null)
                {
                    try { result = _cache.SquadPath.ApplyOffsetTo(result); }
                    catch { }
                }
                else if (_bot?.BotsGroup != null && _bot.BotsGroup.MembersCount > 1)
                {
                    int idx = GetSquadIndex(_bot);
                    Vector3 perp = Vector3.Cross(Vector3.up, _bot.LookDirection.normalized);
                    result += perp * (SquadSpread * (idx - (_bot.BotsGroup.MembersCount / 2f)));
                }

                // Final micro-drift
                result = BotMovementHelper.ApplyMicroDrift(
                    result, _bot.ProfileId, Time.frameCount, _cache?.PersonalityProfile);

                return result;
            }
            catch (Exception ex)
            {
                Plugin.LoggerInstance.LogError($"[InvestigateHandler] GetInvestigateTarget failed: {ex}");
                return _bot?.Position ?? Vector3.zero;
            }
        }

        /// <summary>
        /// Main investigation: path-based, personality, squad, anticipation, comms, stance.
        /// </summary>
        public void Investigate(Vector3 target)
        {
            if (_cache == null || _bot == null)
                return;

            if (_hasGivenUp)
                return;

            try
            {
                float now = Time.time;
                float anticipation = UnityEngine.Random.Range(MinHumanDelay, MaxHumanDelay) * (1f + ((_cache.PersonalityProfile?.Caution ?? 0.1f) * 0.55f));
                if (now - _lastInvestigateTime < anticipation)
                    return;

                _lastInvestigateTime = now;
                Vector3 destination = GetNavMeshSafeTarget(target);

                // Squad anti-cluster (advance and arrival)
                if (_cache.SquadPath != null)
                {
                    try { destination = _cache.SquadPath.ApplyOffsetTo(destination); }
                    catch { }
                }
                else if (_bot?.BotsGroup != null && _bot.BotsGroup.MembersCount > 1)
                {
                    int idx = GetSquadIndex(_bot);
                    Vector3 perp = Vector3.Cross(Vector3.up, _bot.LookDirection.normalized);
                    destination += perp * (SquadSpread * (idx - (_bot.BotsGroup.MembersCount / 2f)));
                }

                // Final micro-drift and personality
                destination = BotMovementHelper.ApplyMicroDrift(
                    destination, _bot.ProfileId, Time.frameCount, _cache.PersonalityProfile);

                float cohesion = 1.0f;
                if (_cache.PersonalityProfile != null)
                    cohesion = Mathf.Clamp(_cache.PersonalityProfile.Cohesion, 0.7f, 1.3f);

                if (_bot.Mover != null)
                {
                    BotMovementHelper.SmoothMoveTo(_bot, destination, slow: true, cohesionScale: cohesion);

                    // Mark cleared in tactical memory
                    _memory?.MarkCleared(destination);

                    // Dynamic stance: crouch if cautious/close, otherwise scan cover
                    if (_cache.PoseController != null)
                    {
                        float close = (_bot.Position - destination).magnitude;
                        float crouchChance = 0.35f + ((_cache.PersonalityProfile?.Caution ?? 0.0f) * 0.45f);
                        if (close < 2.4f && UnityEngine.Random.value < crouchChance)
                            _cache.PoseController.Crouch();
                        else
                            _cache.PoseController.TrySetStanceFromNearbyCover(destination);
                    }

                    // Arrival check: only perform idle scan/give up once per arrival
                    float dist = Vector3.Distance(_bot.Position, destination);
                    if (!_hasArrived && dist < 1.1f)
                    {
                        _hasArrived = true;

                        // “Give up” logic (rare)
                        if (!_hasGivenUp && UnityEngine.Random.value < (GiveUpChanceBase + (_cache.PersonalityProfile?.Caution ?? 0.0f)))
                        {
                            _hasGivenUp = true;
                            if (_bot.BotTalk != null && !FikaHeadlessDetector.IsHeadless && UnityEngine.Random.value < AllClearVoiceChance)
                            {
                                try { _bot.BotTalk.TrySay(EPhraseTrigger.Clear); } catch { }
                            }
                        }

                        // Idle scan
                        PerformIdleLookScan();
                    }
                    else if (dist > 1.2f)
                    {
                        _hasArrived = false; // reset on move away
                    }
                }
                else
                {
                    Plugin.LoggerInstance.LogWarning("[InvestigateHandler] Cannot move, Mover missing.");
                }
            }
            catch (Exception ex)
            {
                Plugin.LoggerInstance.LogError($"[InvestigateHandler] Investigate failed: {ex}");
            }
        }

        public bool ShallUseNow(float now, float lastTransition)
        {
            try
            {
                if (_cache?.AIRefactoredBotOwner?.PersonalityProfile == null)
                    return false;
                if (_cache.AIRefactoredBotOwner.PersonalityProfile.Caution < MinCaution)
                    return false;

                return (_cache.LastHeardTime + SoundReactTime) > now &&
                       (now - lastTransition) > ExitDelayBuffer && !_hasGivenUp;
            }
            catch (Exception ex)
            {
                Plugin.LoggerInstance.LogError($"[InvestigateHandler] ShallUseNow failed: {ex}");
                return false;
            }
        }

        public bool ShouldExit(float now, float lastHitTime, float cooldown)
        {
            try
            {
                float elapsed = now - lastHitTime;
                return _hasGivenUp || elapsed > cooldown || elapsed > MaxInvestigateTime;
            }
            catch (Exception ex)
            {
                Plugin.LoggerInstance.LogError($"[InvestigateHandler] ShouldExit failed: {ex}");
                return true;
            }
        }

        public bool IsInvestigating()
        {
            try
            {
                return (Time.time - _cache.LastHeardTime) <= ActiveWindow && !_hasGivenUp;
            }
            catch (Exception ex)
            {
                Plugin.LoggerInstance.LogError($"[InvestigateHandler] IsInvestigating failed: {ex}");
                return false;
            }
        }

        #endregion

        #region Internals

        private bool TryGetMemoryEnemyPosition(out Vector3 result)
        {
            result = Vector3.zero;
            if (_memory == null)
                return false;

            try
            {
                Vector3? memory = _memory.GetRecentEnemyMemory();
                if (memory.HasValue && IsVectorValid(memory.Value))
                {
                    result = memory.Value;
                    return true;
                }
            }
            catch (Exception ex)
            {
                Plugin.LoggerInstance.LogError($"[InvestigateHandler] Memory lookup failed: {ex}");
            }
            return false;
        }

        private bool TryGetSquadMemory(out Vector3 result)
        {
            result = Vector3.zero;
            if (_bot?.BotsGroup == null || _bot.BotsGroup.MembersCount < 2)
                return false;

            try
            {
                for (int i = 0; i < _bot.BotsGroup.MembersCount; i++)
                {
                    var mate = _bot.BotsGroup.Member(i);
                    if (mate == null || mate == _bot || mate.IsDead) continue;
                    var mateCache = BotCacheUtility.GetCache(mate);
                    if (mateCache?.TacticalMemory != null)
                    {
                        Vector3? squadMemory = mateCache.TacticalMemory.GetRecentEnemyMemory();
                        if (squadMemory.HasValue && IsVectorValid(squadMemory.Value))
                        {
                            result = squadMemory.Value;
                            return true;
                        }
                    }
                }
            }
            catch (Exception ex)
            {
                Plugin.LoggerInstance.LogError($"[InvestigateHandler] Squad memory lookup failed: {ex}");
            }
            return false;
        }

        private Vector3 GetSafeNearbyPosition()
        {
            Vector3 origin = _bot?.Position ?? Vector3.zero;
            Vector3 candidate = origin + UnityEngine.Random.insideUnitSphere * ScanRadius;
            candidate.y = origin.y;

            if (NavMesh.SamplePosition(candidate, out NavMeshHit hit, ScanRadius, NavMesh.AllAreas))
            {
                if (IsVectorValid(hit.position))
                    return hit.position;
            }
            return origin + Vector3.forward * 0.15f;
        }

        private static Vector3 GetNavMeshSafeTarget(Vector3 pos)
        {
            if (NavMesh.SamplePosition(pos, out NavMeshHit hit, NavMeshSampleRadius, NavMesh.AllAreas))
                return hit.position;
            return pos;
        }

        private static int GetSquadIndex(BotOwner bot)
        {
            if (bot == null || bot.BotsGroup == null) return -1;
            int count = bot.BotsGroup.MembersCount;
            for (int i = 0; i < count; i++)
                if (bot.BotsGroup.Member(i) == bot) return i;
            return -1;
        }

        private static bool IsVectorValid(Vector3 v)
        {
            return !float.IsNaN(v.x) && !float.IsNaN(v.y) && !float.IsNaN(v.z) && v != Vector3.zero;
        }

        private void PerformIdleLookScan()
        {
            try
            {
                float now = Time.time;
                if (now < _nextIdleScanTime) return;
                _nextIdleScanTime = now + UnityEngine.Random.Range(IdleLookIntervalMin, IdleLookIntervalMax);

                if (_bot == null || _bot.Transform == null || _bot.IsDead)
                    return;

                Vector3 scanOffset = UnityEngine.Random.insideUnitSphere * 1.6f;
                scanOffset.y = 0f;
                Vector3 lookTarget = _bot.Position + _bot.LookDirection.normalized * 2.4f + scanOffset;
                BotMovementHelper.SmoothLookTo(_bot, lookTarget, 2.2f + UnityEngine.Random.value * 1.4f);
            }
            catch
            {
                // Always silent; never spam errors on scan.
            }
        }

        #endregion
    }
}
