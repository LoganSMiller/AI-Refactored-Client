// <auto-generated>
//   This file is part of AI-Refactored, an open-source project focused on realistic AI behavior in Escape from Tarkov.
//   Licensed under the MIT License. See LICENSE in the repository root for more information.
//
//   THIS FILE IS SYSTEMATICALLY MANAGED.
//   Please follow strict StyleCop, ReSharper, and AI-Refactored code standards for all modifications.
// </auto-generated>

namespace AIRefactored.AI.Combat.States
{
    using System;
    using AIRefactored.AI.Core;
    using AIRefactored.AI.Helpers;
    using AIRefactored.AI.Memory;
    using AIRefactored.Runtime;
    using EFT;
    using UnityEngine;

    /// <summary>
    /// Manages bot investigation behavior when sound or memory suggest enemy presence.
    /// Guides cautious, reactive movement toward enemy vicinity with adaptive stance.
    /// </summary>
    public sealed class InvestigateHandler
    {
        #region Constants

        private const float InvestigateCooldown = 10.0f;
        private const float ScanRadius = 4.0f;
        private const float SoundReactTime = 1.0f;
        private const float MaxInvestigateTime = 15.0f;
        private const float MinCaution = 0.3f;
        private const float ExitDelayBuffer = 1.25f;
        private const float ActiveWindow = 5.0f;

        #endregion

        #region Fields

        private readonly BotOwner _bot;
        private readonly BotComponentCache _cache;
        private readonly BotTacticalMemory _memory;

        #endregion

        #region Constructor

        /// <summary>
        /// Initializes a new instance of the <see cref="InvestigateHandler"/> class.
        /// </summary>
        /// <param name="cache">Bot component cache containing shared systems.</param>
        public InvestigateHandler(BotComponentCache cache)
        {
            if (cache == null || cache.Bot == null || cache.TacticalMemory == null)
            {
                Plugin.LoggerInstance.LogError("[InvestigateHandler] Constructor failed: Cache or required fields are null.");
                throw new InvalidOperationException("InvestigateHandler requires valid cache, BotOwner, and TacticalMemory.");
            }

            _cache = cache;
            _bot = cache.Bot;
            _memory = cache.TacticalMemory;
        }

        #endregion

        #region Public Methods

        /// <summary>
        /// Returns the best candidate position for investigation.
        /// </summary>
        /// <param name="visualLastKnown">Visual enemy position if known, or Vector3.zero.</param>
        public Vector3 GetInvestigateTarget(Vector3 visualLastKnown)
        {
            if (!float.IsNaN(visualLastKnown.x) &&
                !float.IsNaN(visualLastKnown.y) &&
                !float.IsNaN(visualLastKnown.z) &&
                visualLastKnown != Vector3.zero)
            {
                return visualLastKnown;
            }

            Vector3 memoryPos;
            if (TryGetMemoryEnemyPosition(out memoryPos))
            {
                return memoryPos;
            }

            return RandomNearbyPosition();
        }

        /// <summary>
        /// Triggers investigate behavior toward the given position.
        /// </summary>
        /// <param name="target">Investigate location.</param>
        public void Investigate(Vector3 target)
        {
            Vector3 destination = _cache.SquadPath != null
                ? _cache.SquadPath.ApplyOffsetTo(target)
                : target;

            if (float.IsNaN(destination.x) || float.IsNaN(destination.y) || float.IsNaN(destination.z))
            {
                Plugin.LoggerInstance.LogWarning("[InvestigateHandler] Skipped investigation: invalid destination.");
                return;
            }

            BotMovementHelper.SmoothMoveTo(_bot, destination);
            _memory.MarkCleared(destination);

            if (_cache.Combat != null)
            {
                _cache.Combat.TrySetStanceFromNearbyCover(destination);
            }
        }

        /// <summary>
        /// Determines whether investigate state should activate.
        /// </summary>
        /// <param name="time">Current world time.</param>
        /// <param name="lastTransition">Last combat state switch time.</param>
        public bool ShallUseNow(float time, float lastTransition)
        {
            if (_cache.AIRefactoredBotOwner == null)
            {
                return false;
            }

            BotPersonalityProfile profile = _cache.AIRefactoredBotOwner.PersonalityProfile;
            if (profile == null || profile.Caution < MinCaution)
            {
                return false;
            }

            float heardTime = _cache.LastHeardTime;
            return (heardTime + SoundReactTime) > time && (time - lastTransition) > ExitDelayBuffer;
        }

        /// <summary>
        /// Returns true if investigate behavior has expired.
        /// </summary>
        /// <param name="now">Current time.</param>
        /// <param name="lastHitTime">Start time of investigation.</param>
        /// <param name="cooldown">Optional state cooldown.</param>
        public bool ShouldExit(float now, float lastHitTime, float cooldown)
        {
            float elapsed = now - lastHitTime;
            return elapsed > cooldown || elapsed > MaxInvestigateTime;
        }

        /// <summary>
        /// Returns true if bot is within active investigate window.
        /// </summary>
        public bool IsInvestigating()
        {
            return (Time.time - _cache.LastHeardTime) <= ActiveWindow;
        }

        #endregion

        #region Private Methods

        private bool TryGetMemoryEnemyPosition(out Vector3 result)
        {
            Vector3? memory = _memory.GetRecentEnemyMemory();
            if (memory.HasValue)
            {
                Vector3 value = memory.Value;
                if (!float.IsNaN(value.x) && !float.IsNaN(value.y) && !float.IsNaN(value.z))
                {
                    result = value;
                    return true;
                }
            }

            result = Vector3.zero;
            return false;
        }

        private Vector3 RandomNearbyPosition()
        {
            Vector3 basePos = _bot.Position;
            Vector3 offset = UnityEngine.Random.insideUnitSphere * ScanRadius;
            offset.y = 0f;
            return basePos + offset;
        }

        #endregion
    }
}
