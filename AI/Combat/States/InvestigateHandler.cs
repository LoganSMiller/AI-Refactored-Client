// <auto-generated>
//   AI-Refactored: InvestigateHandler.cs (Supreme Arbitration Overlay/Event, Max Realism, June 2025)
//   Overlay/event-only, NavMesh/cover/squad/personality safe, pooled, bulletproof, SPT/FIKA/headless/client parity.
//   Never disables, teleports, or issues per-frame MoveTo. MIT License.
// </auto-generated>

namespace AIRefactored.AI.Combat.States
{
    using System;
    using AIRefactored.AI.Core;
    using AIRefactored.AI.Helpers;
    using AIRefactored.AI.Memory;
    using AIRefactored.AI.Navigation;
    using AIRefactored.Core;
    using EFT;
    using UnityEngine;
    using UnityEngine.AI;

    /// <summary>
    /// Handles all event-driven investigation overlays: realistic search, cover, fallback, stance, voice, squad overlays.
    /// All moves NavMesh-sampled, pooled, error-guarded. Never disables or teleports. Ultra-realistic, headless/MP safe.
    /// </summary>
    public sealed class InvestigateHandler
    {
        #region Constants

        private const float InvestigateCooldown = 10f;
        private const float ScanRadius = 4f;
        private const float SoundReactTime = 1f;
        private const float MaxInvestigateTime = 15f;
        private const float ExitDelayBuffer = 1.25f;
        private const float ActiveWindow = 5f;
        private const float MinCaution = 0.3f;
        private const float MinHumanDelay = 0.07f;
        private const float MaxHumanDelay = 0.18f;
        private const float NavMeshSampleRadius = 1.2f;
        private const float SquadSpread = 0.9f;
        private const float IdleLookIntervalMin = 0.65f;
        private const float IdleLookIntervalMax = 1.15f;
        private const float GiveUpChanceBase = 0.13f;
        private const float AllClearVoiceChance = 0.25f;
        private const float MaxInvestigateMoveDistance = 7.5f;
        private const float MinInvestigateMoveDistance = 0.13f;
        private const float OverlayMoveDedupSqr = 0.0001f;
        private const int BackupNavAttempts = 3;
        private const float MaxNavmeshDeltaY = 3.0f;

        private const BotOverlayType OverlayType = BotOverlayType.Investigate;

        #endregion

        #region Fields

        private readonly BotOwner _bot;
        private readonly BotComponentCache _cache;
        private readonly BotTacticalMemory _memory;
        private float _lastInvestigateTime = -1000f;
        private float _nextIdleScanTime = -1000f;
        private bool _hasGivenUp = false;
        private bool _hasArrived = false;
        private Vector3 _lastIssuedMove = Vector3.zero;

        #endregion

        #region Construction & Reset

        public InvestigateHandler(BotComponentCache cache)
        {
            _cache = cache;
            _bot = cache?.Bot;
            _memory = cache?.TacticalMemory;
        }

        public void Clear()
        {
            _hasGivenUp = false;
            _hasArrived = false;
            _lastInvestigateTime = -1000f;
            _nextIdleScanTime = -1000f;
            _lastIssuedMove = Vector3.zero;
        }

        #endregion

        #region Overlay-Driven Investigation

        /// <summary>
        /// Gets a bulletproof, NavMesh/overlay/personality safe investigation target.
        /// </summary>
        public Vector3 GetInvestigateTarget(Vector3 visualLastKnown)
        {
            Vector3 origin = _bot?.Position ?? Vector3.zero;
            Vector3 result = Vector3.zero;

            if (IsValid(visualLastKnown))
                result = SampleNavMeshBulletproof(visualLastKnown, origin);
            else if (TryGetMemory(out var mem))
                result = SampleNavMeshBulletproof(mem, origin);
            else if (TryGetSquadMemory(out var squad))
                result = SampleNavMeshBulletproof(squad, origin);
            else
                result = SampleNavMeshBulletproof(origin + UnityEngine.Random.insideUnitSphere * ScanRadius, origin);

            // Overlay: squad/role/personality offset overlays after sampling
            if (_cache?.SquadPath != null)
            {
                try { result = _cache.SquadPath.ApplyOffsetTo(result); } catch { }
            }
            else if (_bot?.BotsGroup != null && _bot.BotsGroup.MembersCount > 1)
            {
                int index = GetSquadIndex(_bot);
                Vector3 perp = Vector3.Cross(Vector3.up, _bot.LookDirection.normalized);
                result += perp * (SquadSpread * (index - (_bot.BotsGroup.MembersCount / 2f)));
            }

            return BotMovementHelper.ApplyMicroDrift(result, _bot.ProfileId, Time.frameCount, _cache.PersonalityProfile);
        }

        /// <summary>
        /// Executes an overlay-only, anticipation/cooldown/overlay/stance/voice safe investigation move.
        /// </summary>
        public void Investigate(Vector3 target)
        {
            if (_hasGivenUp || _bot == null || _cache == null) return;

            float now = Time.time;
            float anticipate = UnityEngine.Random.Range(MinHumanDelay, MaxHumanDelay) *
                               (1f + (_cache.PersonalityProfile?.Caution ?? 0.1f) * 0.55f);
            if (now - _lastInvestigateTime < anticipate) return;

            // Overlay arbitration: only one investigation overlay per bot per tick/type
            if (!BotOverlayManager.CanIssueMove(_bot, OverlayType))
                return;

            Vector3 dest = SampleNavMeshBulletproof(target, _bot.Position);

            // Squad/role overlay after NavMesh
            if (_cache?.SquadPath != null)
            {
                try { dest = _cache.SquadPath.ApplyOffsetTo(dest); } catch { }
            }
            else if (_bot?.BotsGroup != null && _bot.BotsGroup.MembersCount > 1)
            {
                int index = GetSquadIndex(_bot);
                Vector3 perp = Vector3.Cross(Vector3.up, _bot.LookDirection.normalized);
                dest += perp * (SquadSpread * (index - (_bot.BotsGroup.MembersCount / 2f)));
            }

            dest = BotMovementHelper.ApplyMicroDrift(dest, _bot.ProfileId, Time.frameCount, _cache.PersonalityProfile);
            float cohesion = Mathf.Clamp(_cache?.PersonalityProfile?.Cohesion ?? 1f, 0.7f, 1.3f);

            float distance = Vector3.Distance(_bot.Position, dest);
            if (distance > MaxInvestigateMoveDistance || distance < MinInvestigateMoveDistance)
                return;
            if ((_lastIssuedMove - dest).sqrMagnitude < OverlayMoveDedupSqr)
                return;
            if (BotMovementHelper.IsMovementPaused(_bot) || BotMovementHelper.IsInInteractionState(_bot))
                return;

            if (_bot.Mover != null)
            {
                BotMovementHelper.SmoothMoveToSafe(_bot, dest, true, cohesion, OverlayType);
                _lastIssuedMove = dest;
                _memory?.MarkCleared(dest);

                if (!_hasArrived && distance < 1.1f)
                {
                    _hasArrived = true;
                    if (!_hasGivenUp && UnityEngine.Random.value < (GiveUpChanceBase + (_cache.PersonalityProfile?.Caution ?? 0)))
                    {
                        _hasGivenUp = true;
                        if (_bot.BotTalk != null && UnityEngine.Random.value < AllClearVoiceChance)
                        {
                            try { _bot.BotTalk.TrySay(EPhraseTrigger.Clear); } catch { }
                        }
                    }
                    PerformIdleScan();
                }
                else if (distance > 1.2f) _hasArrived = false;

                if (_cache?.PoseController != null)
                {
                    if (distance < 2.4f && UnityEngine.Random.value < 0.4f + (_cache.PersonalityProfile?.Caution ?? 0.15f))
                        _cache.PoseController.Crouch();
                    else
                        _cache.PoseController.TrySetStanceFromNearbyCover(dest);
                }
            }

            _lastInvestigateTime = now;
            // Overlay lock released by arbitration manager next tick
        }

        #endregion

        #region Exit/State Logic

        public bool ShallUseNow(float now, float lastTransition)
        {
            return _cache?.AIRefactoredBotOwner?.PersonalityProfile?.Caution >= MinCaution &&
                   (_cache.LastHeardTime + SoundReactTime) > now &&
                   (now - lastTransition) > ExitDelayBuffer && !_hasGivenUp;
        }

        public bool ShouldExit(float now, float lastHit, float cooldown)
        {
            float elapsed = now - lastHit;
            return _hasGivenUp || elapsed > cooldown || elapsed > MaxInvestigateTime;
        }

        public bool IsInvestigating() => (Time.time - _cache.LastHeardTime) <= ActiveWindow && !_hasGivenUp;

        #endregion

        #region Memory/Overlay Helpers

        private bool TryGetMemory(out Vector3 result)
        {
            result = _memory?.GetRecentEnemyMemory() ?? Vector3.zero;
            return IsValid(result);
        }

        private bool TryGetSquadMemory(out Vector3 result)
        {
            result = Vector3.zero;
            if (_bot?.BotsGroup == null) return false;

            for (int i = 0; i < _bot.BotsGroup.MembersCount; i++)
            {
                var mate = _bot.BotsGroup.Member(i);
                if (mate == null || mate == _bot || mate.IsDead) continue;
                var cache = BotCacheUtility.GetCache(mate);
                if (cache?.TacticalMemory != null)
                {
                    Vector3? memory = cache.TacticalMemory.GetRecentEnemyMemory();
                    if (memory.HasValue && IsValid(memory.Value))
                    {
                        result = memory.Value;
                        return true;
                    }
                }
            }
            return false;
        }

        private static Vector3 SampleNavMeshBulletproof(Vector3 candidate, Vector3 origin)
        {
            if (NavMesh.SamplePosition(candidate, out var hit, NavMeshSampleRadius, NavMesh.AllAreas))
                return ClampYValid(hit.position, origin);

            for (int i = 0; i < BackupNavAttempts; i++)
            {
                Vector3 fallback = origin + UnityEngine.Random.insideUnitSphere * (2.0f + i * 0.6f);
                fallback.y = origin.y;
                if (NavMesh.SamplePosition(fallback, out var nav, NavMeshSampleRadius, NavMesh.AllAreas))
                    return ClampYValid(nav.position, origin);
            }

            return ClampYValid(origin, origin);
        }

        private void PerformIdleScan()
        {
            if (Time.time < _nextIdleScanTime) return;
            _nextIdleScanTime = Time.time + UnityEngine.Random.Range(IdleLookIntervalMin, IdleLookIntervalMax);

            Vector3 offset = UnityEngine.Random.insideUnitSphere * 1.6f;
            offset.y = 0;
            BotMovementHelper.SmoothLookTo(_bot, _bot.Position + _bot.LookDirection * 2.4f + offset, 2.4f);
        }

        private static Vector3 ClampYValid(Vector3 v, Vector3 basePos)
        {
            if (Mathf.Abs(v.y - basePos.y) > MaxNavmeshDeltaY || v.y < -2.5f)
                v.y = basePos.y;
            return v;
        }

        private static bool IsValid(Vector3 v)
        {
            return v != Vector3.zero &&
                   !float.IsNaN(v.x) && !float.IsNaN(v.y) && !float.IsNaN(v.z) &&
                   Mathf.Abs(v.y) < 1000f && v.y > -2.5f;
        }

        private static int GetSquadIndex(BotOwner bot)
        {
            if (bot?.BotsGroup == null) return -1;
            for (int i = 0; i < bot.BotsGroup.MembersCount; i++)
                if (bot.BotsGroup.Member(i) == bot) return i;
            return -1;
        }

        #endregion
    }
}
