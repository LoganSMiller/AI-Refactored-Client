// <auto-generated>
//   This file is part of AI-Refactored, an open-source project focused on realistic AI behavior in Escape from Tarkov.
//   Licensed under the MIT License. See LICENSE in the repository root for more information.
//
//   THIS FILE IS SYSTEMATICALLY MANAGED.
//   Please follow strict StyleCop, ReSharper, and AI-Refactored code standards for all modifications.
// </auto-generated>

#nullable enable

namespace AIRefactored.AI.Combat.States
{
    using System;
    using AIRefactored.AI.Core;
    using AIRefactored.AI.Helpers;
    using AIRefactored.AI.Memory;
    using AIRefactored.Runtime;
    using EFT;
    using UnityEngine;

    /// <summary>
    /// Handles investigation behavior when a bot hears or senses enemy presence without visual contact.
    /// Bots move toward the source and dynamically search nearby points to simulate real player behavior.
    /// </summary>
    public sealed class InvestigateHandler
    {
        #region Constants

        private const float InvestigateCooldown = 10.0f;
        private const float ScanRadius = 4.0f;
        private const float SoundReactTime = 1.0f;
        private const float MaxInvestigateTime = 15.0f;

        #endregion

        #region Fields

        private readonly BotOwner _bot;
        private readonly BotComponentCache _cache;
        private readonly BotTacticalMemory _memory;

        #endregion

        #region Constructor

        /// <summary>
        /// Initializes a new instance of the <see cref="InvestigateHandler"/> class.
        /// </summary>
        /// <param name="cache">Bot component cache containing shared systems.</param>
        public InvestigateHandler(BotComponentCache cache)
        {
            if (cache == null)
            {
                AIRefactoredController.Logger.LogError("[InvestigateHandler] ❌ Constructor failed: cache is null.");
                throw new ArgumentNullException(nameof(cache));
            }

            if (cache.Bot == null)
            {
                AIRefactoredController.Logger.LogError("[InvestigateHandler] ❌ Constructor failed: BotOwner is null.");
                throw new InvalidOperationException("InvestigateHandler requires a valid BotOwner.");
            }

            if (cache.TacticalMemory == null)
            {
                AIRefactoredController.Logger.LogError("[InvestigateHandler] ❌ Constructor failed: TacticalMemory is null.");
                throw new InvalidOperationException("InvestigateHandler requires TacticalMemory to function.");
            }

            this._cache = cache;
            this._bot = cache.Bot;
            this._memory = cache.TacticalMemory;
        }

        #endregion

        #region Public Methods

        /// <summary>
        /// Gets the best target to investigate from last known enemy position or memory.
        /// </summary>
        /// <param name="lastKnownEnemyPos">Last known position of enemy if available.</param>
        /// <returns>Investigate target position.</returns>
        public Vector3 GetInvestigateTarget(Vector3? lastKnownEnemyPos)
        {
            if (lastKnownEnemyPos.HasValue)
            {
                return lastKnownEnemyPos.Value;
            }

            Vector3? memoryPos = this._memory.GetRecentEnemyMemory();
            if (memoryPos.HasValue)
            {
                return memoryPos.Value;
            }

            return this.RandomNearbyPosition();
        }

        /// <summary>
        /// Starts an investigation by moving to the target and clearing tactical memory.
        /// </summary>
        /// <param name="target">Investigate position.</param>
        public void Investigate(Vector3 target)
        {
            Vector3 destination = this._cache.SquadPath != null
                ? this._cache.SquadPath.ApplyOffsetTo(target)
                : target;

            if (float.IsNaN(destination.x) || float.IsNaN(destination.y) || float.IsNaN(destination.z))
            {
                AIRefactoredController.Logger.LogWarning("[InvestigateHandler] Skipped investigation: invalid destination.");
                return;
            }

            BotMovementHelper.SmoothMoveTo(this._bot, destination);
            this._memory.MarkCleared(destination);

            if (this._cache.Combat != null)
            {
                this._cache.Combat.TrySetStanceFromNearbyCover(destination);
            }
        }

        /// <summary>
        /// Determines if the bot should transition into Investigate state.
        /// </summary>
        /// <param name="time">Current time.</param>
        /// <param name="lastTransition">Last time the bot changed state.</param>
        /// <returns>True if investigate should activate.</returns>
        public bool ShallUseNow(float time, float lastTransition)
        {
            if (this._cache == null || this._cache.AIRefactoredBotOwner == null)
            {
                return false;
            }

            BotPersonalityProfile? profile = this._cache.AIRefactoredBotOwner.PersonalityProfile;
            if (profile == null || profile.Caution < 0.3f)
            {
                return false;
            }

            bool recentlyHeard = this._cache.LastHeardTime + SoundReactTime > time;
            bool transitionDelayMet = time - lastTransition > 1.25f;

            return recentlyHeard && transitionDelayMet;
        }

        /// <summary>
        /// Determines whether the bot should exit investigate state based on a cooldown.
        /// </summary>
        /// <param name="now">Current time.</param>
        /// <param name="lastHitTime">Last investigate trigger time.</param>
        /// <param name="cooldown">Cooldown duration.</param>
        /// <returns>True if bot should exit investigate.</returns>
        public bool ShouldExit(float now, float lastHitTime, float cooldown)
        {
            return (now - lastHitTime) > cooldown || (now - lastHitTime) > MaxInvestigateTime;
        }

        #endregion

        #region Private Methods

        private Vector3 RandomNearbyPosition()
        {
            Vector3 basePos = this._bot.Position;
            Vector3 jitter = UnityEngine.Random.insideUnitSphere * ScanRadius;
            jitter.y = 0f;
            return basePos + jitter;
        }
        /// <summary>
        /// Returns true if the bot is investigating a recent sound or memory.
        /// </summary>
        public bool IsInvestigating()
        {
            return this._cache.LastHeardTime + 5f > Time.time;
        }

        #endregion
    }
}
