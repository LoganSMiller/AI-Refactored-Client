// <auto-generated>
//   This file is part of AI-Refactored, an open-source project focused on realistic AI behavior in Escape from Tarkov.
//   Licensed under the MIT License. See LICENSE in the repository root for more information.
//
//   THIS FILE IS SYSTEMATICALLY MANAGED.
//   Bulletproof: All errors are locally isolated, never disables itself, never triggers fallback AI.
//   Teleportation forbidden: All investigation movement is path-based, NavMesh-validated, and smooth.
// </auto-generated>

namespace AIRefactored.AI.Combat.States
{
    using System;
    using AIRefactored.AI.Core;
    using AIRefactored.AI.Helpers;
    using AIRefactored.AI.Memory;
    using AIRefactored.AI.Navigation;
    using AIRefactored.Core;
    using EFT;
    using UnityEngine;
    using UnityEngine.AI;

    /// <summary>
    /// Manages bot investigation behavior when sound or memory suggest enemy presence.
    /// Guides cautious, reactive movement toward enemy vicinity with adaptive stance.
    /// Bulletproof: All errors are locally isolated, never disables itself, never triggers fallback AI.
    /// All investigation moves are NavMesh validated and never cause instant relocation.
    /// </summary>
    public sealed class InvestigateHandler
    {
        #region Constants

        private const float InvestigateCooldown = 10f;
        private const float ScanRadius = 4f;
        private const float SoundReactTime = 1f;
        private const float MaxInvestigateTime = 15f;
        private const float ExitDelayBuffer = 1.25f;
        private const float ActiveWindow = 5f;
        private const float MinCaution = 0.3f;
        private const float MinHumanDelay = 0.07f;
        private const float MaxHumanDelay = 0.18f;
        private const float RandomSweepDistance = 0.65f;
        private const float NavMeshSampleRadius = 1.2f;

        #endregion

        #region Fields

        private readonly BotOwner _bot;
        private readonly BotComponentCache _cache;
        private readonly BotTacticalMemory _memory;
        private float _lastInvestigateTime = -1000f;

        #endregion

        #region Constructor

        public InvestigateHandler(BotComponentCache cache)
        {
            _cache = cache;
            _bot = cache?.Bot;
            _memory = cache?.TacticalMemory;
        }

        #endregion

        #region Main API

        /// <summary>
        /// Picks an investigation target, always NavMesh safe and human-randomized.
        /// </summary>
        public Vector3 GetInvestigateTarget(Vector3 visualLastKnown)
        {
            try
            {
                if (IsVectorValid(visualLastKnown))
                    return GetNavMeshSafeTarget(ApplyHumanRandomness(visualLastKnown));

                if (TryGetMemoryEnemyPosition(out Vector3 memory))
                    return GetNavMeshSafeTarget(ApplyHumanRandomness(memory));

                return GetSafeNearbyPosition();
            }
            catch (Exception ex)
            {
                Plugin.LoggerInstance.LogError($"[InvestigateHandler] GetInvestigateTarget failed: {ex}");
                return _bot?.Position ?? Vector3.zero;
            }
        }

        /// <summary>
        /// Orders a move to an investigation target. Only issues path-based move commands.
        /// </summary>
        public void Investigate(Vector3 target)
        {
            if (_cache == null || _bot == null)
                return;

            try
            {
                float now = Time.time;
                float hesitation = UnityEngine.Random.Range(MinHumanDelay, MaxHumanDelay);
                if (now - _lastInvestigateTime < hesitation)
                    return;

                _lastInvestigateTime = now;

                Vector3 destination = target;
                if (_cache.SquadPath != null)
                {
                    try { destination = _cache.SquadPath.ApplyOffsetTo(target); }
                    catch { destination = target; }
                }

                destination = ApplyHumanRandomness(destination);
                destination = GetNavMeshSafeTarget(destination);

                if (_bot.Mover != null)
                {
                    BotMovementHelper.SmoothMoveTo(_bot, destination);
                    _memory?.MarkCleared(destination);
                    _cache.Combat?.TrySetStanceFromNearbyCover(destination);
                }
                else
                {
                    Plugin.LoggerInstance.LogWarning("[InvestigateHandler] Cannot move, Mover missing.");
                }
            }
            catch (Exception ex)
            {
                Plugin.LoggerInstance.LogError($"[InvestigateHandler] Investigate failed: {ex}");
            }
        }

        /// <summary>
        /// Whether the bot should enter investigation mode.
        /// </summary>
        public bool ShallUseNow(float now, float lastTransition)
        {
            try
            {
                if (_cache?.AIRefactoredBotOwner?.PersonalityProfile == null)
                    return false;

                if (_cache.AIRefactoredBotOwner.PersonalityProfile.Caution < MinCaution)
                    return false;

                return (_cache.LastHeardTime + SoundReactTime) > now &&
                       (now - lastTransition) > ExitDelayBuffer;
            }
            catch (Exception ex)
            {
                Plugin.LoggerInstance.LogError($"[InvestigateHandler] ShallUseNow failed: {ex}");
                return false;
            }
        }

        public bool ShouldExit(float now, float lastHitTime, float cooldown)
        {
            try
            {
                float elapsed = now - lastHitTime;
                return elapsed > cooldown || elapsed > MaxInvestigateTime;
            }
            catch (Exception ex)
            {
                Plugin.LoggerInstance.LogError($"[InvestigateHandler] ShouldExit failed: {ex}");
                return true;
            }
        }

        public bool IsInvestigating()
        {
            try
            {
                return (Time.time - _cache.LastHeardTime) <= ActiveWindow;
            }
            catch (Exception ex)
            {
                Plugin.LoggerInstance.LogError($"[InvestigateHandler] IsInvestigating failed: {ex}");
                return false;
            }
        }

        #endregion

        #region Internals

        private bool TryGetMemoryEnemyPosition(out Vector3 result)
        {
            result = Vector3.zero;
            if (_memory == null)
                return false;

            try
            {
                Vector3? memory = _memory.GetRecentEnemyMemory();
                if (memory.HasValue && IsVectorValid(memory.Value))
                {
                    result = memory.Value;
                    return true;
                }
            }
            catch (Exception ex)
            {
                Plugin.LoggerInstance.LogError($"[InvestigateHandler] Memory lookup failed: {ex}");
            }

            return false;
        }

        /// <summary>
        /// Returns a random, NavMesh-safe local position as a last resort.
        /// </summary>
        private Vector3 GetSafeNearbyPosition()
        {
            Vector3 origin = _bot?.Position ?? Vector3.zero;
            Vector3 candidate = origin + UnityEngine.Random.insideUnitSphere * ScanRadius;
            candidate.y = origin.y;

            if (NavMesh.SamplePosition(candidate, out NavMeshHit hit, ScanRadius, NavMesh.AllAreas))
            {
                if (IsVectorValid(hit.position))
                    return hit.position;
            }

            return origin + Vector3.forward * 0.15f;
        }

        /// <summary>
        /// Applies randomization and ensures result is always on NavMesh, never causes teleport.
        /// </summary>
        private static Vector3 GetNavMeshSafeTarget(Vector3 pos)
        {
            if (NavMesh.SamplePosition(pos, out NavMeshHit hit, NavMeshSampleRadius, NavMesh.AllAreas))
                return hit.position;
            return pos;
        }

        private Vector3 ApplyHumanRandomness(Vector3 pos)
        {
            float caution = _cache?.AIRefactoredBotOwner?.PersonalityProfile?.Caution ?? 0.5f;
            float maxOffset = Mathf.Lerp(RandomSweepDistance, 0.16f, caution);
            Vector3 jitter = UnityEngine.Random.insideUnitSphere * maxOffset;
            jitter.y = 0f;
            return pos + jitter;
        }

        private static bool IsVectorValid(Vector3 v)
        {
            return !float.IsNaN(v.x) && !float.IsNaN(v.y) && !float.IsNaN(v.z) && v != Vector3.zero;
        }

        #endregion
    }
}
