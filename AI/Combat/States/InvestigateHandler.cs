// <auto-generated>
//   AI-Refactored: InvestigateHandler.cs (Supreme Arbitration Overlay/Event, Beyond Diamond, June 2025)
//   Overlay/event-only, NavMesh/cover/squad/personality/anti-clump safe, pooled, bulletproof. SPT/FIKA/headless/client parity.
//   No disables, no teleport, never tick-move. Anti-loop, anti-spam, zero alloc in hot path. MIT License.
// </auto-generated>

namespace AIRefactored.AI.Combat.States
{
    using System;
    using AIRefactored.AI.Core;
    using AIRefactored.AI.Helpers;
    using AIRefactored.AI.Memory;
    using AIRefactored.AI.Navigation;
    using AIRefactored.Core;
    using EFT;
    using UnityEngine;
    using UnityEngine.AI;

    /// <summary>
    /// Handles all event-driven investigation overlays: NavMesh, squad, personality, anti-clump overlays.
    /// Overlay-only, pooled, zero alloc in hot path, bulletproof, SPT/FIKA/headless/client parity, error-proof.
    /// </summary>
    public sealed class InvestigateHandler
    {
        #region Constants

        private const float InvestigateCooldown = 10f;
        private const float ScanRadius = 4f;
        private const float SoundReactTime = 1f;
        private const float MaxInvestigateTime = 15f;
        private const float ExitDelayBuffer = 1.25f;
        private const float ActiveWindow = 5f;
        private const float MinCaution = 0.3f;
        private const float MinHumanDelay = 0.07f;
        private const float MaxHumanDelay = 0.18f;
        private const float NavMeshSampleRadius = 1.2f;
        private const float SquadSpread = 0.91f;
        private const float IdleLookIntervalMin = 0.63f;
        private const float IdleLookIntervalMax = 1.13f;
        private const float GiveUpChanceBase = 0.13f;
        private const float AllClearVoiceChance = 0.25f;
        private const float MaxInvestigateMoveDistance = 7.5f;
        private const float MinInvestigateMoveDistance = 0.13f;
        private const float OverlayMoveDedupSqr = 0.0001f;
        private const int BackupNavAttempts = 3;
        private const float MaxNavmeshDeltaY = 3.0f;
        private const float AntiClumpRadius = 1.15f;
        private const float MicroJitter = 0.09f;
        private const BotOverlayType OverlayType = BotOverlayType.Investigate;

        #endregion

        #region Fields

        private readonly BotOwner _bot;
        private readonly BotComponentCache _cache;
        private readonly BotTacticalMemory _memory;
        private float _lastInvestigateTime = -1000f;
        private float _nextIdleScanTime = -1000f;
        private bool _hasGivenUp = false;
        private bool _hasArrived = false;
        private Vector3 _lastIssuedMove = Vector3.zero;

        #endregion

        #region Construction & Reset

        public InvestigateHandler(BotComponentCache cache)
        {
            _cache = cache;
            _bot = cache?.Bot;
            _memory = cache?.TacticalMemory;
        }

        public void Clear()
        {
            _hasGivenUp = false;
            _hasArrived = false;
            _lastInvestigateTime = -1000f;
            _nextIdleScanTime = -1000f;
            _lastIssuedMove = Vector3.zero;
        }

        #endregion

        #region Overlay-Driven Investigation

        /// <summary>
        /// Gets a bulletproof, NavMesh/squad/personality/anti-clump safe investigation target.
        /// </summary>
        public Vector3 GetInvestigateTarget(Vector3 visualLastKnown)
        {
            Vector3 origin = _bot?.Position ?? Vector3.zero;
            Vector3 result = Vector3.zero;

            if (IsValid(visualLastKnown))
                result = SampleNavMeshBulletproof(visualLastKnown, origin);
            else if (TryGetMemory(out var mem))
                result = SampleNavMeshBulletproof(mem, origin);
            else if (TryGetSquadMemory(out var squad))
                result = SampleNavMeshBulletproof(squad, origin);
            else
                result = SampleNavMeshBulletproof(origin + UnityEngine.Random.insideUnitSphere * ScanRadius, origin);

            // Squad/role/personality offset overlays after sampling
            result = ApplySquadOverlay(_bot, _cache, result);
            // Post-NavMesh anti-clump
            result = ApplyAntiClump(_bot, result);

            return BotMovementHelper.ApplyMicroDrift(result, _bot.ProfileId, Time.frameCount, _cache.PersonalityProfile);
        }

        /// <summary>
        /// Executes an overlay-only, anticipation/cooldown/overlay/stance/voice safe investigation move.
        /// </summary>
        public void Investigate(Vector3 target)
        {
            if (_hasGivenUp || _bot == null || _cache == null) return;

            float now = Time.time;
            float anticipate = UnityEngine.Random.Range(MinHumanDelay, MaxHumanDelay) *
                               (1f + (_cache.PersonalityProfile?.Caution ?? 0.1f) * 0.53f);
            if (now - _lastInvestigateTime < anticipate) return;

            // Overlay arbitration: only one investigation overlay per bot per tick/type
            if (!BotOverlayManager.CanIssueMove(_bot, OverlayType))
                return;

            Vector3 dest = SampleNavMeshBulletproof(target, _bot.Position);
            dest = ApplySquadOverlay(_bot, _cache, dest);
            dest = ApplyAntiClump(_bot, dest);

            dest = BotMovementHelper.ApplyMicroDrift(dest, _bot.ProfileId, Time.frameCount, _cache.PersonalityProfile);
            if (UnityEngine.Random.value < 0.24f)
                dest += UnityEngine.Random.insideUnitSphere * MicroJitter;

            float cohesion = Mathf.Clamp(_cache?.PersonalityProfile?.Cohesion ?? 1f, 0.7f, 1.3f);

            float distance = Vector3.Distance(_bot.Position, dest);
            if (distance > MaxInvestigateMoveDistance || distance < MinInvestigateMoveDistance)
                return;
            if ((_lastIssuedMove - dest).sqrMagnitude < OverlayMoveDedupSqr)
                return;
            if (BotMovementHelper.IsMovementPaused(_bot) || BotMovementHelper.IsInInteractionState(_bot))
                return;

            BotMovementHelper.SmoothMoveToSafe(_bot, dest, true, cohesion, OverlayType);
            BotOverlayManager.RegisterMove(_bot, OverlayType);

            _lastIssuedMove = dest;
            _memory?.MarkCleared(dest);

            if (!_hasArrived && distance < 1.1f)
            {
                _hasArrived = true;
                if (!_hasGivenUp && UnityEngine.Random.value < (GiveUpChanceBase + (_cache.PersonalityProfile?.Caution ?? 0)))
                {
                    _hasGivenUp = true;
                    if (_bot.BotTalk != null && UnityEngine.Random.value < AllClearVoiceChance)
                    {
                        try { _bot.BotTalk.TrySay(EPhraseTrigger.Clear); } catch { }
                    }
                }
                PerformIdleScan();
            }
            else if (distance > 1.2f) _hasArrived = false;

            if (_cache?.PoseController != null)
            {
                if (distance < 2.4f && UnityEngine.Random.value < 0.43f + (_cache.PersonalityProfile?.Caution ?? 0.15f))
                    _cache.PoseController.Crouch();
                else
                    _cache.PoseController.TrySetStanceFromNearbyCover(dest);
            }

            _lastInvestigateTime = now;
        }

        #endregion

        #region Exit/State Logic

        public bool ShallUseNow(float now, float lastTransition)
        {
            return _cache?.AIRefactoredBotOwner?.PersonalityProfile?.Caution >= MinCaution &&
                   (_cache.LastHeardTime + SoundReactTime) > now &&
                   (now - lastTransition) > ExitDelayBuffer && !_hasGivenUp;
        }

        public bool ShouldExit(float now, float lastHit, float cooldown)
        {
            float elapsed = now - lastHit;
            return _hasGivenUp || elapsed > cooldown || elapsed > MaxInvestigateTime;
        }

        public bool IsInvestigating() => (Time.time - _cache.LastHeardTime) <= ActiveWindow && !_hasGivenUp;

        #endregion

        #region Memory/Overlay Helpers

        private bool TryGetMemory(out Vector3 result)
        {
            result = _memory?.GetRecentEnemyMemory() ?? Vector3.zero;
            return IsValid(result);
        }

        private bool TryGetSquadMemory(out Vector3 result)
        {
            result = Vector3.zero;
            if (_bot?.BotsGroup == null) return false;

            for (int i = 0; i < _bot.BotsGroup.MembersCount; i++)
            {
                var mate = _bot.BotsGroup.Member(i);
                if (mate == null || mate == _bot || mate.IsDead) continue;
                var cache = BotCacheUtility.GetCache(mate);
                if (cache?.TacticalMemory != null)
                {
                    Vector3? memory = cache.TacticalMemory.GetRecentEnemyMemory();
                    if (memory.HasValue && IsValid(memory.Value))
                    {
                        result = memory.Value;
                        return true;
                    }
                }
            }
            return false;
        }

        private static Vector3 SampleNavMeshBulletproof(Vector3 candidate, Vector3 origin)
        {
            if (NavMesh.SamplePosition(candidate, out var hit, NavMeshSampleRadius, NavMesh.AllAreas))
                return ClampYValid(hit.position, origin);

            for (int i = 0; i < BackupNavAttempts; i++)
            {
                Vector3 fallback = origin + UnityEngine.Random.insideUnitSphere * (2.0f + i * 0.6f);
                fallback.y = origin.y;
                if (NavMesh.SamplePosition(fallback, out var nav, NavMeshSampleRadius, NavMesh.AllAreas))
                    return ClampYValid(nav.position, origin);
            }

            return ClampYValid(origin, origin);
        }

        /// <summary>
        /// Applies squad and personality overlays (offset) to an investigation target.
        /// </summary>
        private static Vector3 ApplySquadOverlay(BotOwner bot, BotComponentCache cache, Vector3 input)
        {
            Vector3 result = input;
            if (cache?.SquadPath != null)
            {
                try { result = cache.SquadPath.ApplyOffsetTo(result); }
                catch { }
            }
            else if (bot?.BotsGroup != null && bot.BotsGroup.MembersCount > 1)
            {
                int idx = GetSquadIndex(bot);
                Vector3 perp = Vector3.Cross(Vector3.up, bot.LookDirection.normalized);
                result += perp * (SquadSpread * (idx - (bot.BotsGroup.MembersCount / 2f)));
            }
            return result;
        }

        /// <summary>
        /// Post-NavMesh anti-clump overlay (prevents investigation stack).
        /// </summary>
        private static Vector3 ApplyAntiClump(BotOwner bot, Vector3 dest)
        {
            if (bot?.BotsGroup == null || bot.BotsGroup.MembersCount <= 1) return dest;
            for (int i = 0; i < bot.BotsGroup.MembersCount; i++)
            {
                var mate = bot.BotsGroup.Member(i);
                if (mate == null || mate == bot) continue;
                if ((dest - mate.Position).magnitude < AntiClumpRadius)
                    dest += UnityEngine.Random.insideUnitSphere * MicroJitter;
            }
            return dest;
        }

        private void PerformIdleScan()
        {
            if (Time.time < _nextIdleScanTime) return;
            _nextIdleScanTime = Time.time + UnityEngine.Random.Range(IdleLookIntervalMin, IdleLookIntervalMax);

            Vector3 offset = UnityEngine.Random.insideUnitSphere * 1.6f;
            offset.y = 0;
            BotMovementHelper.SmoothLookTo(_bot, _bot.Position + _bot.LookDirection * 2.5f + offset, 2.5f);
        }

        private static Vector3 ClampYValid(Vector3 v, Vector3 basePos)
        {
            if (Mathf.Abs(v.y - basePos.y) > MaxNavmeshDeltaY || v.y < -2.5f)
                v.y = basePos.y;
            return v;
        }

        private static bool IsValid(Vector3 v)
        {
            return v != Vector3.zero &&
                   !float.IsNaN(v.x) && !float.IsNaN(v.y) && !float.IsNaN(v.z) &&
                   Mathf.Abs(v.y) < 1000f && v.y > -2.5f;
        }

        private static int GetSquadIndex(BotOwner bot)
        {
            if (bot?.BotsGroup == null) return -1;
            for (int i = 0; i < bot.BotsGroup.MembersCount; i++)
                if (bot.BotsGroup.Member(i) == bot) return i;
            return -1;
        }

        #endregion
    }
}
