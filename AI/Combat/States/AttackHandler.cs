// <auto-generated>
//   AI-Refactored: AttackHandler.cs (Supreme Arbitration Overlay/Event Edition – Max Realism & Robustness, June 2025)
//   Overlay-driven, squad/cover/fakeout/anticipation attack movement. Full arbitration, NavMesh/Y/door/anti-parallel, squad overlays, micro-jitter, zero alloc, error isolation.
//   Only one move per overlay/intent, triple-guard, 1:1 SPT/FIKA/headless/client. Bulletproof. MIT License.
// </auto-generated>

namespace AIRefactored.AI.Combat.States
{
    using System;
    using AIRefactored.AI.Core;
    using AIRefactored.AI.Helpers;
    using AIRefactored.AI.Navigation;
    using AIRefactored.Pools;
    using AIRefactored.Core;
    using EFT;
    using UnityEngine;
    using UnityEngine.AI;
    using AIRefactored.AI.Groups;

    /// <summary>
    /// Drives overlay-only, triple-guarded, anti-parallel, anticipation/overlay/intent attack movement.
    /// Only one move per overlay/intent, squad/role-aware, zero teleports, zero spam, error isolation.
    /// Fully pooled, arbitration-locked, deduped, and NavMesh/Y/door-safe. SPT/FIKA/headless/client parity.
    /// </summary>
    public sealed class AttackHandler
    {
        #region Constants

        private const float PositionUpdateThresholdSqr = 0.31f;
        private const float MicroAdjustRadius = 0.45f;
        private const float MinAdvanceDistance = 1.12f;
        private const float MaxAggroDistance = 55.0f;
        private const float AdvanceIntervalMin = 0.18f;
        private const float AdvanceIntervalMax = 0.33f;
        private const float MoveBlendSpeed = 4.85f;
        private const float SafeMoveMax = 8.7f;
        private const float SafeMoveMin = 0.085f;
        private const float MaxNavmeshDeltaY = 2.1f;
        private const float FakeoutChance = 0.14f;
        private const float FakeoutPauseMin = 0.23f;
        private const float FakeoutPauseMax = 0.41f;
        private const float SquadSpread = 0.99f;
        private const float MaxAntiParallelDist = 2.41f;
        private const float OverlayMoveDedupSqr = 0.00011f;
        private const float OvershootVariance = 0.17f;
        private const float VoiceGoChance = 0.15f;
        private const float VoiceFakeoutChance = 0.11f;
        private const BotOverlayType OverlayType = BotOverlayType.Attack;
        private const float MaxVoiceInterval = 0.41f;
        private const float TargetJumpSqr = 6.25f;
        private const float FakeoutDistSqr = 9.0f;
        private const float AdvanceDistSqr = 12.0f;

        #endregion

        #region Fields

        private readonly BotOwner _bot;
        private readonly BotComponentCache _cache;
        private Vector3 _lastTargetPosition;
        private bool _hasLastTarget;
        private float _nextAdvanceTime;
        private Vector3 _lastMoveDir;
        private Vector3 _lastIssuedMove;
        private float _lastVoiceTime;

        #endregion

        #region Constructor

        /// <summary>
        /// Initializes a new instance of the <see cref="AttackHandler"/> class.
        /// </summary>
        public AttackHandler(BotComponentCache cache)
        {
            _cache = cache;
            _bot = cache?.Bot;
            _lastIssuedMove = Vector3.zero;
            _lastVoiceTime = -10f;
            ClearTarget();
        }

        #endregion

        #region Public API

        /// <summary>
        /// Clears all target/advance state.
        /// </summary>
        public void ClearTarget()
        {
            _hasLastTarget = false;
            _lastTargetPosition = Vector3.zero;
            _nextAdvanceTime = 0f;
            _lastMoveDir = Vector3.zero;
            _lastIssuedMove = Vector3.zero;
        }

        /// <summary>
        /// Returns true if handler should run (valid target exists).
        /// </summary>
        public bool ShallUseNow()
        {
            return TryResolveEnemy(out _);
        }

        /// <summary>
        /// Tick method, called by BotBrain (never per-frame/coroutine).
        /// Centralized, pooled, arbitration-locked attack overlay.
        /// </summary>
        /// <param name="deltaTime">Delta time (tick interval).</param>
        public void Tick(float deltaTime)
        {
            try
            {
                if (_bot == null || _cache == null)
                    return;

                if (!TryResolveEnemy(out Player enemy))
                {
                    ReleaseOverlay();
                    return;
                }

                if (!BotOverlayManager.CanIssueMove(_bot, OverlayType))
                    return;

                Vector3 botPos = EFTPlayerUtil.GetPosition(_bot);
                Vector3 targetPos = EFTPlayerUtil.GetPosition(enemy);
                float distToTarget = (botPos - targetPos).magnitude;
                float now = Time.time;

                // Out of aggro range: cancel overlay and clear.
                if (distToTarget > MaxAggroDistance)
                {
                    ClearTarget();
                    ReleaseOverlay();
                    return;
                }

                float deltaSqr = (targetPos - _lastTargetPosition).sqrMagnitude;
                bool needsAdvance = !_hasLastTarget || deltaSqr > PositionUpdateThresholdSqr || now >= _nextAdvanceTime;

                // Not time for advance, exit overlay immediately (prevents spam/tick-move).
                if (!needsAdvance)
                {
                    ReleaseOverlay();
                    return;
                }

                // Target jump: anticipation/fakeout, say "Go!" if squad.
                if (_hasLastTarget && deltaSqr > TargetJumpSqr)
                {
                    BotOverlayManager.RegisterMove(_bot, OverlayType);
                    TrySayGo(now, 0.97f);
                    ReleaseOverlay();
                    return;
                }

                // Random fakeout pause for realism.
                if (UnityEngine.Random.value < FakeoutChance && deltaSqr > FakeoutDistSqr && !(_cache.Perception?.IsSuppressed ?? false))
                {
                    BotOverlayManager.RegisterMove(_bot, OverlayType);
                    TrySayFakeout(now, 0.79f);
                    ReleaseOverlay();
                    return;
                }

                _lastTargetPosition = targetPos;
                _hasLastTarget = true;
                _nextAdvanceTime = now + UnityEngine.Random.Range(AdvanceIntervalMin, AdvanceIntervalMax);
                if (deltaSqr > AdvanceDistSqr)
                    _nextAdvanceTime += UnityEngine.Random.Range(0.09f, 0.19f);

                // Overlay move intent: cover/squad/fallback/personality/anti-clump/anticipation.
                Vector3 advancePoint = GetAdvancePoint(botPos, targetPos, distToTarget, out bool usedCover, out bool usedSquad);

                // Squad anti-parallel: check close mates and drift to avoid bunching.
                if (_bot.BotsGroup != null && _bot.BotsGroup.MembersCount > 1)
                {
                    for (int i = 0; i < _bot.BotsGroup.MembersCount; i++)
                    {
                        var mate = _bot.BotsGroup.Member(i);
                        if (mate == null || mate == _bot) continue;
                        if ((advancePoint - mate.Position).magnitude < MaxAntiParallelDist)
                            advancePoint += UnityEngine.Random.insideUnitSphere * 0.71f;
                    }
                }

                if (!IsAdvancePointSafe(botPos, advancePoint))
                {
                    ReleaseOverlay();
                    return;
                }

                float cohesion = Mathf.Clamp(_cache.PersonalityProfile?.Cohesion ?? 1f, 0.7f, 1.33f);
                float overshoot = UnityEngine.Random.Range(-OvershootVariance, OvershootVariance);

                Vector3 moveDir = advancePoint - botPos;
                moveDir.y = 0f;
                if (_lastMoveDir == Vector3.zero)
                    _lastMoveDir = moveDir.normalized;
                Vector3 blended = Vector3.Lerp(_lastMoveDir, moveDir.normalized, Mathf.Clamp01(deltaTime * MoveBlendSpeed)).normalized;
                _lastMoveDir = blended;
                Vector3 moveTarget = botPos + blended * Mathf.Clamp(moveDir.magnitude + overshoot, SafeMoveMin, SafeMoveMax);

                // Overlay deduplication (never double-issue, no tick spam).
                if ((_lastIssuedMove - moveTarget).sqrMagnitude < OverlayMoveDedupSqr)
                {
                    ReleaseOverlay();
                    return;
                }

                // Arbitration: single pooled move, max safety, error-guarded.
                BotMovementHelper.SmoothMoveToSafe(_bot, moveTarget, false, cohesion, OverlayType);
                BotOverlayManager.RegisterMove(_bot, OverlayType);

                _lastIssuedMove = moveTarget;
                SetStance(distToTarget, advancePoint, usedCover, _cache.Perception?.IsSuppressed ?? false);

                if (usedSquad)
                    TrySayGo(now, 0.96f);
                if (UnityEngine.Random.value < VoiceGoChance)
                    TrySayGo(now, 0.89f);

                ReleaseOverlay();
            }
            catch (Exception ex)
            {
                Plugin.LoggerInstance.LogError("[AttackHandler] Tick failed: " + ex);
                ReleaseOverlay();
            }
        }

        #endregion

        #region Overlay Intent/Targeting

        /// <summary>
        /// Tries to resolve the current attack enemy target.
        /// </summary>
        private bool TryResolveEnemy(out Player result)
        {
            result = null;
            if (_cache?.ThreatSelector?.CurrentTarget is Player t && EFTPlayerUtil.IsValid(t))
            {
                result = t;
                return true;
            }
            if (_bot?.Memory?.GoalEnemy?.Person is Player fallback && EFTPlayerUtil.IsValid(fallback))
            {
                result = fallback;
                return true;
            }
            return false;
        }

        /// <summary>
        /// Computes the next advance point (cover, squad, or fallback logic).
        /// </summary>
        private Vector3 GetAdvancePoint(Vector3 botPos, Vector3 target, float dist, out bool usedCover, out bool usedSquad)
        {
            usedCover = false;
            usedSquad = false;

            // Shuffle at extreme close range
            if (dist < MinAdvanceDistance)
            {
                Vector3 sidestep = Vector3.Cross(Vector3.up, _bot.LookDirection.normalized);
                float shuffle = UnityEngine.Random.Range(-1f, 1f) * MicroAdjustRadius;
                return target + sidestep * shuffle;
            }

            // Use cover if available
            if (_cache.CoverPlanner != null && _cache.CoverPlanner.TryGetBestCoverNear(target, botPos, out Vector3 cover))
            {
                usedCover = true;
                Vector3 lateral = Vector3.Cross(Vector3.up, (target - cover).normalized);
                Vector3 candidate = cover + lateral * UnityEngine.Random.Range(-0.5f, 0.5f);
                return BotNavHelper.TryGetSafeTarget(_bot, out Vector3 safeCover) ? safeCover : candidate;
            }

            // Squad overlays after NavMesh
            if (_bot.BotsGroup != null && _bot.BotsGroup.MembersCount > 1)
            {
                usedSquad = true;
                int idx = GetSquadIndex(_bot);
                Vector3 perp = Vector3.Cross(Vector3.up, _bot.LookDirection.normalized);
                float squadOffset = SquadSpread * (idx - (_bot.BotsGroup.MembersCount / 2f));
                return target + perp * squadOffset;
            }

            // Fallback to bot position if all else fails
            return BotNavHelper.TryGetSafeTarget(_bot, out Vector3 fallback) ? fallback : botPos;
        }

        #endregion

        #region Stance/Overlay Post-Move

        /// <summary>
        /// Sets stance/pose post-move, fully error-guarded.
        /// </summary>
        private void SetStance(float distance, Vector3 advancePos, bool usedCover, bool isSuppressed)
        {
            try
            {
                var pose = _cache.PoseController;
                if (pose == null) return;
                if (usedCover || distance < 7.4f)
                    pose.TrySetStanceFromNearbyCover(advancePos);
                else if (distance < 16.2f)
                    pose.Stand();
                if (isSuppressed)
                    pose.Crouch();
            }
            catch (Exception ex)
            {
                Plugin.LoggerInstance.LogError("[AttackHandler] Stance logic failed: " + ex);
            }
        }

        /// <summary>
        /// Attempts to play squad "Go Forward" voice, with random chance.
        /// </summary>
        private void TrySayGo(float now, float chance)
        {
            if (_bot?.BotTalk == null || now - _lastVoiceTime < MaxVoiceInterval) return;
            if (UnityEngine.Random.value < chance)
            {
                try { _bot.BotTalk.TrySay(EPhraseTrigger.GoForward); } catch { }
                _lastVoiceTime = now;
            }
        }

        /// <summary>
        /// Attempts to play "Fakeout" voice line, with random chance.
        /// </summary>
        private void TrySayFakeout(float now, float chance)
        {
            if (_bot?.BotTalk == null || now - _lastVoiceTime < MaxVoiceInterval) return;
            if (UnityEngine.Random.value < chance)
            {
                try { _bot.BotTalk.TrySay(EPhraseTrigger.Toxic); } catch { }
                _lastVoiceTime = now;
            }
        }

        #endregion

        #region Ultra-Safety Checks

        /// <summary>
        /// Validates that the advance point is safe, on NavMesh, not too far, and not through a closed door.
        /// </summary>
        private static bool IsAdvancePointSafe(Vector3 current, Vector3 target)
        {
            float dist = Vector3.Distance(current, target);
            if (dist < SafeMoveMin || dist > SafeMoveMax)
                return false;
            if (!BotNavHelper.IsNavMeshPositionValid(target))
                return false;
            if (!NavMesh.SamplePosition(target, out var hit, 0.59f, NavMesh.AllAreas))
                return false;
            if (Mathf.Abs(hit.position.y - current.y) > MaxNavmeshDeltaY)
                return false;
            if (BotNavHelper.IsBlockedByClosedDoor(current, target))
                return false;
            return true;
        }

        /// <summary>
        /// Gets this bot's index in squad (for squad spread).
        /// </summary>
        private static int GetSquadIndex(BotOwner bot)
        {
            if (bot?.BotsGroup == null) return -1;
            for (int i = 0; i < bot.BotsGroup.MembersCount; i++)
                if (bot.BotsGroup.Member(i) == bot) return i;
            return -1;
        }

        /// <summary>
        /// Helper for overlay release, never throws.
        /// </summary>
        private void ReleaseOverlay()
        {
            try { BotOverlayManager.ReleaseMove(_bot, OverlayType); }
            catch { /* never break flow */ }
        }

        #endregion
    }
}
