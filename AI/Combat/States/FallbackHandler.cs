// <auto-generated>
//   This file is part of AI-Refactored, an open-source project focused on realistic AI behavior in Escape from Tarkov.
//   Licensed under the MIT License. See LICENSE in the repository root for more information.
//
//   THIS FILE IS SYSTEMATICALLY MANAGED.
//   Please follow strict StyleCop, ReSharper, and AI-Refactored code standards for all modifications.
// </auto-generated>

namespace AIRefactored.AI.Combat.States
{
    using System;
    using System.Collections.Generic;
    using AIRefactored.AI.Core;
    using AIRefactored.AI.Helpers;
    using AIRefactored.Pools;
    using AIRefactored.Runtime;
    using EFT;
    using UnityEngine;

    /// <summary>
    /// Handles suppression fallback, retreat routing, and cover movement during engagements.
    /// </summary>
    public sealed class FallbackHandler
    {
        #region Constants

        private const float MinArrivalDistance = 2.0f;

        #endregion

        #region Fields

        private readonly BotOwner _bot;
        private readonly BotComponentCache _cache;
        private readonly List<Vector3> _currentFallbackPath;

        private Vector3 _fallbackTarget;

        #endregion

        #region Constructor

        public FallbackHandler(BotComponentCache cache)
        {
            if (cache == null || cache.Bot == null)
            {
                throw new ArgumentException("[FallbackHandler] Cache or Bot is null.");
            }

            _cache = cache;
            _bot = cache.Bot;
            _fallbackTarget = _bot.Position;
            _currentFallbackPath = TempListPool.Rent<Vector3>();
        }

        #endregion

        #region Public API

        public Vector3 GetFallbackPosition()
        {
            return _fallbackTarget;
        }

        public Vector3 GetFallbackPositionOrDefault(Vector3 defaultPos)
        {
            return HasValidFallbackPath() ? _fallbackTarget : defaultPos;
        }

        public bool HasValidFallbackPath()
        {
            return _currentFallbackPath.Count >= 2 && IsVectorValid(_fallbackTarget);
        }

        public void SetFallbackTarget(Vector3 target)
        {
            if (!IsVectorValid(target))
            {
                Plugin.LoggerInstance.LogWarning("[FallbackHandler] Ignored fallback target with NaN or invalid values.");
                return;
            }

            _fallbackTarget = target;
        }

        public void SetFallbackPath(List<Vector3> path)
        {
            if (path == null || path.Count < 2)
            {
                Plugin.LoggerInstance.LogWarning("[FallbackHandler] Rejected fallback path: insufficient length.");
                return;
            }

            _currentFallbackPath.Clear();
            for (int i = 0, count = path.Count; i < count; i++)
            {
                if (!IsVectorValid(path[i]))
                {
                    continue;
                }

                _currentFallbackPath.Add(path[i]);
            }

            if (_currentFallbackPath.Count >= 2)
            {
                _fallbackTarget = _currentFallbackPath[_currentFallbackPath.Count - 1];
            }
            else
            {
                Plugin.LoggerInstance.LogWarning("[FallbackHandler] Final fallback path was invalid or corrupted.");
            }
        }

        public bool ShallUseNow(float time)
        {
            if (_cache.IsFallbackMode || _bot == null)
            {
                return false;
            }

            return Vector3.Distance(_bot.Position, _fallbackTarget) > MinArrivalDistance;
        }

        public bool ShouldTriggerSuppressedFallback(float now, float lastStateChangeTime, float minStateDuration)
        {
            if (_cache == null || _cache.Suppression == null)
            {
                return false;
            }

            return _cache.Suppression.IsSuppressed() &&
                   (now - lastStateChangeTime) >= minStateDuration;
        }

        public void Tick(float time, Action<CombatState, float> forceState)
        {
            if (_cache.IsFallbackMode || _bot == null ||
                _bot.GetPlayer == null || _bot.GetPlayer.HealthController == null || !_bot.GetPlayer.HealthController.IsAlive)
            {
                return;
            }

            if (!IsVectorValid(_fallbackTarget))
            {
                Plugin.LoggerInstance.LogWarning("[FallbackHandler] Skipped Tick: fallback target was invalid.");
                return;
            }

            Vector3 currentPos = _bot.Position;
            float dist = Vector3.Distance(currentPos, _fallbackTarget);

            // Always try move; SmoothMoveTo includes GoToPoint fallback logic now
            BotMovementHelper.SmoothMoveTo(_bot, _fallbackTarget);

            // Optionally trigger crouch/prone from cover at target
            BotCoverHelper.TrySetStanceFromNearbyCover(_cache, _fallbackTarget);

            if (dist < MinArrivalDistance)
            {
                forceState?.Invoke(CombatState.Patrol, time);

                if (!FikaHeadlessDetector.IsHeadless && _bot.BotTalk != null)
                {
                    _bot.BotTalk.TrySay(EPhraseTrigger.NeedHelp);
                }
            }
        }

        public bool IsActive()
        {
            return _bot != null &&
                   _bot.GetPlayer != null &&
                   _bot.GetPlayer.HealthController != null &&
                   _bot.GetPlayer.HealthController.IsAlive &&
                   Vector3.Distance(_bot.Position, _fallbackTarget) > MinArrivalDistance;
        }

        public void Cancel()
        {
            _fallbackTarget = _bot != null ? _bot.Position : Vector3.zero;
            _currentFallbackPath.Clear();
        }

        #endregion

        #region Private Methods

        private static bool IsVectorValid(Vector3 v)
        {
            return !float.IsNaN(v.x) && !float.IsNaN(v.y) && !float.IsNaN(v.z) && v != Vector3.zero;
        }

        #endregion
    }
}
