// <auto-generated>
//   This file is part of AI-Refactored, an open-source project focused on realistic AI behavior in Escape from Tarkov.
//   Licensed under the MIT License. See LICENSE in the repository root for more information.
//
//   THIS FILE IS SYSTEMATICALLY MANAGED.
//   Bulletproof: All errors are locally isolated, never disables itself, never triggers fallback AI, never enters terminal state.
//   Teleportation is strictly forbidden: all fallback movement is path-based and validated.
// </auto-generated>

namespace AIRefactored.AI.Combat.States
{
    using System;
    using System.Collections.Generic;
    using AIRefactored.AI.Core;
    using AIRefactored.AI.Helpers;
    using AIRefactored.AI.Navigation;
    using AIRefactored.Core;
    using AIRefactored.Pools;
    using EFT;
    using UnityEngine;
    using UnityEngine.AI;

    /// <summary>
    /// Handles suppression fallback, retreat routing, and cover movement during engagements.
    /// Bulletproof: All errors are locally isolated, never disables itself, never triggers fallback AI, never enters terminal state.
    /// All fallback movement is smooth, path-based, and validated; teleportation is strictly forbidden.
    /// </summary>
    public sealed class FallbackHandler : IDisposable
    {
        #region Constants

        private const float MinArrivalDistance = 0.1f;
        private const float MinHumanDelay = 0.09f;
        private const float MaxHumanDelay = 0.22f;
        private const float NavMeshSampleRadius = 2.5f;
        private const float MaxFallbackDistance = 16f;

        #endregion

        #region Fields

        private readonly BotOwner _bot;
        private readonly BotComponentCache _cache;
        private readonly List<Vector3> _currentFallbackPath;
        private Vector3 _fallbackTarget;
        private float _lastMoveTime;

        #endregion

        #region Constructor

        public FallbackHandler(BotComponentCache cache)
        {
            _cache = cache;
            _bot = cache?.Bot;
            _fallbackTarget = _bot != null ? _bot.Position : Vector3.zero;
            _currentFallbackPath = TempListPool.Rent<Vector3>();
            _lastMoveTime = -1000f;
        }

        #endregion

        #region Public API

        public Vector3 GetFallbackPosition() => _fallbackTarget;

        public Vector3 GetFallbackPositionOrDefault(Vector3 defaultPos)
        {
            return HasValidFallbackPath() ? _fallbackTarget : defaultPos;
        }

        public bool HasValidFallbackPath()
        {
            return _currentFallbackPath.Count >= 2 && IsVectorValid(_fallbackTarget);
        }

        /// <summary>
        /// Sets a new fallback target; always NavMesh validated, never allows instant relocation.
        /// </summary>
        public void SetFallbackTarget(Vector3 target)
        {
            if (!IsVectorValid(target))
            {
                Plugin.LoggerInstance.LogWarning("[FallbackHandler] Ignored fallback target with invalid vector.");
                return;
            }

            // Validate on NavMesh to ensure it's always walkable
            if (TrySampleNavMesh(target, NavMeshSampleRadius, out Vector3 navSafe))
                _fallbackTarget = navSafe;
        }

        public void SetFallbackPath(List<Vector3> path)
        {
            if (path == null || path.Count < 2)
                return;

            _currentFallbackPath.Clear();
            for (int i = 0; i < path.Count; i++)
            {
                Vector3 point = path[i];
                if (IsVectorValid(point))
                    _currentFallbackPath.Add(point);
            }

            if (_currentFallbackPath.Count >= 2)
                _fallbackTarget = _currentFallbackPath[_currentFallbackPath.Count - 1];
        }

        public bool ShallUseNow(float time)
        {
            return _bot != null &&
                   IsVectorValid(_fallbackTarget) &&
                   Vector3.Distance(_bot.Position, _fallbackTarget) > MinArrivalDistance;
        }

        public bool ShouldTriggerSuppressedFallback(float now, float lastStateChangeTime, float minStateDuration)
        {
            var suppression = _cache?.Suppression;
            var panic = _cache?.PanicHandler;
            float caution = _cache?.PersonalityProfile?.Caution ?? 0.5f;

            bool isSuppressed = suppression?.IsSuppressed() == true;
            bool isPanicking = panic?.IsPanicking == true;

            if (isSuppressed && (now - lastStateChangeTime) >= minStateDuration)
            {
                if (isPanicking || (caution < 0.2f && UnityEngine.Random.value < 0.4f))
                    return false;
                return true;
            }

            return false;
        }

        /// <summary>
        /// Tick handler—executes validated, path-based fallback movement only.
        /// </summary>
        public void Tick(float time, Action<CombatState, float> forceState)
        {
            if (_bot == null || !IsVectorValid(_fallbackTarget))
                return;

            try
            {
                if (!EFTPlayerUtil.IsValid(_bot.GetPlayer))
                    return;

                float now = Time.time;
                float delay = UnityEngine.Random.Range(MinHumanDelay, MaxHumanDelay);
                if (now - _lastMoveTime < delay)
                    return;

                _lastMoveTime = now;

                Vector3 destination = _fallbackTarget;

                // Prefer BotNavHelper for tactical fallback pathing, always NavMesh validated
                if (!BotNavHelper.TryGetSafeTarget(_bot, out destination) || !IsVectorValid(destination))
                    destination = GetSafeRandomFallback(_bot.Position);

                destination += UnityEngine.Random.insideUnitSphere * 0.15f;
                destination.y = _bot.Position.y;

                // Absolute anti-teleport: only allow valid, walkable, and reasonable fallback destinations
                if (!TrySampleNavMesh(destination, NavMeshSampleRadius, out Vector3 navSafe))
                    navSafe = _bot.Position;

                if ((_bot.Mover != null) && (Vector3.Distance(_bot.Position, navSafe) < MaxFallbackDistance))
                {
                    BotMovementHelper.SmoothMoveTo(_bot, navSafe); // Only issues path-based moves
                    BotCoverHelper.TrySetStanceFromNearbyCover(_cache, navSafe);
                }

                if (Vector3.Distance(_bot.Position, navSafe) < MinArrivalDistance)
                {
                    forceState?.Invoke(CombatState.Patrol, time);

                    if (!FikaHeadlessDetector.IsHeadless && _bot.BotTalk != null)
                    {
                        try { _bot.BotTalk.TrySay(EPhraseTrigger.NeedHelp); }
                        catch { }
                    }
                }
            }
            catch (Exception ex)
            {
                Plugin.LoggerInstance.LogError($"[FallbackHandler] Tick exception: {ex}");
            }
        }

        public bool IsActive()
        {
            return _bot != null &&
                   EFTPlayerUtil.IsValid(_bot.GetPlayer) &&
                   IsVectorValid(_fallbackTarget) &&
                   Vector3.Distance(_bot.Position, _fallbackTarget) > MinArrivalDistance;
        }

        public void Cancel()
        {
            _fallbackTarget = _bot != null ? _bot.Position : Vector3.zero;
            _currentFallbackPath.Clear();
        }

        public void Dispose()
        {
            TempListPool.Return(_currentFallbackPath);
        }

        #endregion

        #region Internal Helpers

        private static bool IsVectorValid(Vector3 v)
        {
            return !float.IsNaN(v.x) && !float.IsNaN(v.y) && !float.IsNaN(v.z) && v != Vector3.zero;
        }

        /// <summary>
        /// Returns a random fallback that is always walkable; never teleports.
        /// </summary>
        private Vector3 GetSafeRandomFallback(Vector3 origin)
        {
            if (_bot?.PatrollingData != null)
            {
                Vector3 patrol = _bot.PatrollingData.CurTargetPoint;
                if (IsVectorValid(patrol) && Vector3.Distance(patrol, origin) > 1.0f)
                    return TrySampleNavMesh(patrol, NavMeshSampleRadius, out Vector3 patrolNav) ? patrolNav : origin;
            }

            Vector3 candidate = origin + UnityEngine.Random.onUnitSphere * 2.0f;
            candidate.y = origin.y;

            return TrySampleNavMesh(candidate, NavMeshSampleRadius, out Vector3 navSafe) && IsVectorValid(navSafe)
                ? navSafe
                : origin + Vector3.forward * 0.25f;
        }

        /// <summary>
        /// NavMesh validation wrapper—no teleports, no unwalkable fallback points.
        /// </summary>
        private static bool TrySampleNavMesh(Vector3 candidate, float radius, out Vector3 navSafe)
        {
            navSafe = candidate;
            if (NavMesh.SamplePosition(candidate, out NavMeshHit hit, radius, NavMesh.AllAreas))
            {
                navSafe = hit.position;
                return true;
            }
            return false;
        }

        #endregion
    }
}
