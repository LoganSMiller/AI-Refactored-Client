// <auto-generated>
//   AI-Refactored: FallbackHandler.cs (Ultra-Platinum++, Max Realism Overlay Edition, June 2025, Hitch/Teleport Fix Pass)
//   Overlay/intent-only fallback—NavMesh/personality/squad validated, retry-guarded, no disables, teleports, or direct transform.
//   Bulletproof: pooling, error isolation, SPT/FIKA/headless/client parity. Squad/panic/personality aware. MIT License.
// </auto-generated>

namespace AIRefactored.AI.Combat.States
{
    using System;
    using System.Collections.Generic;
    using AIRefactored.AI.Core;
    using AIRefactored.AI.Helpers;
    using AIRefactored.AI.Navigation;
    using AIRefactored.Core;
    using AIRefactored.Pools;
    using EFT;
    using UnityEngine;
    using UnityEngine.AI;

    public sealed class FallbackHandler : IDisposable
    {
        private const float MinArrivalDistance = 0.13f;
        private const float NavSampleRadius = 2.2f;
        private const int MaxRetries = 3;
        private const float PanicSpreadRadius = 6.2f;
        private const float PanicSpreadChance = 0.27f;
        private const float AnticipationPauseMin = 0.08f;
        private const float AnticipationPauseMax = 0.19f;
        private const float SquadSpread = 1.19f;
        private const float MinCohesion = 0.7f;
        private const float MaxCohesion = 1.3f;
        private const float MoveCooldown = 0.62f;
        private const float MaxFallbackDistance = 9.7f;
        private const float OverlayMoveDedupSqr = 0.0001f;

        private readonly BotOwner _bot;
        private readonly BotComponentCache _cache;
        private readonly List<Vector3> _path;
        private Vector3 _target;
        private int _retryCount;
        private float _anticipateUntil;
        private bool _hasArrived;
        private bool _panicSpread;
        private float _lastMoveIssueTime;
        private Vector3 _lastIssuedMove;

        public FallbackHandler(BotComponentCache cache)
        {
            _cache = cache;
            _bot = cache?.Bot;
            _target = _bot?.Position ?? Vector3.zero;
            _path = TempListPool.Rent<Vector3>();
            _lastIssuedMove = Vector3.zero;
            Clear();
        }

        public void Dispose()
        {
            _path.Clear();
            TempListPool.Return(_path);
        }

        public void Clear()
        {
            _target = _bot?.Position ?? Vector3.zero;
            _path.Clear();
            _retryCount = 0;
            _hasArrived = false;
            _anticipateUntil = -1f;
            _panicSpread = false;
            _lastMoveIssueTime = -MoveCooldown;
            _lastIssuedMove = Vector3.zero;
        }

        public void Cancel() => Clear();

        public bool IsActive() =>
            _bot != null &&
            EFTPlayerUtil.IsValid(_bot.GetPlayer) &&
            IsValid(_target) &&
            Vector3.Distance(_bot.Position, _target) > MinArrivalDistance;

        public bool HasArrived() => _hasArrived;
        public bool IsAnticipating(float now) => now < _anticipateUntil;
        public bool IsRetrying => _retryCount > 0;
        public Vector3 GetFallbackPosition() => _target;
        public bool ShallUseNow(float now) => IsActive() && !_hasArrived && !IsAnticipating(now);
        public bool HasValidFallbackPath() => _path.Count >= 2 && IsValid(_target);
        public Vector3 GetFallbackPositionOrDefault(Vector3 defaultPos) =>
            HasValidFallbackPath() ? _target : defaultPos;

        public bool ShouldTriggerSuppressedFallback(float now, float lastStateChangeTime, float minStateDuration)
        {
            var suppression = _cache?.Suppression;
            var panic = _cache?.PanicHandler;
            float caution = _cache?.PersonalityProfile?.Caution ?? 0.5f;

            bool isSuppressed = suppression?.IsSuppressed() == true;
            bool isPanicking = panic?.IsPanicking == true;

            if (isSuppressed && (now - lastStateChangeTime) >= minStateDuration)
            {
                if (isPanicking || (caution < 0.2f && UnityEngine.Random.value < 0.4f))
                    return false;
                return true;
            }
            return false;
        }

        public void SetFallbackTarget(Vector3 pos, float now)
        {
            if (!IsValid(pos) || !IsBotMoveCapable(_bot)) return;

            Vector3 squadOffset = GetSquadOffset();
            Vector3 candidate = pos + squadOffset;

            if (!TrySampleNavMesh(candidate, NavSampleRadius, out Vector3 result))
                return;

            result = ClampY(result, _bot.Position);
            if (!IsValid(result)) return;

            _target = result;
            _retryCount = 0;
            _anticipateUntil = now + UnityEngine.Random.Range(AnticipationPauseMin, AnticipationPauseMax);
            _hasArrived = false;
        }

        public void SetFallbackPath(List<Vector3> path, float now)
        {
            if (path == null || path.Count < 2)
                return;

            _path.Clear();
            for (int i = 0; i < path.Count; i++)
            {
                Vector3 point = path[i];
                if (IsValid(point))
                    _path.Add(point);
            }

            if (_path.Count >= 2)
                SetFallbackTarget(_path[_path.Count - 1], now);
        }

        public void Tick(float deltaTime, float now, Action<CombatState, float> forceExit)
        {
            // Overlay anticipation/interaction/pause guard: never move/cooldown if anticipation or pause in effect.
            if (!IsBotMoveCapable(_bot) || !IsValid(_target) || now < _anticipateUntil)
                return;

            // Panic spread (only once per fallback)
            if (!_panicSpread && _bot.BotsGroup != null)
            {
                for (int i = 0; i < _bot.BotsGroup.MembersCount; i++)
                {
                    var mate = _bot.BotsGroup.Member(i);
                    if (mate == null || mate == _bot || mate.IsDead) continue;
                    if (Vector3.Distance(_bot.Position, mate.Position) < PanicSpreadRadius)
                    {
                        var mateCache = BotCacheUtility.GetCache(mate);
                        if (mateCache?.PanicHandler != null && UnityEngine.Random.value < PanicSpreadChance)
                            mateCache.PanicHandler.TriggerPanic();
                    }
                }
                _panicSpread = true;
            }

            // Validate NavMesh position before move
            if (!TrySampleNavMesh(_target, NavSampleRadius, out Vector3 navSafe))
            {
                _retryCount++;
                if (_retryCount >= MaxRetries)
                {
                    Cancel();
                    return;
                }
                _target = FindBackupFallback(_bot.Position);
                return;
            }

            navSafe = ClampY(navSafe, _bot.Position);
            if (!IsValid(navSafe))
            {
                _retryCount++;
                if (_retryCount >= MaxRetries)
                {
                    Cancel();
                    return;
                }
                _target = FindBackupFallback(_bot.Position);
                return;
            }

            _retryCount = 0;

            float dist = Vector3.Distance(_bot.Position, navSafe);
            if (dist > MaxFallbackDistance || dist < MinArrivalDistance)
                return;

            // Overlay-move dedup/cooldown check: do not update move cache or issue move if cooldown or same target.
            if ((_lastIssuedMove - navSafe).sqrMagnitude < OverlayMoveDedupSqr && now - _lastMoveIssueTime < MoveCooldown)
                return;

            float cohesion = Mathf.Clamp(_cache?.PersonalityProfile?.Cohesion ?? 1f, MinCohesion, MaxCohesion);
            Vector3 adjusted = BotMovementHelper.ApplyMicroDrift(navSafe, _bot.ProfileId, Time.frameCount, _cache.PersonalityProfile);

            // Only issue and cache move if anticipation and cooldown not pending
            if (now - _lastMoveIssueTime >= MoveCooldown)
            {
                BotMovementHelper.SmoothMoveToSafe(_bot, adjusted, slow: true, cohesion);
                BotCoverHelper.TrySetStanceFromNearbyCover(_cache, adjusted);
                _lastMoveIssueTime = now;
                _lastIssuedMove = adjusted;
            }

            if (Vector3.Distance(_bot.Position, navSafe) <= MinArrivalDistance)
            {
                _hasArrived = true;
                forceExit?.Invoke(CombatState.Patrol, now);
            }
        }

        private Vector3 GetSquadOffset()
        {
            if (_bot?.BotsGroup == null || _bot.BotsGroup.MembersCount <= 1) return Vector3.zero;
            int index = GetSquadIndex(_bot);
            Vector3 perp = Vector3.Cross(Vector3.up, _bot.LookDirection.normalized);
            float offset = (index - (_bot.BotsGroup.MembersCount / 2f)) * SquadSpread;
            return perp * offset;
        }

        // Bulletproof fallback: up to 4 attempts at increasingly larger radii, then two random nudges, then finally clamp to origin.
        private Vector3 FindBackupFallback(Vector3 origin)
        {
            if (_bot?.PatrollingData != null)
            {
                var p = _bot.PatrollingData.CurTargetPoint;
                if (IsValid(p) && Vector3.Distance(p, origin) > 1f &&
                    TrySampleNavMesh(p, NavSampleRadius, out var fallbackNav))
                    return ClampY(fallbackNav, origin);
            }

            for (int i = 0; i < 4; i++)
            {
                Vector3 candidate = origin + UnityEngine.Random.insideUnitSphere * (2.3f + i * 1.1f);
                candidate.y = origin.y;
                if (TrySampleNavMesh(candidate, NavSampleRadius, out var navSafe) && IsValid(navSafe))
                    return ClampY(navSafe, origin);
            }

            // Absolute last-resort: up to 2 random direction nudges, both NavMesh-sampled and clamped.
            for (int j = 0; j < 2; j++)
            {
                Vector3 nudge = Quaternion.Euler(0, UnityEngine.Random.Range(0, 360f), 0) * Vector3.forward * 0.35f;
                Vector3 nudgeCandidate = origin + nudge;
                if (TrySampleNavMesh(nudgeCandidate, NavSampleRadius, out var nudgeNav) && IsValid(nudgeNav))
                    return ClampY(nudgeNav, origin);
            }

            // If all else fails, return the origin itself clamped (bot will remain in place, never teleport or snap).
            return ClampY(origin, origin);
        }

        private static Vector3 ClampY(Vector3 v, Vector3 basePos)
        {
            if (Mathf.Abs(v.y - basePos.y) > 3f || v.y < -2.5f)
                v.y = basePos.y;
            return v;
        }

        private static bool TrySampleNavMesh(Vector3 pos, float radius, out Vector3 result)
        {
            result = pos;
            if (NavMesh.SamplePosition(pos, out NavMeshHit hit, radius, NavMesh.AllAreas))
            {
                result = hit.position;
                return true;
            }
            return false;
        }

        private static bool IsValid(Vector3 v)
        {
            return !float.IsNaN(v.x) && !float.IsNaN(v.y) && !float.IsNaN(v.z)
                && v != Vector3.zero && v.y > -2.5f && Mathf.Abs(v.y) < 1000f;
        }

        private static bool IsBotMoveCapable(BotOwner bot)
        {
            if (bot == null || bot.Mover == null) return false;
            var p = bot.GetPlayer;
            return p != null && p.HealthController != null && p.HealthController.IsAlive && p.MovementContext != null;
        }

        private static int GetSquadIndex(BotOwner bot)
        {
            if (bot?.BotsGroup == null) return -1;
            for (int i = 0; i < bot.BotsGroup.MembersCount; i++)
                if (bot.BotsGroup.Member(i) == bot) return i;
            return -1;
        }
    }
}
