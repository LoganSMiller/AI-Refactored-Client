// <auto-generated>
//   AI-Refactored: FallbackHandler.cs (Supreme Arbitration Overlay/Event, Ultra-Max Realism, June 2025)
//   Overlay/intent-only fallback. All fallback moves NavMesh/personality/squad validated, retry-guarded, never disables, never teleports, never direct transform.
//   Feature-complete: pooling, error isolation, SPT/FIKA/headless/client parity. Squad/panic/personality overlays, cover-seeking, comms, anticipation, anti-clump, anti-loop, anti-NaN. MIT License.
// </auto-generated>

namespace AIRefactored.AI.Combat.States
{
    using System;
    using System.Collections.Generic;
    using AIRefactored.AI.Core;
    using AIRefactored.AI.Helpers;
    using AIRefactored.AI.Navigation;
    using AIRefactored.Core;
    using AIRefactored.Pools;
    using EFT;
    using UnityEngine;
    using UnityEngine.AI;

    /// <summary>
    /// Drives all fallback overlay/event-only movement: NavMesh+personality+squad validated, retry-guarded, pooled, error-isolated, ultra-realistic.
    /// All fallback moves are overlay/event-only (never disables, never teleports, never direct transform, never vanilla fallback).
    /// Panic/cover anticipation, squad comms, anti-clump/anti-loop/anti-NaN/Inf, max realism. All overlays pooled and arbitration guarded.
    /// </summary>
    public sealed class FallbackHandler : IDisposable
    {
        #region Constants

        private const float MinArrivalDistance = 0.13f;
        private const float NavSampleRadius = 2.2f;
        private const int MaxRetries = 3;
        private const float PanicSpreadRadius = 6.2f;
        private const float PanicSpreadChance = 0.27f;
        private const float AnticipationPauseMin = 0.11f;
        private const float AnticipationPauseMax = 0.28f;
        private const float SquadSpread = 1.19f;
        private const float AntiClumpRadius = 1.23f;
        private const float AntiLoopJitter = 0.22f;
        private const float MinCohesion = 0.7f;
        private const float MaxCohesion = 1.3f;
        private const float MoveCooldown = 0.62f;
        private const float MaxFallbackDistance = 9.7f;
        private const float OverlayMoveDedupSqr = 0.0001f;
        private const float MaxNavmeshDeltaY = 3.1f;
        private const float MicroJitter = 0.16f;
        private const int MaxBackupCandidates = 7;
        private const float CoverSeekChance = 0.72f;
        private const float GroupRegroupChance = 0.29f;
        private const float RegroupVoiceChance = 0.44f;
        private const float StressPenaltyFactor = 0.14f;
        private const BotOverlayType OverlayType = BotOverlayType.Fallback;

        #endregion

        #region Fields

        private readonly BotOwner _bot;
        private readonly BotComponentCache _cache;
        private readonly List<Vector3> _path;
        private Vector3 _target;
        private int _retryCount;
        private float _anticipateUntil;
        private bool _hasArrived;
        private bool _panicSpread;
        private float _lastMoveIssueTime;
        private Vector3 _lastIssuedMove;
        private float _fallbackStress;
        private float _lastRegroupVoiceTime;

        #endregion

        #region Construction & Cleanup

        public FallbackHandler(BotComponentCache cache)
        {
            _cache = cache;
            _bot = cache?.Bot;
            _target = _bot?.Position ?? Vector3.zero;
            _path = TempListPool.Rent<Vector3>();
            _lastIssuedMove = Vector3.zero;
            Clear();
        }

        public void Dispose()
        {
            _path.Clear();
            TempListPool.Return(_path);
        }

        public void Clear()
        {
            _target = _bot?.Position ?? Vector3.zero;
            _path.Clear();
            _retryCount = 0;
            _hasArrived = false;
            _anticipateUntil = -1f;
            _panicSpread = false;
            _lastMoveIssueTime = -MoveCooldown;
            _lastIssuedMove = Vector3.zero;
            _fallbackStress = 0f;
            _lastRegroupVoiceTime = -4f;
        }

        public void Cancel() => Clear();

        #endregion

        #region State Accessors

        public bool IsActive() =>
            _bot != null &&
            EFTPlayerUtil.IsValid(_bot.GetPlayer) &&
            IsValid(_target) &&
            Vector3.Distance(_bot.Position, _target) > MinArrivalDistance;

        public bool HasArrived() => _hasArrived;
        public bool IsAnticipating(float now) => now < _anticipateUntil;
        public bool IsRetrying => _retryCount > 0;
        public Vector3 GetFallbackPosition() => _target;
        public bool ShallUseNow(float now) => IsActive() && !_hasArrived && !IsAnticipating(now);
        public bool HasValidFallbackPath() => _path.Count >= 2 && IsValid(_target);
        public Vector3 GetFallbackPositionOrDefault(Vector3 defaultPos) =>
            HasValidFallbackPath() ? _target : defaultPos;

        #endregion

        #region Fallback/Overlay API

        /// <summary>
        /// Determines if suppression fallback should be triggered based on suppression, panic, and personality.
        /// </summary>
        public bool ShouldTriggerSuppressedFallback(float now, float lastStateChangeTime, float minStateDuration)
        {
            var suppression = _cache?.Suppression;
            var panic = _cache?.PanicHandler;
            float caution = _cache?.PersonalityProfile?.Caution ?? 0.5f;

            bool isSuppressed = suppression?.IsSuppressed() == true;
            bool isPanicking = panic?.IsPanicking == true;

            if (isSuppressed && (now - lastStateChangeTime) >= minStateDuration)
            {
                if (isPanicking || (caution < 0.2f && UnityEngine.Random.value < 0.4f))
                    return false;
                return true;
            }
            return false;
        }

        /// <summary>
        /// Sets a fallback move intent to a NavMesh/Y/squad/personality/cover safe overlay position, anti-clump drift, squad comms.
        /// </summary>
        public void SetFallbackTarget(Vector3 pos, float now)
        {
            if (!IsValid(pos) || !IsBotMoveCapable(_bot)) return;

            Vector3 squadOffset = GetSquadOffset();
            Vector3 candidate = pos + squadOffset;
            candidate = ApplyAntiClump(_bot, candidate);

            // Seek cover if possible, simulate player-like cover fallback
            if (_cache.CoverPlanner != null && UnityEngine.Random.value < CoverSeekChance)
            {
                if (_cache.CoverPlanner.TryGetBestCoverNear(candidate, _bot.Position, out Vector3 coverPoint))
                {
                    candidate = coverPoint + UnityEngine.Random.insideUnitSphere * 0.22f;
                }
            }

            if (!TrySampleNavMesh(candidate, NavSampleRadius, out Vector3 result))
                return;

            result = ClampY(result, _bot.Position);
            if (!IsValid(result)) return;

            _target = result;
            _retryCount = 0;
            _anticipateUntil = now + UnityEngine.Random.Range(AnticipationPauseMin, AnticipationPauseMax);
            _hasArrived = false;
            _fallbackStress = Mathf.Clamp01(_fallbackStress + 0.21f); // Increase fallback stress per event

            // Squad comms: trigger group fallback overlays and optional voice
            TryTriggerGroupRegroup(now, result);
        }

        /// <summary>
        /// Sets a fallback path for the handler; always overlay-only, fully NavMesh/Y safe.
        /// </summary>
        public void SetFallbackPath(List<Vector3> path, float now)
        {
            if (path == null || path.Count < 2)
                return;

            _path.Clear();
            for (int i = 0; i < path.Count; i++)
            {
                Vector3 point = path[i];
                if (IsValid(point))
                    _path.Add(point);
            }

            if (_path.Count >= 2)
                SetFallbackTarget(_path[_path.Count - 1], now);
        }

        /// <summary>
        /// Overlay-only, error-isolated fallback tick. All moves are strictly overlay-guarded, NavMesh/Y/personality/squad safe.
        /// </summary>
        public void Tick(float deltaTime, float now, Action<CombatState, float> forceExit)
        {
            if (!IsBotMoveCapable(_bot) || !IsValid(_target) || now < _anticipateUntil)
                return;

            if (!BotOverlayManager.CanIssueMove(_bot, OverlayType))
                return;

            // Panic contagion spread (squad, realistic panic, once per fallback event)
            if (!_panicSpread && _bot.BotsGroup != null)
            {
                for (int i = 0; i < _bot.BotsGroup.MembersCount; i++)
                {
                    var mate = _bot.BotsGroup.Member(i);
                    if (mate == null || mate == _bot || mate.IsDead) continue;
                    if (Vector3.Distance(_bot.Position, mate.Position) < PanicSpreadRadius)
                    {
                        var mateCache = BotCacheUtility.GetCache(mate);
                        if (mateCache?.PanicHandler != null && UnityEngine.Random.value < PanicSpreadChance)
                            mateCache.PanicHandler.TriggerPanic();
                    }
                }
                _panicSpread = true;
            }

            // NavMesh/Y fallback overlay revalidation; retries if invalid (anti-loop, anti-NaN)
            if (!TrySampleNavMesh(_target, NavSampleRadius, out Vector3 navSafe) || !IsValid(navSafe))
            {
                _retryCount++;
                if (_retryCount >= MaxRetries)
                {
                    Cancel();
                    _fallbackStress = 0f; // Reset stress on total failure
                    return;
                }
                _target = FindBackupFallback(_bot.Position);
                _target += UnityEngine.Random.insideUnitSphere * AntiLoopJitter;
                _fallbackStress = Mathf.Clamp01(_fallbackStress + 0.22f); // Stress rises on retries
                return;
            }

            navSafe = ClampY(navSafe, _bot.Position);
            _retryCount = 0;

            float dist = Vector3.Distance(_bot.Position, navSafe);
            if (dist > MaxFallbackDistance || dist < MinArrivalDistance)
                return;

            if ((navSafe - _lastIssuedMove).sqrMagnitude < OverlayMoveDedupSqr)
                return;

            if (BotMovementHelper.IsMovementPaused(_bot) || BotMovementHelper.IsInInteractionState(_bot))
                return;

            float cohesion = Mathf.Clamp(_cache?.PersonalityProfile?.Cohesion ?? 1f, MinCohesion, MaxCohesion);

            // Under fallback stress, bots move less accurately and scan more (emulates panic/inattention)
            Vector3 adjusted = BotMovementHelper.ApplyMicroDrift(navSafe, _bot.ProfileId, Time.frameCount, _cache.PersonalityProfile);
            adjusted += UnityEngine.Random.insideUnitSphere * (_fallbackStress * MicroJitter + 0.01f);

            // Occasional extra scan/voice on fallback arrival to simulate group comms/regroup
            if (_hasArrived && now - _lastRegroupVoiceTime > 2.2f && UnityEngine.Random.value < GroupRegroupChance)
            {
                TryTriggerGroupRegroup(now, navSafe);
                _lastRegroupVoiceTime = now;
            }

            BotMovementHelper.SmoothMoveToSafe(_bot, adjusted, true, cohesion, OverlayType);
            BotOverlayManager.RegisterMove(_bot, OverlayType);

            BotCoverHelper.TrySetStanceFromNearbyCover(_cache, adjusted);
            _lastMoveIssueTime = now;
            _lastIssuedMove = adjusted;

            if (Vector3.Distance(_bot.Position, navSafe) <= MinArrivalDistance)
            {
                _hasArrived = true;
                _fallbackStress = Mathf.Max(0f, _fallbackStress - 0.33f); // Stress releases on successful fallback
                forceExit?.Invoke(CombatState.Patrol, now);
            }
        }

        #endregion

        #region Helpers

        /// <summary>
        /// Squad anti-parallel/anti-clump offset.
        /// </summary>
        private Vector3 GetSquadOffset()
        {
            if (_bot?.BotsGroup == null || _bot.BotsGroup.MembersCount <= 1) return Vector3.zero;
            int index = GetSquadIndex(_bot);
            Vector3 perp = Vector3.Cross(Vector3.up, _bot.LookDirection.normalized);
            float offset = (index - (_bot.BotsGroup.MembersCount / 2f)) * SquadSpread;
            return perp * offset;
        }

        /// <summary>
        /// Post-NavMesh anti-clump adjustment.
        /// </summary>
        private static Vector3 ApplyAntiClump(BotOwner bot, Vector3 dest)
        {
            if (bot?.BotsGroup == null || bot.BotsGroup.MembersCount <= 1) return dest;
            for (int i = 0; i < bot.BotsGroup.MembersCount; i++)
            {
                var mate = bot.BotsGroup.Member(i);
                if (mate == null || mate == bot) continue;
                if ((dest - mate.Position).magnitude < AntiClumpRadius)
                    dest += UnityEngine.Random.insideUnitSphere * MicroJitter;
            }
            return dest;
        }

        /// <summary>
        /// Trigger squad regroup overlays and group comms after fallback, with optional voice.
        /// </summary>
        private void TryTriggerGroupRegroup(float now, Vector3 fallbackPos)
        {
            if (_bot?.BotsGroup == null) return;
            int count = _bot.BotsGroup.MembersCount;
            for (int i = 0; i < count; i++)
            {
                BotOwner mate = _bot.BotsGroup.Member(i);
                if (mate == null || mate == _bot || mate.IsDead) continue;
                var mateCache = BotCacheUtility.GetCache(mate);
                if (!BotOverlayManager.CanIssueMove(mate, OverlayType)) continue;
                Vector3 regroupPoint = fallbackPos + UnityEngine.Random.insideUnitSphere * 1.2f;
                regroupPoint = ApplyAntiClump(mate, regroupPoint);
                if (TrySampleNavMesh(regroupPoint, NavSampleRadius, out Vector3 safePoint) && IsValid(safePoint))
                {
                    float cohesion = Mathf.Clamp(mateCache?.PersonalityProfile?.Cohesion ?? 1f, MinCohesion, MaxCohesion);
                    BotMovementHelper.SmoothMoveToSafe(mate, safePoint, true, cohesion, OverlayType);
                    BotOverlayManager.RegisterMove(mate, OverlayType);
                    BotCoverHelper.TrySetStanceFromNearbyCover(mateCache, safePoint);

                    if (mate.BotTalk != null && UnityEngine.Random.value < RegroupVoiceChance)
                    {
                        try { mate.BotTalk.TrySay(EPhraseTrigger.Regroup); } catch { }
                    }
                }
            }
        }

        private Vector3 FindBackupFallback(Vector3 origin)
        {
            if (_bot?.PatrollingData != null)
            {
                var p = _bot.PatrollingData.CurTargetPoint;
                if (IsValid(p) && Vector3.Distance(p, origin) > 1f &&
                    TrySampleNavMesh(p, NavSampleRadius, out var fallbackNav))
                    return ClampY(fallbackNav, origin);
            }
            for (int i = 0; i < MaxBackupCandidates; i++)
            {
                Vector3 candidate = origin + UnityEngine.Random.insideUnitSphere * (2.8f + i * 1.2f);
                candidate.y = origin.y;
                if (TrySampleNavMesh(candidate, NavSampleRadius, out var navSafe) && IsValid(navSafe))
                    return ClampY(navSafe, origin);
            }
            for (int j = 0; j < 2; j++)
            {
                Vector3 nudge = Quaternion.Euler(0, UnityEngine.Random.Range(0, 360f), 0) * Vector3.forward * 0.45f;
                Vector3 nudgeCandidate = origin + nudge;
                if (TrySampleNavMesh(nudgeCandidate, NavSampleRadius, out var nudgeNav) && IsValid(nudgeNav))
                    return ClampY(nudgeNav, origin);
            }
            return ClampY(origin, origin);
        }

        private static Vector3 ClampY(Vector3 v, Vector3 basePos)
        {
            if (Mathf.Abs(v.y - basePos.y) > MaxNavmeshDeltaY || v.y < -2.5f)
                v.y = basePos.y;
            return v;
        }

        private static bool TrySampleNavMesh(Vector3 pos, float radius, out Vector3 result)
        {
            result = pos;
            if (NavMesh.SamplePosition(pos, out NavMeshHit hit, radius, NavMesh.AllAreas))
            {
                result = hit.position;
                return true;
            }
            return false;
        }

        private static bool IsValid(Vector3 v)
        {
            return !float.IsNaN(v.x) && !float.IsNaN(v.y) && !float.IsNaN(v.z)
                && v != Vector3.zero && v.y > -2.5f && Mathf.Abs(v.y) < 1000f;
        }

        private static bool IsBotMoveCapable(BotOwner bot)
        {
            if (bot == null || bot.Mover == null) return false;
            var p = bot.GetPlayer;
            return p != null && p.HealthController != null && p.HealthController.IsAlive && p.MovementContext != null;
        }

        private static int GetSquadIndex(BotOwner bot)
        {
            if (bot?.BotsGroup == null) return -1;
            for (int i = 0; i < bot.BotsGroup.MembersCount; i++)
                if (bot.BotsGroup.Member(i) == bot) return i;
            return -1;
        }

        #endregion
    }
}
