// <auto-generated>
//   This file is part of AI-Refactored, an open-source project focused on realistic AI behavior in Escape from Tarkov.
//   Licensed under the MIT License. See LICENSE in the repository root for more information.
//
//   THIS FILE IS SYSTEMATICALLY MANAGED.
//   Please follow strict StyleCop, ReSharper, and AI-Refactored code standards for all modifications.
// </auto-generated>

#nullable enable

namespace AIRefactored.AI.Combat.States
{
    using System;
    using System.Collections.Generic;
    using AIRefactored.AI.Core;
    using AIRefactored.AI.Helpers;
    using EFT;
    using UnityEngine;

    /// <summary>
    /// Handles fallback movement, suppression retreat, and cover repositioning behavior.
    /// Integrates fallback pathing with squad-aware hybrid cover logic.
    /// </summary>
    public sealed class FallbackHandler
    {
        #region Constants

        private const float MinArrivalDistance = 2.0f;

        #endregion

        #region Fields

        private readonly BotOwner _bot;
        private readonly BotComponentCache _cache;
        private readonly List<Vector3> _currentFallbackPath;
        private Vector3 _fallbackTarget;

        #endregion

        #region Constructor

        /// <summary>
        /// Initializes a new instance of the <see cref="FallbackHandler"/> class.
        /// </summary>
        /// <param name="cache">The bot component cache reference.</param>
        public FallbackHandler(BotComponentCache cache)
        {
            if (cache == null)
            {
                throw new ArgumentNullException(nameof(cache));
            }

            if (cache.Bot == null)
            {
                throw new ArgumentException("Bot is null on cache.", nameof(cache));
            }

            this._cache = cache;
            this._bot = cache.Bot;
            this._fallbackTarget = this._bot.Position;
            this._currentFallbackPath = new List<Vector3>(8);
        }

        #endregion

        #region Public API

        /// <summary>
        /// Gets the current fallback target position.
        /// </summary>
        /// <returns>The fallback destination.</returns>
        public Vector3 GetFallbackPosition()
        {
            return this._fallbackTarget;
        }

        /// <summary>
        /// Gets a fallback target if valid, or returns the current position.
        /// </summary>
        /// <param name="defaultPos">Default fallback if none set.</param>
        /// <returns>Resolved fallback target.</returns>
        public Vector3 GetFallbackPositionOrDefault(Vector3 defaultPos)
        {
            return this.HasValidFallbackPath() ? this._fallbackTarget : defaultPos;
        }

        /// <summary>
        /// Returns true if a valid fallback path is currently cached.
        /// </summary>
        /// <returns>True if fallback path is usable; otherwise, false.</returns>
        public bool HasValidFallbackPath()
        {
            return this._currentFallbackPath.Count >= 2;
        }

        /// <summary>
        /// Sets a fallback path for the bot.
        /// </summary>
        /// <param name="path">The fallback path points.</param>
        public void SetFallbackPath(List<Vector3> path)
        {
            if (path == null || path.Count < 2)
            {
                return;
            }

            this._currentFallbackPath.Clear();
            for (int i = 0; i < path.Count; i++)
            {
                this._currentFallbackPath.Add(path[i]);
            }

            this._fallbackTarget = path[path.Count - 1];
        }

        /// <summary>
        /// Sets a fallback target directly without a path.
        /// </summary>
        /// <param name="target">Fallback destination position.</param>
        public void SetFallbackTarget(Vector3 target)
        {
            this._fallbackTarget = target;
        }

        /// <summary>
        /// Determines whether the bot should continue fallback movement.
        /// </summary>
        /// <param name="time">The current time.</param>
        /// <returns>True if fallback should be active; otherwise, false.</returns>
        public bool ShallUseNow(float time)
        {
            float distance = Vector3.Distance(this._bot.Position, this._fallbackTarget);
            return distance > MinArrivalDistance;
        }

        /// <summary>
        /// Determines if suppression conditions warrant triggering fallback override.
        /// </summary>
        /// <param name="now">Current time.</param>
        /// <param name="lastStateChangeTime">Last state change timestamp.</param>
        /// <param name="minStateDuration">Minimum time in previous state before fallback allowed.</param>
        /// <returns>True if fallback override should occur.</returns>
        public bool ShouldTriggerSuppressedFallback(float now, float lastStateChangeTime, float minStateDuration)
        {
            if (this._cache.Suppression == null)
            {
                return false;
            }

            return this._cache.Suppression.IsSuppressed() &&
                   (now - lastStateChangeTime) >= minStateDuration;
        }

        /// <summary>
        /// Executes fallback movement and cover checks.
        /// </summary>
        /// <param name="time">Current world time.</param>
        /// <param name="lastKnownEnemyPos">Optional last known enemy position (not used).</param>
        /// <param name="forceState">Callback to force combat state transitions.</param>
        public void Tick(float time, Vector3? lastKnownEnemyPos, Action<CombatState, float> forceState)
        {
            BotMovementHelper.SmoothMoveTo(this._bot, this._fallbackTarget);
            BotCoverHelper.TrySetStanceFromNearbyCover(this._cache, this._fallbackTarget);

            float dist = Vector3.Distance(this._bot.Position, this._fallbackTarget);
            if (dist < MinArrivalDistance)
            {
                forceState(CombatState.Patrol, time);

                if (!FikaHeadlessDetector.IsHeadless)
                {
                    if (this._bot.BotTalk != null)
                    {
                        this._bot.BotTalk.TrySay(EPhraseTrigger.NeedHelp);
                    }
                }
            }
        }

        #endregion
    }
}
