// <auto-generated>
//   This file is part of AI-Refactored, an open-source project focused on realistic AI behavior in Escape from Tarkov.
//   Licensed under the MIT License. See LICENSE in the repository root for more information.
//
//   THIS FILE IS SYSTEMATICALLY MANAGED.
//   Bulletproof: All errors are locally isolated, never disables itself, never triggers fallback AI, never enters terminal state.
//   Teleportation is strictly forbidden: all fallback movement is path-based and validated.
// </auto-generated>

namespace AIRefactored.AI.Combat.States
{
    using System;
    using System.Collections.Generic;
    using AIRefactored.AI.Core;
    using AIRefactored.AI.Helpers;
    using AIRefactored.AI.Navigation;
    using AIRefactored.Core;
    using AIRefactored.Pools;
    using EFT;
    using UnityEngine;
    using UnityEngine.AI;

    /// <summary>
    /// Handles suppression fallback, retreat routing, and cover movement during engagements.
    /// Bulletproof: All errors are locally isolated, never disables itself, never triggers fallback AI, never enters terminal state.
    /// All fallback movement is smooth, path-based, and validated; teleportation is strictly forbidden.
    /// </summary>
    public sealed class FallbackHandler : IDisposable
    {
        #region Constants

        private const float MinArrivalDistance = 0.1f;
        private const float MinHumanDelay = 0.09f;
        private const float MaxHumanDelay = 0.22f;
        private const float NavMeshSampleRadius = 2.5f;
        private const float MaxFallbackDistance = 16f;
        private const int MaxFallbackRetries = 3;
        private const float FallbackCooldownSeconds = 1.2f;

        #endregion

        #region Fields

        private readonly BotOwner _bot;
        private readonly BotComponentCache _cache;
        private readonly List<Vector3> _currentFallbackPath;
        private Vector3 _fallbackTarget;
        private float _lastMoveTime;
        private int _fallbackRetryCount;
        private float _lastFallbackAssignTime;

        #endregion

        #region Constructor

        public FallbackHandler(BotComponentCache cache)
        {
            _cache = cache;
            _bot = cache?.Bot;
            _fallbackTarget = _bot != null ? _bot.Position : Vector3.zero;
            _currentFallbackPath = TempListPool.Rent<Vector3>();
            _lastMoveTime = -1000f;
            _fallbackRetryCount = 0;
            _lastFallbackAssignTime = -1000f;
        }

        #endregion

        #region Public API

        public Vector3 GetFallbackPosition() => _fallbackTarget;

        public Vector3 GetFallbackPositionOrDefault(Vector3 defaultPos)
        {
            return HasValidFallbackPath() ? _fallbackTarget : defaultPos;
        }

        public bool HasValidFallbackPath()
        {
            return _currentFallbackPath.Count >= 2 && IsVectorValid(_fallbackTarget);
        }

        public void SetFallbackTarget(Vector3 target)
        {
            if (!IsVectorValid(target))
                return;

            if (Time.time - _lastFallbackAssignTime < FallbackCooldownSeconds)
                return;

            if (!IsBotMoveCapable(_bot))
                return;

            if (TrySampleNavMesh(target, NavMeshSampleRadius, out Vector3 navSafe) && IsVectorValid(navSafe))
            {
                _fallbackTarget = navSafe;
                _fallbackRetryCount = 0;
                _lastFallbackAssignTime = Time.time;
            }
        }

        public void SetFallbackPath(List<Vector3> path)
        {
            if (path == null || path.Count < 2)
                return;

            _currentFallbackPath.Clear();
            for (int i = 0; i < path.Count; i++)
            {
                Vector3 point = path[i];
                if (IsVectorValid(point))
                    _currentFallbackPath.Add(point);
            }

            if (_currentFallbackPath.Count >= 2)
                _fallbackTarget = _currentFallbackPath[_currentFallbackPath.Count - 1];
        }

        public bool ShallUseNow(float time)
        {
            return _bot != null &&
                   IsVectorValid(_fallbackTarget) &&
                   Vector3.Distance(_bot.Position, _fallbackTarget) > MinArrivalDistance;
        }

        public bool ShouldTriggerSuppressedFallback(float now, float lastStateChangeTime, float minStateDuration)
        {
            var suppression = _cache?.Suppression;
            var panic = _cache?.PanicHandler;
            float caution = _cache?.PersonalityProfile?.Caution ?? 0.5f;

            bool isSuppressed = suppression?.IsSuppressed() == true;
            bool isPanicking = panic?.IsPanicking == true;

            if (isSuppressed && (now - lastStateChangeTime) >= minStateDuration)
            {
                if (isPanicking || (caution < 0.2f && UnityEngine.Random.value < 0.4f))
                    return false;
                return true;
            }

            return false;
        }

        /// <summary>
        /// Per-frame update for fallback movement. All movement is path-based and validated. Teleportation forbidden.
        /// </summary>
        public void Tick(float time, Action<CombatState, float> forceState)
        {
            if (!IsBotMoveCapable(_bot) || !IsVectorValid(_fallbackTarget))
                return;

            try
            {
                if (!EFTPlayerUtil.IsValid(_bot.GetPlayer))
                    return;

                float now = Time.time;
                float delay = UnityEngine.Random.Range(MinHumanDelay, MaxHumanDelay);
                if (now - _lastMoveTime < delay)
                    return;

                _lastMoveTime = now;
                Vector3 destination = _fallbackTarget;

                if (!IsVectorValid(destination) || !TrySampleNavMesh(destination, NavMeshSampleRadius, out destination))
                {
                    // Fallback: retry up to MaxFallbackRetries, then give up this tick
                    _fallbackRetryCount++;
                    if (_fallbackRetryCount >= MaxFallbackRetries)
                    {
                        _fallbackRetryCount = 0;
                        Cancel();
                        return;
                    }
                    _fallbackTarget = GetSafeRandomFallback(_bot.Position);
                    return;
                }
                _fallbackRetryCount = 0;

                float cohesion = 1.0f;
                if (_cache?.PersonalityProfile != null)
                    cohesion = Mathf.Clamp(_cache.PersonalityProfile.Cohesion, 0.7f, 1.3f);

                if (Vector3.Distance(_bot.Position, destination) < MaxFallbackDistance)
                {
                    BotMovementHelper.SmoothMoveTo(_bot, destination, slow: true, cohesionScale: cohesion);
                    BotCoverHelper.TrySetStanceFromNearbyCover(_cache, destination);
                }

                if (Vector3.Distance(_bot.Position, destination) < MinArrivalDistance)
                {
                    forceState?.Invoke(CombatState.Patrol, time);
                    if (!FikaHeadlessDetector.IsHeadless)
                    {
                        try { _bot.BotTalk?.TrySay(EPhraseTrigger.NeedHelp); } catch { }
                    }
                }
            }
            catch
            {
                // All errors locally contained. No log spam.
            }
        }

        public bool IsActive()
        {
            return _bot != null &&
                   EFTPlayerUtil.IsValid(_bot.GetPlayer) &&
                   IsVectorValid(_fallbackTarget) &&
                   Vector3.Distance(_bot.Position, _fallbackTarget) > MinArrivalDistance;
        }

        public void Cancel()
        {
            _fallbackTarget = _bot != null ? _bot.Position : Vector3.zero;
            _currentFallbackPath.Clear();
            _fallbackRetryCount = 0;
        }

        public void Dispose()
        {
            _currentFallbackPath.Clear();
            TempListPool.Return(_currentFallbackPath);
        }

        #endregion

        #region Internal Helpers

        private static bool IsVectorValid(Vector3 v)
        {
            return !float.IsNaN(v.x) && !float.IsNaN(v.y) && !float.IsNaN(v.z)
                && v != Vector3.zero && v.y > -2.5f
                && v.x < 10000f && v.z < 10000f && v.x > -10000f && v.z > -10000f;
        }

        /// <summary>
        /// Minimal, EFT-safe movement gating (no IsActive/Stopped/CanMove).
        /// </summary>
        private static bool IsBotMoveCapable(BotOwner bot)
        {
            if (bot == null) return false;
            if (bot.Mover == null) return false;
            var player = bot.GetPlayer;
            if (player == null || player.HealthController == null || !player.HealthController.IsAlive) return false;
            if (player.MovementContext == null) return false;
            return true;
        }

        private Vector3 GetSafeRandomFallback(Vector3 origin)
        {
            if (_bot?.PatrollingData != null)
            {
                Vector3 patrol = _bot.PatrollingData.CurTargetPoint;
                if (IsVectorValid(patrol) && Vector3.Distance(patrol, origin) > 1.0f)
                    return TrySampleNavMesh(patrol, NavMeshSampleRadius, out Vector3 patrolNav) ? patrolNav : origin;
            }

            Vector3 candidate = origin + UnityEngine.Random.onUnitSphere * 2.0f;
            candidate.y = origin.y;

            return TrySampleNavMesh(candidate, NavMeshSampleRadius, out Vector3 navSafe) && IsVectorValid(navSafe)
                ? navSafe
                : origin + Vector3.forward * 0.25f;
        }

        private static bool TrySampleNavMesh(Vector3 candidate, float radius, out Vector3 navSafe)
        {
            navSafe = candidate;
            if (NavMesh.SamplePosition(candidate, out NavMeshHit hit, radius, NavMesh.AllAreas))
            {
                navSafe = hit.position;
                return true;
            }
            return false;
        }

        #endregion
    }
}
