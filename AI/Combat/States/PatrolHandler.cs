// <auto-generated>
//   This file is part of AI-Refactored, an open-source project focused on realistic AI behavior in Escape from Tarkov.
//   Licensed under the MIT License. See LICENSE in the repository root for more information.
//
//   THIS FILE IS SYSTEMATICALLY MANAGED.
//   Please follow strict StyleCop, ReSharper, and AI-Refactored code standards for all modifications.
// </auto-generated>

#nullable enable

namespace AIRefactored.AI.Combat.States
{
    using System;
    using System.Collections.Generic;
    using AIRefactored.AI.Core;
    using AIRefactored.AI.Helpers;
    using AIRefactored.AI.Hotspots;
    using AIRefactored.AI.Optimization;
    using EFT;
    using UnityEngine;

    /// <summary>
    /// Handles bot behavior while in the Patrol combat state.
    /// Evaluates sound cues, injuries, panic, suppression, and squad loss to trigger fallback.
    /// Periodically patrols between hotspots.
    /// </summary>
    public sealed class PatrolHandler
    {
        #region Constants

        private const float DeadAllyRadius = 10.0f;
        private const float InvestigateSoundDelay = 3.0f;
        private const float PanicThreshold = 0.25f;

        #endregion

        #region Fields

        private readonly BotOwner _bot;
        private readonly BotComponentCache _cache;
        private readonly float _minStateDuration;
        private readonly float _switchCooldownBase;

        private float _nextSwitchTime;

        #endregion

        #region Constructor

        /// <summary>
        /// Initializes a new instance of the <see cref="PatrolHandler"/> class.
        /// </summary>
        /// <param name="cache">The component cache for this bot.</param>
        /// <param name="minStateDuration">Minimum state duration before transition.</param>
        /// <param name="switchCooldownBase">Base delay between patrol switches.</param>
        public PatrolHandler(BotComponentCache cache, float minStateDuration, float switchCooldownBase)
        {
            if (cache == null || cache.Bot == null)
            {
                throw new ArgumentNullException(nameof(cache));
            }

            this._cache = cache;
            this._bot = cache.Bot;
            this._minStateDuration = minStateDuration;
            this._switchCooldownBase = switchCooldownBase;
        }

        #endregion

        #region Public Methods

        /// <summary>
        /// Always valid. Patrol state is the default idle behavior.
        /// </summary>
        /// <returns>True always.</returns>
        public bool ShallUseNow()
        {
            return true;
        }

        /// <summary>
        /// Returns true if a recent sound and personality caution warrant transition to Investigate.
        /// </summary>
        /// <param name="time">Current world time.</param>
        /// <returns>True if Investigate transition should occur.</returns>
        public bool ShouldTransitionToInvestigate(float time)
        {
            if (this._cache.Combat == null)
            {
                return false;
            }

            BotPersonalityProfile? profile = this._cache.AIRefactoredBotOwner?.PersonalityProfile;
            if (profile == null || profile.Caution <= 0.35f)
            {
                return false;
            }

            return this._cache.LastHeardTime + InvestigateSoundDelay > time &&
                   time - this._cache.Combat.LastStateChangeTime > this._minStateDuration;
        }

        /// <summary>
        /// Patrols randomly between hotspots and checks for fallback triggers.
        /// </summary>
        /// <param name="time">Current world time.</param>
        public void Tick(float time)
        {
            if (this.ShouldTriggerFallback())
            {
                if (this._cache.Pathing == null)
                {
                    this._cache.Combat?.TriggerFallback(this._bot.Position);
                    return;
                }

                List<Vector3> path = BotCoverRetreatPlanner.GetCoverRetreatPath(
                    this._bot,
                    this._bot.LookDirection.normalized,
                    this._cache.Pathing);

                Vector3 fallback = path.Count >= 2 ? path[path.Count - 1] : this._bot.Position;
                this._cache.Combat?.TriggerFallback(fallback);
                return;
            }

            if (time < this._nextSwitchTime)
            {
                return;
            }

            HotspotRegistry.Hotspot hotspot = HotspotRegistry.GetRandomHotspot();
            Vector3 target = hotspot.Position;
            Vector3 destination = this._cache.SquadPath != null
                ? this._cache.SquadPath.ApplyOffsetTo(target)
                : target;

            BotMovementHelper.SmoothMoveTo(this._bot, destination);
            BotCoverHelper.TrySetStanceFromNearbyCover(this._cache, destination);

            this._nextSwitchTime = time + UnityEngine.Random.Range(this._switchCooldownBase, this._switchCooldownBase + 18.0f);

            if (!FikaHeadlessDetector.IsHeadless && UnityEngine.Random.value < 0.25f)
            {
                this._bot.BotTalk?.TrySay(EPhraseTrigger.GoForward);
            }
        }

        #endregion

        #region Private Methods

        /// <summary>
        /// Determines whether fallback logic should be triggered due to low composure,
        /// injury state, suppression, or squadmate deaths nearby.
        /// </summary>
        /// <returns>True if fallback should be forced.</returns>
        private bool ShouldTriggerFallback()
        {
            float composure = this._cache.PanicHandler != null
                ? this._cache.PanicHandler.GetComposureLevel()
                : 1.0f;

            if (composure < PanicThreshold)
            {
                return true;
            }

            if (this._cache.InjurySystem != null && this._cache.InjurySystem.ShouldHeal())
            {
                return true;
            }

            if (this._cache.Suppression != null && this._cache.Suppression.IsSuppressed())
            {
                return true;
            }

            if (this._bot.BotsGroup != null)
            {
                int count = this._bot.BotsGroup.MembersCount;
                for (int i = 0; i < count; i++)
                {
                    BotOwner? member = this._bot.BotsGroup.Member(i);
                    if (member != null &&
                        member != this._bot &&
                        member.IsDead &&
                        Vector3.Distance(this._bot.Position, member.Position) < DeadAllyRadius)
                    {
                        return true;
                    }
                }
            }

            return false;
        }

        #endregion
    }
}
