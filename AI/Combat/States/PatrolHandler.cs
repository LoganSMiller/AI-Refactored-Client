// <auto-generated>
//   AI-Refactored: PatrolHandler.cs (Supreme Arbitration Overlay/Event, Beyond Diamond, Max Realism, June 2025)
//   Overlay/event-only patrol/fallback—NavMesh/squad/personality/cover aware, pooled, anti-parallel, anti-clump, error-isolated. No disables, no tick-move, never teleports or sets transform.
//   Follower/leader drift, stuck detection/correction, squad voice/pose overlays, anti-spam, all arbitration/event. SPT/FIKA/headless/client parity.
//   MIT License.
// </auto-generated>

namespace AIRefactored.AI.Combat.States
{
    using System;
    using AIRefactored.AI.Core;
    using AIRefactored.AI.Helpers;
    using AIRefactored.AI.Hotspots;
    using AIRefactored.AI.Navigation;
    using AIRefactored.Pools;
    using AIRefactored.Core;
    using EFT;
    using UnityEngine;
    using UnityEngine.AI;

    /// <summary>
    /// Drives all overlay-driven patrol/fallback logic. NavMesh sampled, deduped, anti-parallel, anti-clump, pooled, error-isolated.
    /// Squad-aware drift, stuck correction, event/overlay-only: SPT/FIKA/headless/client parity guaranteed.
    /// </summary>
    public sealed class PatrolHandler
    {
        #region Constants

        private const float DeadAllyRadius = 10f;
        private const float InvestigateSoundDelay = 3f;
        private const float PanicThreshold = 0.25f;
        private const float MinHumanDelay = 0.09f;
        private const float MaxHumanDelay = 0.22f;
        private const float MinHotspotRandomOffset = 0.19f;
        private const float MaxHotspotRandomOffset = 1.15f;
        private const float NavMeshSampleRadius = 1.2f;
        private const float MaxPatrolDistance = 18.5f;
        private const float MinPatrolMoveDistance = 0.16f;
        private const float PatrolLookPauseMin = 0.35f;
        private const float PatrolLookPauseMax = 1.09f;
        private const float SquadSpread = 1.23f;
        private const float IdleLookVariance = 0.29f;
        private const float FallbackVoiceChance = 0.22f;
        private const float GroupAggroSpread = 0.23f;
        private const float FollowerLagSeconds = 0.91f;
        private const float LeaderFastTrackChance = 0.36f;
        private const float OverlayMoveDedupSqr = 0.00012f;
        private const int BackupNavAttempts = 4;
        private const float MaxNavmeshDeltaY = 3.4f;
        private const float StuckDetectionDist = 0.41f;
        private const float StuckDetectionTime = 7.4f;
        private const float PatrolAntiParallelRadius = 2.85f;

        private const BotOverlayType OverlayType = BotOverlayType.Patrol;

        #endregion

        #region Fields

        private readonly BotOwner _bot;
        private readonly BotComponentCache _cache;
        private readonly float _minStateDuration;
        private readonly float _switchCooldownBase;
        private float _nextSwitchTime;
        private float _lastPatrolTime = -1000f;
        private float _nextPatrolLookTime = -1000f;
        private bool _isLeader;
        private bool _isFollower;
        private float _followerLagUntil = -1000f;
        private Vector3 _lastIssuedMove = Vector3.zero;
        private Vector3 _lastRealPos = Vector3.zero;
        private float _lastMoveProgressTime = -1000f;

        #endregion

        #region Construction

        public PatrolHandler(BotComponentCache cache, float minStateDuration, float switchCooldownBase)
        {
            _cache = cache;
            _bot = cache?.Bot;
            _minStateDuration = minStateDuration;
            _switchCooldownBase = switchCooldownBase;
            _isLeader = IsSquadLeader(_bot);
            _isFollower = !_isLeader && (_bot?.BotsGroup?.MembersCount ?? 0) > 1;
            _lastIssuedMove = Vector3.zero;
            _lastRealPos = _bot?.Position ?? Vector3.zero;
            _lastMoveProgressTime = -1000f;
        }

        #endregion

        #region Overlay Patrol API

        public bool ShallUseNow() => _bot != null && _cache != null;

        public bool ShouldTransitionToInvestigate(float time)
        {
            if (_cache?.Combat == null || _cache.AIRefactoredBotOwner?.PersonalityProfile == null)
                return false;
            try
            {
                if (_cache.AIRefactoredBotOwner.PersonalityProfile.Caution <= 0.35f)
                    return false;
                return (_cache.LastHeardTime + InvestigateSoundDelay > time) &&
                       (time - _cache.Combat.LastStateChangeTime > _minStateDuration);
            }
            catch (Exception ex)
            {
                Plugin.LoggerInstance.LogError($"[PatrolHandler] ShouldTransitionToInvestigate failed: {ex}");
                return false;
            }
        }

        /// <summary>
        /// Overlay/event-driven patrol tick: NavMesh/squad/personality/cover overlays, anti-clump, stuck detection/correction, dedup, anticipation.
        /// </summary>
        public void Tick(float time)
        {
            if (_bot == null || _cache == null) return;

            try
            {
                float delay = UnityEngine.Random.Range(MinHumanDelay, MaxHumanDelay);
                if (time - _lastPatrolTime < delay)
                    return;

                if (_isFollower && _followerLagUntil > time)
                    return;

                // Stuck detection: If no progress for too long, trigger fallback/correction.
                float moveDelta = (_bot.Position - _lastRealPos).magnitude;
                if (moveDelta > StuckDetectionDist)
                {
                    _lastMoveProgressTime = time;
                    _lastRealPos = _bot.Position;
                }
                else if ((time - _lastMoveProgressTime) > StuckDetectionTime)
                {
                    if (_cache.Combat != null)
                        _cache.Combat.TriggerFallback(TryGetFallbackPosition(), time);
                    _lastMoveProgressTime = time;
                    _lastRealPos = _bot.Position;
                    if (_bot.BotTalk != null && UnityEngine.Random.value < 0.39f)
                    {
                        try { _bot.BotTalk.TrySay(EPhraseTrigger.NeedHelp); } catch { }
                    }
                    return;
                }

                _lastPatrolTime = time;

                if (ShouldTriggerFallback(time))
                {
                    _cache.Combat?.TriggerFallback(TryGetFallbackPosition(), time);
                    if (_bot.BotTalk != null && UnityEngine.Random.value < FallbackVoiceChance)
                    {
                        try { _bot.BotTalk.TrySay(EPhraseTrigger.NeedHelp); } catch { }
                    }
                    if (_isFollower)
                        _followerLagUntil = time + UnityEngine.Random.Range(0.3f, 0.8f);
                    return;
                }

                if (time < _nextSwitchTime)
                {
                    PerformPatrolIdleLook();
                    if (_isFollower && UnityEngine.Random.value < 0.18f)
                        _followerLagUntil = time + UnityEngine.Random.Range(FollowerLagSeconds * 0.8f, FollowerLagSeconds * 1.5f);
                    return;
                }

                Vector3 target = GetNextPatrolPoint(_bot.Position);

                // Anti-parallel: Check squad for parallel/overlap and adjust drift if needed.
                if (_bot.BotsGroup != null && _bot.BotsGroup.MembersCount > 1)
                {
                    for (int i = 0; i < _bot.BotsGroup.MembersCount; i++)
                    {
                        var mate = _bot.BotsGroup.Member(i);
                        if (mate == null || mate == _bot) continue;
                        if ((target - mate.Position).magnitude < PatrolAntiParallelRadius)
                            target += UnityEngine.Random.insideUnitSphere * 1.1f;
                    }
                }

                if ((_lastIssuedMove - target).sqrMagnitude < OverlayMoveDedupSqr)
                    return;

                if (BotMovementHelper.IsMovementPaused(_bot) || BotMovementHelper.IsInInteractionState(_bot))
                    return;

                float patrolCohesion = Mathf.Clamp(_cache?.PersonalityProfile?.Cohesion ?? 1f, 0.72f, 1.34f);

                if (_isLeader && UnityEngine.Random.value < LeaderFastTrackChance)
                    patrolCohesion *= 0.93f + UnityEngine.Random.value * 0.13f;
                if (_isFollower && UnityEngine.Random.value < 0.18f)
                    _followerLagUntil = time + UnityEngine.Random.Range(FollowerLagSeconds, FollowerLagSeconds * 2.7f);

                // Overlay arbitration: only one patrol overlay per bot per tick/type
                if (!BotOverlayManager.CanIssueMove(_bot, OverlayType))
                    return;

                BotMovementHelper.SmoothMoveToSafe(_bot, target, true, patrolCohesion, OverlayType);
                BotOverlayManager.RegisterMove(_bot, OverlayType);
                _lastIssuedMove = target;

                // Stance/cover overlays
                BotCoverHelper.TrySetStanceFromNearbyCover(_cache, target);

                // Personality/role/idle look overlays
                if (UnityEngine.Random.value < 0.23f + (_cache.PersonalityProfile?.Caution ?? 0f) * 0.13f)
                    PerformPatrolIdleLook();

                _nextSwitchTime = time + UnityEngine.Random.Range(_switchCooldownBase, _switchCooldownBase + 19.5f);

                // Squad/role/voice overlays
                if (_bot.BotTalk != null && UnityEngine.Random.value < 0.31f)
                {
                    try
                    {
                        if (_isLeader)
                            _bot.BotTalk.TrySay(UnityEngine.Random.value < 0.55f ? EPhraseTrigger.GoForward : EPhraseTrigger.CoverMe);
                        else if (_isFollower)
                            _bot.BotTalk.TrySay(UnityEngine.Random.value < 0.69f ? EPhraseTrigger.Ready : EPhraseTrigger.HoldPosition);
                        else
                            _bot.BotTalk.TrySay(UnityEngine.Random.value < 0.5f ? EPhraseTrigger.GoForward : EPhraseTrigger.CoverMe);
                    }
                    catch { }
                }
            }
            catch (Exception ex)
            {
                Plugin.LoggerInstance.LogError($"[PatrolHandler] Tick failed: {ex}");
            }
        }

        /// <summary>
        /// Returns the current planned patrol destination (or fallback), always NavMesh/Y validated.
        /// Used by FSM for overlay dedup/cooldown—never used for direct moves.
        /// </summary>
        public Vector3 GetNextPatrolPoint(Vector3 botPosition)
        {
            var hotspot = HotspotRegistry.GetRandomHotspot();
            if (hotspot == null || !IsVectorValid(hotspot.Position))
                return botPosition;

            Vector3 offset = UnityEngine.Random.insideUnitSphere * UnityEngine.Random.Range(MinHotspotRandomOffset, MaxHotspotRandomOffset);
            offset.y = 0f;
            Vector3 target = hotspot.Position + offset;

            if (_cache.SquadPath != null)
            {
                try { target = _cache.SquadPath.ApplyOffsetTo(target); } catch { }
            }
            else if (_bot?.BotsGroup != null && _bot.BotsGroup.MembersCount > 1)
            {
                int idx = GetSquadIndex(_bot);
                Vector3 perp = Vector3.Cross(Vector3.up, _bot.LookDirection.normalized);
                target += perp * (SquadSpread * (idx - (_bot.BotsGroup.MembersCount / 2f)));
                float aggro = Mathf.Clamp(_cache.PersonalityProfile?.AggressionLevel ?? 0f, 0f, 1f);
                float caution = Mathf.Clamp(_cache.PersonalityProfile?.Caution ?? 0f, 0f, 1f);
                target += perp * (GroupAggroSpread * (aggro - caution));
            }

            target = GetNavMeshSafeBulletproof(target, botPosition);
            float moveDist = (target - botPosition).magnitude;
            if (!IsVectorValid(target) || moveDist > MaxPatrolDistance || moveDist < MinPatrolMoveDistance)
                target = botPosition;

            return target;
        }

        #endregion

        #region Overlay/Hotspot/Fallback Safety

        private bool ShouldTriggerFallback(float time)
        {
            try
            {
                if (_cache.PanicHandler?.GetComposureLevel() < PanicThreshold) return true;
                if (_cache.InjurySystem?.ShouldHeal(time) == true) return true;
                if (_cache.Suppression?.IsSuppressed() == true) return true;

                var group = _bot?.BotsGroup;
                if (group == null) return false;

                for (int i = 0; i < group.MembersCount; i++)
                {
                    var mate = group.Member(i);
                    if (mate != null && mate != _bot && mate.IsDead)
                        if (Vector3.Distance(_bot.Position, mate.Position) < DeadAllyRadius)
                            return true;
                }
                return false;
            }
            catch (Exception ex)
            {
                Plugin.LoggerInstance.LogError($"[PatrolHandler] ShouldTriggerFallback failed: {ex}");
                return false;
            }
        }

        private Vector3 TryGetFallbackPosition()
        {
            try
            {
                Vector3 retreat = _bot.Position - _bot.LookDirection.normalized * 7.8f;
                retreat.y = _bot.Position.y;
                return GetNavMeshSafeBulletproof(retreat, _bot.Position);
            }
            catch
            {
                return _bot.Position;
            }
        }

        private void PerformPatrolIdleLook()
        {
            float now = Time.time;
            if (now < _nextPatrolLookTime)
                return;

            _nextPatrolLookTime = now + UnityEngine.Random.Range(PatrolLookPauseMin, PatrolLookPauseMax);

            Vector3 offset = UnityEngine.Random.insideUnitSphere * IdleLookVariance;
            offset.y = 0f;
            Vector3 lookTarget = _bot.Position + _bot.LookDirection.normalized * 2.55f + offset;
            BotMovementHelper.SmoothLookTo(_bot, lookTarget, 2.23f + UnityEngine.Random.value * 1.37f);
        }

        /// <summary>
        /// Bulletproof NavMesh-sampled patrol destination with backup retry logic and vertical clamp.
        /// </summary>
        private static Vector3 GetNavMeshSafeBulletproof(Vector3 candidate, Vector3 origin)
        {
            if (NavMesh.SamplePosition(candidate, out var hit, NavMeshSampleRadius, NavMesh.AllAreas))
                return ClampYValid(hit.position, origin);

            for (int i = 0; i < BackupNavAttempts; i++)
            {
                Vector3 fallback = origin + UnityEngine.Random.insideUnitSphere * (2.2f + i * 0.73f);
                fallback.y = origin.y;
                if (NavMesh.SamplePosition(fallback, out var nav, NavMeshSampleRadius, NavMesh.AllAreas))
                    return ClampYValid(nav.position, origin);
            }

            return ClampYValid(origin, origin);
        }

        private static Vector3 ClampYValid(Vector3 v, Vector3 basePos)
        {
            if (Mathf.Abs(v.y - basePos.y) > MaxNavmeshDeltaY || v.y < -2.5f)
                v.y = basePos.y;
            return v;
        }

        private static int GetSquadIndex(BotOwner bot)
        {
            if (bot?.BotsGroup == null) return -1;
            for (int i = 0; i < bot.BotsGroup.MembersCount; i++)
                if (bot.BotsGroup.Member(i) == bot) return i;
            return -1;
        }

        private static bool IsSquadLeader(BotOwner bot)
        {
            return GetSquadIndex(bot) == 0;
        }

        private static bool IsVectorValid(Vector3 v)
        {
            return !float.IsNaN(v.x) && !float.IsNaN(v.y) && !float.IsNaN(v.z)
                   && Mathf.Abs(v.y) < 1000f && v.y > -2.5f;
        }

        #endregion
    }
}
