// <auto-generated>
//   This file is part of AI-Refactored, an open-source project focused on realistic AI behavior in Escape from Tarkov.
//   Licensed under the MIT License. See LICENSE in the repository root for more information.
//
//   THIS FILE IS SYSTEMATICALLY MANAGED.
//   Please follow strict StyleCop, ReSharper, and AI-Refactored code standards for all modifications.
// </auto-generated>

#nullable enable

namespace AIRefactored.AI.Combat.States
{
    using System.Collections.Generic;

    using AIRefactored.AI.Core;
    using AIRefactored.AI.Helpers;
    using AIRefactored.AI.Hotspots;
    using AIRefactored.AI.Optimization;
    using EFT;
    using UnityEngine;

    /// <summary>
    /// Handles bot behavior while in the Patrol combat state.
    /// Evaluates sound cues, injuries, panic, suppression, and squad loss to trigger fallback.
    /// Periodically patrols between hotspots.
    /// </summary>
    public sealed class PatrolHandler
    {
        private const float DeadAllyRadius = 10.0f;
        private const float InvestigateSoundDelay = 3.0f;
        private const float PanicThreshold = 0.25f;

        private readonly BotOwner _bot;
        private readonly BotComponentCache _cache;
        private readonly float _minStateDuration;
        private readonly float _switchCooldownBase;

        private float _nextSwitchTime;

        /// <summary>
        /// Initializes a new instance of the <see cref="PatrolHandler"/> class.
        /// </summary>
        public PatrolHandler(BotComponentCache cache, float minStateDuration = 1.25f, float switchCooldownBase = 12.0f)
        {
            this._cache = cache ?? throw new System.ArgumentNullException(nameof(cache));
            this._bot = cache.Bot ?? throw new System.ArgumentNullException(nameof(cache.Bot));
            this._minStateDuration = minStateDuration;
            this._switchCooldownBase = switchCooldownBase;
        }

        /// <summary>
        /// Always active when no other combat layer is active.
        /// </summary>
        public bool ShallUseNow()
        {
            return true;
        }

        /// <summary>
        /// Checks if caution + recent sound should trigger Investigate.
        /// </summary>
        public bool ShouldTransitionToInvestigate(float time)
        {
            if (this._cache.Combat == null)
            {
                return false;
            }

            return this._cache.LastHeardTime + InvestigateSoundDelay > time &&
                   this._cache.AIRefactoredBotOwner?.PersonalityProfile?.Caution > 0.35f &&
                   time - this._cache.Combat.LastStateChangeTime > this._minStateDuration;
        }

        /// <summary>
        /// Drives patrol pathing, fallback checks, and ambient VO.
        /// </summary>
        public void Tick(float time)
        {
            if (this.ShouldTriggerFallback())
            {
                if (this._cache.Pathing == null)
                {
                    this._cache.Combat?.TriggerFallback(this._bot.Position);
                    return;
                }

                List<Vector3> fallbackPath = BotCoverRetreatPlanner.GetCoverRetreatPath(
                    this._bot,
                    this._bot.LookDirection.normalized,
                    this._cache.Pathing);

                Vector3 fallbackDestination = fallbackPath.Count >= 2
                                                  ? fallbackPath[fallbackPath.Count - 1]
                                                  : this._bot.Position;

                this._cache.Combat?.TriggerFallback(fallbackDestination);
                return;
            }

            if (time < this._nextSwitchTime)
            {
                return;
            }

            HotspotRegistry.Hotspot hotspot = HotspotRegistry.GetRandomHotspot();
            Vector3 baseTarget = hotspot.Position;
            Vector3 destination = this._cache.Pathing?.ApplyOffsetTo(baseTarget) ?? baseTarget;

            BotMovementHelper.SmoothMoveTo(this._bot, destination);
            BotCoverHelper.TrySetStanceFromNearbyCover(this._cache, destination);

            this._nextSwitchTime = time + UnityEngine.Random.Range(
                                       this._switchCooldownBase,
                                       this._switchCooldownBase + 18.0f);

            if (UnityEngine.Random.value < 0.25f)
            {
                this._bot.BotTalk?.TrySay(EPhraseTrigger.GoForward);
            }
        }


        /// <summary>
        /// Checks panic, injuries, suppression, or nearby dead squadmates to trigger fallback.
        /// </summary>
        private bool ShouldTriggerFallback()
        {
            float composure = this._cache.PanicHandler?.GetComposureLevel() ?? 1.0f;
            if (composure < PanicThreshold)
            {
                return true;
            }

            if (this._cache.InjurySystem?.ShouldHeal() == true)
            {
                return true;
            }

            if (this._cache.Suppression?.IsSuppressed() == true)
            {
                return true;
            }

            if (this._bot.BotsGroup != null)
            {
                for (int i = 0; i < this._bot.BotsGroup.MembersCount; i++)
                {
                    BotOwner? mate = this._bot.BotsGroup.Member(i);
                    if (mate != null &&
                        mate != this._bot &&
                        mate.IsDead &&
                        Vector3.Distance(this._bot.Position, mate.Position) < DeadAllyRadius)
                    {
                        return true;
                    }
                }
            }

            return false;
        }
    }
}
