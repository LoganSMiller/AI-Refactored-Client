// <auto-generated>
//   This file is part of AI-Refactored, an open-source project focused on realistic AI behavior in Escape from Tarkov.
//   Licensed under the MIT License. See LICENSE in the repository root for more information.
//
//   THIS FILE IS SYSTEMATICALLY MANAGED.
//   Please follow strict StyleCop, ReSharper, and AI-Refactored code standards for all modifications.
// </auto-generated>

#nullable enable

namespace AIRefactored.AI.Combat.States
{
    using System;
    using System.Collections.Generic;
    using AIRefactored.AI.Core;
    using AIRefactored.AI.Helpers;
    using AIRefactored.AI.Hotspots;
    using AIRefactored.AI.Optimization;
    using AIRefactored.Runtime;
    using EFT;
    using UnityEngine;

    /// <summary>
    /// Handles bot behavior while in the Patrol combat state.
    /// Evaluates sound cues, injuries, panic, suppression, and squad loss to trigger fallback.
    /// Periodically patrols between hotspots.
    /// </summary>
    public sealed class PatrolHandler
    {
        #region Constants

        private const float DeadAllyRadius = 10.0f;
        private const float InvestigateSoundDelay = 3.0f;
        private const float PanicThreshold = 0.25f;

        #endregion

        #region Fields

        private readonly BotOwner _bot;
        private readonly BotComponentCache _cache;
        private readonly float _minStateDuration;
        private readonly float _switchCooldownBase;
        private float _nextSwitchTime;

        #endregion

        #region Constructor

        /// <summary>
        /// Initializes a new instance of the <see cref="PatrolHandler"/> class.
        /// </summary>
        /// <param name="cache">Component cache containing bot subsystems.</param>
        /// <param name="minStateDuration">Minimum duration before transitioning from patrol.</param>
        /// <param name="switchCooldownBase">Base time before switching patrol target.</param>
        public PatrolHandler(BotComponentCache cache, float minStateDuration, float switchCooldownBase)
        {
            if (cache == null || cache.Bot == null)
            {
                throw new ArgumentNullException(nameof(cache), "[PatrolHandler] Initialization failed: cache or bot is null.");
            }

            this._cache = cache;
            this._bot = cache.Bot;
            this._minStateDuration = minStateDuration;
            this._switchCooldownBase = switchCooldownBase;
        }

        #endregion

        #region Public Methods

        public bool ShallUseNow()
        {
            return true;
        }

        public bool ShouldTransitionToInvestigate(float time)
        {
            if (this._cache.Combat == null || this._cache.AIRefactoredBotOwner == null)
            {
                return false;
            }

            BotPersonalityProfile? profile = this._cache.AIRefactoredBotOwner.PersonalityProfile;
            if (profile == null || profile.Caution <= 0.35f)
            {
                return false;
            }

            bool heardRecently = this._cache.LastHeardTime + InvestigateSoundDelay > time;
            bool cooldownPassed = time - this._cache.Combat.LastStateChangeTime > this._minStateDuration;

            return heardRecently && cooldownPassed;
        }

        public void Tick(float time)
        {
            if (this.ShouldTriggerFallback())
            {
                if (this._cache.Pathing == null || this._cache.Combat == null)
                {
                    this._cache.Combat?.TriggerFallback(this._bot.Position);
                    return;
                }

                List<Vector3> path = BotCoverRetreatPlanner.GetCoverRetreatPath(
                    this._bot,
                    this._bot.LookDirection.normalized,
                    this._cache.Pathing);

                Vector3 fallback = path.Count >= 2 ? path[path.Count - 1] : this._bot.Position;
                this._cache.Combat.TriggerFallback(fallback);
                return;
            }

            if (time < this._nextSwitchTime)
            {
                return;
            }

            HotspotRegistry.Hotspot hotspot = HotspotRegistry.GetRandomHotspot();
            Vector3 target = hotspot.Position;

            Vector3 destination = this._cache.SquadPath != null
                ? this._cache.SquadPath.ApplyOffsetTo(target)
                : target;

            if (float.IsNaN(destination.x) || float.IsNaN(destination.y) || float.IsNaN(destination.z))
            {
                AIRefactoredController.Logger.LogWarning("[PatrolHandler] Skipped patrol move: destination contains NaN.");
                return;
            }

            BotMovementHelper.SmoothMoveTo(this._bot, destination);
            BotCoverHelper.TrySetStanceFromNearbyCover(this._cache, destination);

            this._nextSwitchTime = time + UnityEngine.Random.Range(this._switchCooldownBase, this._switchCooldownBase + 18.0f);

            if (!FikaHeadlessDetector.IsHeadless && this._bot.BotTalk != null && UnityEngine.Random.value < 0.25f)
            {
                this._bot.BotTalk.TrySay(EPhraseTrigger.GoForward);
            }
        }

        #endregion

        #region Private Methods

        private bool ShouldTriggerFallback()
        {
            if (this._cache.PanicHandler != null && this._cache.PanicHandler.GetComposureLevel() < PanicThreshold)
            {
                return true;
            }

            if (this._cache.InjurySystem != null && this._cache.InjurySystem.ShouldHeal())
            {
                return true;
            }

            if (this._cache.Suppression != null && this._cache.Suppression.IsSuppressed())
            {
                return true;
            }

            BotsGroup? group = this._bot.BotsGroup;
            if (group == null)
            {
                return false;
            }

            for (int i = 0; i < group.MembersCount; i++)
            {
                BotOwner? member = group.Member(i);
                if (member == null || member == this._bot)
                {
                    continue;
                }

                float dist = Vector3.Distance(this._bot.Position, member.Position);
                if (member.IsDead && dist < DeadAllyRadius)
                {
                    return true;
                }
            }

            return false;
        }

        #endregion
    }
}
