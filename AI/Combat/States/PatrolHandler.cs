// <auto-generated>
//   This file is part of AI-Refactored, an open-source project focused on realistic AI behavior in Escape from Tarkov.
//   Licensed under the MIT License. See LICENSE in the repository root for more information.
//
//   THIS FILE IS SYSTEMATICALLY MANAGED.
//   Please follow strict StyleCop, ReSharper, and AI-Refactored code standards for all modifications.
// </auto-generated>

namespace AIRefactored.AI.Combat.States
{
    using System;
    using System.Collections.Generic;
    using AIRefactored.AI.Core;
    using AIRefactored.AI.Helpers;
    using AIRefactored.AI.Hotspots;
    using AIRefactored.AI.Optimization;
    using AIRefactored.Runtime;
    using EFT;
    using UnityEngine;

    /// <summary>
    /// Handles bot behavior while in Patrol state.
    /// Evaluates suppression, panic, wounds, or nearby deaths to trigger fallback, and moves bots between hotspots.
    /// </summary>
    public sealed class PatrolHandler
    {
        #region Constants

        private const float DeadAllyRadius = 10.0f;
        private const float InvestigateSoundDelay = 3.0f;
        private const float PanicThreshold = 0.25f;
        private const float FallbackPathMinLength = 2;

        #endregion

        #region Fields

        private readonly BotOwner _bot;
        private readonly BotComponentCache _cache;
        private readonly float _minStateDuration;
        private readonly float _switchCooldownBase;

        private float _nextSwitchTime;

        #endregion

        #region Constructor

        /// <summary>
        /// Initializes a new instance of the <see cref="PatrolHandler"/> class.
        /// </summary>
        /// <param name="cache">Component cache containing bot subsystems.</param>
        /// <param name="minStateDuration">Minimum duration before switching states.</param>
        /// <param name="switchCooldownBase">Base interval before picking a new patrol target.</param>
        public PatrolHandler(BotComponentCache cache, float minStateDuration, float switchCooldownBase)
        {
            if (cache == null || cache.Bot == null)
            {
                throw new ArgumentException("[PatrolHandler] Initialization failed: cache or Bot is null.");
            }

            this._cache = cache;
            this._bot = cache.Bot;
            this._minStateDuration = minStateDuration;
            this._switchCooldownBase = switchCooldownBase;
        }

        #endregion

        #region Public Methods

        /// <summary>
        /// Patrol state is always available unless superseded by higher priority conditions.
        /// </summary>
        public bool ShallUseNow()
        {
            return true;
        }

        /// <summary>
        /// Determines if bot should escalate to investigate based on caution and sound cues.
        /// </summary>
        public bool ShouldTransitionToInvestigate(float time)
        {
            CombatStateMachine combat = this._cache.Combat;
            BotPersonalityProfile profile = this._cache.AIRefactoredBotOwner?.PersonalityProfile;

            if (combat == null || profile == null || profile.Caution <= 0.35f)
            {
                return false;
            }

            bool heardSound = this._cache.LastHeardTime + InvestigateSoundDelay > time;
            bool cooldownPassed = time - combat.LastStateChangeTime > this._minStateDuration;

            return heardSound && cooldownPassed;
        }

        /// <summary>
        /// Drives patrol logic. Evaluates fallback triggers and executes patrol route traversal.
        /// </summary>
        public void Tick(float time)
        {
            if (this.ShouldTriggerFallback())
            {
                CombatStateMachine combat = this._cache.Combat;
                if (combat == null)
                {
                    return;
                }

                Vector3 fallback = this.TryGetFallbackPosition();
                combat.TriggerFallback(fallback);
                return;
            }

            if (time < this._nextSwitchTime)
            {
                return;
            }

            HotspotRegistry.Hotspot hotspot = HotspotRegistry.GetRandomHotspot();
            Vector3 target = hotspot.Position;

            Vector3 destination = (this._cache.SquadPath != null)
                ? this._cache.SquadPath.ApplyOffsetTo(target)
                : target;

            if (float.IsNaN(destination.x) || float.IsNaN(destination.y) || float.IsNaN(destination.z))
            {
                Plugin.LoggerInstance.LogWarning("[PatrolHandler] Skipped patrol move: destination contains NaN.");
                return;
            }

            BotMovementHelper.SmoothMoveTo(this._bot, destination);
            BotCoverHelper.TrySetStanceFromNearbyCover(this._cache, destination);

            this._nextSwitchTime = time + UnityEngine.Random.Range(this._switchCooldownBase, this._switchCooldownBase + 18.0f);

            if (!FikaHeadlessDetector.IsHeadless && this._bot.BotTalk != null && UnityEngine.Random.value < 0.25f)
            {
                this._bot.BotTalk.TrySay(EPhraseTrigger.GoForward);
            }
        }

        #endregion

        #region Private Methods

        private bool ShouldTriggerFallback()
        {
            if (this._cache.PanicHandler != null && this._cache.PanicHandler.GetComposureLevel() < PanicThreshold)
            {
                return true;
            }

            if (this._cache.InjurySystem != null && this._cache.InjurySystem.ShouldHeal())
            {
                return true;
            }

            if (this._cache.Suppression != null && this._cache.Suppression.IsSuppressed())
            {
                return true;
            }

            BotsGroup group = this._bot.BotsGroup;
            if (group == null)
            {
                return false;
            }

            Vector3 myPos = this._bot.Position;
            for (int i = 0, count = group.MembersCount; i < count; i++)
            {
                BotOwner member = group.Member(i);
                if (member != null && member != this._bot && member.IsDead)
                {
                    if (Vector3.Distance(myPos, member.Position) < DeadAllyRadius)
                    {
                        return true;
                    }
                }
            }

            return false;
        }

        private Vector3 TryGetFallbackPosition()
        {
            Vector3 fallback = this._bot.Position;

            if (this._cache.Pathing != null)
            {
                Vector3 lookDir = this._bot.LookDirection.normalized;
                List<Vector3> path = BotCoverRetreatPlanner.GetCoverRetreatPath(this._bot, lookDir, this._cache.Pathing);

                if (path != null && path.Count >= FallbackPathMinLength)
                {
                    fallback = path[path.Count - 1];
                }
            }

            return fallback;
        }

        #endregion
    }
}
