// <auto-generated>
//   AI-Refactored: CombatStateMachine.cs (Max Realism Edition)
//   Fully squad-aware, error-isolated, never disables, never triggers fallback AI.
//   All movement, fallback, and patrol logic uses helper-only navigation and pooling. 
//   Licensed under MIT.
// </auto-generated>

namespace AIRefactored.AI.Combat
{
    using System;
    using AIRefactored.AI.Combat.States;
    using AIRefactored.AI.Core;
    using AIRefactored.AI.Groups;
    using AIRefactored.AI.Helpers;
    using AIRefactored.AI.Memory;
    using AIRefactored.AI.Navigation;
    using AIRefactored.Core;
    using AIRefactored.Pools;
    using AIRefactored.Runtime;
    using BepInEx.Logging;
    using EFT;
    using UnityEngine;

    /// <summary>
    /// Drives full bot combat state transitions, including fallback, engagement, patrol, suppression, and escalation.
    /// No disables, all errors locally isolated, full squad/voice/cover/safety.
    /// </summary>
    public sealed class CombatStateMachine
    {
        #region Constants

        private const float MinTransitionDelay = 0.4f;
        private const float PatrolMinDuration = 1.25f;
        private const float PatrolCooldown = 12.0f;
        private const float ReentryCooldown = 3.0f;

        #endregion

        #region Fields

        private BotComponentCache _cache;
        private BotOwner _bot;

        private AttackHandler _attack;
        private EngageHandler _engage;
        private FallbackHandler _fallback;
        private InvestigateHandler _investigate;
        private PatrolHandler _patrol;
        private EchoCoordinator _echo;

        private Vector3 _lastKnownEnemyPos;
        private bool _hasKnownEnemy;
        private float _lastStateChangeTime;
        private bool _initialized;

        #endregion

        #region Properties

        /// <summary>Last seen position of enemy.</summary>
        public Vector3 LastKnownEnemyPos => _lastKnownEnemyPos;

        /// <summary>Time of last state change.</summary>
        public float LastStateChangeTime => _lastStateChangeTime;

        #endregion

        #region Initialization

        public void Initialize(BotComponentCache componentCache)
        {
            if (componentCache?.Bot == null)
            {
                Plugin.LoggerInstance.LogError("[CombatStateMachine] Initialization failed: null references.");
                _initialized = false;
                return;
            }

            try
            {
                _cache = componentCache;
                _bot = componentCache.Bot;

                _fallback = componentCache.Fallback ?? new FallbackHandler(componentCache);
                _patrol = new PatrolHandler(componentCache, PatrolMinDuration, PatrolCooldown);
                _investigate = new InvestigateHandler(componentCache);
                _engage = new EngageHandler(componentCache);
                _attack = new AttackHandler(componentCache);
                _echo = new EchoCoordinator(componentCache);

                _lastKnownEnemyPos = Vector3.zero;
                _hasKnownEnemy = false;
                _lastStateChangeTime = 0f;
                _initialized = true;
            }
            catch (Exception ex)
            {
                Plugin.LoggerInstance.LogError("[CombatStateMachine] Exception during Initialize: " + ex);
                _initialized = false;
            }
        }

        #endregion

        #region Public API

        /// <summary>
        /// True if bot is in any combat state (fallback, engage, investigate, targeting).
        /// </summary>
        public bool IsInCombatState()
        {
            try
            {
                return _initialized &&
                    (_fallback?.IsActive() == true ||
                     _engage?.IsEngaging() == true ||
                     _investigate?.IsInvestigating() == true ||
                     _cache?.ThreatSelector?.CurrentTarget != null);
            }
            catch (Exception ex)
            {
                Plugin.LoggerInstance.LogError("[CombatStateMachine] Exception in IsInCombatState: " + ex);
                return false;
            }
        }

        /// <summary>
        /// Notifies the machine that the bot has been damaged (triggers fallback logic).
        /// </summary>
        public void NotifyDamaged()
        {
            if (!_initialized || _fallback == null) return;

            try
            {
                float time = Time.time;
                if (_fallback.ShallUseNow(time))
                {
                    AssignFallbackIfNeeded();
                    TrySay(EPhraseTrigger.OnBeingHurt);
                    _lastStateChangeTime = time;
                }
            }
            catch (Exception ex)
            {
                Plugin.LoggerInstance.LogError("[CombatStateMachine] Exception in NotifyDamaged: " + ex);
            }
        }

        /// <summary>
        /// Squad coordination: triggers investigation on echo.
        /// </summary>
        public void NotifyEchoInvestigate()
        {
            if (!_initialized || _investigate == null) return;

            try
            {
                float time = Time.time;
                if (_investigate.ShallUseNow(time, _lastStateChangeTime))
                {
                    _lastStateChangeTime = time;
                    TrySay(EPhraseTrigger.Cooperation);
                }
            }
            catch (Exception ex)
            {
                Plugin.LoggerInstance.LogError("[CombatStateMachine] Exception in NotifyEchoInvestigate: " + ex);
            }
        }

        /// <summary>
        /// Main Tick – advances all combat state logic, transitions, patrols, fallback, and engagement.
        /// </summary>
        public void Tick(float time)
        {
            if (!_initialized || _bot == null || _bot.IsDead || !EFTPlayerUtil.IsValid(_bot.GetPlayer)) return;

            try
            {
                if (time - _lastStateChangeTime < MinTransitionDelay)
                    return;

                if (TryReenterCombatState(time))
                {
                    _lastStateChangeTime = time;
                    return;
                }

                if (ShouldTriggerSuppressedFallback(time))
                {
                    AssignFallbackIfNeeded();
                    TrySay(EPhraseTrigger.OnBeingHurt);
                    _echo?.EchoFallbackToSquad(_fallback.GetFallbackPositionOrDefault(_bot.Position));
                    _lastStateChangeTime = time;
                    return;
                }

                if (_fallback?.ShallUseNow(time) == true)
                {
                    AssignFallbackIfNeeded();
                    _fallback.Tick(time, SetLastStateChangeTime);
                    return;
                }

                Player enemy = _cache?.ThreatSelector?.CurrentTarget;
                if (EFTPlayerUtil.IsValid(enemy))
                {
                    _lastKnownEnemyPos = EFTPlayerUtil.GetPosition(enemy);
                    _hasKnownEnemy = true;

                    string id = enemy.ProfileId;
                    if (!string.IsNullOrEmpty(id))
                        _cache?.TacticalMemory?.RecordEnemyPosition(_lastKnownEnemyPos, "Combat", id);

                    if (_bot.Mover != null && !_bot.Mover.Sprinting)
                        _bot.Sprint(true);

                    _echo?.EchoSpottedEnemyToSquad(_lastKnownEnemyPos);
                }

                if (_engage?.ShallUseNow() == true)
                {
                    if (_engage.CanAttack())
                        _attack?.Tick(time);
                    else
                        _engage.Tick();

                    _lastStateChangeTime = time;
                    return;
                }

                if (_investigate?.ShallUseNow(time, _lastStateChangeTime) == true)
                {
                    Vector3 target = _investigate.GetInvestigateTarget(_hasKnownEnemy ? _lastKnownEnemyPos : Vector3.zero);
                    if (target != Vector3.zero)
                    {
                        _investigate.Investigate(target);
                        _lastStateChangeTime = time;
                    }
                    return;
                }

                _patrol?.Tick(time);
            }
            catch (Exception ex)
            {
                Plugin.LoggerInstance.LogError("[CombatStateMachine] Exception in Tick: " + ex);
            }
        }

        /// <summary>
        /// External system can request an explicit fallback to a given position.
        /// </summary>
        public void TriggerFallback(Vector3 fallbackPos)
        {
            if (!_initialized || _fallback == null) return;

            try
            {
                _fallback.SetFallbackTarget(fallbackPos);
                TrySay(EPhraseTrigger.OnLostVisual);
                _lastStateChangeTime = Time.time;
            }
            catch (Exception ex)
            {
                Plugin.LoggerInstance.LogError("[CombatStateMachine] Exception in TriggerFallback: " + ex);
            }
        }

        /// <summary>
        /// Helper to update stance based on cover, using cover-aware helpers only.
        /// </summary>
        public void TrySetStanceFromNearbyCover(Vector3 pos)
        {
            try
            {
                _cache?.PoseController?.TrySetStanceFromNearbyCover(pos);
            }
            catch (Exception ex)
            {
                Plugin.LoggerInstance.LogError("[CombatStateMachine] Exception in TrySetStanceFromNearbyCover: " + ex);
            }
        }

        #endregion

        #region Internal State Logic

        /// <summary>
        /// Assigns fallback logic and valid path/cover if required, pools all path data.
        /// </summary>
        private void AssignFallbackIfNeeded()
        {
            try
            {
                if (_fallback == null || _fallback.HasValidFallbackPath())
                    return;

                Vector3 retreatDir = _bot.LookDirection.sqrMagnitude > 0.01f
                    ? -_bot.LookDirection.normalized
                    : Vector3.back;

                Vector3 fallback;
                if (!BotNavHelper.TryGetSafeTarget(_bot, out fallback) || !IsVectorValid(fallback))
                    fallback = _bot.Position + retreatDir * 5f;

                // Vector3.y guard: prevent all teleport/fallback bugs
                if (fallback.y < -2.5f)
                    fallback = _bot.Position;

                var path = TempListPool.Rent<Vector3>();
                path.Clear();
                path.Add(_bot.Position);
                path.Add(fallback);

                _fallback.SetFallbackPath(path);
                _fallback.SetFallbackTarget(fallback);
                TrySetStanceFromNearbyCover(fallback);

                TempListPool.Return(path);
            }
            catch (Exception ex)
            {
                Plugin.LoggerInstance.LogError("[CombatStateMachine] Exception in AssignFallbackIfNeeded: " + ex);
            }
        }

        /// <summary>
        /// If suppression/panic threshold is exceeded, fallback is triggered.
        /// </summary>
        private bool ShouldTriggerSuppressedFallback(float time)
        {
            try
            {
                if (_cache?.PanicHandler == null || _fallback == null)
                    return false;

                float composure = _cache.PanicHandler.GetComposureLevel();
                float delay = Mathf.Lerp(0.75f, 1.5f, 1f - composure);
                return _fallback.ShouldTriggerSuppressedFallback(time, _lastStateChangeTime, delay);
            }
            catch (Exception ex)
            {
                Plugin.LoggerInstance.LogError("[CombatStateMachine] Exception in ShouldTriggerSuppressedFallback: " + ex);
                return false;
            }
        }

        /// <summary>
        /// Attempts to re-enter combat from fallback state based on squad, targets, or cooldown.
        /// </summary>
        private bool TryReenterCombatState(float time)
        {
            try
            {
                if (_fallback == null || !_fallback.IsActive())
                    return false;

                if (_cache?.ThreatSelector?.CurrentTarget != null)
                {
                    _fallback.Cancel();
                    TrySay(EPhraseTrigger.OnEnemyConversation);
                    return true;
                }

                if (_cache?.GroupSync?.IsSquadReady() == true)
                {
                    Vector3 self = _bot.Position;
                    var squad = _cache.GroupSync.GetTeammates();
                    for (int i = 0; i < squad.Count; i++)
                    {
                        BotOwner mate = squad[i];
                        if (mate != null && !mate.IsDead && mate != _bot && Vector3.Distance(mate.Position, self) < 12f)
                        {
                            _fallback.Cancel();
                            TrySay(EPhraseTrigger.Cooperation);
                            return true;
                        }
                    }
                }

                if (time - _lastStateChangeTime > ReentryCooldown)
                {
                    _fallback.Cancel();
                    TrySay(EPhraseTrigger.Ready);
                    return true;
                }

                return false;
            }
            catch (Exception ex)
            {
                Plugin.LoggerInstance.LogError("[CombatStateMachine] Exception in TryReenterCombatState: " + ex);
                return false;
            }
        }

        /// <summary>
        /// State callback: set last state change time.
        /// </summary>
        private void SetLastStateChangeTime(CombatState state, float time)
        {
            _lastStateChangeTime = time;
        }

        /// <summary>
        /// Voice/phrase helper, null-safe, never disables.
        /// </summary>
        private void TrySay(EPhraseTrigger phrase)
        {
            try { _bot?.BotTalk?.TrySay(phrase); }
            catch { }
        }

        /// <summary>
        /// Validates that vector is safe, not NaN, not deep negative Y.
        /// </summary>
        private static bool IsVectorValid(Vector3 v)
        {
            return !float.IsNaN(v.x) && !float.IsNaN(v.y) && !float.IsNaN(v.z) && v != Vector3.zero && v.y > -2.5f;
        }

        #endregion
    }
}
