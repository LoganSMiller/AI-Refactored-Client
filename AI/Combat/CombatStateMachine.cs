// <auto-generated>
//   AI-Refactored: CombatStateMachine.cs (Supreme Arbitration Overlay/Event-Only, Ultra-Platinum++, June 2025, Mastermoveplan, Squad-Realism, Max Safety)
//   One-overlay-move-per-intent. Zero per-frame move. Triple-guard arbitration, squad comms, pooled, bulletproof, SPT/FIKA/headless/client safe.
//   MIT License.
// </auto-generated>

namespace AIRefactored.AI.Combat
{
    using System;
    using AIRefactored.AI.Combat.States;
    using AIRefactored.AI.Core;
    using AIRefactored.AI.Groups;
    using AIRefactored.AI.Helpers;
    using AIRefactored.AI.Memory;
    using AIRefactored.AI.Navigation;
    using AIRefactored.Core;
    using AIRefactored.Pools;
    using AIRefactored.Runtime;
    using BepInEx.Logging;
    using EFT;
    using UnityEngine;

    /// <summary>
    /// Central FSM for all bot combat, fallback, panic, engage, investigate, and patrol overlays.
    /// Arbitration/event-only, max realism, squad/voice/anticipation overlays, SPT/FIKA/headless/client parity.
    /// </summary>
    public sealed class CombatStateMachine
    {
        #region Constants

        private const float MinTransitionDelay = 0.41f;
        private const float PatrolMinDuration = 1.22f;
        private const float PatrolCooldown = 12.2f;
        private const float OverlayMoveDedupSqr = 0.16f;
        private const float OverlayMoveCooldown = 0.44f;
        private const float VoiceCooldown = 1.23f;
        private const float VoiceSquadChance = 0.18f;

        #endregion

        #region FSM Overlay State

        private enum OverlayState { None, Fallback, Panic, Engage, Investigate, Patrol }

        #endregion

        #region Fields

        private BotComponentCache _cache;
        private BotOwner _bot;
        private AttackHandler _attack;
        private EngageHandler _engage;
        private FallbackHandler _fallback;
        private InvestigateHandler _investigate;
        private PatrolHandler _patrol;
        private EchoCoordinator _echo;

        private Vector3 _lastKnownEnemyPos;
        private bool _hasKnownEnemy;
        private float _lastStateChangeTime;
        private float _lastVoiceTime;
        private bool _initialized;

        private OverlayState _currentOverlayState = OverlayState.None;
        private Vector3 _currentOverlayMove = Vector3.zero;
        private float _lastOverlayMoveTime = -10f;

        #endregion

        #region Properties

        public Vector3 LastKnownEnemyPos => _lastKnownEnemyPos;
        public float LastStateChangeTime => _lastStateChangeTime;

        #endregion

        #region Initialization

        public void Initialize(BotComponentCache componentCache)
        {
            if (componentCache?.Bot == null)
            {
                Plugin.LoggerInstance.LogError("[CombatStateMachine] Initialization failed: null references.");
                _initialized = false;
                return;
            }

            _cache = componentCache;
            _bot = componentCache.Bot;
            _fallback = componentCache.Fallback ?? new FallbackHandler(componentCache);
            _patrol = new PatrolHandler(componentCache, PatrolMinDuration, PatrolCooldown);
            _investigate = new InvestigateHandler(componentCache);
            _engage = new EngageHandler(componentCache);
            _attack = new AttackHandler(componentCache);
            _echo = new EchoCoordinator(componentCache);

            _lastKnownEnemyPos = Vector3.zero;
            _hasKnownEnemy = false;
            _lastStateChangeTime = 0f;
            _lastVoiceTime = -10f;
            _initialized = true;
            _currentOverlayState = OverlayState.None;
            _currentOverlayMove = Vector3.zero;
            _lastOverlayMoveTime = -10f;
        }

        #endregion

        #region Public API

        public bool IsInCombatState()
        {
            try
            {
                return _initialized &&
                    (_fallback?.IsActive() == true ||
                     _engage?.IsEngaging() == true ||
                     _investigate?.IsInvestigating() == true ||
                     _cache?.ThreatSelector?.CurrentTarget != null ||
                     (_cache?.PanicHandler?.IsPanicking ?? false));
            }
            catch (Exception ex)
            {
                Plugin.LoggerInstance.LogError("[CombatStateMachine] Exception in IsInCombatState: " + ex);
                return false;
            }
        }

        public void NotifyDamaged()
        {
            if (!_initialized || _fallback == null) return;
            float now = Time.time;
            if (!_fallback.IsActive())
            {
                Vector3 dir = _bot.LookDirection.sqrMagnitude > 0.01f ? -_bot.LookDirection.normalized : Vector3.back;
                Vector3 fallback = !BotNavHelper.TryGetSafeTarget(_bot, out var safe) || !IsVectorValid(safe)
                    ? _bot.Position + dir * 5f
                    : safe;
                if (fallback.y < -2.5f || !IsVectorValid(fallback)) fallback = _bot.Position;

                _fallback.SetFallbackTarget(fallback, now);
                TrySay(EPhraseTrigger.OnBeingHurt, now, squad: true);
                _lastStateChangeTime = now;
            }
        }

        public void NotifyEchoInvestigate()
        {
            if (!_initialized || _investigate == null) return;
            float now = Time.time;
            if (_investigate.ShallUseNow(now, _lastStateChangeTime))
            {
                _lastStateChangeTime = now;
                TrySay(EPhraseTrigger.Cooperation, now, squad: true);
            }
        }

        public void Tick(float now)
        {
            if (!_initialized || _bot == null || _bot.IsDead || !EFTPlayerUtil.IsValid(_bot.GetPlayer)) return;
            if (now - _lastStateChangeTime < MinTransitionDelay) return;

            // 1. Panic state (overlay only, never tick-poll/cooldown-flagged)
            if (ShouldTriggerPanicFallback(now))
            {
                Vector3 retreat = _bot.Position;
                if (_cache.PanicHandler != null && _cache.PanicHandler.IsPanicking)
                    retreat = _fallback.GetFallbackPosition();

                if (_currentOverlayState != OverlayState.Panic || !IsSameMove(retreat))
                {
                    if (TryOverlayMoveProposal(retreat, OverlayState.Panic, now, BotOverlayType.Panic))
                    {
                        _fallback.Tick(0f, now, SetLastStateChangeTime);
                        TrySay(EPhraseTrigger.OnBeingHurt, now, squad: true);
                        _echo?.EchoFallbackToSquad(retreat);
                        _lastStateChangeTime = now;
                    }
                }
                return;
            }

            // 2. Fallback (cover/suppression/retreat)
            if (NeedsFallbackNow(now))
            {
                Vector3 fallbackPos = _fallback.GetFallbackPosition();
                if (_currentOverlayState != OverlayState.Fallback || !IsSameMove(fallbackPos))
                {
                    if (TryOverlayMoveProposal(fallbackPos, OverlayState.Fallback, now, BotOverlayType.Fallback))
                    {
                        _fallback.Tick(0f, now, SetLastStateChangeTime);
                        TrySay(EPhraseTrigger.Regroup, now, squad: true);
                        _echo?.EchoFallbackToSquad(fallbackPos);
                        _lastStateChangeTime = now;
                    }
                }
                return;
            }

            // 3. Engage/attack
            Player enemy = _cache?.ThreatSelector?.CurrentTarget;
            if (EFTPlayerUtil.IsValid(enemy))
            {
                _lastKnownEnemyPos = EFTPlayerUtil.GetPosition(enemy);
                _hasKnownEnemy = true;
                if (!string.IsNullOrEmpty(enemy.ProfileId))
                    _cache?.TacticalMemory?.RecordEnemyPosition(_lastKnownEnemyPos, "Combat", enemy.ProfileId);
                if (_bot.Mover != null && !_bot.Mover.Sprinting)
                    _bot.Sprint(true);
                _echo?.EchoSpottedEnemyToSquad(_lastKnownEnemyPos);

                if (_engage?.ShallUseNow() == true)
                {
                    if (_currentOverlayState != OverlayState.Engage || !IsSameMove(_lastKnownEnemyPos))
                    {
                        if (TryOverlayMoveProposal(_lastKnownEnemyPos, OverlayState.Engage, now, BotOverlayType.Engage))
                        {
                            if (_engage.CanAttack())
                                _attack?.Tick(now);
                            else
                                _engage.Tick();
                            TrySay(EPhraseTrigger.GoForward, now, squad: true);
                            _lastStateChangeTime = now;
                        }
                    }
                    return;
                }
            }

            // 4. Investigate (last enemy pos or tactical overlay)
            if (_investigate?.ShallUseNow(now, _lastStateChangeTime) == true)
            {
                Vector3 investigateTarget = _investigate.GetInvestigateTarget(_hasKnownEnemy ? _lastKnownEnemyPos : Vector3.zero);
                if (_currentOverlayState != OverlayState.Investigate || !IsSameMove(investigateTarget))
                {
                    if (TryOverlayMoveProposal(investigateTarget, OverlayState.Investigate, now, BotOverlayType.Investigate))
                    {
                        _investigate.Investigate(investigateTarget);
                        TrySay(EPhraseTrigger.Cooperation, now, squad: true);
                        _lastStateChangeTime = now;
                    }
                }
                return;
            }

            // 5. Patrol (idle/default, never spams overlays)
            if (_patrol != null)
            {
                Vector3 patrolTarget = _patrol.GetNextPatrolPoint(_bot.Position);
                if (_currentOverlayState != OverlayState.Patrol || !IsSameMove(patrolTarget))
                {
                    TryOverlayMoveProposal(patrolTarget, OverlayState.Patrol, now, BotOverlayType.Patrol);
                    _patrol.Tick(now);
                }
            }
        }

        public void TriggerFallback(Vector3 fallbackPos, float now)
        {
            if (!_initialized || _fallback == null) return;
            _fallback.SetFallbackTarget(fallbackPos, now);
            TrySay(EPhraseTrigger.OnLostVisual, now, squad: true);
            _lastStateChangeTime = now;
        }

        public void TrySetStanceFromNearbyCover(Vector3 pos)
        {
            try { _cache?.PoseController?.TrySetStanceFromNearbyCover(pos); }
            catch (Exception ex) { Plugin.LoggerInstance.LogError("[CombatStateMachine] TrySetStanceFromNearbyCover: " + ex); }
        }

        #endregion

        #region Arbitration/Event-Only Helper Logic

        private bool ShouldTriggerPanicFallback(float now)
        {
            if (_cache?.PanicHandler?.IsPanicking == true)
                return true;

            // Squad contagion: propagate fallback if any squadmate is panicking (event/overlay-only).
            if (_bot?.BotsGroup != null)
            {
                for (int i = 0; i < _bot.BotsGroup.MembersCount; i++)
                {
                    var mate = _bot.BotsGroup.Member(i);
                    if (mate != null && mate != _bot)
                    {
                        var mateCache = mate.GetComponent<BotComponentCache>();
                        if (mateCache?.PanicHandler != null && mateCache.PanicHandler.IsPanicking)
                            return true;
                    }
                }
            }
            return false;
        }

        private bool NeedsFallbackNow(float now) => _fallback != null && _fallback.IsActive();

        private bool TryOverlayMoveProposal(Vector3 proposed, OverlayState newState, float now, BotOverlayType overlayType)
        {
            if (!IsVectorValid(proposed)) return false;
            if ((proposed - _currentOverlayMove).sqrMagnitude < OverlayMoveDedupSqr && (now - _lastOverlayMoveTime) < OverlayMoveCooldown)
                return false;
            if (BotMovementHelper.IsMovementPaused(_bot) || BotMovementHelper.IsInInteractionState(_bot))
                return false;

            if (!BotOverlayManager.CanIssueMove(_bot, overlayType))
                return false;

            BotOverlayManager.RegisterMove(_bot, overlayType);

            _currentOverlayState = newState;
            _currentOverlayMove = proposed;
            _lastOverlayMoveTime = now;

            BotMovementHelper.SmoothMoveToSafe(_bot, proposed, true, _cache?.PersonalityProfile?.Cohesion ?? 1f, overlayType);
            return true;
        }

        private bool IsSameMove(Vector3 v)
        {
            return (v - _currentOverlayMove).sqrMagnitude < OverlayMoveDedupSqr;
        }

        private void SetLastStateChangeTime(CombatState _, float time) => _lastStateChangeTime = time;

        private void TrySay(EPhraseTrigger phrase, float now, bool squad = false)
        {
            if (_bot?.BotTalk == null || (now - _lastVoiceTime) < VoiceCooldown) return;
            try { _bot.BotTalk.TrySay(phrase); } catch { }
            _lastVoiceTime = now;

            // Squad comms: propagate comm event (squad realism)
            if (squad && _bot?.BotsGroup != null && UnityEngine.Random.value < VoiceSquadChance)
            {
                for (int i = 0; i < _bot.BotsGroup.MembersCount; i++)
                {
                    var mate = _bot.BotsGroup.Member(i);
                    if (mate != null && mate != _bot && !mate.IsDead && mate.BotTalk != null)
                    {
                        try { mate.BotTalk.TrySay(phrase); } catch { }
                    }
                }
            }
        }

        private static bool IsVectorValid(Vector3 v)
        {
            return !float.IsNaN(v.x) && !float.IsNaN(v.y) && !float.IsNaN(v.z) && v != Vector3.zero && v.y > -2.5f;
        }

        #endregion
    }
}
