// <auto-generated>
//   This file is part of AI-Refactored, an open-source project focused on realistic AI behavior in Escape from Tarkov.
//   Licensed under the MIT License. See LICENSE in the repository root for more information.
//
//   THIS FILE IS SYSTEMATICALLY MANAGED.
//   Please follow strict StyleCop, ReSharper, and AI-Refactored code standards for all modifications.
// </auto-generated>

#nullable enable

namespace AIRefactored.AI.Combat
{
    using System;
    using AIRefactored.AI.Combat.States;
    using AIRefactored.AI.Core;
    using AIRefactored.AI.Optimization;
    using EFT;
    using UnityEngine;

    /// <summary>
    /// Central AI controller coordinating patrol, investigation, engagement, attack, and fallback behaviors.
    /// Evaluates tactical layers each frame and routes bot actions dynamically.
    /// </summary>
    public sealed class CombatStateMachine
    {
        #region Constants

        private const float MinTransitionDelay = 0.4f;

        #endregion

        #region Fields

        private AttackHandler? attack;
        private EngageHandler? engage;
        private FallbackHandler? fallback;
        private InvestigateHandler? investigate;
        private PatrolHandler? patrol;
        private EchoCoordinator? echo;

        private BotOwner? bot;
        private BotComponentCache? cache;

        private Vector3? lastKnownEnemyPos;

        #endregion

        #region Properties

        /// <summary>
        /// Gets the last known enemy position.
        /// </summary>
        public Vector3? LastKnownEnemyPos => this.lastKnownEnemyPos;

        /// <summary>
        /// Gets the last recorded time a state transition occurred.
        /// </summary>
        public float LastStateChangeTime { get; private set; }

        #endregion

        #region Public Methods

        /// <summary>
        /// Initializes the CombatStateMachine with a bot's component cache.
        /// </summary>
        /// <param name="componentCache">The bot's component cache.</param>
        public void Initialize(BotComponentCache componentCache)
        {
            if (componentCache == null)
            {
                throw new ArgumentNullException(nameof(componentCache));
            }

            if (componentCache.Bot == null)
            {
                throw new ArgumentNullException(nameof(componentCache.Bot));
            }

            this.cache = componentCache;
            this.bot = componentCache.Bot;

            this.patrol = new PatrolHandler(componentCache);
            this.investigate = new InvestigateHandler(componentCache);
            this.engage = new EngageHandler(componentCache);
            this.attack = new AttackHandler(componentCache);
            this.fallback = new FallbackHandler(componentCache);
            this.echo = new EchoCoordinator(componentCache);
        }

        /// <summary>
        /// Returns true if the bot is currently engaged in combat.
        /// </summary>
        public bool IsInCombatState()
        {
            return this.cache?.ThreatSelector?.CurrentTarget != null;
        }

        /// <summary>
        /// Notifies the CombatStateMachine that the bot has been damaged.
        /// </summary>
        public void NotifyDamaged()
        {
            var time = Time.time;

            if (this.fallback != null && !this.fallback.ShallUseNow(time))
            {
                this.LastStateChangeTime = time;
                this.bot?.BotTalk?.TrySay(EPhraseTrigger.OnBeingHurt);
            }
        }

        /// <summary>
        /// Notifies the CombatStateMachine that an echo investigation has been triggered.
        /// </summary>
        public void NotifyEchoInvestigate()
        {
            var time = Time.time;

            if (this.investigate != null && !this.investigate.ShallUseNow(time, this.LastStateChangeTime))
            {
                this.LastStateChangeTime = time;
                this.bot?.BotTalk?.TrySay(EPhraseTrigger.Cooperation);
            }
        }

        /// <summary>
        /// Updates the CombatStateMachine each frame.
        /// </summary>
        /// <param name="time">The current game time.</param>
        public void Tick(float time)
        {
            var botRef = this.bot;
            var cacheRef = this.cache;

            if (botRef == null || cacheRef == null)
            {
                return;
            }

            if (botRef.IsDead || botRef.GetPlayer?.IsAI != true)
            {
                return;
            }

            if (time - this.LastStateChangeTime < MinTransitionDelay)
            {
                return;
            }

            var enemy = cacheRef.ThreatSelector?.CurrentTarget;
            if (enemy != null && enemy.HealthController?.IsAlive == true)
            {
                this.lastKnownEnemyPos = enemy.Transform.position;
                cacheRef.TacticalMemory?.RecordEnemyPosition(this.lastKnownEnemyPos.Value);

                if (botRef.Mover?.Sprinting != true)
                {
                    botRef.Sprint(true);
                    this.echo?.EchoSpottedEnemyToSquad(this.lastKnownEnemyPos.Value);
                }
            }

            // Decision Layer Priority Chain:

            if (this.fallback?.ShouldTriggerSuppressedFallback(time, this.LastStateChangeTime, 1.25f) == true)
            {
                this.TryAssignFallbackPath();
                botRef.BotTalk?.TrySay(EPhraseTrigger.OnBeingHurt);
                this.echo?.EchoFallbackToSquad(this.fallback.GetFallbackPosition());
                this.LastStateChangeTime = time;
                return;
            }

            if (this.fallback != null && this.fallback.ShallUseNow(time))
            {
                this.TryAssignFallbackPath();
                this.fallback.Tick(
                    time,
                    this.lastKnownEnemyPos,
                    (CombatState _, float t) => this.LastStateChangeTime = t);
                return;
            }

            if (this.engage != null && this.engage.ShallUseNow())
            {
                if (this.engage.CanAttack())
                {
                    this.attack?.Tick(time);
                }
                else
                {
                    this.engage.Tick();
                }

                this.LastStateChangeTime = time;
                return;
            }

            if (this.investigate != null && this.investigate.ShallUseNow(time, this.LastStateChangeTime))
            {
                var target = this.investigate.GetInvestigateTarget(this.lastKnownEnemyPos);

                if (target != Vector3.zero)
                {
                    this.investigate.Investigate(target);
                    this.LastStateChangeTime = time;
                }

                return;
            }

            this.patrol?.Tick(time);
        }

        /// <summary>
        /// Manually triggers a fallback to a specified fallback position.
        /// </summary>
        /// <param name="fallbackPos">The fallback position to move towards.</param>
        public void TriggerFallback(Vector3 fallbackPos)
        {
            var time = Time.time;
            this.fallback?.SetFallbackTarget(fallbackPos);
            this.bot?.BotTalk?.TrySay(EPhraseTrigger.OnLostVisual);
            this.LastStateChangeTime = time;
        }

        /// <summary>
        /// Instructs the bot to adapt its stance based on available nearby cover.
        /// </summary>
        /// <param name="position">The reference position for stance evaluation.</param>
        internal void TrySetStanceFromNearbyCover(Vector3 position)
        {
            this.cache?.PoseController?.TrySetStanceFromNearbyCover(position);
        }

        #endregion

        #region Private Methods

        private void TryAssignFallbackPath()
        {
            if (this.fallback == null || this.cache?.Pathing == null || this.bot == null)
            {
                return;
            }

            if (!this.fallback.HasValidFallbackPath())
            {
                var retreatDir = -this.bot.LookDirection.normalized;
                var path = BotCoverRetreatPlanner.GetCoverRetreatPath(this.bot, retreatDir, this.cache.Pathing);

                if (path.Count > 0)
                {
                    this.fallback.SetFallbackPath(path);
                    this.fallback.SetFallbackTarget(path[path.Count - 1]);
                }
            }
        }

        #endregion
    }
}
