// <auto-generated>
//   AI-Refactored: CombatStateMachine.cs (Supreme Arbitration Overlay/Event-Only, Ultra-Platinum++, June 2025)
//   One-overlay-move-per-intent. Never issues per-frame move. Global dedup/cooldown/validity enforced after handler proposal.
//   No direct Mover/NavMeshAgent/position set. Squad/event-only, error-guarded, multiplayer/headless/vanilla safe.
//   MIT License.
// </auto-generated>

namespace AIRefactored.AI.Combat
{
    using System;
    using AIRefactored.AI.Combat.States;
    using AIRefactored.AI.Core;
    using AIRefactored.AI.Groups;
    using AIRefactored.AI.Helpers;
    using AIRefactored.AI.Memory;
    using AIRefactored.AI.Navigation;
    using AIRefactored.Core;
    using AIRefactored.Pools;
    using AIRefactored.Runtime;
    using BepInEx.Logging;
    using EFT;
    using UnityEngine;

    /// <summary>
    /// Central FSM for all bot combat, fallback, engage, investigate, and patrol logic.
    /// Overlay arbitration: Only one overlay/event move per intent, zero per-tick move spam.
    /// Dedup/cooldown/validity enforced globally. SPT/FIKA/headless safe, error-guarded.
    /// </summary>
    public sealed class CombatStateMachine
    {
        #region Constants

        private const float MinTransitionDelay = 0.4f;
        private const float PatrolMinDuration = 1.25f;
        private const float PatrolCooldown = 12.0f;
        private const float OverlayMoveDedupSqr = 0.0001f;
        private const float OverlayMoveCooldown = 0.42f;

        #endregion

        #region FSM Overlay State

        private enum OverlayState { None, Fallback, Engage, Investigate, Patrol }

        #endregion

        #region Fields

        private BotComponentCache _cache;
        private BotOwner _bot;
        private AttackHandler _attack;
        private EngageHandler _engage;
        private FallbackHandler _fallback;
        private InvestigateHandler _investigate;
        private PatrolHandler _patrol;
        private EchoCoordinator _echo;

        private Vector3 _lastKnownEnemyPos;
        private bool _hasKnownEnemy;
        private float _lastStateChangeTime;
        private bool _initialized;

        private OverlayState _currentOverlayState = OverlayState.None;
        private Vector3 _currentOverlayMove = Vector3.zero;
        private float _lastOverlayMoveTime = -10f;

        #endregion

        #region Properties

        public Vector3 LastKnownEnemyPos => _lastKnownEnemyPos;
        public float LastStateChangeTime => _lastStateChangeTime;

        #endregion

        #region Initialization

        public void Initialize(BotComponentCache componentCache)
        {
            if (componentCache?.Bot == null)
            {
                Plugin.LoggerInstance.LogError("[CombatStateMachine] Initialization failed: null references.");
                _initialized = false;
                return;
            }

            _cache = componentCache;
            _bot = componentCache.Bot;
            _fallback = componentCache.Fallback ?? new FallbackHandler(componentCache);
            _patrol = new PatrolHandler(componentCache, PatrolMinDuration, PatrolCooldown);
            _investigate = new InvestigateHandler(componentCache);
            _engage = new EngageHandler(componentCache);
            _attack = new AttackHandler(componentCache);
            _echo = new EchoCoordinator(componentCache);

            _lastKnownEnemyPos = Vector3.zero;
            _hasKnownEnemy = false;
            _lastStateChangeTime = 0f;
            _initialized = true;
            _currentOverlayState = OverlayState.None;
            _currentOverlayMove = Vector3.zero;
            _lastOverlayMoveTime = -10f;
        }

        #endregion

        #region Public API

        /// <summary>
        /// Returns true if in an active combat/engage/investigate state (not passive patrol).
        /// </summary>
        public bool IsInCombatState()
        {
            try
            {
                return _initialized &&
                    (_fallback?.IsActive() == true ||
                     _engage?.IsEngaging() == true ||
                     _investigate?.IsInvestigating() == true ||
                     _cache?.ThreatSelector?.CurrentTarget != null);
            }
            catch (Exception ex)
            {
                Plugin.LoggerInstance.LogError("[CombatStateMachine] Exception in IsInCombatState: " + ex);
                return false;
            }
        }

        /// <summary>
        /// Call on bot damage: triggers fallback/retreat overlay if not already in fallback.
        /// </summary>
        public void NotifyDamaged()
        {
            if (!_initialized || _fallback == null) return;
            float now = Time.time;
            if (!_fallback.IsActive())
            {
                Vector3 dir = _bot.LookDirection.sqrMagnitude > 0.01f ? -_bot.LookDirection.normalized : Vector3.back;
                Vector3 fallback = !BotNavHelper.TryGetSafeTarget(_bot, out var safe) || !IsVectorValid(safe)
                    ? _bot.Position + dir * 5f
                    : safe;
                if (fallback.y < -2.5f || !IsVectorValid(fallback)) fallback = _bot.Position;

                _fallback.SetFallbackTarget(fallback, now);
                TrySay(EPhraseTrigger.OnBeingHurt);
                _lastStateChangeTime = now;
            }
        }

        /// <summary>
        /// Call on squad echo investigate event (audio/vision relay).
        /// </summary>
        public void NotifyEchoInvestigate()
        {
            if (!_initialized || _investigate == null) return;
            float now = Time.time;
            if (_investigate.ShallUseNow(now, _lastStateChangeTime))
            {
                _lastStateChangeTime = now;
                TrySay(EPhraseTrigger.Cooperation);
            }
        }

        /// <summary>
        /// Main FSM tick, called by BotBrain. Overlay arbitration logic—only one intent/overlay/event-move per intent/state.
        /// </summary>
        public void Tick(float now)
        {
            if (!_initialized || _bot == null || _bot.IsDead || !EFTPlayerUtil.IsValid(_bot.GetPlayer)) return;
            if (now - _lastStateChangeTime < MinTransitionDelay) return;

            // 1. Check for transition to Fallback (panic/retreat/suppression)
            if (ShouldTriggerSuppressedFallback(now) || NeedsFallbackNow(now))
            {
                Vector3 fallbackPos = _fallback.GetFallbackPosition();
                if (_currentOverlayState != OverlayState.Fallback || !IsSameMove(fallbackPos))
                {
                    if (TryOverlayMoveProposal(fallbackPos, OverlayState.Fallback, now, BotOverlayType.Fallback))
                    {
                        _fallback.Tick(0f, now, SetLastStateChangeTime);
                        TrySay(EPhraseTrigger.OnBeingHurt);
                        _echo?.EchoFallbackToSquad(fallbackPos);
                        _lastStateChangeTime = now;
                    }
                }
                return;
            }

            // 2. Check for engage/attack
            Player enemy = _cache?.ThreatSelector?.CurrentTarget;
            if (EFTPlayerUtil.IsValid(enemy))
            {
                _lastKnownEnemyPos = EFTPlayerUtil.GetPosition(enemy);
                _hasKnownEnemy = true;
                if (!string.IsNullOrEmpty(enemy.ProfileId))
                    _cache?.TacticalMemory?.RecordEnemyPosition(_lastKnownEnemyPos, "Combat", enemy.ProfileId);
                if (_bot.Mover != null && !_bot.Mover.Sprinting)
                    _bot.Sprint(true);
                _echo?.EchoSpottedEnemyToSquad(_lastKnownEnemyPos);

                if (_engage?.ShallUseNow() == true)
                {
                    if (_currentOverlayState != OverlayState.Engage || !IsSameMove(_lastKnownEnemyPos))
                    {
                        if (TryOverlayMoveProposal(_lastKnownEnemyPos, OverlayState.Engage, now, BotOverlayType.Engage))
                        {
                            if (_engage.CanAttack())
                                _attack?.Tick(now);
                            else
                                _engage.Tick();
                            _lastStateChangeTime = now;
                        }
                    }
                    return;
                }
            }

            // 3. Investigate state
            if (_investigate?.ShallUseNow(now, _lastStateChangeTime) == true)
            {
                Vector3 investigateTarget = _investigate.GetInvestigateTarget(_hasKnownEnemy ? _lastKnownEnemyPos : Vector3.zero);
                if (_currentOverlayState != OverlayState.Investigate || !IsSameMove(investigateTarget))
                {
                    if (TryOverlayMoveProposal(investigateTarget, OverlayState.Investigate, now, BotOverlayType.Investigate))
                    {
                        _investigate.Investigate(investigateTarget);
                        _lastStateChangeTime = now;
                    }
                }
                return;
            }

            // 4. Patrol state (default, fallback)
            if (_patrol != null)
            {
                Vector3 patrolTarget = _patrol.GetNextPatrolPoint(_bot.Position);
                if (_currentOverlayState != OverlayState.Patrol || !IsSameMove(patrolTarget))
                {
                    TryOverlayMoveProposal(patrolTarget, OverlayState.Patrol, now, BotOverlayType.Patrol);
                    _patrol.Tick(now);
                }
            }
        }

        /// <summary>
        /// Triggers a fallback overlay/event, e.g. on lost visual or forced retreat.
        /// </summary>
        public void TriggerFallback(Vector3 fallbackPos, float now)
        {
            if (!_initialized || _fallback == null) return;
            _fallback.SetFallbackTarget(fallbackPos, now);
            TrySay(EPhraseTrigger.OnLostVisual);
            _lastStateChangeTime = now;
        }

        /// <summary>
        /// Forwards to pose/cover logic for realism overlays.
        /// </summary>
        public void TrySetStanceFromNearbyCover(Vector3 pos)
        {
            try { _cache?.PoseController?.TrySetStanceFromNearbyCover(pos); }
            catch (Exception ex) { Plugin.LoggerInstance.LogError("[CombatStateMachine] TrySetStanceFromNearbyCover: " + ex); }
        }

        #endregion

        #region Internal Arbitration/Helper Logic

        private bool NeedsFallbackNow(float now) => _fallback != null && _fallback.IsActive();

        private bool ShouldTriggerSuppressedFallback(float now)
        {
            if (_cache?.PanicHandler == null || _fallback == null) return false;
            float c = _cache.PanicHandler.GetComposureLevel();
            float delay = Mathf.Lerp(0.75f, 1.5f, 1f - c);
            return _cache.PanicHandler.ShouldTriggerSuppressedFallback(_fallback, now, _lastStateChangeTime, delay);
        }

        /// <summary>
        /// Proposes and issues a triple-guarded overlay move for the given intent, enforcing arbitration, dedup, cooldown, and overlay type.
        /// </summary>
        private bool TryOverlayMoveProposal(Vector3 proposed, OverlayState newState, float now, BotOverlayType overlayType)
        {
            if (!IsVectorValid(proposed)) return false;
            if ((proposed - _currentOverlayMove).sqrMagnitude < OverlayMoveDedupSqr && (now - _lastOverlayMoveTime) < OverlayMoveCooldown)
                return false;
            if (BotMovementHelper.IsMovementPaused(_bot) || BotMovementHelper.IsInInteractionState(_bot))
                return false;

            // Overlay arbitration: per overlay type and global, using two-argument signature.
            if (!BotOverlayManager.CanIssueMove(_bot, overlayType))
                return false;

            BotOverlayManager.RegisterMove(_bot, overlayType);

            _currentOverlayState = newState;
            _currentOverlayMove = proposed;
            _lastOverlayMoveTime = now;

            // Only here: issue overlay-move via canonical helper!
            BotMovementHelper.SmoothMoveToSafe(_bot, proposed, true, _cache?.PersonalityProfile?.Cohesion ?? 1f, overlayType);
            return true;
        }

        private bool IsSameMove(Vector3 v)
        {
            return (v - _currentOverlayMove).sqrMagnitude < OverlayMoveDedupSqr;
        }

        private void SetLastStateChangeTime(CombatState _, float time) => _lastStateChangeTime = time;

        private void TrySay(EPhraseTrigger phrase)
        {
            try { _bot?.BotTalk?.TrySay(phrase); } catch { }
        }

        private static bool IsVectorValid(Vector3 v)
        {
            return !float.IsNaN(v.x) && !float.IsNaN(v.y) && !float.IsNaN(v.z) && v != Vector3.zero && v.y > -2.5f;
        }

        #endregion
    }
}
