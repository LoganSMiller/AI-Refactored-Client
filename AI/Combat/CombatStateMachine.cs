// <auto-generated>
//   This file is part of AI-Refactored, an open-source project focused on realistic AI behavior in Escape from Tarkov.
//   Licensed under the MIT License. See LICENSE in the repository root for more information.
//
//   THIS FILE IS SYSTEMATICALLY MANAGED.
//   Please follow strict StyleCop, ReSharper, and AI-Refactored code standards for all modifications.
// </auto-generated>

#nullable enable

namespace AIRefactored.AI.Combat
{
    using System.Collections.Generic;
    using AIRefactored.AI.Combat.States;
    using AIRefactored.AI.Core;
    using AIRefactored.AI.Optimization;
    using EFT;
    using UnityEngine;

    /// <summary>
    /// Central AI controller coordinating patrol, investigation, engagement, attack, and fallback behaviors.
    /// Evaluates tactical layers each frame and routes bot actions dynamically.
    /// </summary>
    public sealed class CombatStateMachine
    {
        #region Constants

        private const float MinTransitionDelay = 0.4f;
        private const float PatrolMinDuration = 1.25f;
        private const float PatrolCooldown = 12.0f;

        #endregion

        #region Static Buffers

        private static readonly List<Vector3> FallbackPathBuffer = new List<Vector3>(16);

        #endregion

        #region Fields

        private AttackHandler? _attack;
        private EngageHandler? _engage;
        private FallbackHandler? _fallback;
        private InvestigateHandler? _investigate;
        private PatrolHandler? _patrol;
        private EchoCoordinator? _echo;

        private BotOwner? _bot;
        private BotComponentCache? _cache;
        private Vector3? _lastKnownEnemyPos;

        #endregion

        #region Properties

        /// <summary>
        /// Gets the last known enemy position.
        /// </summary>
        public Vector3? LastKnownEnemyPos => this._lastKnownEnemyPos;

        /// <summary>
        /// Gets the last recorded time a state transition occurred.
        /// </summary>
        public float LastStateChangeTime { get; private set; }

        #endregion

        #region Public API

        /// <summary>
        /// Initializes the CombatStateMachine with a bot's component cache.
        /// </summary>
        /// <param name="componentCache">Bot component cache.</param>
        public void Initialize(BotComponentCache componentCache)
        {
            this._cache = componentCache;
            this._bot = componentCache.Bot;

            this._patrol = new PatrolHandler(componentCache, PatrolMinDuration, PatrolCooldown);
            this._investigate = new InvestigateHandler(componentCache);
            this._engage = new EngageHandler(componentCache);
            this._attack = new AttackHandler(componentCache);
            this._fallback = new FallbackHandler(componentCache);
            this._echo = new EchoCoordinator(componentCache);
        }

        /// <summary>
        /// Returns true if the bot is currently engaged in combat.
        /// </summary>
        public bool IsInCombatState()
        {
            return this._cache?.ThreatSelector?.CurrentTarget != null;
        }

        /// <summary>
        /// Notifies the CombatStateMachine that the bot has been damaged.
        /// </summary>
        public void NotifyDamaged()
        {
            if (this._fallback == null || this._bot == null)
            {
                return;
            }

            float now = Time.time;

            if (!this._fallback.ShallUseNow(now))
            {
                this.LastStateChangeTime = now;

                if (!FikaHeadlessDetector.IsHeadless && this._bot.BotTalk != null)
                {
                    this._bot.BotTalk.TrySay(EPhraseTrigger.OnBeingHurt);
                }
            }
        }

        /// <summary>
        /// Notifies the CombatStateMachine that an echo investigation has been triggered.
        /// </summary>
        public void NotifyEchoInvestigate()
        {
            if (this._investigate == null || this._bot == null)
            {
                return;
            }

            float now = Time.time;

            if (!this._investigate.ShallUseNow(now, this.LastStateChangeTime))
            {
                this.LastStateChangeTime = now;

                if (!FikaHeadlessDetector.IsHeadless && this._bot.BotTalk != null)
                {
                    this._bot.BotTalk.TrySay(EPhraseTrigger.Cooperation);
                }
            }
        }

        /// <summary>
        /// Updates the CombatStateMachine each frame.
        /// </summary>
        /// <param name="time">Current time value.</param>
        public void Tick(float time)
        {
            if (this._bot == null || this._cache == null || this._bot.IsDead)
            {
                return;
            }

            Player? player = this._bot.GetPlayer;
            if (player == null || !player.IsAI)
            {
                return;
            }

            if (time - this.LastStateChangeTime < MinTransitionDelay)
            {
                return;
            }

            IPlayer? enemy = this._cache.ThreatSelector?.CurrentTarget;
            if (enemy != null && enemy.HealthController != null && enemy.HealthController.IsAlive && enemy.Transform != null)
            {
                Vector3 targetPos = enemy.Transform.position;
                this._lastKnownEnemyPos = targetPos;

                string? enemyId = enemy.ProfileId;
                this._cache.TacticalMemory?.RecordEnemyPosition(targetPos, "Combat", enemyId);

                if (this._bot.Mover != null && !this._bot.Mover.Sprinting)
                {
                    this._bot.Sprint(true);
                }

                this._echo?.EchoSpottedEnemyToSquad(targetPos);
            }

            if (this._fallback != null && this.ShouldTriggerSuppressedFallback(time))
            {
                this.AssignFallbackIfNeeded();

                if (!FikaHeadlessDetector.IsHeadless && this._bot.BotTalk != null)
                {
                    this._bot.BotTalk.TrySay(EPhraseTrigger.OnBeingHurt);
                }

                Vector3 fallbackPos = this._fallback.HasValidFallbackPath()
                    ? this._fallback.GetFallbackPosition()
                    : this._bot.Position;

                this._echo?.EchoFallbackToSquad(fallbackPos);
                this.LastStateChangeTime = time;
                return;
            }

            if (this._fallback != null && this._fallback.ShallUseNow(time))
            {
                this.AssignFallbackIfNeeded();
                this._fallback.Tick(time, this._lastKnownEnemyPos, this.SetLastStateChangeTime);
                return;
            }

            if (this._engage != null && this._engage.ShallUseNow())
            {
                if (this._engage.CanAttack())
                {
                    this._attack?.Tick(time);
                }
                else
                {
                    this._engage.Tick();
                }

                this.LastStateChangeTime = time;
                return;
            }

            if (this._investigate != null && this._investigate.ShallUseNow(time, this.LastStateChangeTime))
            {
                Vector3 target = this._investigate.GetInvestigateTarget(this._lastKnownEnemyPos);
                if (target != Vector3.zero)
                {
                    this._investigate.Investigate(target);
                    this.LastStateChangeTime = time;
                }

                return;
            }

            this._patrol?.Tick(time);
        }

        /// <summary>
        /// Manually triggers a fallback to a specified fallback position.
        /// </summary>
        /// <param name="fallbackPos">Fallback destination.</param>
        public void TriggerFallback(Vector3 fallbackPos)
        {
            this._fallback?.SetFallbackTarget(fallbackPos);

            if (!FikaHeadlessDetector.IsHeadless && this._bot?.BotTalk != null)
            {
                this._bot.BotTalk.TrySay(EPhraseTrigger.OnLostVisual);
            }

            this.LastStateChangeTime = Time.time;
        }

        /// <summary>
        /// Instructs the bot to adapt its stance based on available nearby cover.
        /// </summary>
        /// <param name="position">Cover position to evaluate.</param>
        public void TrySetStanceFromNearbyCover(Vector3 position)
        {
            this._cache?.PoseController?.TrySetStanceFromNearbyCover(position);
        }

        #endregion

        #region Private Helpers

        private bool ShouldTriggerSuppressedFallback(float time)
        {
            float composure = this._cache?.PanicHandler?.GetComposureLevel() ?? 1.0f;
            float delay = Mathf.Lerp(0.75f, 1.5f, 1.0f - composure);

            return this._fallback != null &&
                   this._fallback.ShouldTriggerSuppressedFallback(time, this.LastStateChangeTime, delay);
        }

        private void AssignFallbackIfNeeded()
        {
            if (this._fallback == null || this._fallback.HasValidFallbackPath())
            {
                return;
            }

            if (this._bot == null || this._cache?.Pathing == null)
            {
                return;
            }

            Vector3 retreatDirection = -this._bot.LookDirection.normalized;
            FallbackPathBuffer.Clear();

            List<Vector3> retreatPath = BotCoverRetreatPlanner.GetCoverRetreatPath(this._bot, retreatDirection, this._cache.Pathing);
            if (retreatPath != null && retreatPath.Count > 0)
            {
                Vector3 final = retreatPath[retreatPath.Count - 1];
                this._fallback.SetFallbackPath(retreatPath);
                this._fallback.SetFallbackTarget(final);
                this.TrySetStanceFromNearbyCover(final);
            }
        }

        private void SetLastStateChangeTime(CombatState state, float time)
        {
            this.LastStateChangeTime = time;
        }

        #endregion
    }
}
