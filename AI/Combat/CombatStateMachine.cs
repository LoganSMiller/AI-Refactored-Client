// <auto-generated>
//   This file is part of AI-Refactored, an open-source project focused on realistic AI behavior in Escape from Tarkov.
//   Licensed under the MIT License. See LICENSE in the repository root for more information.
//
//   THIS FILE IS SYSTEMATICALLY MANAGED.
//   Please follow strict StyleCop, ReSharper, and AI-Refactored code standards for all modifications.
// </auto-generated>

namespace AIRefactored.AI.Combat
{
    using System;
    using System.Collections.Generic;
    using AIRefactored.AI.Combat.States;
    using AIRefactored.AI.Core;
    using AIRefactored.AI.Memory;
    using AIRefactored.AI.Optimization;
    using AIRefactored.Core;
    using AIRefactored.Runtime;
    using EFT;
    using UnityEngine;

    /// <summary>
    /// Coordinates bot combat state transitions across patrol, engage, attack, fallback, and investigation.
    /// </summary>
    public sealed class CombatStateMachine
    {
        #region Constants

        private const float MinTransitionDelay = 0.4f;
        private const float PatrolMinDuration = 1.25f;
        private const float PatrolCooldown = 12.0f;

        #endregion

        #region Static Buffers

        private static readonly List<Vector3> FallbackPathBuffer = new List<Vector3>(16);

        #endregion

        #region Fields

        private BotComponentCache _cache;
        private BotOwner _bot;

        private AttackHandler _attack;
        private EngageHandler _engage;
        private FallbackHandler _fallback;
        private InvestigateHandler _investigate;
        private PatrolHandler _patrol;
        private EchoCoordinator _echo;

        private Vector3 _lastKnownEnemyPos;
        private bool _hasKnownEnemy;
        private float _lastStateChangeTime;
        private bool _initialized;

        #endregion

        #region Properties

        public Vector3 LastKnownEnemyPos => this._lastKnownEnemyPos;

        public float LastStateChangeTime => this._lastStateChangeTime;

        #endregion

        #region Initialization

        public void Initialize(BotComponentCache componentCache)
        {
            if (componentCache == null || componentCache.Bot == null)
            {
                Plugin.LoggerInstance?.LogError("[CombatStateMachine] Initialization failed: BotComponentCache or Bot is null.");
                return;
            }

            this._cache = componentCache;
            this._bot = componentCache.Bot;

            this._patrol = new PatrolHandler(componentCache, PatrolMinDuration, PatrolCooldown);
            this._investigate = new InvestigateHandler(componentCache);
            this._engage = new EngageHandler(componentCache);
            this._attack = new AttackHandler(componentCache);
            this._fallback = new FallbackHandler(componentCache);
            this._echo = new EchoCoordinator(componentCache);

            this._initialized = true;
        }

        #endregion

        #region Public API

        public bool IsInCombatState()
        {
            return this._initialized &&
                   (this._fallback.IsActive()
                    || this._engage.IsEngaging()
                    || this._investigate.IsInvestigating()
                    || this._cache.ThreatSelector.CurrentTarget != null);
        }

        public void NotifyDamaged()
        {
            if (!this._initialized)
            {
                return;
            }

            float now = Time.time;
            if (this._fallback.ShallUseNow(now))
            {
                this.AssignFallbackIfNeeded();
                this._bot.BotTalk?.TrySay(EPhraseTrigger.OnBeingHurt);
                this._lastStateChangeTime = now;
            }
        }

        public void NotifyEchoInvestigate()
        {
            if (!this._initialized)
            {
                return;
            }

            float now = Time.time;
            if (!this._investigate.ShallUseNow(now, this._lastStateChangeTime))
            {
                this._lastStateChangeTime = now;
                this._bot.BotTalk?.TrySay(EPhraseTrigger.Cooperation);
            }
        }

        public void Tick(float time)
        {
            if (!this._initialized || this._bot.IsDead)
            {
                return;
            }

            if (!EFTPlayerUtil.IsValid(this._bot.GetPlayer))
            {
                return;
            }

            if (time - this._lastStateChangeTime < MinTransitionDelay)
            {
                return;
            }

            if (this.ShouldTriggerSuppressedFallback(time))
            {
                this.AssignFallbackIfNeeded();
                this._bot.BotTalk?.TrySay(EPhraseTrigger.OnBeingHurt);

                Vector3 fallback = this._fallback.HasValidFallbackPath()
                    ? this._fallback.GetFallbackPosition()
                    : this._bot.Position;

                this._echo.EchoFallbackToSquad(fallback);
                this._lastStateChangeTime = time;
                return;
            }

            if (this._fallback.ShallUseNow(time))
            {
                this.AssignFallbackIfNeeded();
                this._fallback.Tick(time, this.SetLastStateChangeTime);
                return;
            }

            Player enemy = this._cache.ThreatSelector.CurrentTarget;
            if (EFTPlayerUtil.IsValid(enemy))
            {
                this._lastKnownEnemyPos = EFTPlayerUtil.GetPosition(enemy);
                this._hasKnownEnemy = true;

                string id = enemy.ProfileId;
                if (!string.IsNullOrEmpty(id))
                {
                    this._cache.TacticalMemory.RecordEnemyPosition(this._lastKnownEnemyPos, "Combat", id);
                }

                if (this._bot.Mover != null && !this._bot.Mover.Sprinting)
                {
                    this._bot.Sprint(true);
                }

                this._echo.EchoSpottedEnemyToSquad(this._lastKnownEnemyPos);
            }

            if (this._engage.ShallUseNow())
            {
                if (this._engage.CanAttack())
                {
                    this._attack.Tick(time);
                }
                else
                {
                    this._engage.Tick();
                }

                this._lastStateChangeTime = time;
                return;
            }

            if (this._investigate.ShallUseNow(time, this._lastStateChangeTime))
            {
                Vector3 investigateTarget = this._investigate.GetInvestigateTarget(this._hasKnownEnemy ? this._lastKnownEnemyPos : Vector3.zero);
                if (investigateTarget != Vector3.zero)
                {
                    this._investigate.Investigate(investigateTarget);
                    this._lastStateChangeTime = time;
                }

                return;
            }

            this._patrol.Tick(time);
        }

        public void TriggerFallback(Vector3 fallbackPos)
        {
            if (!this._initialized)
            {
                return;
            }

            this._fallback.SetFallbackTarget(fallbackPos);
            this._bot.BotTalk?.TrySay(EPhraseTrigger.OnLostVisual);
            this._lastStateChangeTime = Time.time;
        }

        public void TrySetStanceFromNearbyCover(Vector3 pos)
        {
            if (!this._initialized)
            {
                return;
            }

            this._cache.PoseController.TrySetStanceFromNearbyCover(pos);
        }

        #endregion

        #region Private Helpers

        private void AssignFallbackIfNeeded()
        {
            if (this._fallback.HasValidFallbackPath())
            {
                return;
            }

            if (this._cache.Pathing == null)
            {
                return;
            }

            Vector3 lookDir = this._bot.LookDirection;
            Vector3 retreatDir = lookDir.sqrMagnitude > 0.01f ? -lookDir.normalized : Vector3.back;

            FallbackPathBuffer.Clear();
            List<Vector3> path = BotCoverRetreatPlanner.GetCoverRetreatPath(this._bot, retreatDir, this._cache.Pathing);

            if (path.Count > 0)
            {
                Vector3 final = path[path.Count - 1];
                this._fallback.SetFallbackPath(path);
                this._fallback.SetFallbackTarget(final);
                this.TrySetStanceFromNearbyCover(final);
            }
            else
            {
                Plugin.LoggerInstance?.LogWarning("[CombatStateMachine] Fallback path was not found.");
            }
        }

        private bool ShouldTriggerSuppressedFallback(float time)
        {
            float composure = this._cache.PanicHandler.GetComposureLevel();
            float delay = Mathf.Lerp(0.75f, 1.5f, 1f - composure);

            return this._fallback.ShouldTriggerSuppressedFallback(time, this._lastStateChangeTime, delay);
        }

        private void SetLastStateChangeTime(CombatState state, float time)
        {
            this._lastStateChangeTime = time;
        }

        #endregion
    }
}
