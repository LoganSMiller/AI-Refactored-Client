// <auto-generated>
//   This file is part of AI-Refactored, an open-source project focused on realistic AI behavior in Escape from Tarkov.
//   Licensed under the MIT License. See LICENSE in the repository root for more information.
//
//   THIS FILE IS SYSTEMATICALLY MANAGED.
//   Please follow strict StyleCop, ReSharper, and AI-Refactored code standards for all modifications.
// </auto-generated>

namespace AIRefactored.AI.Combat
{
    using System;
    using AIRefactored.AI.Core;
    using AIRefactored.AI.Optimization;
    using AIRefactored.Core;
    using AIRefactored.Runtime;
    using BepInEx.Logging;
    using EFT;
    using UnityEngine;

    /// <summary>
    /// Tracks panic events, visible enemies, and squad losses to trigger escalation behavior.
    /// Applies tuning and personality adaptations based on threat severity.
    /// </summary>
    public sealed class BotThreatEscalationMonitor
    {
        #region Constants

        private const float CheckInterval = 1.0f;
        private const float PanicDurationThreshold = 4.0f;
        private const float SquadCasualtyThreshold = 0.4f;

        #endregion

        #region Fields

        private static readonly ManualLogSource Logger = Plugin.LoggerInstance;

        private BotOwner _bot;
        private bool _hasEscalated;
        private float _nextCheckTime;
        private float _panicStartTime;

        #endregion

        #region Public Methods

        /// <summary>
        /// Initializes the escalation monitor for the specified bot.
        /// </summary>
        /// <param name="botOwner">Bot owner reference.</param>
        public void Initialize(BotOwner botOwner)
        {
            if (botOwner == null)
            {
                throw new ArgumentNullException(nameof(botOwner));
            }

            _bot = botOwner;
            _panicStartTime = -1f;
            _nextCheckTime = -1f;
            _hasEscalated = false;
        }

        /// <summary>
        /// Records the panic start time.
        /// </summary>
        public void NotifyPanicTriggered()
        {
            if (_panicStartTime < 0f)
            {
                _panicStartTime = Time.time;
            }
        }

        /// <summary>
        /// Updates escalation check at defined intervals.
        /// </summary>
        /// <param name="time">Current game time.</param>
        public void Tick(float time)
        {
            if (_hasEscalated || !IsValid() || time < _nextCheckTime)
            {
                return;
            }

            _nextCheckTime = time + CheckInterval;

            if (ShouldEscalate(time))
            {
                EscalateBot();
            }
        }

        #endregion

        #region Private Methods

        private bool IsValid()
        {
            return _bot != null &&
                   !_bot.IsDead &&
                   _bot.GetPlayer != null &&
                   _bot.GetPlayer.IsAI;
        }

        private bool PanicDurationExceeded(float now)
        {
            return _panicStartTime >= 0f && (now - _panicStartTime) > PanicDurationThreshold;
        }

        private bool MultipleEnemiesVisible()
        {
            BotEnemiesController controller = _bot.EnemiesController;
            if (controller == null || controller.EnemyInfos == null)
            {
                return false;
            }

            int visibleCount = 0;
            foreach (var pair in controller.EnemyInfos)
            {
                if (pair.Value != null && pair.Value.IsVisible)
                {
                    visibleCount++;
                    if (visibleCount >= 2)
                    {
                        return true;
                    }
                }
            }

            return false;
        }

        private bool SquadHasLostTeammates()
        {
            BotsGroup group = _bot.BotsGroup;
            if (group == null)
            {
                return false;
            }

            int total = group.MembersCount;
            if (total <= 1)
            {
                return false;
            }

            int dead = 0;
            for (int i = 0; i < total; i++)
            {
                BotOwner member = group.Member(i);
                if (member == null || member.IsDead)
                {
                    dead++;
                }
            }

            return dead >= Mathf.CeilToInt(total * SquadCasualtyThreshold);
        }

        private bool ShouldEscalate(float now)
        {
            return PanicDurationExceeded(now) ||
                   MultipleEnemiesVisible() ||
                   SquadHasLostTeammates();
        }

        private void EscalateBot()
        {
            _hasEscalated = true;

            string nickname = _bot.Profile != null && _bot.Profile.Info != null
                ? _bot.Profile.Info.Nickname
                : "Unknown";

            Logger.LogInfo($"[AIRefactored-Escalation] Escalating behavior for bot '{nickname}'.");

            AIOptimizationManager.Reset(_bot);
            AIOptimizationManager.Apply(_bot);

            ApplyEscalationTuning(_bot);
            ApplyPersonalityTuning(_bot);

            if (!FikaHeadlessDetector.IsHeadless && _bot.BotTalk != null)
            {
                _bot.BotTalk.TrySay(EPhraseTrigger.OnFight);
            }
        }

        private void ApplyEscalationTuning(BotOwner botRef)
        {
            BotSettingsComponents settings = botRef.Settings != null ? botRef.Settings.FileSettings : null;
            if (settings == null)
            {
                return;
            }

            if (settings.Shoot != null)
            {
                settings.Shoot.RECOIL_PER_METER = Mathf.Clamp(settings.Shoot.RECOIL_PER_METER * 0.85f, 0.1f, 2.0f);
            }

            if (settings.Mind != null)
            {
                settings.Mind.DIST_TO_FOUND_SQRT = Mathf.Clamp(settings.Mind.DIST_TO_FOUND_SQRT * 1.2f, 200.0f, 800.0f);
                settings.Mind.ENEMY_LOOK_AT_ME_ANG = Mathf.Clamp(settings.Mind.ENEMY_LOOK_AT_ME_ANG * 0.75f, 5.0f, 45.0f);
                settings.Mind.CHANCE_TO_RUN_CAUSE_DAMAGE_0_100 = Mathf.Clamp(
                    settings.Mind.CHANCE_TO_RUN_CAUSE_DAMAGE_0_100 + 20.0f, 0.0f, 100.0f);
            }

            if (settings.Look != null)
            {
                settings.Look.MAX_VISION_GRASS_METERS = Mathf.Clamp(settings.Look.MAX_VISION_GRASS_METERS + 5.0f, 5.0f, 40.0f);
            }

            Logger.LogInfo($"[AIRefactored-Tuning] Escalation tuning applied to '{botRef.Profile?.Info?.Nickname ?? "Unknown"}'.");
        }

        private void ApplyPersonalityTuning(BotOwner botRef)
        {
            string profileId = botRef.ProfileId;
            if (profileId.Length == 0)
            {
                return;
            }

            BotPersonalityProfile profile = BotRegistry.Get(profileId);
            if (profile == null)
            {
                return;
            }

            profile.AggressionLevel = Mathf.Clamp01(profile.AggressionLevel + 0.25f);
            profile.Caution = Mathf.Clamp01(profile.Caution - 0.25f);
            profile.SuppressionSensitivity = Mathf.Clamp01(profile.SuppressionSensitivity * 0.75f);
            profile.AccuracyUnderFire = Mathf.Clamp01(profile.AccuracyUnderFire + 0.2f);
            profile.CommunicationLevel = Mathf.Clamp01(profile.CommunicationLevel + 0.2f);

            Logger.LogInfo(
                $"[AIRefactored-Tuning] Personality tuned for '{botRef.Profile?.Info?.Nickname ?? "Unknown"}': " +
                $"Agg={profile.AggressionLevel:F2}, Caution={profile.Caution:F2}, " +
                $"Supp={profile.SuppressionSensitivity:F2}, AccUF={profile.AccuracyUnderFire:F2}");
        }

        #endregion
    }
}
