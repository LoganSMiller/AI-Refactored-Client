// <auto-generated>
//   AI-Refactored: HearingDamageComponent.cs (Supreme Arbitration, Max Realism, June 2025, Ultra-Expanded, Squad-Ready)
//   Nonlinear ear fatigue, ring, squad/cover hooks, self-healing, anti-alloc, bulletproof. SPT/FIKA/headless/client parity.
//   Licensed under MIT.
// </auto-generated>

namespace AIRefactored.AI.Combat
{
    using System;
    using UnityEngine;

    /// <summary>
    /// Simulates realistic, nonlinear bot hearing loss, ringing, and recovery after loud events.
    /// Cumulative ear fatigue, self-healing, bulletproof: zero alloc, always recovers, SPT/FIKA/headless/client safe.
    /// Includes extension points for squad/cover/stress/voice integration.
    /// </summary>
    public sealed class HearingDamageComponent
    {
        #region Fields

        private float _targetDeafness;       // Fade-from intensity (0..1)
        private float _deafnessLevel;        // Current (0..1)
        private float _deafDuration;         // Remaining seconds
        private float _elapsedTime;          // Since last event
        private float _recoverySlope;        // Controls fade curve
        private float _lastApplyTime;        // Time of last trauma
        private float _earFatigue;           // Cumulative (0..1)
        private float _ringing;              // Ringing intensity (0..1)
        private float _lastRingingPeak;      // Last time ringing peaked

        #endregion

        #region Properties

        /// <summary>
        /// Current deafness level (0..1).
        /// </summary>
        public float Deafness => _deafnessLevel;

        /// <summary>
        /// True if bot is meaningfully deafened.
        /// </summary>
        public bool IsDeafened => _deafnessLevel > 0.08f || _ringing > 0.04f;

        /// <summary>
        /// Remaining deafness time (seconds).
        /// </summary>
        public float RemainingTime => Mathf.Max(_deafDuration - _elapsedTime, 0f);

        /// <summary>
        /// Current ear fatigue level (0..1).
        /// </summary>
        public float EarFatigue => _earFatigue;

        /// <summary>
        /// Current ringing intensity (0..1).
        /// </summary>
        public float Ringing => _ringing;

        #endregion

        #region Public Methods

        /// <summary>
        /// Apply a new trauma event (gunshot, explosion, flashbang, etc).
        /// Handles nonlinear combination, builds up fatigue, and can induce ringing.
        /// </summary>
        public void ApplyDeafness(float intensity, float duration, float ringingIntensity = 0.0f)
        {
            try
            {
                float newIntensity = Mathf.Clamp01(intensity);
                float newDuration = Mathf.Max(duration, 0.1f);
                float now = Time.time;

                // Fatigue: increases if stacking traumas, decays if resting
                float fatigueDecay = 0.19f;
                if (now - _lastApplyTime < 3.5f)
                    _earFatigue = Mathf.Clamp01(_earFatigue + newIntensity * 0.32f + (ringingIntensity * 0.18f));
                else
                    _earFatigue = Mathf.Clamp01(_earFatigue - fatigueDecay * (now - _lastApplyTime) / 7.0f);

                _lastApplyTime = now;

                // Escalate only if worse
                if (newIntensity > _targetDeafness ||
                    (Mathf.Approximately(newIntensity, _targetDeafness) && newDuration > RemainingTime))
                {
                    _targetDeafness = Mathf.Clamp01(newIntensity + _earFatigue * 0.28f);
                    _deafDuration = newDuration + _earFatigue * 1.2f;
                    _elapsedTime = 0f;
                    _deafnessLevel = _targetDeafness;
                    _recoverySlope = 1.35f + 2.7f * _targetDeafness + (_earFatigue * 1.6f);

                    // Ringing: loud events or high fatigue make ringing spike
                    if (ringingIntensity > 0.02f || _earFatigue > 0.45f)
                    {
                        _ringing = Mathf.Clamp01(ringingIntensity + newIntensity * 0.45f + UnityEngine.Random.Range(0.03f, 0.09f));
                        _lastRingingPeak = now;
                    }
                }
            }
            catch
            {
                Clear();
            }
        }

        /// <summary>
        /// Instantly clear all deafness, fatigue, and ringing.
        /// </summary>
        public void Clear()
        {
            _targetDeafness = 0f;
            _deafnessLevel = 0f;
            _deafDuration = 0f;
            _elapsedTime = 0f;
            _recoverySlope = 2f;
            _lastApplyTime = 0f;
            _earFatigue = 0f;
            _ringing = 0f;
            _lastRingingPeak = 0f;
        }

        /// <summary>
        /// Updates deafness and ringing. Nonlinear recovery. Call every frame. Bulletproof: always self-healing.
        /// </summary>
        public void Tick(float deltaTime)
        {
            try
            {
                if (_targetDeafness <= 0.01f || _deafDuration <= 0f)
                {
                    Clear();
                    return;
                }

                _elapsedTime += Mathf.Max(0f, deltaTime);

                if (_elapsedTime >= _deafDuration)
                {
                    Clear();
                    return;
                }

                // Fatigue decays very slowly if no new traumas
                if (_earFatigue > 0.01f)
                    _earFatigue = Mathf.Clamp01(_earFatigue - deltaTime * 0.019f);

                // Ringing: nonlinear fade with possible "spikes" if fatigue is high
                if (_ringing > 0.01f)
                {
                    float ringFade = 1f - Mathf.Pow(1f - Mathf.Clamp01((_elapsedTime - (_lastRingingPeak - _lastApplyTime)) / (_deafDuration + 0.1f)), 1.7f + _earFatigue * 2.1f);
                    _ringing = Mathf.Lerp(_ringing, 0f, ringFade * (deltaTime * 0.89f));
                    if (_ringing < 0.01f) _ringing = 0f;
                }

                // Deafness nonlinear fade (slow at first, then accelerates)
                float t = Mathf.Clamp01(_elapsedTime / _deafDuration);
                float recovery = 1f - Mathf.Pow(1f - t, _recoverySlope);
                _deafnessLevel = Mathf.Lerp(_targetDeafness, 0f, recovery);

                if (_deafnessLevel < 0.01f && _ringing < 0.01f)
                {
                    Clear();
                }
            }
            catch
            {
                Clear();
            }
        }

        #endregion

        #region Extension Points

        /// <summary>
        /// OPTIONAL: Apply squad- or cover-modified reduction to hearing loss for realistic squad/cover behavior.
        /// Call this before ApplyDeafness if using advanced squad/cover logic.
        /// </summary>
        public float GetModifiedIntensity(float baseIntensity, float coverFactor = 0f, float squadMorale = 0f)
        {
            // Cover (0=no cover, 1=full): reduces intensity
            float coverMod = Mathf.Lerp(1f, 0.63f, Mathf.Clamp01(coverFactor));
            // Squad morale: high morale reduces effective trauma
            float moraleMod = Mathf.Lerp(1f, 0.85f, Mathf.Clamp01(squadMorale));
            return baseIntensity * coverMod * moraleMod;
        }

        #endregion
    }
}
