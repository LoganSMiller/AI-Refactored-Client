// <auto-generated>
//   This file is part of AI-Refactored, an open-source project focused on realistic AI behavior in Escape from Tarkov.
//   Licensed under the MIT License. See LICENSE in the repository root for more information.
//
//   THIS FILE IS SYSTEMATICALLY MANAGED.
//   Please follow strict StyleCop, ReSharper, and AI-Refactored code standards for all modifications.
// </auto-generated>

#nullable enable

namespace AIRefactored.AI.Combat
{
    using System;
    using AIRefactored.AI.Core;
    using AIRefactored.AI.Helpers;
    using AIRefactored.AI.Optimization;
    using EFT;
    using UnityEngine;

    /// <summary>
    /// Handles bot suppression logic, including flinch, sprint retreat, and composure effects.
    /// Suppression is triggered by incoming fire, sound cues, or visual threats.
    /// </summary>
    public sealed class BotSuppressionReactionComponent
    {
        #region Constants

        private const float MinSuppressionRetreatDistance = 6f;
        private const float SuppressionDuration = 2.0f;

        #endregion

        #region Fields

        private BotOwner? bot;
        private BotComponentCache? cache;
        private bool isSuppressed;
        private float suppressionStartTime = -99f;

        #endregion

        #region Public Methods

        /// <summary>
        /// Initializes the suppression reaction component with the given bot cache.
        /// </summary>
        /// <param name="componentCache">The bot's component cache.</param>
        public void Initialize(BotComponentCache componentCache)
        {
            this.cache = componentCache ?? throw new ArgumentNullException(nameof(componentCache));
            this.bot = componentCache.Bot ?? throw new ArgumentNullException(nameof(componentCache.Bot));
        }

        /// <summary>
        /// Returns whether the bot is currently suppressed.
        /// </summary>
        /// <returns>True if suppressed, otherwise false.</returns>
        public bool IsSuppressed()
        {
            return this.isSuppressed;
        }

        /// <summary>
        /// Updates suppression decay over time.
        /// </summary>
        /// <param name="now">The current game time.</param>
        public void Tick(float now)
        {
            if (!this.isSuppressed)
            {
                return;
            }

            if (!this.IsValid())
            {
                this.isSuppressed = false;
                return;
            }

            if ((now - this.suppressionStartTime) >= SuppressionDuration)
            {
                this.isSuppressed = false;
            }
        }

        /// <summary>
        /// Triggers bot suppression behavior when under fire or near explosions.
        /// </summary>
        /// <param name="from">Optional position where suppression originated from.</param>
        public void TriggerSuppression(Vector3? from = null)
        {
            var botRef = this.bot;
            var cacheRef = this.cache;

            if (botRef == null || cacheRef == null)
            {
                return;
            }

            if (this.isSuppressed || cacheRef.PanicHandler?.IsPanicking == true)
            {
                return;
            }

            this.isSuppressed = true;
            this.suppressionStartTime = Time.time;

            Vector3 retreatDir;
            if (from.HasValue)
            {
                retreatDir = (botRef.Position - from.Value).normalized;
            }
            else
            {
                retreatDir = -botRef.LookDirection.normalized;
            }

            var fallback = this.CalculateFallback(retreatDir);

            var cohesion = cacheRef.AIRefactoredBotOwner?.PersonalityProfile?.Cohesion ?? 1f;

            botRef.Sprint(true);
            BotMovementHelper.SmoothMoveTo(botRef, fallback, false, cohesion);

            cacheRef.PanicHandler?.TriggerPanic();
            botRef.BotTalk?.TrySay(EPhraseTrigger.OnLostVisual);
        }

        #endregion

        #region Private Methods

        private Vector3 CalculateFallback(Vector3 retreatDir)
        {
            var botRef = this.bot;
            var cacheRef = this.cache;

            if (botRef == null)
            {
                return Vector3.zero;
            }

            var fallback = botRef.Position + (retreatDir * MinSuppressionRetreatDistance);

            if (cacheRef?.Pathing != null)
            {
                var path = BotCoverRetreatPlanner.GetCoverRetreatPath(botRef, retreatDir, cacheRef.Pathing);
                if (path.Count > 0)
                {
                    fallback = (Vector3.Distance(path[0], botRef.Position) < 1f && path.Count > 1)
                        ? path[1]
                        : path[0];
                }
            }

            return fallback;
        }

        private bool IsValid()
        {
            var botRef = this.bot;
            var cacheRef = this.cache;

            if (botRef == null || cacheRef == null || botRef.IsDead)
            {
                return false;
            }

            var player = botRef.GetPlayer;
            return player != null && player.IsAI;
        }

        #endregion
    }
}
