// <auto-generated>
//   AI-Refactored: BotSuppressionReactionComponent.cs (Ultimate Comms Realism – Beyond Diamond, June 2025, Hitch/Teleport Fix Pass)
//   Squad suppression, composure decay, panic escalation, emotional contagion, and fully dynamic squad comms.
//   Overlay retreat moves deduped, guarded, and never teleported or double-issued.
//   Bulletproof: All failures locally isolated, never disables, never triggers fallback, never allocates in hot path.
//   MIT License.
// </auto-generated>

namespace AIRefactored.AI.Combat
{
    using System;
    using System.Reflection;
    using AIRefactored.AI.Core;
    using AIRefactored.AI.Helpers;
    using AIRefactored.AI.Navigation;
    using AIRefactored.Core;
    using EFT;
    using UnityEngine;

    /// <summary>
    /// Handles suppression events, composure decay, squad contagion, panic escalation, and comms.
    /// Bulletproof: All errors are locally isolated, no disables, never allocates in hot path.
    /// All overlay retreat moves are anti-hitch/anti-teleport and never double-issued.
    /// </summary>
    public sealed class BotSuppressionReactionComponent
    {
        #region Constants

        private const float MinSuppressionRetreatDistance = 6.0f;
        private const float SuppressionDuration = 2.2f;
        private const float SquadSuppressionRadiusSqr = 144f;
        private const float SuppressionVoiceCooldown = 1.5f;
        private const float SquadSuppressionSyncChance = 0.23f;
        private const float ComposureLossMin = 0.12f;
        private const float ComposureLossMax = 0.25f;
        private const float PanicComposureThreshold = 0.18f;
        private const float OverlayMoveDedupSqr = 0.0001f;
        private const float OverlayMoveCooldown = 0.48f;

        private static readonly EPhraseTrigger[] SuppressionTriggers = new[]
        {
            EPhraseTrigger.NeedHelp, EPhraseTrigger.UnderFire, EPhraseTrigger.GetBack,
            EPhraseTrigger.OnBeingHurt, EPhraseTrigger.EnemyHit, EPhraseTrigger.Regroup,
            EPhraseTrigger.Cooperation, EPhraseTrigger.GetInCover, EPhraseTrigger.OnEnemyGrenade,
            EPhraseTrigger.CoverMe, EPhraseTrigger.FollowMe
        };

        private static readonly EPhraseTrigger[] SquadSyncTriggers = new[]
        {
            EPhraseTrigger.GoForward, EPhraseTrigger.Regroup, EPhraseTrigger.CoverMe,
            EPhraseTrigger.FollowMe, EPhraseTrigger.HoldPosition, EPhraseTrigger.Spreadout
        };

        #endregion

        #region Fields

        private BotOwner _bot;
        private BotComponentCache _cache;
        private bool _isSuppressed;
        private float _suppressionStartTime = float.NegativeInfinity;
        private float _lastVoiceTime = float.NegativeInfinity;
        private static FieldInfo _composureField;

        // Overlay dedup for suppression retreat
        private Vector3 _lastSuppressionMoveIssued = Vector3.zero;
        private float _lastSuppressionMoveTime = -10f;

        #endregion

        #region Initialization

        /// <summary>
        /// Initializes the suppression reaction component for a bot.
        /// </summary>
        /// <param name="componentCache">The bot's component cache.</param>
        public void Initialize(BotComponentCache componentCache)
        {
            if (componentCache == null || componentCache.Bot == null)
            {
                Plugin.LoggerInstance?.LogError("[Suppression] Bot or cache is null in Initialize.");
                return;
            }

            _cache = componentCache;
            _bot = componentCache.Bot;
            _isSuppressed = false;
            _suppressionStartTime = float.NegativeInfinity;
            _lastVoiceTime = float.NegativeInfinity;
            _lastSuppressionMoveIssued = Vector3.zero;
            _lastSuppressionMoveTime = -10f;

            if (_composureField == null)
                _composureField = typeof(BotPanicHandler).GetField("_composureLevel", BindingFlags.NonPublic | BindingFlags.Instance);
        }

        #endregion

        #region Public API

        /// <summary>
        /// Returns whether the bot is currently suppressed.
        /// </summary>
        public bool IsSuppressed() => _isSuppressed;

        /// <summary>
        /// Suppression tick: composure decay, voice, clear suppression. Bulletproof: all errors isolated.
        /// </summary>
        public void Tick(float time)
        {
            if (!_isSuppressed)
                return;

            try
            {
                if (!IsValid())
                {
                    _isSuppressed = false;
                    return;
                }

                if (_bot.BotTalk != null && time - _lastVoiceTime > SuppressionVoiceCooldown)
                {
                    if (UnityEngine.Random.value < 0.33f)
                    {
                        var trigger = SuppressionTriggers[UnityEngine.Random.Range(0, SuppressionTriggers.Length)];
                        try { _bot.BotTalk.TrySay(trigger); } catch { }
                        _lastVoiceTime = time;
                    }
                }

                if (time - _suppressionStartTime >= SuppressionDuration)
                {
                    _isSuppressed = false;
                }
            }
            catch (Exception ex)
            {
                Plugin.LoggerInstance?.LogError("[BotSuppression] Tick exception: " + ex);
                _isSuppressed = false;
            }
        }

        /// <summary>
        /// Triggers suppression (panic, retreat, voice, squad contagion, comms). Overlay/intent-only, anti-teleport, anti-hitch.
        /// </summary>
        /// <param name="source">Optional: source of suppression event (e.g. incoming fire).</param>
        public void TriggerSuppression(Vector3? source)
        {
            if (_isSuppressed || !IsValid())
                return;

            try
            {
                var panic = _cache.PanicHandler;
                if (panic != null && panic.IsPanicking)
                    return;

                _isSuppressed = true;
                _suppressionStartTime = Time.time;

                // Composure decay (deep panic risk)
                if (panic != null && _composureField != null)
                {
                    float loss = UnityEngine.Random.Range(ComposureLossMin, ComposureLossMax);
                    float current = panic.GetComposureLevel();
                    _composureField.SetValue(panic, Mathf.Clamp01(current - loss));
                }

                // Overlay retreat direction, fully anti-hitch/anti-teleport/anti-double-issue
                Vector3 retreatDir = source.HasValue
                    ? (_bot.Position - source.Value).normalized
                    : GetDefaultRetreatDirection();

                Vector3 fallback = _bot.Position + retreatDir * MinSuppressionRetreatDistance;
                fallback.y = _bot.Position.y;

                // Always NavMesh validate, clamp, dedup after sampling (never raw move)
                if (BotNavHelper.TryGetSafeTarget(_bot, out var navTarget) && IsVectorValid(navTarget))
                    fallback = navTarget;

                float cohesion = _cache.AIRefactoredBotOwner?.PersonalityProfile?.Cohesion ?? 1f;

                // Anti-hitch/anti-teleport overlay dedup and overlay guard
                if (!BotMovementHelper.IsMovementPaused(_bot)
                    && !BotMovementHelper.IsInInteractionState(_bot)
                    && (_lastSuppressionMoveIssued - fallback).sqrMagnitude > OverlayMoveDedupSqr
                    && (Time.time - _lastSuppressionMoveTime) > OverlayMoveCooldown
                    && !IsAnticipationActive(_bot)) // Centralized anticipation/fakeout overlay block
                {
                    BotMovementHelper.SmoothMoveToSafe(_bot, fallback, slow: false, cohesion);
                    _bot.Sprint(true);
                    BotCoverHelper.TrySetStanceFromNearbyCover(_cache, fallback);

                    _lastSuppressionMoveIssued = fallback;
                    _lastSuppressionMoveTime = Time.time;
                }
                // Never update cache/timestamp on blocked or failed move

                // Panic escalation (contagion)
                if (panic != null && panic.GetComposureLevel() < PanicComposureThreshold)
                    panic.TriggerPanic();

                _cache.Escalation?.NotifyPanicTriggered();
                TryPropagateSuppression();

                // Voice/phrase logic
                if (_bot.BotTalk != null && Time.time - _lastVoiceTime > SuppressionVoiceCooldown)
                {
                    var triggers = UnityEngine.Random.value < 0.5f ? SuppressionTriggers : SquadSyncTriggers;
                    var trigger = triggers[UnityEngine.Random.Range(0, triggers.Length)];
                    try { _bot.BotTalk.TrySay(trigger); } catch { }
                    _lastVoiceTime = Time.time;
                }
            }
            catch (Exception ex)
            {
                Plugin.LoggerInstance?.LogError("[BotSuppression] TriggerSuppression failed: " + ex);
            }
        }

        #endregion

        #region Squad Propagation

        /// <summary>
        /// Spreads suppression to nearby squadmates. Overlay-only, with emotional contagion chance.
        /// </summary>
        private void TryPropagateSuppression()
        {
            try
            {
                if (_bot?.BotsGroup == null)
                    return;

                Vector3 self = _bot.Position;
                int count = _bot.BotsGroup.MembersCount;

                for (int i = 0; i < count; i++)
                {
                    BotOwner mate = _bot.BotsGroup.Member(i);
                    if (mate == null || mate == _bot || mate.IsDead)
                        continue;

                    if ((mate.Position - self).sqrMagnitude > SquadSuppressionRadiusSqr)
                        continue;

                    if (UnityEngine.Random.value > SquadSuppressionSyncChance)
                        continue;

                    BotComponentCache mateCache = BotCacheUtility.GetCache(mate);
                    if (mateCache?.Suppression != null && !mateCache.Suppression.IsSuppressed())
                    {
                        mateCache.Suppression.TriggerSuppression(self);

                        if (mate.BotTalk != null && UnityEngine.Random.value < 0.22f)
                        {
                            var trigger = SquadSyncTriggers[UnityEngine.Random.Range(0, SquadSyncTriggers.Length)];
                            try { mate.BotTalk.TrySay(trigger); } catch { }
                        }
                    }
                }
            }
            catch (Exception ex)
            {
                Plugin.LoggerInstance?.LogError("[BotSuppression] Propagation error: " + ex);
            }
        }

        #endregion

        #region Internal Helpers

        private static Vector3 GetDefaultRetreatDirection() => Vector3.back;

        private bool IsValid()
        {
            try
            {
                return _bot != null &&
                       _cache != null &&
                       !_bot.IsDead &&
                       _bot.GetPlayer is Player player &&
                       player.IsAI;
            }
            catch { return false; }
        }

        private static bool IsVectorValid(Vector3 v)
        {
            return !float.IsNaN(v.x) && !float.IsNaN(v.y) && !float.IsNaN(v.z);
        }

        /// <summary>
        /// Returns true if an anticipation/fakeout overlay/lock is currently active on the bot.
        /// </summary>
        private static bool IsAnticipationActive(BotOwner bot)
        {
            // Placeholder for future: Integrate with centralized anticipation/fakeout overlay lock manager if present.
            return false;
        }

        #endregion
    }
}
