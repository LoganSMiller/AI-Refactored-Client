// <auto-generated>
//   This file is part of AI-Refactored, an open-source project focused on realistic AI behavior in Escape from Tarkov.
//   Licensed under the MIT License. See LICENSE in the repository root for more information.
//
//   THIS FILE IS SYSTEMATICALLY MANAGED.
//   All fallback logic removed: Bot fire logic is always eligible and self-recovering. No fallback mode. No terminal disables.
//   Realism: Suppression, panic, personality, and recoil are simulated for all fire events.
// </auto-generated>

namespace AIRefactored.AI.Combat
{
    using System;
    using System.Collections.Generic;
    using AIRefactored.AI.Core;
    using AIRefactored.AI.Helpers;
    using AIRefactored.AI.Navigation;
    using AIRefactored.Core;
    using AIRefactored.Pools;
    using EFT;
    using EFT.HealthSystem;
    using EFT.InventoryLogic;
    using UnityEngine;
    using GClass2814 = GClass2814<HealthControllerClass.GClass2819>;
    using Random = UnityEngine.Random;

    /// <summary>
    /// Core weapon fire controller for bots. Handles aiming, cadence, suppression effects, and fire mode switching.
    /// Bulletproof: All failures are locally isolated. Never disables itself, never triggers fallback AI.
    /// </summary>
    public sealed class BotFireLogic
    {
        private const float MaxAimPitch = 70f;
        private const float MaxHumanRecoilAngle = 11f;
        private const float MaxMissAngle = 6.2f;
        private const float AimDriftMagnitude = 0.14f;

        private static readonly EBodyPart[] AllBodyParts = (EBodyPart[])Enum.GetValues(typeof(EBodyPart));
        private static readonly PlayerBoneType[] PreferredBones =
        {
            PlayerBoneType.Head, PlayerBoneType.Ribcage, PlayerBoneType.Spine, PlayerBoneType.LeftShoulder,
            PlayerBoneType.RightShoulder, PlayerBoneType.Pelvis, PlayerBoneType.LeftThigh1, PlayerBoneType.RightThigh1
        };

        private static readonly Dictionary<string, float> WeaponTypeRanges = new Dictionary<string, float>(StringComparer.OrdinalIgnoreCase)
        {
            { "sniper", 180f },
            { "marksman", 150f },
            { "rifle", 120f },
            { "assault", 100f },
            { "smg", 75f },
            { "shotgun", 50f },
            { "pistol", 35f }
        };

        private readonly BotOwner _bot;
        private readonly BotComponentCache _cache;

        private Vector3 _idleLookDirection = Vector3.forward;
        private float _lastLookAroundTime;
        private float _nextDecisionTime;
        private float _nextFireTime;

        public BotFireLogic(BotOwner bot, BotComponentCache cache)
        {
            _bot = bot;
            _cache = cache;
        }

        public void Tick(float time)
        {
            if (_bot == null || _cache == null || _bot.IsDead || !_bot.IsAI || _bot.Memory == null)
                return;

            try
            {
                var weaponManager = _bot.WeaponManager;
                var shootData = _bot.ShootData;
                var weaponInfo = weaponManager?._currentWeaponInfo;
                var weapon = weaponInfo?.weapon;
                var settings = _bot.Settings?.FileSettings?.Core;
                var profile = _cache.AIRefactoredBotOwner?.PersonalityProfile;

                if (weaponManager == null || shootData == null || weaponInfo == null || weapon == null || settings == null || profile == null)
                    return;

                if (!TryResolveEnemy(out Player target))
                    return;

                Vector3 aimPosition = GetHumanizedAimPosition(target, time, profile);
                UpdateBotAiming(aimPosition, profile, time);

                if (!EFTPlayerUtil.IsValid(target))
                    return;

                float distance = Vector3.Distance(_bot.Position, aimPosition);
                float weaponRange = EstimateWeaponRange(weapon);
                float maxRange = Mathf.Min(profile.EngagementRange, weaponRange, 200f);

                if (distance > maxRange)
                {
                    if (profile.ChaosFactor > 0f && Random.value < profile.ChaosFactor * 0.6f)
                    {
                        if (BotNavHelper.TryGetSafeTarget(_bot, out var advance) && IsVectorValid(advance))
                        {
                            if (Random.value < 0.6f)
                                BotMovementHelper.SmoothMoveTo(_bot, advance, false, Mathf.Clamp(profile.Cohesion, 0.7f, 1.3f));
                        }
                    }
                    return;
                }

                if (time < _nextDecisionTime || time < _nextFireTime)
                    return;

                float composure = _cache.PanicHandler?.GetComposureLevel() ?? 1f;
                float suppressionPenalty = _cache.Suppression?.IsSuppressed() == true ? (1f - composure) : 0f;
                float microFlinch = Random.Range(-0.07f, 0.15f) * suppressionPenalty;

                _nextDecisionTime = time + GetBurstCadence(profile) + microFlinch;

                float fireRhythm = Mathf.Lerp(0.13f, 0.35f, Random.value) * Mathf.Lerp(1.0f, 1.4f, 1f - profile.ReactionTime);
                fireRhythm += suppressionPenalty * 0.22f + Random.Range(0f, 0.07f);
                _nextFireTime = time + fireRhythm;

                if (weaponInfo.BulletCount <= 0 && !weaponInfo.CheckHaveAmmoForReload())
                {
                    weaponManager.Selector?.TryChangeWeaponCauseNoAmmo();
                    weaponManager.Melee?.Activate();
                    return;
                }

                ApplyFireMode(weaponInfo, weapon, distance, profile, settings, suppressionPenalty);

                if (weaponManager.IsWeaponReady)
                {
                    float fireChance = suppressionPenalty < 0.55f
                        ? 0.92f + (profile.AggressionLevel * 0.06f)
                        : 0.65f + (profile.AggressionLevel * 0.22f);

                    if (Random.value < fireChance)
                    {
                        shootData.Shoot();
                        _cache.LastShotTracker?.RegisterShot(target.ProfileId);
                    }
                }
            }
            catch (Exception ex)
            {
                Plugin.LoggerInstance?.LogError($"[BotFireLogic] Tick exception: {ex}");
            }
        }

        /// <summary>
        /// Aim with composure, panic, and human miss profile, including micro drift/recoil.
        /// </summary>
        private void UpdateBotAiming(Vector3 aimPosition, BotPersonalityProfile profile, float time)
        {
            try
            {
                Vector3 dir = aimPosition - _bot.Position;
                if (dir.sqrMagnitude < 0.01f)
                    return;

                float composure = _cache.PanicHandler?.GetComposureLevel() ?? 1f;
                float suppression = _cache.Suppression?.IsSuppressed() == true ? (1f - composure) : 0f;
                float panicMiss = (1f - composure) * 0.9f;
                float aimCone = Mathf.Lerp(0.85f, 2.3f, 1f - profile.AccuracyUnderFire);
                float suppressionCone = Mathf.Lerp(1f, 2.6f, suppression);
                float cone = aimCone + suppressionCone + panicMiss * 2.6f;
                cone = Mathf.Clamp(cone, 0.7f, 5.0f);

                float missAngle = Random.Range(-MaxMissAngle, MaxMissAngle) * cone * Random.Range(0.76f, 1.24f);
                float recoil = Random.Range(0f, MaxHumanRecoilAngle) * (1f - composure) * Random.Range(0.7f, 1.1f);

                Quaternion offsetQ = Quaternion.AngleAxis(missAngle, Vector3.up) * Quaternion.AngleAxis(recoil, Vector3.right);
                Vector3 adjustedDir = offsetQ * dir.normalized;

                float drift = AimDriftMagnitude * (Random.value - 0.5f);
                adjustedDir += Vector3.Cross(Vector3.up, adjustedDir) * drift;

                Quaternion rot = Quaternion.LookRotation(adjustedDir);
                float pitch = rot.eulerAngles.x > 180f ? rot.eulerAngles.x - 360f : rot.eulerAngles.x;
                pitch = Mathf.Clamp(pitch, -MaxAimPitch, MaxAimPitch);

                Vector3 finalFwd = Quaternion.Euler(pitch, rot.eulerAngles.y, 0f) * Vector3.forward;
                _bot.AimingManager?.CurrentAiming?.SetTarget(finalFwd);
            }
            catch (Exception ex)
            {
                Plugin.LoggerInstance?.LogError($"[BotFireLogic] Aiming exception: {ex}");
            }
        }

        /// <summary>
        /// Returns an aim position factoring in enemy location, memory fallback, and random idle drift.
        /// Bone targeting uses PlayerBones.BifacialTransforms for robust, version-safe access.
        /// </summary>
        private Vector3 GetHumanizedAimPosition(Player target, float time, BotPersonalityProfile profile)
        {
            try
            {
                if (EFTPlayerUtil.IsValid(target))
                {
                    Vector3 center = EFTPlayerUtil.GetPosition(target);

                    float composure = _cache.PanicHandler?.GetComposureLevel() ?? 1f;
                    float miss = UnityEngine.Random.value;
                    if (miss > 0.9f || composure < 0.55f)
                    {
                        // Use PlayerBones.BifacialTransforms for robust bone targeting
                        var bones = target.PlayerBones;
                        Vector3 partPos = center;
                        if (bones != null)
                        {
                            var boneType = PreferredBones[UnityEngine.Random.Range(0, PreferredBones.Length)];
                            if (bones.BifacialTransforms.TryGetValue(boneType, out var bifacial))
                            {
                                Transform t = bifacial?.Original;
                                if (t != null)
                                    partPos = t.position;
                            }
                        }
                        center = Vector3.Lerp(center, partPos, UnityEngine.Random.Range(0.34f, 0.94f));
                    }
                    return center;
                }

                Vector3 memory = _bot.Memory.LastEnemy?.CurrPosition ?? Vector3.zero;
                if (memory != Vector3.zero)
                    return memory;

                if (time - _lastLookAroundTime > 1.5f)
                {
                    float yaw = UnityEngine.Random.Range(-75f, 75f);
                    float pitch = UnityEngine.Random.Range(-10f, 10f);
                    Quaternion q = Quaternion.Euler(pitch, yaw, 0f);
                    Vector3 baseDir = _bot.Transform != null ? _bot.Transform.forward : Vector3.forward;
                    _idleLookDirection = q * baseDir;
                    _lastLookAroundTime = time;
                }

                return _bot.Position + _idleLookDirection.normalized * 10f;
            }
            catch (Exception ex)
            {
                Plugin.LoggerInstance?.LogError($"[BotFireLogic] AimPos exception: {ex}");
                return _bot.Position;
            }
        }

        private void ApplyFireMode(BotWeaponInfo info, Weapon weapon, float distance, BotPersonalityProfile profile, GClass592 settings, float suppressionPenalty)
        {
            try
            {
                if (suppressionPenalty > 0.45f && Random.value < 0.34f)
                {
                    SetFireMode(info, Weapon.EFireMode.single);
                    ApplyScatter(settings, true, profile, suppressionPenalty);
                    return;
                }

                if (distance <= 40f)
                {
                    SetFireMode(info, Weapon.EFireMode.fullauto);
                    RecoverAccuracy(settings);
                }
                else if (distance <= 100f && SupportsFireMode(weapon, Weapon.EFireMode.burst))
                {
                    SetFireMode(info, Weapon.EFireMode.burst);
                    ApplyScatter(settings, true, profile, suppressionPenalty);
                }
                else
                {
                    SetFireMode(info, Weapon.EFireMode.single);
                    ApplyScatter(settings, true, profile, suppressionPenalty);
                }
            }
            catch (Exception ex)
            {
                Plugin.LoggerInstance?.LogError($"[BotFireLogic] ApplyFireMode exception: {ex}");
            }
        }

        private void SetFireMode(BotWeaponInfo info, Weapon.EFireMode mode)
        {
            try
            {
                if (info.weapon.SelectedFireMode != mode)
                    info.ChangeFireMode(mode);
            }
            catch (Exception ex)
            {
                Plugin.LoggerInstance?.LogError($"[BotFireLogic] FireMode switch failed: {ex}");
            }
        }

        private bool SupportsFireMode(Weapon weapon, Weapon.EFireMode mode)
        {
            try
            {
                foreach (var m in weapon.WeapFireType)
                {
                    if (m == mode)
                        return true;
                }
            }
            catch (Exception ex)
            {
                Plugin.LoggerInstance?.LogError($"[BotFireLogic] SupportsFireMode exception: {ex}");
            }
            return false;
        }

        private void RecoverAccuracy(GClass592 settings)
        {
            try
            {
                settings.ScatteringPerMeter = Mathf.Clamp(settings.ScatteringPerMeter * 0.95f, 0.4f, 3.0f);
            }
            catch (Exception ex)
            {
                Plugin.LoggerInstance?.LogError($"[BotFireLogic] RecoverAccuracy failed: {ex}");
            }
        }

        private void ApplyScatter(GClass592 settings, bool underFire, BotPersonalityProfile profile, float suppressionPenalty)
        {
            try
            {
                float composure = _cache.PanicHandler?.GetComposureLevel() ?? 1f;
                float scatterPenalty = underFire ? (1f - profile.AccuracyUnderFire) * (1f - composure) : 0f;
                scatterPenalty += suppressionPenalty * 0.55f;
                float scatterFactor = 1.1f + scatterPenalty;

                if (suppressionPenalty > 0.2f && Random.value < 0.35f)
                    scatterFactor *= Random.Range(1.08f, 1.2f);

                settings.ScatteringPerMeter = Mathf.Clamp(settings.ScatteringPerMeter * scatterFactor, 0.6f, 3.5f);
            }
            catch (Exception ex)
            {
                Plugin.LoggerInstance?.LogError($"[BotFireLogic] ApplyScatter failed: {ex}");
            }
        }

        private float EstimateWeaponRange(Weapon weapon)
        {
            try
            {
                var template = weapon.Template;
                if (template == null || string.IsNullOrEmpty(template.Name))
                    return 90f;

                foreach (var kv in WeaponTypeRanges)
                {
                    if (template.Name.IndexOf(kv.Key, StringComparison.OrdinalIgnoreCase) >= 0)
                        return kv.Value;
                }

                return 90f;
            }
            catch (Exception ex)
            {
                Plugin.LoggerInstance?.LogError($"[BotFireLogic] EstimateWeaponRange failed: {ex}");
                return 90f;
            }
        }

        private float GetBurstCadence(BotPersonalityProfile profile)
        {
            try
            {
                float baseDelay = Mathf.Lerp(0.75f, 0.25f, profile.AggressionLevel);
                float reactionDelay = Mathf.Lerp(0.15f, 0.35f, 1f - profile.ReactionTime);
                float chaosOffset = Random.Range(-0.08f, 0.2f) * profile.ChaosFactor;
                return Mathf.Clamp(baseDelay + reactionDelay + chaosOffset, 0.15f, 1.1f);
            }
            catch (Exception ex)
            {
                Plugin.LoggerInstance?.LogError($"[BotFireLogic] GetBurstCadence failed: {ex}");
                return 0.45f;
            }
        }

        private bool TryResolveEnemy(out Player result)
        {
            result = null;
            try
            {
                if (_cache.ThreatSelector?.CurrentTarget is Player direct && EFTPlayerUtil.IsValid(direct))
                {
                    result = direct;
                    return true;
                }

                if (_bot.Memory?.GoalEnemy?.Person is Player fallback && EFTPlayerUtil.IsValid(fallback))
                {
                    result = fallback;
                    return true;
                }
            }
            catch (Exception ex)
            {
                Plugin.LoggerInstance?.LogError($"[BotFireLogic] TryResolveEnemy failed: {ex}");
            }

            return false;
        }

        private static bool IsVectorValid(Vector3 v)
        {
            return !float.IsNaN(v.x) && !float.IsNaN(v.y) && !float.IsNaN(v.z);
        }
    }
}
