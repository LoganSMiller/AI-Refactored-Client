// <auto-generated>
//   This file is part of AI-Refactored, an open-source project focused on realistic AI behavior in Escape from Tarkov.
//   Licensed under the MIT License. See LICENSE in the repository root for more information.
//
//   THIS FILE IS SYSTEMATICALLY MANAGED.
//   Please follow strict StyleCop, ReSharper, and AI-Refactored code standards for all modifications.
// </auto-generated>

namespace AIRefactored.AI.Combat
{
    using System;
    using System.Collections.Generic;
    using AIRefactored.AI.Core;
    using AIRefactored.AI.Helpers;
    using AIRefactored.AI.Optimization;
    using EFT;
    using EFT.HealthSystem;
    using EFT.InventoryLogic;
    using UnityEngine;
    using GClass2814 = GClass2814<HealthControllerClass.GClass2819>;
    using Random = UnityEngine.Random;

    /// <summary>
    /// Controls bot firing, aiming, fire mode selection, and fallback behavior.
    /// Dynamically adjusts based on distance, suppression, weapon state, and bot personality.
    /// </summary>
    public sealed class BotFireLogic
    {
        #region Constants

        private const float MaxAimPitch = 70f;

        private static readonly EBodyPart[] AllBodyParts = (EBodyPart[])Enum.GetValues(typeof(EBodyPart));

        private static readonly Dictionary<string, float> WeaponTypeRanges = new Dictionary<string, float>(StringComparer.OrdinalIgnoreCase)
        {
            { "sniper", 180f },
            { "marksman", 150f },
            { "rifle", 120f },
            { "assault", 100f },
            { "smg", 75f },
            { "shotgun", 50f },
            { "pistol", 35f }
        };

        #endregion

        #region Fields

        private readonly BotOwner _bot;
        private readonly BotComponentCache _cache;

        private Vector3 _idleLookDirection = Vector3.forward;
        private float _lastLookAroundTime;
        private float _nextDecisionTime;

        #endregion

        #region Constructor

        public BotFireLogic(BotOwner bot, BotComponentCache cache)
        {
            if (bot == null)
                throw new ArgumentNullException(nameof(bot));
            if (cache == null)
                throw new ArgumentNullException(nameof(cache));

            this._bot = bot;
            this._cache = cache;
        }

        #endregion

        #region Public Methods

        /// <summary>
        /// Updates firing logic based on target, distance, suppression, and bot personality.
        /// </summary>
        /// <param name="time">Current world time.</param>
        public void Tick(float time)
        {
            if (this._bot == null || this._bot.IsDead || !this._bot.IsAI || this._bot.Memory == null)
                return;

            BotWeaponManager weaponManager = this._bot.WeaponManager;
            ShootData shootData = this._bot.ShootData;
            BotWeaponInfo weaponInfo = weaponManager?._currentWeaponInfo;
            Weapon weapon = weaponInfo?.weapon;
            GClass592 settings = this._bot.Settings?.FileSettings?.Core;
            BotPersonalityProfile profile = this._cache.AIRefactoredBotOwner?.PersonalityProfile;

            if (weaponManager == null || shootData == null || weaponInfo == null || weapon == null || settings == null || profile == null)
                return;

            IPlayer target = this._cache.ThreatSelector?.GetPriorityTarget() ?? this._bot.Memory.GoalEnemy?.Person;
            Vector3 aimPosition = this.GetValidatedAimPosition(target, time);
            this.UpdateBotAiming(aimPosition);

            if (target == null || target.HealthController == null || !target.HealthController.IsAlive)
                return;

            float distance = Vector3.Distance(this._bot.Position, aimPosition);
            float weaponRange = this.EstimateWeaponRange(weapon);
            float maxRange = Mathf.Min(profile.EngagementRange, weaponRange, 200f);

            if (this._bot.Memory.IsUnderFire && this.GetHealthRatio() <= profile.RetreatThreshold)
            {
                this.TriggerFallback();
                return;
            }

            if (distance > maxRange)
            {
                if (profile.ChaosFactor > 0f && Random.value < profile.ChaosFactor)
                {
                    BotMovementHelper.SmoothMoveTo(this._bot, aimPosition, false, profile.Cohesion);
                }

                return;
            }

            if (time < this._nextDecisionTime)
                return;

            this._nextDecisionTime = time + this.GetBurstCadence(profile);

            if (weaponInfo.BulletCount <= 0 && !weaponInfo.CheckHaveAmmoForReload())
            {
                weaponManager.Selector.TryChangeWeaponCauseNoAmmo();
                weaponManager.Melee.Activate();
                return;
            }

            this.ApplyFireMode(weaponInfo, weapon, distance, profile, settings);

            if (weaponManager.IsWeaponReady)
            {
                shootData.Shoot();
                this._cache.LastShotTracker?.RegisterShot(target);
            }
        }

        #endregion

        #region Private Methods

        private void UpdateBotAiming(Vector3 aimPosition)
        {
            Vector3 dir = aimPosition - this._bot.Position;
            if (dir.sqrMagnitude < 0.01f)
                return;

            Quaternion rot = Quaternion.LookRotation(dir);
            float pitch = rot.eulerAngles.x > 180f ? rot.eulerAngles.x - 360f : rot.eulerAngles.x;
            pitch = Mathf.Clamp(pitch, -MaxAimPitch, MaxAimPitch);

            Vector3 forward = Quaternion.Euler(pitch, rot.eulerAngles.y, 0f) * Vector3.forward;
            this._bot.AimingManager?.CurrentAiming?.SetTarget(forward);
        }

        private Vector3 GetValidatedAimPosition(IPlayer target, float time)
        {
            if (target != null && target.HealthController?.IsAlive == true)
                return target.Position;

            Vector3 mem = this._bot.Memory?.LastEnemy?.CurrPosition ?? Vector3.zero;
            if (mem != Vector3.zero)
                return mem;

            if (time - this._lastLookAroundTime > 1.5f)
            {
                float yaw = Random.Range(-75f, 75f);
                float pitch = Random.Range(-10f, 10f);
                Quaternion q = Quaternion.Euler(pitch, yaw, 0f);
                Vector3 baseDir = this._bot.Transform != null ? this._bot.Transform.forward : Vector3.forward;
                this._idleLookDirection = q * baseDir;
                this._lastLookAroundTime = time;
            }

            return this._bot.Position + this._idleLookDirection.normalized * 10f;
        }

        private void ApplyFireMode(BotWeaponInfo info, Weapon weapon, float distance, BotPersonalityProfile profile, GClass592 settings)
        {
            if (distance <= 40f)
            {
                this.SetFireMode(info, Weapon.EFireMode.fullauto);
                this.RecoverAccuracy(settings);
            }
            else if (distance <= 100f && this.SupportsFireMode(weapon, Weapon.EFireMode.burst))
            {
                this.SetFireMode(info, Weapon.EFireMode.burst);
                this.ApplyScatter(settings, true, profile);
            }
            else
            {
                this.SetFireMode(info, Weapon.EFireMode.single);
                this.ApplyScatter(settings, true, profile);
            }
        }

        private void SetFireMode(BotWeaponInfo info, Weapon.EFireMode mode)
        {
            if (info.weapon.SelectedFireMode != mode)
            {
                info.ChangeFireMode(mode);
            }
        }

        private bool SupportsFireMode(Weapon weapon, Weapon.EFireMode mode)
        {
            Weapon.EFireMode[] modes = weapon.WeapFireType;
            for (int i = 0; i < modes.Length; i++)
            {
                if (modes[i] == mode)
                    return true;
            }

            return false;
        }

        private void RecoverAccuracy(GClass592 settings)
        {
            settings.ScatteringPerMeter = Mathf.Clamp(settings.ScatteringPerMeter * 0.95f, 0.4f, 3.0f);
        }

        private void ApplyScatter(GClass592 settings, bool underFire, BotPersonalityProfile profile)
        {
            float composure = this._cache.PanicHandler?.GetComposureLevel() ?? 1f;
            float scatterPenalty = underFire ? (1f - profile.AccuracyUnderFire) * (1f - composure) : 0f;
            float scatterFactor = 1.1f + scatterPenalty;

            settings.ScatteringPerMeter = Mathf.Clamp(settings.ScatteringPerMeter * scatterFactor, 0.6f, 3.5f);
        }

        private float EstimateWeaponRange(Weapon weapon)
        {
            ItemTemplate template = weapon.Template;
            if (template == null || string.IsNullOrEmpty(template.Name))
                return 90f;

            foreach (KeyValuePair<string, float> kv in WeaponTypeRanges)
            {
                if (template.Name.IndexOf(kv.Key, StringComparison.OrdinalIgnoreCase) >= 0)
                    return kv.Value;
            }

            return 90f;
        }

        private float GetBurstCadence(BotPersonalityProfile profile)
        {
            float baseDelay = Mathf.Lerp(0.75f, 0.25f, profile.AggressionLevel);
            float reactionDelay = Mathf.Lerp(0.15f, 0.35f, 1f - profile.ReactionTime);
            float chaosOffset = Random.Range(-0.08f, 0.2f) * profile.ChaosFactor;

            return Mathf.Clamp(baseDelay + reactionDelay + chaosOffset, 0.15f, 1.1f);
        }

        private float GetHealthRatio()
        {
            HealthControllerClass hc = this._bot.HealthController as HealthControllerClass;
            if (hc == null || hc.Dictionary_0 == null)
                return 1f;

            float current = 0f;
            float maximum = 0f;
            Dictionary<EBodyPart, GClass2814<HealthControllerClass.GClass2819>.BodyPartState> dict = hc.Dictionary_0;

            for (int i = 0; i < AllBodyParts.Length; i++)
            {
                EBodyPart part = AllBodyParts[i];
                GClass2814<HealthControllerClass.GClass2819>.BodyPartState state;
                if (dict.TryGetValue(part, out state) && state.Health != null)
                {
                    current += state.Health.Current;
                    maximum += state.Health.Maximum;
                }
            }

            return maximum > 0f ? current / maximum : 1f;
        }

        private void TriggerFallback()
        {
            if (this._cache.Pathing == null)
                return;

            List<Vector3> path = BotCoverRetreatPlanner.GetCoverRetreatPath(this._bot, this._bot.LookDirection.normalized, this._cache.Pathing);
            if (path == null || path.Count < 2)
                return;

            Vector3 fallback = path[path.Count - 1];
            BotMovementHelper.SmoothMoveTo(this._bot, fallback, false);
            BotCoverHelper.TrySetStanceFromNearbyCover(this._cache, fallback);

            if (!FikaHeadlessDetector.IsHeadless && this._bot.BotTalk != null)
            {
                this._bot.BotTalk.TrySay(EPhraseTrigger.OnLostVisual);
            }
        }

        #endregion
    }
}
