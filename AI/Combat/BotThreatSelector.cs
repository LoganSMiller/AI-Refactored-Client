// <auto-generated>
//   AI-Refactored: BotThreatSelector.cs (Supreme Arbitration Overlay/Event, June 2025)
//   Overlay arbitration, dedup, pooled, triple-guarded. All movement overlays locked/guarded. Max realism, multiplayer/headless parity.
//   MIT License.
// </auto-generated>

namespace AIRefactored.AI.Combat
{
    using System;
    using System.Collections.Generic;
    using AIRefactored.AI.Core;
    using AIRefactored.AI.Helpers;
    using AIRefactored.AI.Memory;
    using AIRefactored.AI.Navigation;
    using AIRefactored.Core;
    using AIRefactored.Pools;
    using BepInEx.Logging;
    using EFT;
    using UnityEngine;

    /// <summary>
    /// Selects and prioritizes threats using live data, bot memory, personality, and squad logic.
    /// All overlay movement intents are deduped, arbitration/cooldown-locked, never double-issued or teleported.
    /// Bulletproof: All failures locally isolated, never disables, multiplayer/headless safe.
    /// </summary>
    public sealed class BotThreatSelector
    {
        #region Constants

        private const float EvaluateCooldown = 0.31f;
        private const float MaxDistance = 120f;
        private const float SwitchCooldown = 2.2f;
        private const float SwitchThreshold = 10.2f;

        private const float SquadAssistBonus = 12.5f;
        private const float CloseDistanceBonus = 14f;
        private const float LineOfSightBonus = 19.7f;
        private const float VisibleRecentBonus = 8.6f;
        private const float SuppressionPenalty = 12.9f;
        private const float PanicPenalty = 20f;

        private const float OverlayMoveDedupSqr = 0.0001f;
        private const float OverlayMoveCooldown = 0.46f;
        private const BotOverlayType OverlayType = BotOverlayType.Attack;

        #endregion

        #region Fields

        private readonly BotComponentCache _cache;
        private readonly BotOwner _bot;
        private readonly BotPersonalityProfile _profile;
        private readonly ManualLogSource _logger;

        private float _nextEvalTime;
        private float _lastSwitchTime;
        private Player _target;

        private Vector3 _lastThreatMoveIssued = Vector3.zero;
        private float _lastThreatMoveTime = -10f;

        #endregion

        #region Properties

        public Player CurrentTarget => _target;

        #endregion

        #region Constructor

        public BotThreatSelector(BotComponentCache cache)
        {
            if (cache == null || cache.Bot == null || cache.AIRefactoredBotOwner == null)
                throw new ArgumentException("[BotThreatSelector] Cache or owner null.");

            _cache = cache;
            _bot = cache.Bot;
            _profile = cache.AIRefactoredBotOwner.PersonalityProfile;
            _logger = Plugin.LoggerInstance;

            _lastThreatMoveIssued = Vector3.zero;
            _lastThreatMoveTime = -10f;
        }

        #endregion

        #region Tick

        /// <summary>
        /// Evaluates and updates bot threat targeting, scoring, fallback, and overlay-safe movement.
        /// </summary>
        public void Tick(float time)
        {
            if (time < _nextEvalTime || _bot == null || _bot.IsDead)
                return;

            _nextEvalTime = time + EvaluateCooldown;

            List<Player> players = GameWorldHandler.GetAllAlivePlayers();
            try
            {
                if (players == null || players.Count == 0)
                    return;

                Player best = null;
                float bestScore = float.MinValue;

                for (int i = 0; i < players.Count; i++)
                {
                    Player candidate = players[i];
                    if (!EFTPlayerUtil.IsValid(candidate) || !IsProperEnemy(_bot, candidate))
                        continue;

                    float score = ScoreTarget(candidate, time);
                    if (score > bestScore)
                    {
                        best = candidate;
                        bestScore = score;
                    }
                }

                if (best == null)
                {
                    TryFallbackFromMemory(time);
                    return;
                }

                if (_target == null)
                {
                    SetTarget(best, time);
                    return;
                }

                float currentScore = ScoreTarget(_target, time);
                float cooldown = SwitchCooldown * (1f - _profile.AggressionLevel);
                if (bestScore > currentScore + SwitchThreshold && time > _lastSwitchTime + cooldown)
                {
                    SetTarget(best, time);
                }
            }
            catch (Exception ex)
            {
                _logger.LogError("[BotThreatSelector] Tick failed: " + ex);
            }
            finally
            {
                TempListPool.Return(players);
            }
        }

        #endregion

        #region Scoring

        private float ScoreTarget(Player candidate, float time)
        {
            try
            {
                Vector3 pos = EFTPlayerUtil.GetPosition(candidate);
                float dist = Vector3.Distance(_bot.Position, pos);
                if (dist > MaxDistance) return float.MinValue;

                float score = MaxDistance - dist;

                if (dist < 12f)
                    score += CloseDistanceBonus;

                if (_bot.BotsGroup != null)
                {
                    int count = _bot.BotsGroup.MembersCount;
                    for (int i = 0; i < count; i++)
                    {
                        BotOwner mate = _bot.BotsGroup.Member(i);
                        if (mate != null && mate != _bot && !mate.IsDead &&
                            mate.Memory?.GoalEnemy?.Person?.ProfileId == candidate.ProfileId)
                        {
                            score += SquadAssistBonus;
                        }
                    }
                }

                EnemyInfo info = GetEnemyInfo(candidate);
                if (info != null && info.IsVisible)
                {
                    score += LineOfSightBonus;
                    if (time - info.PersonalLastSeenTime < 2.4f)
                        score += VisibleRecentBonus;
                }

                if (_cache.Suppression?.IsSuppressed() == true)
                    score -= SuppressionPenalty;
                if (_cache.PanicHandler?.IsPanicking == true)
                    score -= PanicPenalty;

                return score;
            }
            catch
            {
                return float.MinValue;
            }
        }

        private EnemyInfo GetEnemyInfo(Player player)
        {
            try
            {
                if (_bot?.EnemiesController?.EnemyInfos == null || player == null)
                    return null;

                foreach (var kv in _bot.EnemiesController.EnemyInfos)
                {
                    if (kv.Key is Player enemy && enemy.ProfileId == player.ProfileId)
                        return kv.Value;
                }

                if (_bot.Memory?.GoalEnemy?.Person?.ProfileId == player.ProfileId)
                    return _bot.Memory.GoalEnemy;
            }
            catch { }
            return null;
        }

        #endregion

        #region Fallback Logic

        private void TryFallbackFromMemory(float time)
        {
            try
            {
                string id = _cache?.TacticalMemory?.GetMostRecentEnemyId();
                if (string.IsNullOrEmpty(id))
                    return;

                Player fallback = EFTPlayerUtil.ResolvePlayerById(id);
                if (EFTPlayerUtil.IsValid(fallback) && IsProperEnemy(_bot, fallback))
                    SetTarget(fallback, time);
            }
            catch (Exception ex)
            {
                _logger.LogError("[BotThreatSelector] FallbackFromMemory failed: " + ex);
            }
        }

        /// <summary>
        /// Sets the current target and, if not moving, issues a deduped, arbitration-locked overlay movement.
        /// </summary>
        private void SetTarget(Player player, float time)
        {
            _target = player;
            _lastSwitchTime = time;

            try
            {
                if (_cache.TacticalMemory != null)
                    _cache.TacticalMemory.RecordEnemyPosition(EFTPlayerUtil.GetPosition(player), "Threat", player.ProfileId);

                if (_cache.Movement != null && !_bot.Mover.IsMoving)
                {
                    if (BotNavHelper.TryGetSafeTarget(_bot, out Vector3 safePos) && IsVectorValid(safePos))
                    {
                        float now = Time.time;
                        // Arbitration/registration signatures: strictly two args, no timestamp
                        if (BotOverlayManager.CanIssueMove(_bot, OverlayType)
                            && !BotMovementHelper.IsMovementPaused(_bot)
                            && !BotMovementHelper.IsInInteractionState(_bot)
                            && (_lastThreatMoveIssued - safePos).sqrMagnitude > OverlayMoveDedupSqr
                            && (now - _lastThreatMoveTime) > OverlayMoveCooldown
                            && !IsAnticipationActive(_bot))
                        {
                            BotOverlayManager.RegisterMove(_bot, OverlayType);
                            BotMovementHelper.SmoothMoveToSafe(_bot, safePos, false, 1f, OverlayType);
                            _lastThreatMoveIssued = safePos;
                            _lastThreatMoveTime = now;
                        }
                    }
                }
            }
            catch (Exception ex)
            {
                _logger.LogError("[BotThreatSelector] SetTarget failed: " + ex);
            }
        }

        public string GetTargetProfileId() => _target?.ProfileId ?? string.Empty;
        public void ResetTarget() => _target = null;

        #endregion

        #region Helpers

        private static bool IsProperEnemy(BotOwner self, Player candidate)
        {
            if (self == null || candidate == null || candidate.ProfileId == self.ProfileId)
                return false;

            EPlayerSide selfSide = self.GetPlayer?.Side ?? EPlayerSide.Savage;
            EPlayerSide otherSide = candidate.Side;

            if (selfSide != otherSide)
                return true;

            string selfGroup = self.GetPlayer?.Profile?.Info?.GroupId ?? "";
            string otherGroup = candidate.Profile?.Info?.GroupId ?? "";

            return selfGroup != otherGroup;
        }

        private static bool IsVectorValid(Vector3 v)
        {
            return !float.IsNaN(v.x) && !float.IsNaN(v.y) && !float.IsNaN(v.z) &&
                   Mathf.Abs(v.x) < 10000f && Mathf.Abs(v.y) < 10000f && Mathf.Abs(v.z) < 10000f;
        }

        /// <summary>
        /// Returns true if an anticipation/fakeout overlay/lock is currently active on the bot.
        /// </summary>
        private static bool IsAnticipationActive(BotOwner bot)
        {
            // Placeholder for anticipation/fakeout lock integration.
            return false;
        }

        #endregion
    }
}
