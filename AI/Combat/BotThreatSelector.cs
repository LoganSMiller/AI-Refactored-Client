// <auto-generated>
//   AI-Refactored: BotThreatSelector.cs (Max Realism Edition, May 2025)
//   Selects/prioritizes threats using live data, memory, personality, and squad logic.
//   Bulletproof: All failures locally isolated, no fallback AI, never disables, always multiplayer/headless safe.
//   MIT License.
// </auto-generated>

namespace AIRefactored.AI.Combat
{
    using System;
    using System.Collections.Generic;
    using AIRefactored.AI.Core;
    using AIRefactored.AI.Helpers;
    using AIRefactored.AI.Memory;
    using AIRefactored.AI.Navigation;
    using AIRefactored.Core;
    using BepInEx.Logging;
    using EFT;
    using UnityEngine;

    /// <summary>
    /// Selects and prioritizes threats based on live awareness, memory, squad, and bot personality.
    /// Handles PMC-vs-PMC, squad/squad, and fallback-to-memory selection. No fallback disables, no AI disables.
    /// </summary>
    public sealed class BotThreatSelector
    {
        #region Constants

        private const float EvaluateCooldown = 0.31f;
        private const float MaxDistance = 120f;
        private const float SwitchCooldown = 2.2f;
        private const float SwitchThreshold = 10.2f;

        private const float SquadAssistBonus = 12.5f;
        private const float CloseDistanceBonus = 14f;
        private const float LineOfSightBonus = 19.7f;
        private const float VisibleRecentBonus = 8.6f;
        private const float SuppressionPenalty = 12.9f;
        private const float PanicPenalty = 20f;

        #endregion

        #region Fields

        private readonly BotComponentCache _cache;
        private readonly BotOwner _bot;
        private readonly BotPersonalityProfile _profile;
        private readonly ManualLogSource _logger;

        private float _nextEvalTime;
        private float _lastSwitchTime;
        private Player _target;

        #endregion

        #region Properties

        public Player CurrentTarget => _target;

        #endregion

        #region Constructor

        public BotThreatSelector(BotComponentCache cache)
        {
            if (cache == null || cache.Bot == null || cache.AIRefactoredBotOwner == null)
                throw new ArgumentException("[BotThreatSelector] Cache or owner null.");

            _cache = cache;
            _bot = cache.Bot;
            _profile = cache.AIRefactoredBotOwner.PersonalityProfile;
            _logger = Plugin.LoggerInstance;
        }

        #endregion

        #region Tick

        public void Tick(float time)
        {
            if (time < _nextEvalTime || _bot == null || _bot.IsDead)
                return;

            _nextEvalTime = time + EvaluateCooldown;

            List<Player> players = GameWorldHandler.GetAllAlivePlayers();
            if (players == null || players.Count == 0)
                return;

            Player best = null;
            float bestScore = float.MinValue;

            for (int i = 0; i < players.Count; i++)
            {
                var p = players[i];
                if (!EFTPlayerUtil.IsValid(p) || !IsProperEnemy(_bot, p))
                    continue;

                float score = ScoreTarget(p, time);
                if (score > bestScore)
                {
                    bestScore = score;
                    best = p;
                }
            }

            if (best == null)
            {
                TryFallbackFromMemory(time);
                return;
            }

            if (_target == null)
            {
                SetTarget(best, time);
                return;
            }

            float currentScore = ScoreTarget(_target, time);
            float cooldown = SwitchCooldown * (1f - _profile.AggressionLevel);
            if (bestScore > currentScore + SwitchThreshold && time > _lastSwitchTime + cooldown)
            {
                SetTarget(best, time);
            }
        }

        #endregion

        #region Scoring

        private float ScoreTarget(Player candidate, float time)
        {
            Vector3 pos = EFTPlayerUtil.GetPosition(candidate);
            float dist = Vector3.Distance(_bot.Position, pos);
            if (dist > MaxDistance) return float.MinValue;

            float score = MaxDistance - dist;

            if (dist < 12f)
                score += CloseDistanceBonus;

            if (_bot.BotsGroup != null)
            {
                int n = _bot.BotsGroup.MembersCount;
                for (int i = 0; i < n; i++)
                {
                    var mate = _bot.BotsGroup.Member(i);
                    if (mate == null || mate == _bot || mate.IsDead) continue;
                    if (mate.Memory?.GoalEnemy?.Person?.ProfileId == candidate.ProfileId)
                        score += SquadAssistBonus;
                }
            }

            EnemyInfo info = GetEnemyInfo(candidate);
            if (info != null)
            {
                if (info.IsVisible)
                {
                    score += LineOfSightBonus;
                    if (time - info.PersonalLastSeenTime < 2.4f)
                        score += VisibleRecentBonus;
                }
            }

            if (_cache.Suppression != null && _cache.Suppression.IsSuppressed())
                score -= SuppressionPenalty;
            if (_cache.PanicHandler != null && _cache.PanicHandler.IsPanicking)
                score -= PanicPenalty;

            return score;
        }

        private EnemyInfo GetEnemyInfo(Player p)
        {
            if (_bot?.EnemiesController?.EnemyInfos == null || p == null || string.IsNullOrEmpty(p.ProfileId))
                return null;

            foreach (var kv in _bot.EnemiesController.EnemyInfos)
            {
                if (kv.Key is Player other && other.ProfileId == p.ProfileId)
                    return kv.Value;
            }

            return _bot.Memory?.GoalEnemy?.Person?.ProfileId == p.ProfileId
                ? _bot.Memory.GoalEnemy
                : null;
        }

        #endregion

        #region Fallback / Target Set

        private void TryFallbackFromMemory(float time)
        {
            string id = _cache?.TacticalMemory?.GetMostRecentEnemyId();
            if (string.IsNullOrEmpty(id))
                return;

            var fallback = EFTPlayerUtil.ResolvePlayerById(id);
            if (EFTPlayerUtil.IsValid(fallback) && IsProperEnemy(_bot, fallback))
                SetTarget(fallback, time);
        }

        private void SetTarget(Player p, float time)
        {
            _target = p;
            _lastSwitchTime = time;

            if (_cache?.TacticalMemory != null && p != null)
                _cache.TacticalMemory.RecordEnemyPosition(EFTPlayerUtil.GetPosition(p), "Threat", p.ProfileId);

            if (_cache?.Movement != null && !_bot.Mover.IsMoving)
            {
                if (BotNavHelper.TryGetSafeTarget(_bot, out Vector3 safePos) && IsVectorValid(safePos))
                    BotMovementHelper.SmoothMoveTo(_bot, safePos, false, _profile.Cohesion);
            }
        }

        public string GetTargetProfileId() => _target?.ProfileId ?? string.Empty;

        public void ResetTarget() => _target = null;

        #endregion

        #region Helper

        private static bool IsProperEnemy(BotOwner self, Player candidate)
        {
            if (self == null || candidate == null || candidate.ProfileId == self.ProfileId)
                return false;

            var selfSide = self.GetPlayer?.Side ?? EPlayerSide.Savage;
            var otherSide = candidate.Side;
            if (selfSide != otherSide) return true;

            string sg = self.GetPlayer?.Profile?.Info?.GroupId ?? "";
            string tg = candidate.Profile?.Info?.GroupId ?? "";
            return sg != tg;
        }

        private static bool IsVectorValid(Vector3 v)
        {
            return !float.IsNaN(v.x) && !float.IsNaN(v.y) && !float.IsNaN(v.z) &&
                   Mathf.Abs(v.x) < 10000f && Mathf.Abs(v.y) < 10000f && Mathf.Abs(v.z) < 10000f;
        }

        #endregion
    }
}
