// <auto-generated>
//   AI-Refactored: BotThreatSelector.cs (Supreme Arbitration Overlay/Event, Beyond Diamond Ultra-Realism, June 2025)
//   All player/bot resolution uses EFTPlayerUtil. No direct Player→BotOwner casts. Multiplayer/headless safe.
//   Overlay arbitration, dedup, pooled, triple-guarded. Max realism. MIT License.
// </auto-generated>

namespace AIRefactored.AI.Combat
{
    using System;
    using AIRefactored.AI.Core;
    using AIRefactored.AI.Helpers;
    using AIRefactored.AI.Memory;
    using AIRefactored.AI.Navigation;
    using AIRefactored.Core;
    using AIRefactored.Pools;
    using BepInEx.Logging;
    using EFT;
    using UnityEngine;

    /// <summary>
    /// Selects and prioritizes threats using live data, bot memory, suppression, personality, and squad overlays.
    /// All movement overlays deduped, arbitration/cooldown-locked, never teleports or disables. Bulletproof.
    /// </summary>
    public sealed class BotThreatSelector
    {
        #region Constants

        private const float EvaluateCooldown = 0.31f;
        private const float MaxDistance = 120f;
        private const float SwitchCooldown = 2.2f;
        private const float SwitchThreshold = 10.2f;
        private const float ThreatStaleTime = 9.5f;

        private const float SquadAssistBonus = 12.5f;
        private const float CloseDistanceBonus = 14f;
        private const float LineOfSightBonus = 19.7f;
        private const float VisibleRecentBonus = 8.6f;
        private const float SuppressionPenalty = 12.9f;
        private const float PanicPenalty = 20f;
        private const float CoverAssistBonus = 6.0f;

        private const float OverlayMoveDedupSqr = 0.0001f;
        private const float OverlayMoveCooldown = 0.46f;
        private const float ThreatLockMinTime = 1.05f;
        private const float StaleTargetDistance = 44.5f;

        private const BotOverlayType OverlayType = BotOverlayType.Attack;

        #endregion

        #region Fields

        private readonly BotComponentCache _cache;
        private readonly BotOwner _bot;
        private readonly BotPersonalityProfile _profile;
        private readonly ManualLogSource _logger;

        private float _nextEvalTime;
        private float _lastSwitchTime;
        private float _lastTargetUpdateTime;
        private Player _target;

        private Vector3 _lastThreatMoveIssued = Vector3.zero;
        private float _lastThreatMoveTime = -10f;

        #endregion

        #region Properties

        public Player CurrentTarget => _target;

        #endregion

        #region Constructor

        public BotThreatSelector(BotComponentCache cache)
        {
            if (cache == null || cache.Bot == null || cache.AIRefactoredBotOwner == null)
                throw new ArgumentException("[BotThreatSelector] Cache or owner null.");

            _cache = cache;
            _bot = cache.Bot;
            _profile = cache.AIRefactoredBotOwner.PersonalityProfile;
            _logger = Plugin.LoggerInstance;

            _lastThreatMoveIssued = Vector3.zero;
            _lastThreatMoveTime = -10f;
            _lastTargetUpdateTime = -10f;
        }

        #endregion

        #region Tick

        /// <summary>
        /// Evaluates and updates bot threat targeting, scoring, fallback, overlay-safe movement, and all arbitration.
        /// </summary>
        public void Tick(float time)
        {
            if (time < _nextEvalTime || _bot == null || _bot.IsDead)
                return;

            _nextEvalTime = time + EvaluateCooldown;

            var players = GameWorldHandler.GetAllAlivePlayers();
            try
            {
                if (players == null || players.Count == 0)
                    return;

                Player best = null;
                float bestScore = float.MinValue;

                for (int i = 0; i < players.Count; i++)
                {
                    Player candidate = players[i];
                    if (!EFTPlayerUtil.IsValid(candidate) || !IsProperEnemy(_bot, candidate))
                        continue;

                    float score = ScoreTarget(candidate, time);
                    if (score > bestScore)
                    {
                        best = candidate;
                        bestScore = score;
                    }
                }

                // Fallback memory recovery
                if (best == null)
                {
                    TryFallbackFromMemory(time);
                    return;
                }

                // No target yet, or target is invalid or stale
                if (_target == null || IsTargetStale(_target, time))
                {
                    SetTarget(best, time);
                    return;
                }

                float currentScore = ScoreTarget(_target, time);
                float cooldown = Mathf.Clamp(SwitchCooldown * (1f - _profile.AggressionLevel), 0.45f, 2.2f);
                // Allow switching only if new target is much better and cooldown elapsed
                if (bestScore > currentScore + SwitchThreshold && time > _lastSwitchTime + cooldown)
                {
                    SetTarget(best, time);
                }
                else
                {
                    // If current target is stale, drop and recover
                    if (IsTargetStale(_target, time, true))
                    {
                        ResetTarget();
                    }
                }
            }
            catch (Exception ex)
            {
                _logger.LogError("[BotThreatSelector] Tick failed: " + ex);
            }
            finally
            {
                TempListPool.Return(players);
            }
        }

        #endregion

        #region Scoring

        private float ScoreTarget(Player candidate, float time)
        {
            try
            {
                Vector3 pos = EFTPlayerUtil.GetPosition(candidate);
                float dist = Vector3.Distance(_bot.Position, pos);
                if (dist > MaxDistance) return float.MinValue;

                float score = MaxDistance - dist;

                if (dist < 12f)
                    score += CloseDistanceBonus;

                // Squad bonus for assisting against same target
                if (_bot.BotsGroup != null)
                {
                    int count = _bot.BotsGroup.MembersCount;
                    for (int i = 0; i < count; i++)
                    {
                        BotOwner mate = _bot.BotsGroup.Member(i);
                        if (mate != null && mate != _bot && !mate.IsDead &&
                            mate.Memory?.GoalEnemy?.Person?.ProfileId == candidate.ProfileId)
                        {
                            score += SquadAssistBonus;
                        }
                    }
                }

                // Cover assist bonus for bot targets (never Player→BotOwner cast; only check all bots)
                if (candidate.IsAI)
                {
                    var aiPlayers = GameWorldHandler.GetAllAlivePlayers();
                    try
                    {
                        for (int j = 0; j < aiPlayers.Count; j++)
                        {
                            Player p = aiPlayers[j];
                            if (!p.IsAI) continue;
                            BotOwner botOwner = p.GetComponent<BotOwner>();
                            if (botOwner == null) continue;
                            if (p.ProfileId == candidate.ProfileId)
                            {
                                if (BotNavHelper.IsNearNavMeshEdge(botOwner, 1.1f))
                                    score += CoverAssistBonus;
                                break;
                            }
                        }
                    }
                    finally
                    {
                        TempListPool.Return(aiPlayers);
                    }
                }

                EnemyInfo info = GetEnemyInfo(candidate);
                if (info != null && info.IsVisible)
                {
                    score += LineOfSightBonus;
                    if (time - info.PersonalLastSeenTime < 2.4f)
                        score += VisibleRecentBonus;
                }

                if (_cache.Suppression?.IsSuppressed() == true)
                    score -= SuppressionPenalty;
                if (_cache.PanicHandler?.IsPanicking == true)
                    score -= PanicPenalty;

                // Score reduction for far/old enemies
                if (info != null && (time - info.PersonalLastSeenTime) > ThreatStaleTime)
                    score -= 15.0f;
                if (dist > StaleTargetDistance)
                    score -= 4.0f;

                // Micro-personality randomization
                score += UnityEngine.Random.Range(-2.2f, 2.2f) * _profile.AggressionLevel;

                return score;
            }
            catch
            {
                return float.MinValue;
            }
        }

        public EnemyInfo GetEnemyInfo(Player player)
        {
            try
            {
                if (_bot?.EnemiesController?.EnemyInfos == null || player == null)
                    return null;

                foreach (var kv in _bot.EnemiesController.EnemyInfos)
                {
                    if (kv.Key is Player enemy && enemy.ProfileId == player.ProfileId)
                        return kv.Value;
                }

                if (_bot.Memory?.GoalEnemy?.Person?.ProfileId == player.ProfileId)
                    return _bot.Memory.GoalEnemy;
            }
            catch { }
            return null;
        }

        #endregion

        #region Fallback Logic

        private void TryFallbackFromMemory(float time)
        {
            try
            {
                string id = _cache?.TacticalMemory?.GetMostRecentEnemyId();
                if (string.IsNullOrEmpty(id))
                    return;

                Player fallback = EFTPlayerUtil.ResolvePlayerById(id);
                if (EFTPlayerUtil.IsValid(fallback) && IsProperEnemy(_bot, fallback))
                    SetTarget(fallback, time);
            }
            catch (Exception ex)
            {
                _logger.LogError("[BotThreatSelector] FallbackFromMemory failed: " + ex);
            }
        }

        /// <summary>
        /// Sets the current target and, if not moving, issues a deduped, arbitration-locked overlay movement.
        /// </summary>
        private void SetTarget(Player player, float time)
        {
            _target = player;
            _lastSwitchTime = time;
            _lastTargetUpdateTime = time;

            try
            {
                if (_cache.TacticalMemory != null)
                    _cache.TacticalMemory.RecordEnemyPosition(EFTPlayerUtil.GetPosition(player), "Threat", player.ProfileId);

                if (_cache.Movement != null && !_bot.Mover.IsMoving)
                {
                    if (BotNavHelper.TryGetSafeTarget(_bot, out Vector3 safePos) && IsVectorValid(safePos))
                    {
                        float now = Time.time;
                        if (BotOverlayManager.CanIssueMove(_bot, OverlayType)
                            && !BotMovementHelper.IsMovementPaused(_bot)
                            && !BotMovementHelper.IsInInteractionState(_bot)
                            && (_lastThreatMoveIssued - safePos).sqrMagnitude > OverlayMoveDedupSqr
                            && (now - _lastThreatMoveTime) > OverlayMoveCooldown
                            && !IsAnticipationActive(_bot))
                        {
                            BotOverlayManager.RegisterMove(_bot, OverlayType);
                            BotMovementHelper.SmoothMoveToSafe(_bot, safePos, false, 1f, OverlayType);
                            _lastThreatMoveIssued = safePos;
                            _lastThreatMoveTime = now;
                        }
                    }
                }

                if (_cache.GroupComms != null && UnityEngine.Random.value < 0.15f)
                    _cache.GroupComms.Say(EPhraseTrigger.FollowMe);
            }
            catch (Exception ex)
            {
                _logger.LogError("[BotThreatSelector] SetTarget failed: " + ex);
            }
        }

        public string GetTargetProfileId() => _target?.ProfileId ?? string.Empty;
        public void ResetTarget() { _target = null; _lastTargetUpdateTime = -10f; }

        #endregion

        #region Helpers

        public static bool HasActiveThreat(BotThreatSelector selector)
        {
            return selector != null && selector.CurrentTarget != null;
        }

        public static bool HasActiveVisibleThreat(BotThreatSelector selector, float maxLastSeen = 2.5f)
        {
            if (selector == null) return false;
            var target = selector.CurrentTarget;
            if (target == null) return false;
            var info = selector.GetEnemyInfo(target);
            if (info == null) return false;
            return info.IsVisible || (Time.time - info.PersonalLastSeenTime) < maxLastSeen;
        }

        private static bool IsProperEnemy(BotOwner self, Player candidate)
        {
            if (self == null || candidate == null || candidate.ProfileId == self.ProfileId)
                return false;

            EPlayerSide selfSide = self.GetPlayer?.Side ?? EPlayerSide.Savage;
            EPlayerSide otherSide = candidate.Side;

            if (selfSide != otherSide)
                return true;

            string selfGroup = self.GetPlayer?.Profile?.Info?.GroupId ?? "";
            string otherGroup = candidate.Profile?.Info?.GroupId ?? "";

            return selfGroup != otherGroup;
        }

        private static bool IsVectorValid(Vector3 v)
        {
            return !float.IsNaN(v.x) && !float.IsNaN(v.y) && !float.IsNaN(v.z) &&
                   Mathf.Abs(v.x) < 10000f && Mathf.Abs(v.y) < 10000f && Mathf.Abs(v.z) < 10000f;
        }

        /// <summary>
        /// Returns true if any anticipation/fakeout overlay or arbitration lock is currently active for this bot.
        /// Includes overlay arbitration, panic/suppression anticipation, squad anticipation, or recent fakeout memory.
        /// </summary>
        private static bool IsAnticipationActive(BotOwner bot)
        {
            if (bot == null)
                return false;

            // Overlay arbitration: anticipation overlays
            if (BotOverlayManager.HasActiveOverlay(bot, BotOverlayType.Anticipation))
                return true;

            // Squad anticipation lock
            var group = bot.BotsGroup;
            if (group != null && group.MembersCount > 1)
            {
                for (int i = 0; i < group.MembersCount; i++)
                {
                    var mate = group.Member(i);
                    if (mate != null && mate != bot && !mate.IsDead)
                    {
                        if (BotOverlayManager.HasActiveOverlay(mate, BotOverlayType.Anticipation))
                            return true;
                    }
                }
            }

            // Panic and suppression anticipation: via arbitration lock or anticipation property
            BotComponentCache cache = BotComponentCacheRegistry.TryGetExisting(bot);
            if (cache != null)
            {
                if (cache.PanicHandler != null && cache.PanicHandler.IsAnticipationLocked)
                    return true;
                if (cache.Suppression != null && cache.Suppression.AnticipationLockActive)
                    return true;
            }

            // Tactical memory: recent anticipation/fakeout event (if your tactical memory supports it)
            if (cache != null && cache.TacticalMemory != null)
            {
                // Example: if tactical memory implements anticipation/fakeout events:
                // if (cache.TacticalMemory.HasRecentAnticipationEvent())
                //     return true;
            }

            return false;
        }

        private bool IsTargetStale(Player player, float time, bool strict = false)
        {
            if (player == null || player.HealthController == null || player.HealthController.IsAlive == false)
                return true;

            float dist = Vector3.Distance(_bot.Position, EFTPlayerUtil.GetPosition(player));
            if (dist > MaxDistance) return true;

            EnemyInfo info = GetEnemyInfo(player);
            if (info == null) return true;

            if (strict)
            {
                // Stricter: lost visual + long since last seen + far away
                if (!info.IsVisible && (time - info.PersonalLastSeenTime) > (ThreatStaleTime * 0.7f) && dist > StaleTargetDistance)
                    return true;
            }
            else
            {
                // Looser: dead, unreachable, or not visible in a while
                if (!info.IsVisible && (time - info.PersonalLastSeenTime) > ThreatStaleTime)
                    return true;
            }
            return false;
        }

        #endregion
    }
}
