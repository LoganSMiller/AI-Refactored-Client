// <auto-generated>
//   AI-Refactored: BotThreatSelector.cs (Supreme Arbitration Overlay/Event, Beyond Diamond Ultra-Realism, June 2025, Max Feature, EFT/AI-Refactored Safe)
//   Arbitration/event-only, squad/cover/tactical/memory/anticipation aware. Full pooling, error isolation, triple-guarded. No disables, teleports, or parallel overlays. SPT/FIKA/headless/client safe.
//   MIT License.
// </auto-generated>

namespace AIRefactored.AI.Combat
{
    using System;
    using System.Collections.Generic;
    using AIRefactored.AI.Core;
    using AIRefactored.AI.Helpers;
    using AIRefactored.AI.Memory;
    using AIRefactored.AI.Navigation;
    using AIRefactored.Core;
    using AIRefactored.Pools;
    using BepInEx.Logging;
    using EFT;
    using UnityEngine;

    /// <summary>
    /// Selects and prioritizes threats using live perception, tactical memory, squad overlays, suppression, and full anticipation/cover context.
    /// Arbitration/event-only, bulletproof, squad and memory-aware, pooled, and fully safe in all SPT/FIKA/headless/client environments.
    /// </summary>
    public sealed class BotThreatSelector
    {
        #region Constants

        private const float EvaluateCooldown = 0.29f;
        private const float MaxDistance = 120f;
        private const float SwitchCooldown = 2.18f;
        private const float SwitchThreshold = 11.2f;
        private const float ThreatStaleTime = 9.3f;
        private const float SquadAssistBonus = 13.5f;
        private const float CloseDistanceBonus = 15f;
        private const float LineOfSightBonus = 21.2f;
        private const float VisibleRecentBonus = 9.8f;
        private const float SuppressionPenalty = 13.7f;
        private const float PanicPenalty = 22f;
        private const float CoverAssistBonus = 7.4f;
        private const float OverlayMoveDedupSqr = 0.00009f;
        private const float OverlayMoveCooldown = 0.39f;
        private const float StaleTargetDistance = 42.3f;
        private const float VoiceChance = 0.16f;

        private const BotOverlayType OverlayType = BotOverlayType.Attack;

        #endregion

        #region Fields

        private readonly BotComponentCache _cache;
        private readonly BotOwner _bot;
        private readonly BotPersonalityProfile _profile;
        private readonly ManualLogSource _logger;

        private float _nextEvalTime;
        private float _lastSwitchTime;
        private float _lastTargetUpdateTime;
        private Player _target;

        private Vector3 _lastThreatMoveIssued = Vector3.zero;
        private float _lastThreatMoveTime = -10f;

        private bool _hasFiredMemoryFallback;

        #endregion

        #region Properties

        public Player CurrentTarget => _target;

        #endregion

        #region Constructor

        public BotThreatSelector(BotComponentCache cache)
        {
            if (cache == null || cache.Bot == null || cache.AIRefactoredBotOwner == null)
                throw new ArgumentException("[BotThreatSelector] Cache or owner null.");

            _cache = cache;
            _bot = cache.Bot;
            _profile = cache.AIRefactoredBotOwner.PersonalityProfile;
            _logger = Plugin.LoggerInstance;

            _lastThreatMoveIssued = Vector3.zero;
            _lastThreatMoveTime = -10f;
            _lastTargetUpdateTime = -10f;
            _hasFiredMemoryFallback = false;
        }

        #endregion

        #region Tick

        /// <summary>
        /// Evaluates and updates bot threat targeting, scoring, fallback, overlay-safe movement, and all arbitration.
        /// </summary>
        public void Tick(float time)
        {
            if (time < _nextEvalTime || _bot == null || _bot.IsDead)
                return;

            _nextEvalTime = time + EvaluateCooldown;

            var players = GameWorldHandler.GetAllAlivePlayers();
            try
            {
                if (players == null || players.Count == 0)
                    return;

                Player best = null;
                float bestScore = float.MinValue;

                // Score all living enemies with full pooling
                for (int i = 0; i < players.Count; i++)
                {
                    Player candidate = players[i];
                    if (!EFTPlayerUtil.IsValid(candidate) || !IsProperEnemy(_bot, candidate))
                        continue;

                    float score = ScoreTarget(candidate, time);
                    if (score > bestScore)
                    {
                        best = candidate;
                        bestScore = score;
                    }
                }

                // Fallback to memory if no visible or scored threat
                if (best == null)
                {
                    TryFallbackFromMemory(time);
                    return;
                }
                _hasFiredMemoryFallback = false;

                // Switch targets if necessary or current is stale/invalid
                if (_target == null || IsTargetStale(_target, time))
                {
                    SetTarget(best, time);
                    return;
                }

                float currentScore = ScoreTarget(_target, time);
                float cooldown = Mathf.Clamp(SwitchCooldown * (1f - _profile.AggressionLevel), 0.4f, 2.2f);
                if (bestScore > currentScore + SwitchThreshold && time > _lastSwitchTime + cooldown)
                {
                    SetTarget(best, time);
                }
                else if (IsTargetStale(_target, time, true))
                {
                    ResetTarget();
                }
            }
            catch (Exception ex)
            {
                _logger.LogError("[BotThreatSelector] Tick failed: " + ex);
            }
            finally
            {
                TempListPool.Return(players);
            }
        }

        #endregion

        #region Scoring

        private float ScoreTarget(Player candidate, float time)
        {
            try
            {
                Vector3 pos = EFTPlayerUtil.GetPosition(candidate);
                float dist = Vector3.Distance(_bot.Position, pos);
                if (dist > MaxDistance) return float.MinValue;

                float score = MaxDistance - dist;

                if (dist < 11f)
                    score += CloseDistanceBonus;

                // Squad assist bonus
                if (_bot.BotsGroup != null)
                {
                    int count = _bot.BotsGroup.MembersCount;
                    for (int i = 0; i < count; i++)
                    {
                        BotOwner mate = _bot.BotsGroup.Member(i);
                        if (mate != null && mate != _bot && !mate.IsDead &&
                            mate.Memory?.GoalEnemy?.Person?.ProfileId == candidate.ProfileId)
                        {
                            score += SquadAssistBonus;
                        }
                    }
                }

                // Cover assist bonus for bots near edge
                if (candidate.IsAI)
                {
                    var aiPlayers = GameWorldHandler.GetAllAlivePlayers();
                    try
                    {
                        for (int j = 0; j < aiPlayers.Count; j++)
                        {
                            Player p = aiPlayers[j];
                            if (!p.IsAI) continue;
                            BotOwner botOwner = p.GetComponent<BotOwner>();
                            if (botOwner == null) continue;
                            if (p.ProfileId == candidate.ProfileId)
                            {
                                if (BotNavHelper.IsNearNavMeshEdge(botOwner, 1.2f))
                                    score += CoverAssistBonus;
                                break;
                            }
                        }
                    }
                    finally
                    {
                        TempListPool.Return(aiPlayers);
                    }
                }

                // Visibility and anticipation bonuses
                EnemyInfo info = GetEnemyInfo(candidate);
                if (info != null && info.IsVisible)
                {
                    score += LineOfSightBonus;
                    if (time - info.PersonalLastSeenTime < 2.0f)
                        score += VisibleRecentBonus;
                }

                // Suppression/panic penalties
                if (_cache.Suppression?.IsSuppressed() == true)
                    score -= SuppressionPenalty;
                if (_cache.PanicHandler?.IsPanicking == true)
                    score -= PanicPenalty;

                // Staleness penalties
                if (info != null && (time - info.PersonalLastSeenTime) > ThreatStaleTime)
                    score -= 14.0f;
                if (dist > StaleTargetDistance)
                    score -= 5.2f;

                // Dynamic personality micro-randomization (mimics subtle human bias)
                score += UnityEngine.Random.Range(-2.6f, 2.6f) * _profile.AggressionLevel;

                return score;
            }
            catch
            {
                return float.MinValue;
            }
        }

        public EnemyInfo GetEnemyInfo(Player player)
        {
            try
            {
                if (_bot?.EnemiesController?.EnemyInfos == null || player == null)
                    return null;

                foreach (var kv in _bot.EnemiesController.EnemyInfos)
                {
                    if (kv.Key is Player enemy && enemy.ProfileId == player.ProfileId)
                        return kv.Value;
                }
                if (_bot.Memory?.GoalEnemy?.Person?.ProfileId == player.ProfileId)
                    return _bot.Memory.GoalEnemy;
            }
            catch { }
            return null;
        }

        #endregion

        #region Fallback Logic

        private void TryFallbackFromMemory(float time)
        {
            // Prevent spamming fallback every frame.
            if (_hasFiredMemoryFallback) return;

            try
            {
                string id = _cache?.TacticalMemory?.GetMostRecentEnemyId();
                if (string.IsNullOrEmpty(id)) return;

                Player fallback = EFTPlayerUtil.ResolvePlayerById(id);
                if (EFTPlayerUtil.IsValid(fallback) && IsProperEnemy(_bot, fallback))
                    SetTarget(fallback, time);

                _hasFiredMemoryFallback = true;
            }
            catch (Exception ex)
            {
                _logger.LogError("[BotThreatSelector] FallbackFromMemory failed: " + ex);
            }
        }

        /// <summary>
        /// Sets the current target and, if not moving, issues arbitration/deduped overlay intent.
        /// </summary>
        private void SetTarget(Player player, float time)
        {
            _target = player;
            _lastSwitchTime = time;
            _lastTargetUpdateTime = time;

            try
            {
                // Record memory/awareness for tactical overlays
                _cache.TacticalMemory?.RecordEnemyPosition(EFTPlayerUtil.GetPosition(player), "Threat", player.ProfileId);

                // Arbitration overlay movement intent (never direct, pooled, deduped)
                if (_cache.Movement != null && !_bot.Mover.IsMoving)
                {
                    if (BotNavHelper.TryGetSafeTarget(_bot, out Vector3 safePos) && IsVectorValid(safePos))
                    {
                        float now = Time.time;
                        if (BotOverlayManager.CanIssueMove(_bot, OverlayType)
                            && !BotMovementHelper.IsMovementPaused(_bot)
                            && !BotMovementHelper.IsInInteractionState(_bot)
                            && (_lastThreatMoveIssued - safePos).sqrMagnitude > OverlayMoveDedupSqr
                            && (now - _lastThreatMoveTime) > OverlayMoveCooldown
                            && !IsAnticipationActive(_bot))
                        {
                            BotOverlayManager.RegisterMove(_bot, OverlayType);
                            BotMovementHelper.SmoothMoveToSafe(_bot, safePos, false, _cache?.PersonalityProfile?.Cohesion ?? 1f, OverlayType);
                            _lastThreatMoveIssued = safePos;
                            _lastThreatMoveTime = now;
                        }
                    }
                }

                // Squad comms: randomized, never spammed
                if (_cache.GroupComms != null && UnityEngine.Random.value < VoiceChance)
                    _cache.GroupComms.Say(EPhraseTrigger.FollowMe);
            }
            catch (Exception ex)
            {
                _logger.LogError("[BotThreatSelector] SetTarget failed: " + ex);
            }
        }

        public string GetTargetProfileId() => _target?.ProfileId ?? string.Empty;
        public void ResetTarget() { _target = null; _lastTargetUpdateTime = -10f; }

        #endregion

        #region Helpers

        public static bool HasActiveThreat(BotThreatSelector selector)
        {
            return selector != null && selector.CurrentTarget != null;
        }

        public static bool HasActiveVisibleThreat(BotThreatSelector selector, float maxLastSeen = 2.5f)
        {
            if (selector == null) return false;
            var target = selector.CurrentTarget;
            if (target == null) return false;
            var info = selector.GetEnemyInfo(target);
            if (info == null) return false;
            return info.IsVisible || (Time.time - info.PersonalLastSeenTime) < maxLastSeen;
        }

        /// <summary>
        /// EFT/AI-Refactored canonical enemy: not same profile, not same group, side-aware, SPT/FIKA safe.
        /// </summary>
        private static bool IsProperEnemy(BotOwner self, Player candidate)
        {
            if (self == null || candidate == null || candidate.ProfileId == self.ProfileId)
                return false;

            EPlayerSide selfSide = self.GetPlayer?.Side ?? EPlayerSide.Savage;
            EPlayerSide otherSide = candidate.Side;
            if (selfSide != otherSide)
                return true;

            string selfGroup = self.GetPlayer?.Profile?.Info?.GroupId ?? "";
            string otherGroup = candidate.Profile?.Info?.GroupId ?? "";
            return selfGroup != otherGroup;
        }

        private static bool IsVectorValid(Vector3 v)
        {
            return !float.IsNaN(v.x) && !float.IsNaN(v.y) && !float.IsNaN(v.z) &&
                   Mathf.Abs(v.x) < 10000f && Mathf.Abs(v.y) < 10000f && Mathf.Abs(v.z) < 10000f;
        }

        /// <summary>
        /// True if anticipation/fakeout overlays or arbitration locks are active for this bot or squad.
        /// </summary>
        private static bool IsAnticipationActive(BotOwner bot)
        {
            if (bot == null)
                return false;

            // Arbitration overlays
            if (BotOverlayManager.HasActiveOverlay(bot, BotOverlayType.Anticipation))
                return true;

            // Squad anticipation locks
            var group = bot.BotsGroup;
            if (group != null && group.MembersCount > 1)
            {
                for (int i = 0; i < group.MembersCount; i++)
                {
                    var mate = group.Member(i);
                    if (mate != null && mate != bot && !mate.IsDead)
                    {
                        if (BotOverlayManager.HasActiveOverlay(mate, BotOverlayType.Anticipation))
                            return true;
                    }
                }
            }

            // Panic/suppression anticipation
            BotComponentCache cache = BotComponentCacheRegistry.TryGetExisting(bot);
            if (cache != null)
            {
                if (cache.PanicHandler != null && cache.PanicHandler.IsAnticipationLocked)
                    return true;
                if (cache.Suppression != null && cache.Suppression.AnticipationLockActive)
                    return true;
            }

            // Tactical memory (expandable for fakeout/anticipation events)
            if (cache != null && cache.TacticalMemory != null)
            {
                // if (cache.TacticalMemory.HasRecentAnticipationEvent()) return true;
            }

            return false;
        }

        private bool IsTargetStale(Player player, float time, bool strict = false)
        {
            if (player == null || player.HealthController == null || player.HealthController.IsAlive == false)
                return true;

            float dist = Vector3.Distance(_bot.Position, EFTPlayerUtil.GetPosition(player));
            if (dist > MaxDistance) return true;

            EnemyInfo info = GetEnemyInfo(player);
            if (info == null) return true;

            if (strict)
            {
                if (!info.IsVisible && (time - info.PersonalLastSeenTime) > (ThreatStaleTime * 0.7f) && dist > StaleTargetDistance)
                    return true;
            }
            else
            {
                if (!info.IsVisible && (time - info.PersonalLastSeenTime) > ThreatStaleTime)
                    return true;
            }
            return false;
        }

        #endregion
    }
}
