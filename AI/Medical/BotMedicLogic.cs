// <auto-generated>
//   AI-Refactored: BotMedicLogic.cs (Ultra-Platinum++, Supreme Arbitration Overlay Edition, Max Realism, Max Logic, June 2025)
//   Arbitration/event overlay only. Squad-first, self-second. Bulletproof, squad-aware, overlay-driven, multiplayer/headless safe. No disables, leaks, or tick/coroutine spam.
//   MIT License.
// </auto-generated>

namespace AIRefactored.AI.Medical
{
    using System;
    using AIRefactored.AI.Core;
    using AIRefactored.Core;
    using BepInEx.Logging;
    using EFT;
    using EFT.HealthSystem;
    using UnityEngine;

    /// <summary>
    /// Controls bot healing: squad-first (using real EFT HealAsk/IsInProcess), then self. Arbitration/event overlays only.
    /// </summary>
    public sealed class BotMedicLogic
    {
        #region Constants

        private const float HealCheckInterval = 1.55f;
        private const float HealSquadRange = 4f;
        private static readonly float HealSquadRangeSqr = HealSquadRange * HealSquadRange;
        private const float VoiceCooldown = 5.9f;
        private const float ArbitrationWindow = 0.21f;

        #endregion

        #region Fields

        private static readonly ManualLogSource Logger = Plugin.LoggerInstance;
        private readonly BotComponentCache _cache;
        private readonly BotInjurySystem _injurySystem;
        private readonly BotOwner _bot;
        private BotMedecine _med;

        private float _nextHealCheck;
        private float _lastVoiceTime;
        private float _lastArbTime;
        private bool _isHealing;
        private bool _isActive = true;

        #endregion

        #region Construction

        public BotMedicLogic(BotComponentCache cache, BotInjurySystem injurySystem)
        {
            if (cache == null || injurySystem == null || cache.Bot == null)
            {
                _isActive = false;
                Logger.LogError("[BotMedicLogic] Initialization failed: cache, injury system, or bot is null. Disabling medic logic for this bot.");
                return;
            }

            _cache = cache;
            _injurySystem = injurySystem;
            _bot = cache.Bot;
            _nextHealCheck = Time.time;
            _lastVoiceTime = -99f;
            _lastArbTime = -99f;

            try
            {
                _med = _bot.Medecine ?? new BotMedecine(_bot);

                if (_bot.HealAnotherTarget == null)
                    _bot.HealAnotherTarget = new BotHealAnotherTarget(_bot);
                _bot.HealAnotherTarget.OnHealAsked -= OnHealAsked;
                _bot.HealAnotherTarget.OnHealAsked += OnHealAsked;

                if (_bot.HealingBySomebody == null)
                    _bot.HealingBySomebody = new BotHealingBySomebody(_bot);

                SubscribeToFirstAid();
            }
            catch (Exception ex)
            {
                _isActive = false;
                Logger.LogError($"[BotMedicLogic] Constructor failed: {ex}. Disabling medic logic for this bot.");
            }
        }

        #endregion

        #region Public API

        public void Reset()
        {
            if (!_isActive) return;
            try
            {
                _isHealing = false;
                _injurySystem.Reset();
                UnsubscribeFromFirstAid();
            }
            catch (Exception ex)
            {
                _isActive = false;
                Logger.LogError($"[BotMedicLogic] Reset() failed: {ex}. Disabling medic logic for this bot.");
            }
        }

        /// <summary>
        /// Arbitration/event-driven main entry for bot medical logic (call via BotBrain tick).
        /// </summary>
        public void OverlayHealIfReady(float now)
        {
            if (!_isActive || _isHealing || now < _nextHealCheck)
                return;

            try
            {
                if (!EFTPlayerUtil.IsValidBotOwner(_bot) || _cache.PanicHandler?.IsPanicking == true)
                    return;

                if (!BotOverlayManager.CanIssueMove(_bot, BotOverlayType.Medical))
                    return;
                if (now - _lastArbTime < ArbitrationWindow)
                    return;

                if (_bot.HealAnotherTarget != null && _bot.HealAnotherTarget.IsInProcess)
                    return;

                _nextHealCheck = now + HealCheckInterval + UnityEngine.Random.Range(0f, 0.77f);
                _lastArbTime = now;

                if (TryHealSquadmate(now))
                {
                    BotOverlayManager.RegisterMove(_bot, BotOverlayType.Medical);
                    return;
                }

                // Fallback: self heal via injury system (handles overlays/triage)
                _injurySystem.Tick(0f, now);
            }
            catch (Exception ex)
            {
                _isActive = false;
                Logger.LogError($"[BotMedicLogic] OverlayHealIfReady() failed: {ex}. Disabling medic logic for this bot.");
            }
        }

        #endregion

        #region Healing Logic

        private bool TryHealSquadmate(float now)
        {
            try
            {
                if (_bot.BotsGroup == null)
                    return false;

                Player self = EFTPlayerUtil.ResolvePlayer(_bot);
                if (!EFTPlayerUtil.IsValidGroupPlayer(self))
                    return false;

                Vector3 selfPos = EFTPlayerUtil.GetPosition(self);
                int count = _bot.BotsGroup.MembersCount;

                for (int i = 0; i < count; i++)
                {
                    BotOwner mate = _bot.BotsGroup.Member(i);
                    if (!EFTPlayerUtil.IsValidBotOwner(mate) || mate == _bot)
                        continue;

                    Player target = EFTPlayerUtil.ResolvePlayer(mate);
                    if (!EFTPlayerUtil.IsValidGroupPlayer(target))
                        continue;

                    Vector3 targetPos = EFTPlayerUtil.GetPosition(target);
                    float distSqr = (targetPos.x - selfPos.x) * (targetPos.x - selfPos.x) + (targetPos.z - selfPos.z) * (targetPos.z - selfPos.z);
                    if (distSqr > HealSquadRangeSqr) continue;

                    IHealthController health = target.HealthController;
                    if (health != null && health.IsAlive)
                    {
                        foreach (EBodyPart part in Enum.GetValues(typeof(EBodyPart)))
                        {
                            var hp = health.GetBodyPartHealth(part);
                            if (hp.Maximum > 0f && hp.Current < hp.Maximum)
                            {
                                if (_bot.HealAnotherTarget != null && !_bot.HealAnotherTarget.IsInProcess)
                                {
                                    IPlayer iTarget = EFTPlayerUtil.AsSafeIPlayer(target);
                                    if (iTarget != null)
                                    {
                                        _bot.HealAnotherTarget.HealAsk(iTarget); // Real EFT: this fires OnHealAsked event
                                        TrySay(EPhraseTrigger.Cooperation, now);
                                        _isHealing = true;
                                        return true;
                                    }
                                }
                            }
                        }
                    }
                }
            }
            catch (Exception ex)
            {
                Logger.LogError($"[BotMedicLogic] TryHealSquadmate() failed: {ex}");
            }
            return false;
        }

        #endregion

        #region Callbacks

        private void OnHealAsked(IPlayer target)
        {
            try
            {
                _isHealing = true;
                TrySay(EPhraseTrigger.StartHeal, Time.time);
                SubscribeToFirstAid();
            }
            catch (Exception ex)
            {
                Logger.LogError($"[BotMedicLogic] OnHealAsked() failed: {ex}");
            }
        }

        private void OnFirstAidComplete(BotOwner _)
        {
            try
            {
                _isHealing = false;
                _injurySystem.Reset();
                UnsubscribeFromFirstAid();
            }
            catch (Exception ex)
            {
                Logger.LogError($"[BotMedicLogic] OnFirstAidComplete() failed: {ex}");
            }
        }

        #endregion

        #region Utilities

        private void TrySay(EPhraseTrigger trigger, float now)
        {
            try
            {
                if (_bot.BotTalk != null && now - _lastVoiceTime > VoiceCooldown)
                {
                    _bot.BotTalk.TrySay(trigger);
                    _lastVoiceTime = now;
                }
            }
            catch (Exception ex)
            {
                Logger.LogError($"[BotMedicLogic] TrySay() failed: {ex}");
            }
        }

        private void SubscribeToFirstAid()
        {
            try
            {
                if (_med != null && _med.FirstAid is BotFirstAidClass fa)
                {
                    fa.OnEndApply -= OnFirstAidComplete;
                    fa.OnEndApply += OnFirstAidComplete;
                }
            }
            catch (Exception ex)
            {
                Logger.LogError($"[BotMedicLogic] SubscribeToFirstAid() failed: {ex}");
            }
        }

        private void UnsubscribeFromFirstAid()
        {
            try
            {
                if (_med != null && _med.FirstAid is BotFirstAidClass fa)
                {
                    fa.OnEndApply -= OnFirstAidComplete;
                }
            }
            catch (Exception ex)
            {
                Logger.LogError($"[BotMedicLogic] UnsubscribeFromFirstAid() failed: {ex}");
            }
        }

        #endregion
    }
}
