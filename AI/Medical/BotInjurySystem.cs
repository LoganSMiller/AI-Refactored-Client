// <auto-generated>
//   This file is part of AI-Refactored, an open-source project focused on realistic AI behavior in Escape from Tarkov.
//   Licensed under the MIT License. See LICENSE in the repository root for more information.
//
//   THIS FILE IS SYSTEMATICALLY MANAGED.
//   Please follow strict StyleCop, ReSharper, and AI-Refactored code standards for all modifications.
// </auto-generated>

#nullable enable

namespace AIRefactored.AI.Medical
{
    using System;
    using AIRefactored.AI.Core;
    using AIRefactored.Runtime;
    using BepInEx.Logging;
    using EFT;
    using EFT.HealthSystem;
    using UnityEngine;

    /// <summary>
    /// Manages bot injuries, healing behavior, and surgical procedures on destroyed limbs.
    /// Prioritizes realistic timing, cover safety, and cooldown between medical actions.
    /// </summary>
    public sealed class BotInjurySystem
    {
        private const float HealCooldown = 6f;

        private static readonly ManualLogSource Logger = AIRefactoredController.Logger;

        private readonly BotComponentCache _cache;

        private bool _hasBlackLimb;
        private EBodyPart? _injuredLimb;
        private float _lastHitTime;
        private float _nextHealTime;

        /// <summary>
        /// Initializes a new instance of the <see cref="BotInjurySystem"/> class.
        /// </summary>
        /// <param name="cache">Bot component cache.</param>
        public BotInjurySystem(BotComponentCache cache)
        {
            this._cache = cache ?? throw new ArgumentNullException(nameof(cache));
        }

        /// <summary>
        /// Called when the bot is damaged. Tracks cooldown and injury flags.
        /// </summary>
        /// <param name="part">Damaged body part.</param>
        /// <param name="damage">Amount of damage.</param>
        public void OnHit(EBodyPart part, float damage)
        {
            this._lastHitTime = Time.time;
            this._nextHealTime = this._lastHitTime + HealCooldown;
            this._injuredLimb = part;

            BotOwner? bot = this._cache.Bot;
            Player? player = bot?.GetPlayer;
            IHealthController? health = player?.HealthController;

            this._hasBlackLimb = health != null && health.IsBodyPartDestroyed(part);
        }

        /// <summary>
        /// Resets internal healing state.
        /// </summary>
        public void Reset()
        {
            this._injuredLimb = null;
            this._hasBlackLimb = false;
        }

        /// <summary>
        /// Determines whether the bot should heal this frame.
        /// </summary>
        /// <returns>True if healing should occur.</returns>
        public bool ShouldHeal()
        {
            return this.ShouldHeal(Time.time);
        }

        /// <summary>
        /// Determines whether the bot should heal at the given time.
        /// </summary>
        /// <param name="time">The current time.</param>
        /// <returns>True if healing should occur.</returns>
        public bool ShouldHeal(float time)
        {
            if (!this._injuredLimb.HasValue || !this._hasBlackLimb)
            {
                return false;
            }

            if (time < this._nextHealTime)
            {
                return false;
            }

            if (this._cache.PanicHandler?.IsPanicking == true)
            {
                return false;
            }

            if (this._cache.Combat?.IsInCombatState() == true)
            {
                return false;
            }

            return true;
        }

        /// <summary>
        /// Executes healing behavior if conditions are met.
        /// </summary>
        /// <param name="time">Current time for cooldown logic.</param>
        public void Tick(float time)
        {
            if (this.ShouldHeal(time))
            {
                this.TryUseMedicine();
            }
        }

        private void TryUseMedicine()
        {
            BotOwner? bot = this._cache.Bot;
            if (bot == null || bot.IsDead || !this._injuredLimb.HasValue)
            {
                return;
            }

            Player? player = bot.GetPlayer;
            IHealthController? health = player?.HealthController;
            if (player == null || health == null || !health.IsBodyPartDestroyed(this._injuredLimb.Value))
            {
                return;
            }

            GClass473? surgical = bot.Medecine?.SurgicalKit as GClass473;
            if (surgical == null || !surgical.HaveWork || !surgical.ShallStartUse())
            {
                return;
            }

            bot.Sprint(false);
            bot.WeaponManager?.Selector?.TakePrevWeapon();
            bot.BotTalk?.Say(EPhraseTrigger.StartHeal);

            surgical.ApplyToCurrentPart();
            this.Reset();

            Logger.LogDebug($"[BotInjurySystem] 🛠 {bot.Profile?.Info?.Nickname ?? "Unknown"} applied surgery to {this._injuredLimb.Value}");
        }
    }
}
