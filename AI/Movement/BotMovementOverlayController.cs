// <auto-generated>
//   AI-Refactored: BotMovementOverlayController.cs (Final Overlay-Only, Ultimate Realism, June 2025)
//   Consumes BotMovementTrajectoryPlanner output, issues NavMesh-safe moves via BotMovementHelper.
//   Never tick-moves, never oscillates, never issues a move except on genuine intent/path change.
//   All logic deduped/cooldown-guarded, overlay-only, pooled, squad/personality aware.
//   MIT License.
// </auto-generated>

namespace AIRefactored.AI.Movement
{
    using System;
    using AIRefactored.AI.Core;
    using AIRefactored.AI.Helpers;
    using AIRefactored.Core;
    using EFT;
    using UnityEngine;
    using UnityEngine.AI;

    /// <summary>
    /// Overlay/event-only controller. Consumes BotMovementTrajectoryPlanner intent vector and issues deduped, cooldown-gated moves.
    /// Never tick-moves or issues spam/oscillation. All moves are NavMesh/personality/squad safe, event-only.
    /// </summary>
    public sealed class BotMovementOverlayController
    {
        private readonly BotOwner _bot;
        private readonly BotComponentCache _cache;
        private readonly BotMoveCache _moveCache;
        private readonly BotMovementTrajectoryPlanner _planner;


        // Raise step, cooldown, and deduplication to be absolutely robust
        private const float StepDistance = 3.0f;
        private const float MoveCooldown = 1.2f;
        private const float MinDeltaSqr = 0.25f;

        public BotMovementOverlayController(BotComponentCache cache)
        {
            if (cache == null || cache.Bot == null)
                throw new ArgumentException("Invalid BotMovementOverlayController initialization.");

            _cache = cache;
            _bot = cache.Bot;
            _moveCache = cache.MoveCache ?? new BotMoveCache();
            _planner = new BotMovementTrajectoryPlanner(_bot, _cache);
        }

        /// <summary>
        /// Called by BotBrain tick with deltaTime. Only issues move if intent genuinely changed and cooldown has elapsed.
        /// </summary>
        public void Tick(float deltaTime)
        {
            try
            {
                if (_bot == null || _bot.IsDead || _bot.Mover == null || _bot.Transform == null)
                    return;

                float now = Time.time;

                // Get move intent only from mission or planner. NO move if not a true intent change.
                Vector3 desiredDir = _cache.MissionEvaluator?.GetCurrentIntentDirection() ?? Vector3.zero;
                if (desiredDir.sqrMagnitude < 0.001f)
                    return;

                Vector3 plannedDir = _planner.ModifyTrajectory(desiredDir, deltaTime);
                if (plannedDir.sqrMagnitude < 0.001f)
                    return;

                Vector3 candidateTarget = _bot.Position + plannedDir.normalized * StepDistance;

                // NavMesh-validate the move
                if (!NavMesh.SamplePosition(candidateTarget, out NavMeshHit hit, 1.2f, NavMesh.AllAreas))
                    return;
                Vector3 navTarget = hit.position;

                // Dedupe and cooldown: Only issue move if it's a new target or cooldown elapsed
                bool cooldownReady = (now - _moveCache.LastMoveTime) > MoveCooldown;
                bool targetNew = (_moveCache.LastIssuedTarget - navTarget).sqrMagnitude > MinDeltaSqr;
                if (cooldownReady || targetNew)
                {
                    _moveCache.LastIssuedTarget = navTarget;
                    _moveCache.LastMoveTime = now;
                    BotMovementHelper.SmoothMoveToSafe(_bot, navTarget, slow: false, cohesion: 1f);
                }
            }
            catch (Exception ex)
            {
                Plugin.LoggerInstance.LogError("[BotMovementOverlayController] Tick failed: " + ex);
            }
        }
    }
}
