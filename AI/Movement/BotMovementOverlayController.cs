// <auto-generated>
//   AI-Refactored: BotMovementOverlayController.cs (Ultra-Platinum Overlay/Event-Only, Max Realism/EFT-Safe, June 2025)
//   Overlay/event-only. Never issues move/path/NavMesh commands. All overlays must be supported by EFT's BotOwner/BifacialTransform APIs.
//   Overlays: anticipation pose, micro-jitter (root rotation), idle lean, idle scan/look—no movement, no forbidden anim logic.
//   Hardened: error-shielded, pooled, multiplayer/headless parity, EFT-rooted, never disables/breaks core logic.
//   MIT License.
// </auto-generated>

namespace AIRefactored.AI.Movement
{
    using System;
    using AIRefactored.AI.Core;
    using AIRefactored.Core;
    using EFT;
    using UnityEngine;

    /// <summary>
    /// Overlay/event-only controller for all pose/anticipation/micro-jitter overlays.
    /// Never issues move/path/navmesh commands—only overlays affecting pose, root rotation, tilt, and look.
    /// Bulletproof: error-shielded, pooled, multiplayer/headless parity, strictly EFT-safe logic.
    /// </summary>
    public sealed class BotMovementOverlayController
    {
        private readonly BotOwner _bot;
        private readonly BotComponentCache _cache;

        // Overlay state
        private float _nextAnticipationCheck;
        private bool _inAnticipationPose;
        private float _lastAnticipationTime;

        private float _nextMicroJitterTime;
        private float _lastMicroYaw;

        private float _nextIdleLeanTime;
        private BotTiltType _idleLean;

        private float _nextIdleScanTime;
        private Vector3 _lastIdleScanTarget;
        private float _idleScanLerpT;
        private float _lastErrorLogTime;

        // Overlay timing/constants
        private const float AnticipationCooldownMin = 1.7f, AnticipationCooldownMax = 3.6f;
        private const float AnticipationPoseDuration = 0.75f;
        private const float MicroJitterIntervalMin = 1.2f, MicroJitterIntervalMax = 2.6f;
        private const float MicroJitterYawMax = 7.0f;
        private const float IdleLeanIntervalMin = 2.3f, IdleLeanIntervalMax = 5.2f;
        private const float IdleScanIntervalMin = 1.6f, IdleScanIntervalMax = 3.5f;
        private const float IdleScanAngleMax = 33.0f;

        /// <summary>
        /// Constructs an overlay-only movement controller. Never issues move/path/nav.
        /// </summary>
        public BotMovementOverlayController(BotComponentCache cache)
        {
            if (cache == null || cache.Bot == null)
                throw new ArgumentException("Invalid BotMovementOverlayController initialization.");

            _cache = cache;
            _bot = cache.Bot;

            var now = Time.time;
            _nextAnticipationCheck = now + UnityEngine.Random.Range(AnticipationCooldownMin, AnticipationCooldownMax);
            _nextMicroJitterTime = now + UnityEngine.Random.Range(MicroJitterIntervalMin, MicroJitterIntervalMax);
            _nextIdleLeanTime = now + UnityEngine.Random.Range(IdleLeanIntervalMin, IdleLeanIntervalMax);
            _idleLean = BotTiltType.right;
            _nextIdleScanTime = now + UnityEngine.Random.Range(IdleScanIntervalMin, IdleScanIntervalMax);
            _lastIdleScanTarget = Vector3.zero;
            _idleScanLerpT = 0f;
        }

        /// <summary>
        /// Overlay-only Tick. Never issues movement/navigation commands.
        /// </summary>
        public void Tick(float deltaTime)
        {
            try
            {
                if (_bot == null || _bot.IsDead || _bot.Mover == null || _bot.Transform == null)
                    return;

                OverlayAnticipationPose();
                OverlayMicroJitter();
                OverlayIdleLean();
                OverlayIdleScan();
            }
            catch (Exception ex)
            {
                if (Time.time > _lastErrorLogTime + 2f)
                {
                    Plugin.LoggerInstance.LogError("[BotMovementOverlayController] Tick (overlay only) failed: " + ex);
                    _lastErrorLogTime = Time.time;
                }
            }
        }

        /// <summary>
        /// Overlay: anticipation pose/shift before movement. (Never triggers movement.)
        /// </summary>
        private void OverlayAnticipationPose()
        {
            float now = Time.time;
            if (_inAnticipationPose && now > _lastAnticipationTime + AnticipationPoseDuration)
                _inAnticipationPose = false;

            if (now < _nextAnticipationCheck || _inAnticipationPose)
                return;

            // Only enter anticipation pose if bot has intent (never moves).
            if (_bot.Memory?.GoalEnemy != null && UnityEngine.Random.value < 0.11f)
            {
                _inAnticipationPose = true;
                _lastAnticipationTime = now;
                _nextAnticipationCheck = now + UnityEngine.Random.Range(AnticipationCooldownMin, AnticipationCooldownMax);
                // Optionally trigger anticipation pose overlay or subtle pose anim here (if supported).
            }
        }

        /// <summary>
        /// Overlay: Micro-jitter, simulating subtle root rotation/fidget—never moves.
        /// </summary>
        private void OverlayMicroJitter()
        {
            float now = Time.time;
            if (now < _nextMicroJitterTime)
                return;
            if (_bot.Transform == null || _bot.IsDead)
                return;

            float microYaw = UnityEngine.Random.Range(-MicroJitterYawMax, MicroJitterYawMax);
            _lastMicroYaw = microYaw;

            Quaternion yawRot = Quaternion.Euler(0f, microYaw, 0f);
            _bot.Transform.rotation = yawRot * _bot.Transform.rotation;

            _nextMicroJitterTime = now + UnityEngine.Random.Range(MicroJitterIntervalMin, MicroJitterIntervalMax);
        }

        /// <summary>
        /// Overlay: Idle lean/pose overlay for realism (never triggers movement).
        /// </summary>
        private void OverlayIdleLean()
        {
            float now = Time.time;
            if (_cache?.Tilt == null || _bot.Transform == null || _bot.IsDead)
                return;

            if (now < _nextIdleLeanTime)
                return;

            // Randomly switch idle lean (left/right) for realism.
            _idleLean = UnityEngine.Random.value > 0.5f ? BotTiltType.right : BotTiltType.left;
            _cache.Tilt.Set(_idleLean);

            _nextIdleLeanTime = now + UnityEngine.Random.Range(IdleLeanIntervalMin, IdleLeanIntervalMax);
        }

        /// <summary>
        /// Overlay: Idle scan/look overlay—slight head/eye drift. (Never moves bot.)
        /// </summary>
        private void OverlayIdleScan()
        {
            float now = Time.time;
            if (now < _nextIdleScanTime)
                return;
            if (_bot.Transform == null || _bot.IsDead)
                return;

            float targetYaw = UnityEngine.Random.Range(-IdleScanAngleMax, IdleScanAngleMax);
            Vector3 scanDir = Quaternion.Euler(0f, targetYaw, 0f) * _bot.Transform.forward;
            _lastIdleScanTarget = _bot.Position + scanDir * 1.2f;
            _idleScanLerpT = 0f;

            // Optionally animate/lerp look direction if supported (for head/eye pose).
            _nextIdleScanTime = now + UnityEngine.Random.Range(IdleScanIntervalMin, IdleScanIntervalMax);
        }
    }
}
