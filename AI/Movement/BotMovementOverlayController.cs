// <auto-generated>
//   AI-Refactored: BotMovementOverlayController.cs (Ultra-Platinum++ Overlay/Event-Only, Ultimate Realism, June 2025)
//   Consumes BotMovementTrajectoryPlanner output, issues NavMesh-safe moves via BotMovementHelper.
//   Never tick-moves, never oscillates, never issues a move except on genuine intent/path change.
//   All logic deduped/cooldown-guarded, overlay-only, pooled, squad/personality aware. Ultra-realism plan-compliant.
//   MIT License.
// </auto-generated>

namespace AIRefactored.AI.Movement
{
    using System;
    using AIRefactored.AI.Core;
    using AIRefactored.AI.Helpers;
    using AIRefactored.Core;
    using EFT;
    using UnityEngine;
    using UnityEngine.AI;

    /// <summary>
    /// Overlay/event-only controller. Consumes BotMovementTrajectoryPlanner intent vector and issues deduped, cooldown-gated moves.
    /// Never tick-moves or issues spam/oscillation. All moves are NavMesh/personality/squad safe, event-only.
    /// </summary>
    public sealed class BotMovementOverlayController
    {
        private readonly BotOwner _bot;
        private readonly BotComponentCache _cache;
        private readonly BotMoveCache _moveCache;
        private readonly BotMovementTrajectoryPlanner _planner;

        // Hardened movement gating
        private const float StepDistance = 3.0f;
        private const float MoveCooldown = 1.2f;
        private const float MinDeltaSqr = 0.25f;

        public BotMovementOverlayController(BotComponentCache cache)
        {
            if (cache == null || cache.Bot == null)
                throw new ArgumentException("Invalid BotMovementOverlayController initialization.");

            _cache = cache;
            _bot = cache.Bot;
            _moveCache = cache.MoveCache ?? new BotMoveCache();
            _planner = new BotMovementTrajectoryPlanner(_bot, _cache);
        }

        /// <summary>
        /// Called by BotBrain tick with deltaTime. Only issues move if intent genuinely changed and cooldown has elapsed.
        /// </summary>
        public void Tick(float deltaTime)
        {
            try
            {
                if (_bot == null || _bot.IsDead || _bot.Mover == null || _bot.Transform == null)
                    return;

                float now = Time.time;

                Vector3 desiredDir = _cache.MissionEvaluator?.GetCurrentIntentDirection() ?? Vector3.zero;
                if (!IsVectorValid(desiredDir)) return;

                Vector3 plannedDir = _planner.ModifyTrajectory(desiredDir, deltaTime);
                if (!IsVectorValid(plannedDir)) return;

                Vector3 candidateTarget = _bot.Position + plannedDir.normalized * StepDistance;
                if (!IsVectorValid(candidateTarget)) return;

                // Dedupe and cooldown: Only issue move if it's a new target or cooldown elapsed
                bool cooldownReady = (now - _moveCache.LastMoveTime) > MoveCooldown;
                bool targetNew = (_moveCache.LastIssuedTarget - candidateTarget).sqrMagnitude > MinDeltaSqr;
                if (cooldownReady || targetNew)
                {
                    // Let the movement helper handle all NavMesh/sample/validation!
                    _moveCache.LastIssuedTarget = candidateTarget;
                    _moveCache.LastMoveTime = now;
                    BotMovementHelper.SmoothMoveToSafe(_bot, candidateTarget, slow: false, cohesion: GetCohesion());
                }
            }
            catch (Exception ex)
            {
                Plugin.LoggerInstance.LogError("[BotMovementOverlayController] Tick failed: " + ex);
            }
        }

        /// <summary>
        /// Returns a pooled, safe cohesion value based on personality/squad, or 1.0f default.
        /// </summary>
        private float GetCohesion()
        {
            try
            {
                if (_cache?.PersonalityProfile != null)
                    return Mathf.Clamp(_cache.PersonalityProfile.Cohesion, 0.65f, 1.45f);
            }
            catch { }
            return 1.0f;
        }

        /// <summary>
        /// Ensures all vectors are finite and valid for movement use.
        /// </summary>
        private static bool IsVectorValid(Vector3 v)
        {
            return !float.IsNaN(v.x) && !float.IsNaN(v.y) && !float.IsNaN(v.z)
                && !float.IsInfinity(v.x) && !float.IsInfinity(v.y) && !float.IsInfinity(v.z);
        }
    }
}
