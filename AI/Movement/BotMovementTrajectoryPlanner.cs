// <auto-generated>
//   AI-Refactored: BotMovementTrajectoryPlanner.cs (Ultra-Platinum++ Overlay-Only, Human Squad/Intent, June 2025)
//   Human-squad overlays: intent, chaos, avoidance, anticipation, pose/lean overlays only. Never issues a move or sets position directly. Overlay-only outputs.
//   Bulletproof: pooled, error-isolated, multiplayer/headless parity, anti-NaN/oscillation. MIT License.
// </auto-generated>

namespace AIRefactored.AI.Movement
{
    using System;
    using AIRefactored.AI.Core;
    using AIRefactored.Core;
    using EFT;
    using UnityEngine;

    /// <summary>
    /// Generates pure overlay/event-driven intent vectors for pose/lean overlays.
    /// Never issues a move, path, or transform command. Output is for overlays/intent only.
    /// Bulletproof: squad/role/chaos/personality overlays; anti-NaN/Inf; SPT/FIKA/headless parity.
    /// </summary>
    public sealed class BotMovementTrajectoryPlanner
    {
        #region Fields

        private readonly BotOwner _bot;
        private readonly BotComponentCache _cache;

        private Vector3 _chaosOffset;
        private Vector3 _targetChaosOffset;
        private float _nextChaosUpdate;

        private Vector3 _anticipationDir;
        private float _nextAnticipationTime;

        private float _lastSquadBiasTime;
        private Vector3 _squadFormationBias;

        #endregion

        #region Constructor

        /// <summary>
        /// Initializes the overlay-only planner for pose/intent overlays.
        /// Throws if invalid bot/cache references.
        /// </summary>
        public BotMovementTrajectoryPlanner(BotOwner bot, BotComponentCache cache)
        {
            if (!EFTPlayerUtil.IsValidBotOwner(bot) || cache == null || bot.GetPlayer == null)
                throw new ArgumentException("[BotMovementTrajectoryPlanner] invalid arguments.");

            _bot = bot;
            _cache = cache;
            _chaosOffset = Vector3.zero;
            _targetChaosOffset = Vector3.zero;
            _anticipationDir = Vector3.zero;
            _squadFormationBias = Vector3.zero;
        }

        #endregion

        #region Public API

        /// <summary>
        /// Generates a context/personality/squad-driven movement overlay intent vector.
        /// Only for overlays. Never sets position, never issues a move, only overlays for humanization.
        /// Bulletproof: all layers error-isolated, SPT/FIKA/headless parity.
        /// </summary>
        public Vector3 GetOverlayIntent(Vector3 targetDir, float deltaTime)
        {
            try
            {
                const float MinMagnitude = 0.0001f;
                float now = Time.unscaledTime;
                var profile = _cache.PersonalityProfile ?? BotPersonalityProfile.Default;

                Vector3 baseDir = (targetDir.sqrMagnitude > MinMagnitude) ? targetDir.normalized : Vector3.forward;
                Vector3 adjusted = baseDir;

                // #1: Chaos/jitter overlays (personality, panic, suppression, cover)
                if (now > _nextChaosUpdate)
                    UpdateTargetChaosOffset(now, profile);

                _chaosOffset = Vector3.Lerp(_chaosOffset, _targetChaosOffset, deltaTime * 4.7f);
                _chaosOffset.y = 0f;
                if (IsVectorValid(_chaosOffset))
                    adjusted += _chaosOffset;

                // #2: Anticipation/fakeout overlays (overshoot, hesitation, overshoot/follow-through)
                TryAnticipation(baseDir, now, ref adjusted);

                // #3: Squad overlays (formation, role offset, formation bias)
                if (_cache.SquadPath != null)
                {
                    Vector3 squadOffset = _cache.SquadPath.GetCurrentOffset();
                    if (squadOffset.sqrMagnitude > MinMagnitude && IsVectorValid(squadOffset))
                    {
                        squadOffset.y = 0f;
                        adjusted += squadOffset.normalized * 0.84f;
                    }
                    if (now - _lastSquadBiasTime > 1.41f)
                    {
                        _squadFormationBias = UnityEngine.Random.insideUnitSphere * 0.19f;
                        _squadFormationBias.y = 0f;
                        _lastSquadBiasTime = now;
                    }
                    adjusted += _squadFormationBias;
                }

                // #4: Anti-collision/avoidance overlays (prevent agent overlap)
                Vector3 avoidVector = ComputeAvoidance();
                if (avoidVector.sqrMagnitude > MinMagnitude && IsVectorValid(avoidVector))
                {
                    avoidVector.y = 0f;
                    adjusted += avoidVector.normalized * 1.33f;
                }

                // #5: Role-based lateral overlays (dynamic left/right bias)
                if (_bot.BotsGroup != null && _bot.BotsGroup.MembersCount > 1)
                {
                    int idx = -1;
                    for (int i = 0; i < _bot.BotsGroup.MembersCount; i++)
                        if (_bot.BotsGroup.Member(i) == _bot) { idx = i; break; }
                    if (idx >= 0)
                    {
                        float posBias = ((idx % 2 == 0) ? -1f : 1f) * 0.45f;
                        Vector3 roleOffset = Vector3.Cross(Vector3.up, baseDir) * posBias;
                        if (IsVectorValid(roleOffset))
                            adjusted += roleOffset;
                    }
                }

                // #6: Cover overlays (micro-alignment to cover edge)
                if (_cache.CoverPlanner != null && _cache.CoverPlanner.IsInCover)
                {
                    Vector3 coverNormal = _cache.CoverPlanner.CoverNormal;
                    if (!IsVectorValid(coverNormal) || coverNormal == Vector3.zero)
                        coverNormal = _bot.Transform != null ? _bot.Transform.right : Vector3.right;

                    Vector3 coverAlign = Vector3.ProjectOnPlane(coverNormal.normalized, Vector3.up) * 0.25f;
                    if (IsVectorValid(coverAlign))
                        adjusted += coverAlign;
                }

                // #7: Velocity/inertia overlay (carry through existing movement)
                Vector3 velocity = _bot.GetPlayer != null ? _bot.GetPlayer.Velocity : Vector3.zero;
                if (velocity.sqrMagnitude > MinMagnitude && IsVectorValid(velocity))
                {
                    velocity.y = 0f;
                    adjusted += velocity.normalized * 1.38f;
                }

                // #8: Suppression/panic overlays (stress micro-move, random direction, temporary)
                if ((_cache.PanicHandler?.IsPanicking ?? false) || (_cache.Suppression?.IsSuppressed() ?? false))
                {
                    Vector3 suppress = UnityEngine.Random.insideUnitSphere * 0.44f;
                    suppress.y = 0f;
                    adjusted += suppress;
                }

                // #9: Aggression overlay (forward bias, rare, based on aggression)
                float personalityAggro = Mathf.Clamp01(profile.AggressionLevel);
                if (personalityAggro > 0.66f && UnityEngine.Random.value < 0.19f)
                    adjusted += baseDir * 0.14f * personalityAggro;

                // #10: Universal micro-jitter overlay (subtle, always)
                Vector3 jitter = UnityEngine.Random.insideUnitSphere * 0.013f;
                jitter.y = 0f;
                adjusted += jitter;

                // #11: Stuck overlay (large random displacement if mover blocked, never disables)
                if (_bot.Mover?.Blocked ?? false)
                {
                    Vector3 wobble = UnityEngine.Random.insideUnitSphere * 0.39f;
                    wobble.y = 0f;
                    adjusted += wobble;
                }

                // #12: Final output sanitize (anti-NaN, clamp to plausible, fallback if invalid)
                if (!IsVectorValid(adjusted) || adjusted.sqrMagnitude < MinMagnitude)
                    return baseDir;
                return adjusted.normalized;
            }
            catch
            {
                return Vector3.forward;
            }
        }

        #endregion

        #region Internal Helpers

        /// <summary>
        /// Updates target chaos offset based on context and bot personality.
        /// </summary>
        private void UpdateTargetChaosOffset(float now, BotPersonalityProfile profile)
        {
            try
            {
                float chaosBase = 0.61f * (1f - Mathf.Clamp01(profile.Caution));
                float chaos = chaosBase;

                if (_cache.PanicHandler?.IsPanicking == true)
                    chaos += 0.95f;
                if (_cache.Suppression?.IsSuppressed() == true)
                    chaos += 0.43f;
                if (_cache.CoverPlanner?.IsInCover == true)
                    chaos *= 0.46f;

                chaos = Mathf.Clamp(chaos, 0.01f, 1.22f);

                float x = UnityEngine.Random.Range(-chaos * 0.5f, chaos * 0.5f);
                float z = UnityEngine.Random.Range(0.1f, chaos);
                _targetChaosOffset = new Vector3(x, 0f, z);

                _nextChaosUpdate = now + UnityEngine.Random.Range(0.29f, 0.59f);
            }
            catch
            {
                _targetChaosOffset = Vector3.zero;
                _nextChaosUpdate = now + UnityEngine.Random.Range(0.29f, 0.59f);
            }
        }

        /// <summary>
        /// Anticipation/overshoot/fakeout overlays (pre-move hesitation or follow-through).
        /// </summary>
        private void TryAnticipation(Vector3 baseDir, float now, ref Vector3 adjusted)
        {
            if (now < _nextAnticipationTime)
            {
                adjusted += _anticipationDir * 0.15f;
                return;
            }

            float angle = Vector3.Angle(adjusted, baseDir);
            if (angle > 27f && UnityEngine.Random.value < 0.19f)
            {
                _anticipationDir = Quaternion.AngleAxis(UnityEngine.Random.Range(-13f, 13f), Vector3.up) * baseDir;
                _nextAnticipationTime = now + 0.44f;
                adjusted += _anticipationDir * 0.15f;
            }
        }

        /// <summary>
        /// Computes avoidance/repulsion from other group members to prevent crowding/collisions.
        /// </summary>
        private Vector3 ComputeAvoidance()
        {
            try
            {
                if (UnityEngine.Random.value < 0.065f)
                    return Vector3.zero;

                BotsGroup group = _bot.BotsGroup;
                if (group == null || group.MembersCount <= 1)
                    return Vector3.zero;

                Vector3 self = _bot.Position;
                Vector3 repulsion = Vector3.zero;
                int count = 0;

                for (int i = 0; i < group.MembersCount; i++)
                {
                    BotOwner other = group.Member(i);
                    if (other == null || other == _bot || other.IsDead)
                        continue;

                    Vector3 offset = self - other.Position;
                    float dist = offset.magnitude;
                    if (dist < 2.18f && dist > 0.01f)
                    {
                        offset.y = 0f;
                        repulsion += offset.normalized / dist;
                        count++;
                    }
                }

                return count > 0 ? repulsion / count : Vector3.zero;
            }
            catch
            {
                return Vector3.zero;
            }
        }

        /// <summary>
        /// Validates a Vector3 for finite/valid values (no NaN, no Inf).
        /// </summary>
        private static bool IsVectorValid(Vector3 v)
        {
            return !float.IsNaN(v.x) && !float.IsNaN(v.y) && !float.IsNaN(v.z)
                && !float.IsInfinity(v.x) && !float.IsInfinity(v.y) && !float.IsInfinity(v.z);
        }

        #endregion
    }
}
