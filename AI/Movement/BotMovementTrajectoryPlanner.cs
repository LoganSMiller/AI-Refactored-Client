// <auto-generated>
//   AI-Refactored: BotMovementTrajectoryPlanner.cs (Overlay-Only, Internal Nav, June 2025)
//   Human-squad movement overlays: intent, chaos, avoidance, pose/lean overlays only. 
//   Never issues a move or sets position directly. All output is for overlays only.
//   MIT License.
// </auto-generated>

namespace AIRefactored.AI.Movement
{
    using System;
    using AIRefactored.AI.Core;
    using AIRefactored.Core;
    using EFT;
    using UnityEngine;

    /// <summary>
    /// Generates pure overlay/event-driven intent vectors for pose/lean overlays.
    /// Never issues a move, path, or transform command. Output is for overlays/intent only.
    /// </summary>
    public sealed class BotMovementTrajectoryPlanner
    {
        #region Fields

        private readonly BotOwner _bot;
        private readonly BotComponentCache _cache;

        private Vector3 _chaosOffset;
        private Vector3 _targetChaosOffset;
        private float _nextChaosUpdate;

        private Vector3 _anticipationDir;
        private float _nextAnticipationTime;

        private float _lastSquadBiasTime;
        private Vector3 _squadFormationBias;

        #endregion

        #region Constructor

        public BotMovementTrajectoryPlanner(BotOwner bot, BotComponentCache cache)
        {
            if (!EFTPlayerUtil.IsValidBotOwner(bot) || cache == null || bot.GetPlayer == null)
                throw new ArgumentException("[BotMovementTrajectoryPlanner] invalid arguments.");

            _bot = bot;
            _cache = cache;
            _chaosOffset = Vector3.zero;
            _targetChaosOffset = Vector3.zero;
            _anticipationDir = Vector3.zero;
            _squadFormationBias = Vector3.zero;
        }

        #endregion

        #region Public API

        /// <summary>
        /// Generates a context/personality/squad-driven movement overlay intent vector.
        /// Only for overlays. Never sets position, never issues a move, only overlays for humanization.
        /// </summary>
        public Vector3 GetOverlayIntent(Vector3 targetDir, float deltaTime)
        {
            try
            {
                const float MinMagnitude = 0.0001f;
                float now = Time.unscaledTime;
                var profile = _cache.PersonalityProfile ?? BotPersonalityProfile.Default;

                Vector3 baseDir = (targetDir.sqrMagnitude > MinMagnitude) ? targetDir.normalized : Vector3.forward;
                Vector3 adjusted = baseDir;

                // Chaos/jitter overlays
                if (now > _nextChaosUpdate)
                    UpdateTargetChaosOffset(now, profile);

                _chaosOffset = Vector3.Lerp(_chaosOffset, _targetChaosOffset, deltaTime * 4.3f);
                _chaosOffset.y = 0f;
                if (IsVectorValid(_chaosOffset))
                    adjusted += _chaosOffset;

                // Anticipation/fake start overlays
                TryAnticipation(baseDir, now, ref adjusted);

                // Squad overlays (formation/edge)
                if (_cache.SquadPath != null)
                {
                    Vector3 squadOffset = _cache.SquadPath.GetCurrentOffset();
                    if (squadOffset.sqrMagnitude > MinMagnitude && IsVectorValid(squadOffset))
                    {
                        squadOffset.y = 0f;
                        adjusted += squadOffset.normalized * 0.84f;
                    }
                    if (now - _lastSquadBiasTime > 1.45f)
                    {
                        _squadFormationBias = UnityEngine.Random.insideUnitSphere * 0.19f;
                        _squadFormationBias.y = 0f;
                        _lastSquadBiasTime = now;
                    }
                    adjusted += _squadFormationBias;
                }

                // Avoidance overlay (anti-collision)
                Vector3 avoidVector = ComputeAvoidance();
                if (avoidVector.sqrMagnitude > MinMagnitude && IsVectorValid(avoidVector))
                {
                    avoidVector.y = 0f;
                    adjusted += avoidVector.normalized * 1.33f;
                }

                // Role-based lateral/positional overlays
                if (_bot.BotsGroup != null && _bot.BotsGroup.MembersCount > 1)
                {
                    int idx = -1;
                    for (int i = 0; i < _bot.BotsGroup.MembersCount; i++)
                        if (_bot.BotsGroup.Member(i) == _bot) { idx = i; break; }
                    if (idx >= 0)
                    {
                        float posBias = ((idx % 2 == 0) ? -1f : 1f) * 0.45f;
                        Vector3 roleOffset = Vector3.Cross(Vector3.up, baseDir) * posBias;
                        if (IsVectorValid(roleOffset))
                            adjusted += roleOffset;
                    }
                }

                // Cover overlays
                if (_cache.CoverPlanner != null && _cache.CoverPlanner.IsInCover)
                {
                    Vector3 coverNormal = _cache.CoverPlanner.CoverNormal;
                    if (!IsVectorValid(coverNormal) || coverNormal == Vector3.zero)
                        coverNormal = _bot.Transform != null ? _bot.Transform.right : Vector3.right;

                    Vector3 coverAlign = Vector3.ProjectOnPlane(coverNormal.normalized, Vector3.up) * 0.25f;
                    if (IsVectorValid(coverAlign))
                        adjusted += coverAlign;
                }

                // Add velocity bias overlay (inertia, never moves)
                Vector3 velocity = _bot.GetPlayer != null ? _bot.GetPlayer.Velocity : Vector3.zero;
                if (velocity.sqrMagnitude > MinMagnitude && IsVectorValid(velocity))
                {
                    velocity.y = 0f;
                    adjusted += velocity.normalized * 1.38f;
                }

                // Suppression/panic overlays
                if ((_cache.PanicHandler?.IsPanicking ?? false) || (_cache.Suppression?.IsSuppressed() ?? false))
                {
                    Vector3 suppress = UnityEngine.Random.insideUnitSphere * 0.44f;
                    suppress.y = 0f;
                    adjusted += suppress;
                }

                // Aggression overlay
                float personalityAggro = Mathf.Clamp01(profile.AggressionLevel);
                if (personalityAggro > 0.65f && UnityEngine.Random.value < 0.21f)
                    adjusted += baseDir * 0.13f * personalityAggro;

                // Universal micro-jitter overlay
                Vector3 jitter = UnityEngine.Random.insideUnitSphere * 0.014f;
                jitter.y = 0f;
                adjusted += jitter;

                // Stuck overlay
                if (_bot.Mover?.Blocked ?? false)
                {
                    Vector3 wobble = UnityEngine.Random.insideUnitSphere * 0.41f;
                    wobble.y = 0f;
                    adjusted += wobble;
                }

                // Final sanitize
                if (!IsVectorValid(adjusted) || adjusted.sqrMagnitude < MinMagnitude)
                    return baseDir;
                return adjusted.normalized;
            }
            catch
            {
                return Vector3.forward;
            }
        }

        #endregion

        #region Internal Helpers

        private void UpdateTargetChaosOffset(float now, BotPersonalityProfile profile)
        {
            try
            {
                float chaosBase = 0.58f * (1f - Mathf.Clamp01(profile.Caution));
                float chaos = chaosBase;

                if (_cache.PanicHandler?.IsPanicking == true)
                    chaos += 0.92f;
                if (_cache.Suppression?.IsSuppressed() == true)
                    chaos += 0.44f;
                if (_cache.CoverPlanner?.IsInCover == true)
                    chaos *= 0.5f;

                chaos = Mathf.Clamp(chaos, 0.01f, 1.22f);

                float x = UnityEngine.Random.Range(-chaos * 0.5f, chaos * 0.5f);
                float z = UnityEngine.Random.Range(0.1f, chaos);
                _targetChaosOffset = new Vector3(x, 0f, z);

                _nextChaosUpdate = now + UnityEngine.Random.Range(0.32f, 0.59f);
            }
            catch
            {
                _targetChaosOffset = Vector3.zero;
                _nextChaosUpdate = now + UnityEngine.Random.Range(0.32f, 0.59f);
            }
        }

        private void TryAnticipation(Vector3 baseDir, float now, ref Vector3 adjusted)
        {
            if (now < _nextAnticipationTime)
            {
                adjusted += _anticipationDir * 0.15f;
                return;
            }

            float angle = Vector3.Angle(adjusted, baseDir);
            if (angle > 29f && UnityEngine.Random.value < 0.21f)
            {
                _anticipationDir = Quaternion.AngleAxis(UnityEngine.Random.Range(-13f, 13f), Vector3.up) * baseDir;
                _nextAnticipationTime = now + 0.44f;
                adjusted += _anticipationDir * 0.15f;
            }
        }

        private Vector3 ComputeAvoidance()
        {
            try
            {
                if (UnityEngine.Random.value < 0.065f)
                    return Vector3.zero;

                BotsGroup group = _bot.BotsGroup;
                if (group == null || group.MembersCount <= 1)
                    return Vector3.zero;

                Vector3 self = _bot.Position;
                Vector3 repulsion = Vector3.zero;
                int count = 0;

                for (int i = 0; i < group.MembersCount; i++)
                {
                    BotOwner other = group.Member(i);
                    if (other == null || other == _bot || other.IsDead)
                        continue;

                    Vector3 offset = self - other.Position;
                    float dist = offset.magnitude;
                    if (dist < 2.18f && dist > 0.01f)
                    {
                        offset.y = 0f;
                        repulsion += offset.normalized / dist;
                        count++;
                    }
                }

                return count > 0 ? repulsion / count : Vector3.zero;
            }
            catch
            {
                return Vector3.zero;
            }
        }

        private static bool IsVectorValid(Vector3 v)
        {
            return !float.IsNaN(v.x) && !float.IsNaN(v.y) && !float.IsNaN(v.z)
                && !float.IsInfinity(v.x) && !float.IsInfinity(v.y) && !float.IsInfinity(v.z);
        }

        #endregion
    }
}
