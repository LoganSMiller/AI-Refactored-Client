// <auto-generated>
//   AI-Refactored: BotMovementTrajectoryPlanner.cs (Ultra-Platinum++ Overlay/Event-Only, June 2025)
//   Human-squad movement flow: anticipation, chaos, inertia, role offset, avoidance, cover adaptation, zero allocations.
//   Overlay-only: outputs single normalized vector, never issues a move or sets position directly. All output bulletproof.
//   MIT License.
// </auto-generated>

namespace AIRefactored.AI.Movement
{
    using System;
    using AIRefactored.AI.Core;
    using AIRefactored.Core;
    using EFT;
    using UnityEngine;

    /// <summary>
    /// Generates ultra-realistic, humanized, squad- and personality-driven movement overlays.
    /// Outputs a single normalized vector—never sets position, never moves, overlays only.
    /// Ultra-hardened: every output vector is safe, valid, and non-NaN, anti-oscillation, pooled, squad/personality aware.
    /// </summary>
    public sealed class BotMovementTrajectoryPlanner
    {
        #region Constants

        private const float AvoidanceRadius = 2.18f;
        private const float AvoidanceScale = 1.33f;
        private const float ChaosIntervalMin = 0.32f;
        private const float ChaosIntervalMax = 0.59f;
        private const float ChaosRadius = 0.58f;
        private const float PanicChaosRadius = 0.92f;
        private const float CoverChaosScale = 0.5f;
        private const float SquadOffsetScale = 0.84f;
        private const float RoleOffsetMul = 0.45f;
        private const float VelocityFactor = 1.38f;
        private const float MinMagnitude = 0.0001f;
        private const float ChaosLerpSpeed = 4.3f;
        private const float AvoidanceMissChance = 0.065f;
        private const float AnticipationInterval = 0.44f;
        private const float AnticipationMagnitude = 0.15f;
        private const float JitterMicro = 0.014f;
        private const float FormationEdgeBias = 0.19f;
        private const float SuppressedChaosBonus = 0.44f;
        private const float AggressionSprintBias = 0.21f;
        private const float CoverAlignmentWeight = 0.25f;
        private const float StuckWobbleMagnitude = 0.41f;

        #endregion

        #region Fields

        private readonly BotOwner _bot;
        private readonly BotComponentCache _cache;

        private Vector3 _chaosOffset;
        private Vector3 _targetChaosOffset;
        private float _nextChaosUpdate;

        private Vector3 _anticipationDir;
        private float _nextAnticipationTime;

        private float _lastSquadBiasTime;
        private Vector3 _squadFormationBias;

        #endregion

        #region Constructor

        /// <summary>
        /// Creates a new trajectory planner for a bot, bulletproof and pooled. Throws on bad args.
        /// </summary>
        public BotMovementTrajectoryPlanner(BotOwner bot, BotComponentCache cache)
        {
            if (!EFTPlayerUtil.IsValidBotOwner(bot) || cache == null || bot.GetPlayer == null)
                throw new ArgumentException("[BotMovementTrajectoryPlanner] invalid arguments.");

            _bot = bot;
            _cache = cache;
            _chaosOffset = Vector3.zero;
            _targetChaosOffset = Vector3.zero;
            _anticipationDir = Vector3.zero;
            _squadFormationBias = Vector3.zero;
        }

        #endregion

        #region Public API

        /// <summary>
        /// Produces a context/personality/squad-driven, micro-jittered movement overlay vector.
        /// All chaos/avoidance/jitter is pooled and stateful; output is always safe/normalized.
        /// </summary>
        public Vector3 ModifyTrajectory(Vector3 targetDir, float deltaTime)
        {
            try
            {
                float now = Time.unscaledTime;
                var profile = _cache.PersonalityProfile ?? BotPersonalityProfile.Default;
                float personalityCaution = Mathf.Clamp01(profile.Caution);
                float personalityAggro = Mathf.Clamp01(profile.AggressionLevel);

                Vector3 baseDir = (targetDir.sqrMagnitude > MinMagnitude) ? targetDir.normalized : Vector3.forward;
                Vector3 adjusted = baseDir;

                // Chaos/jitter layer (personality/context-driven, bulletproof)
                if (now > _nextChaosUpdate)
                    UpdateTargetChaosOffset(now, profile);

                _chaosOffset = Vector3.Lerp(_chaosOffset, _targetChaosOffset, deltaTime * ChaosLerpSpeed);
                _chaosOffset.y = 0f;
                if (IsVectorValid(_chaosOffset))
                    adjusted += _chaosOffset;

                // Human anticipation/overshoot (micro hesitation/fake start, overlay only)
                TryAnticipation(baseDir, now, ref adjusted);

                // Squad path overlay (no alloc, valid check)
                if (_cache.SquadPath != null)
                {
                    Vector3 squadOffset = _cache.SquadPath.GetCurrentOffset();
                    if (squadOffset.sqrMagnitude > MinMagnitude && IsVectorValid(squadOffset))
                    {
                        squadOffset.y = 0f;
                        adjusted += squadOffset.normalized * SquadOffsetScale;
                    }
                    if (now - _lastSquadBiasTime > 1.45f)
                    {
                        _squadFormationBias = UnityEngine.Random.insideUnitSphere * FormationEdgeBias;
                        _squadFormationBias.y = 0f;
                        _lastSquadBiasTime = now;
                    }
                    adjusted += _squadFormationBias;
                }

                // Multi-agent avoidance (anti-clump, anti-collision)
                Vector3 avoidVector = ComputeAvoidance();
                if (avoidVector.sqrMagnitude > MinMagnitude && IsVectorValid(avoidVector))
                {
                    avoidVector.y = 0f;
                    adjusted += avoidVector.normalized * AvoidanceScale;
                }

                // Role-based lateral/positional bias (flanks/leaders)
                if (_bot.BotsGroup != null && _bot.BotsGroup.MembersCount > 1)
                {
                    int idx = -1;
                    for (int i = 0; i < _bot.BotsGroup.MembersCount; i++)
                        if (_bot.BotsGroup.Member(i) == _bot) { idx = i; break; }
                    if (idx >= 0)
                    {
                        float posBias = ((idx % 2 == 0) ? -1f : 1f) * RoleOffsetMul;
                        Vector3 roleOffset = Vector3.Cross(Vector3.up, baseDir) * posBias;
                        if (IsVectorValid(roleOffset))
                            adjusted += roleOffset;
                    }
                }

                // Adapt to cover: bias along walls, maintain alignment
                if (_cache.CoverPlanner != null && _cache.CoverPlanner.IsInCover)
                {
                    Vector3 coverNormal = _cache.CoverPlanner.CoverNormal;
                    if (!IsVectorValid(coverNormal) || coverNormal == Vector3.zero)
                        coverNormal = _bot.Transform != null ? _bot.Transform.right : Vector3.right;

                    Vector3 coverAlign = Vector3.ProjectOnPlane(coverNormal.normalized, Vector3.up) * CoverAlignmentWeight;
                    if (IsVectorValid(coverAlign))
                        adjusted += coverAlign;
                }

                // Add velocity bias (inertia): never alloc, always valid
                Vector3 velocity = _bot.GetPlayer != null ? _bot.GetPlayer.Velocity : Vector3.zero;
                if (velocity.sqrMagnitude > MinMagnitude && IsVectorValid(velocity))
                {
                    velocity.y = 0f;
                    adjusted += velocity.normalized * VelocityFactor;
                }

                // Suppression/panic: inject chaos
                if ((_cache.PanicHandler?.IsPanicking ?? false) || (_cache.Suppression?.IsSuppressed() ?? false))
                {
                    Vector3 suppress = UnityEngine.Random.insideUnitSphere * SuppressedChaosBonus;
                    suppress.y = 0f;
                    adjusted += suppress;
                }

                // Aggression: highly aggressive bots sprint forward more
                if (personalityAggro > 0.65f && UnityEngine.Random.value < AggressionSprintBias)
                    adjusted += baseDir * 0.13f * personalityAggro;

                // Universal micro-jitter
                Vector3 jitter = UnityEngine.Random.insideUnitSphere * JitterMicro;
                jitter.y = 0f;
                adjusted += jitter;

                // Stuck: add strong wobble to break out
                if (_bot.Mover?.Blocked ?? false)
                {
                    Vector3 wobble = UnityEngine.Random.insideUnitSphere * StuckWobbleMagnitude;
                    wobble.y = 0f;
                    adjusted += wobble;
                }

                // Final sanitize: always return valid, normalized vector
                if (!IsVectorValid(adjusted) || adjusted.sqrMagnitude < MinMagnitude)
                    return baseDir;
                return adjusted.normalized;
            }
            catch
            {
                return Vector3.forward;
            }
        }

        #endregion

        #region Internal Helpers

        private void UpdateTargetChaosOffset(float now, BotPersonalityProfile profile)
        {
            try
            {
                float chaosBase = ChaosRadius * (1f - Mathf.Clamp01(profile.Caution));
                float chaos = chaosBase;

                if (_cache.PanicHandler?.IsPanicking == true)
                    chaos += PanicChaosRadius;
                if (_cache.Suppression?.IsSuppressed() == true)
                    chaos += SuppressedChaosBonus;
                if (_cache.CoverPlanner?.IsInCover == true)
                    chaos *= CoverChaosScale;

                chaos = Mathf.Clamp(chaos, 0.01f, 1.22f);

                float x = UnityEngine.Random.Range(-chaos * 0.5f, chaos * 0.5f);
                float z = UnityEngine.Random.Range(0.1f, chaos);
                _targetChaosOffset = new Vector3(x, 0f, z);

                _nextChaosUpdate = now + UnityEngine.Random.Range(ChaosIntervalMin, ChaosIntervalMax);
            }
            catch
            {
                _targetChaosOffset = Vector3.zero;
                _nextChaosUpdate = now + UnityEngine.Random.Range(ChaosIntervalMin, ChaosIntervalMax);
            }
        }

        private void TryAnticipation(Vector3 baseDir, float now, ref Vector3 adjusted)
        {
            if (now < _nextAnticipationTime)
            {
                adjusted += _anticipationDir * AnticipationMagnitude;
                return;
            }

            float angle = Vector3.Angle(adjusted, baseDir);
            if (angle > 29f && UnityEngine.Random.value < 0.21f)
            {
                _anticipationDir = Quaternion.AngleAxis(UnityEngine.Random.Range(-13f, 13f), Vector3.up) * baseDir;
                _nextAnticipationTime = now + AnticipationInterval;
                adjusted += _anticipationDir * AnticipationMagnitude;
            }
        }

        private Vector3 ComputeAvoidance()
        {
            try
            {
                if (UnityEngine.Random.value < AvoidanceMissChance)
                    return Vector3.zero;

                BotsGroup group = _bot.BotsGroup;
                if (group == null || group.MembersCount <= 1)
                    return Vector3.zero;

                Vector3 self = _bot.Position;
                Vector3 repulsion = Vector3.zero;
                int count = 0;

                for (int i = 0; i < group.MembersCount; i++)
                {
                    BotOwner other = group.Member(i);
                    if (other == null || other == _bot || other.IsDead)
                        continue;

                    Vector3 offset = self - other.Position;
                    float dist = offset.magnitude;
                    if (dist < AvoidanceRadius && dist > 0.01f)
                    {
                        offset.y = 0f;
                        repulsion += offset.normalized / dist;
                        count++;
                    }
                }

                return count > 0 ? repulsion / count : Vector3.zero;
            }
            catch
            {
                return Vector3.zero;
            }
        }

        /// <summary>
        /// Ensures vectors are finite and valid for safe overlays.
        /// </summary>
        private static bool IsVectorValid(Vector3 v)
        {
            return !float.IsNaN(v.x) && !float.IsNaN(v.y) && !float.IsNaN(v.z)
                && !float.IsInfinity(v.x) && !float.IsInfinity(v.y) && !float.IsInfinity(v.z);
        }

        #endregion
    }
}
