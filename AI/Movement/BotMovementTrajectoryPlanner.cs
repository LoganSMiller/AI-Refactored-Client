// <auto-generated>
//   This file is part of AI-Refactored, an open-source project focused on realistic AI behavior in Escape from Tarkov.
//   Licensed under the MIT License. See LICENSE in the repository root for more information.
//
//   THIS FILE IS SYSTEMATICALLY MANAGED.
//   Failures in AIRefactored logic must always trigger safe fallback to EFT base AI.
//   Bulletproof: All failures are locally isolated; cannot break or cascade into other systems.
//   Realism Pass: Personality-driven, smoothly-varying chaos; organic avoidance; no robotic movement artifacts.
// </auto-generated>

namespace AIRefactored.AI.Movement
{
    using System;
    using AIRefactored.AI.Core;
    using AIRefactored.Core;
    using EFT;
    using UnityEngine;

    /// <summary>
    /// Modifies a bot’s movement vector by applying chaos wobble, squad staggering offsets,
    /// and teammate collision avoidance. Produces natural movement flow and reduces clustering.
    /// All failures are locally isolated; cannot break or cascade into other systems.
    /// </summary>
    public sealed class BotMovementTrajectoryPlanner
    {
        #region Constants

        private const float AvoidanceRadius = 2.0f;
        private const float AvoidanceScale = 1.25f;
        private const float ChaosInterval = 0.4f;
        private const float ChaosRadius = 0.65f;
        private const float SquadOffsetScale = 0.75f;
        private const float VelocityFactor = 1.5f;
        private const float MinMagnitude = 0.0001f;
        private const float ChaosLerpSpeed = 3.8f; // smooth chaos updates
        private const float AvoidanceMissChance = 0.07f; // ~7% chance to "miss" avoidance, human error

        #endregion

        #region Fields

        private readonly BotOwner _bot;
        private readonly BotComponentCache _cache;

        private Vector3 _chaosOffset;
        private Vector3 _targetChaosOffset;
        private float _nextChaosUpdate;

        #endregion

        #region Constructor

        /// <summary>
        /// Initializes a new instance with bulletproof validation.
        /// </summary>
        /// <param name="bot">The bot owner reference (never null).</param>
        /// <param name="cache">BotComponentCache (never null).</param>
        public BotMovementTrajectoryPlanner(BotOwner bot, BotComponentCache cache)
        {
            if (!EFTPlayerUtil.IsValidBotOwner(bot)) throw new ArgumentException("[BotMovementTrajectoryPlanner] bot is invalid.");
            if (cache == null || bot.GetPlayer == null) throw new ArgumentException("[BotMovementTrajectoryPlanner] cache or player is null.");

            _bot = bot;
            _cache = cache;
            _chaosOffset = Vector3.zero;
            _targetChaosOffset = Vector3.zero;
            _nextChaosUpdate = 0f;
        }

        #endregion

        #region Public API

        /// <summary>
        /// Computes a modified movement direction vector for the bot.
        /// Applies chaos, squad offsets, avoidance, and velocity blending.
        /// Always bulletproof, never allocates, never throws, always returns a valid direction.
        /// </summary>
        /// <param name="targetDir">Intended movement direction (not normalized).</param>
        /// <param name="deltaTime">Delta time for frame.</param>
        /// <returns>Adjusted, normalized movement direction vector.</returns>
        public Vector3 ModifyTrajectory(Vector3 targetDir, float deltaTime)
        {
            try
            {
                float now = Time.unscaledTime;

                // Realistic: Chaos is smoothly interpolated over time, not abrupt
                if (now >= _nextChaosUpdate)
                {
                    UpdateTargetChaosOffset(now);
                }
                _chaosOffset = Vector3.Lerp(_chaosOffset, _targetChaosOffset, deltaTime * ChaosLerpSpeed);

                Vector3 baseDir = (targetDir.sqrMagnitude > MinMagnitude) ? targetDir.normalized : Vector3.forward;
                Vector3 adjusted = baseDir;

                if (_chaosOffset.sqrMagnitude > MinMagnitude)
                {
                    adjusted += _chaosOffset;
                }

                // Squad offset logic
                if (_cache.SquadPath != null)
                {
                    Vector3 squadOffset = _cache.SquadPath.GetCurrentOffset();
                    if (squadOffset.sqrMagnitude > MinMagnitude)
                    {
                        adjusted += squadOffset.normalized * SquadOffsetScale;
                    }
                }

                // Avoidance (now includes human error)
                Vector3 avoidVector = ComputeAvoidance();
                if (avoidVector.sqrMagnitude > MinMagnitude)
                {
                    adjusted += avoidVector.normalized * AvoidanceScale;
                }

                // Bot's current velocity
                Vector3 velocity = Vector3.zero;
                try
                {
                    velocity = _bot.GetPlayer != null ? _bot.GetPlayer.Velocity : Vector3.zero;
                }
                catch { }

                if (velocity.sqrMagnitude > MinMagnitude)
                {
                    adjusted += velocity.normalized * VelocityFactor;
                }

                adjusted.y = 0f;
                return adjusted.sqrMagnitude > MinMagnitude ? adjusted.normalized : baseDir;
            }
            catch (Exception)
            {
                // Always return a valid forward fallback.
                return Vector3.forward;
            }
        }

        #endregion

        #region Internal Helpers

        /// <summary>
        /// Computes avoidance vector from nearby squadmates.
        /// Realism: 7% chance to "miss" avoidance (human error).
        /// </summary>
        /// <returns>Repulsion vector (may be zero).</returns>
        private Vector3 ComputeAvoidance()
        {
            try
            {
                if (UnityEngine.Random.value < AvoidanceMissChance)
                    return Vector3.zero;

                BotsGroup group = _bot.BotsGroup;
                if (group == null || group.MembersCount <= 1) return Vector3.zero;

                Vector3 self = _bot.Position;
                Vector3 repulsion = Vector3.zero;
                int count = 0;

                for (int i = 0; i < group.MembersCount; i++)
                {
                    BotOwner other = group.Member(i);
                    if (other == null || other == _bot || other.IsDead) continue;

                    Vector3 offset = self - other.Position;
                    float dist = offset.magnitude;
                    if (dist < AvoidanceRadius && dist > 0.01f)
                    {
                        repulsion += offset.normalized / dist;
                        count++;
                    }
                }

                return count > 0 ? repulsion / count : Vector3.zero;
            }
            catch
            {
                return Vector3.zero;
            }
        }

        /// <summary>
        /// Updates the target chaos (random) movement offset based on bot personality.
        /// More cautious bots have less chaos; bias is always forward. Lerp to this value over time for smoothness.
        /// </summary>
        /// <param name="now">Current time (unscaled).</param>
        private void UpdateTargetChaosOffset(float now)
        {
            try
            {
                AIRefactoredBotOwner owner = _cache.AIRefactoredBotOwner;
                if (owner == null || owner.PersonalityProfile == null)
                {
                    _targetChaosOffset = Vector3.zero;
                    _nextChaosUpdate = now + ChaosInterval;
                    return;
                }

                float caution = Mathf.Clamp01(owner.PersonalityProfile.Caution);
                float chaosRange = ChaosRadius * (1f - caution);

                float x = UnityEngine.Random.Range(-chaosRange * 0.5f, chaosRange * 0.5f);
                float z = UnityEngine.Random.Range(0.1f, chaosRange); // Always forward biased

                _targetChaosOffset = new Vector3(x, 0f, z);
                _nextChaosUpdate = now + ChaosInterval;
            }
            catch
            {
                _targetChaosOffset = Vector3.zero;
                _nextChaosUpdate = now + ChaosInterval;
            }
        }

        #endregion
    }
}
