// <auto-generated>
//   AI-Refactored: BotMovementTrajectoryPlanner.cs (Ultra-Platinum++ Overlay-Only, Max Realism, MasterMovePlan, June 2025)
//   Human-squad overlays: chaos, anticipation, role/cover, anti-crowd, inertia, panic/suppression, intent overlays only. 
//   Never issues move or sets position. Overlay/event output only. Bulletproof: pooled, error-isolated, max-realism, zero-alloc. MIT License.
// </auto-generated>

namespace AIRefactored.AI.Movement
{
    using System;
    using AIRefactored.AI.Core;
    using AIRefactored.Core;
    using EFT;
    using UnityEngine;

    /// <summary>
    /// Generates event-driven overlay intent vectors for pose/lean overlays.
    /// Pure overlay-only: anti-oscillation, squad/personality/cover aware, pooled, zero-alloc.
    /// Never issues movement or changes position. All output is intent/overlay only.
    /// Max MasterMovePlan compliance. Bulletproof: all logic error-shielded, multiplayer/headless safe.
    /// </summary>
    public sealed class BotMovementTrajectoryPlanner
    {
        #region Fields

        private readonly BotOwner _bot;
        private readonly BotComponentCache _cache;

        private Vector3 _chaosOffset;
        private Vector3 _targetChaosOffset;
        private float _nextChaosUpdate;

        private Vector3 _anticipationDir;
        private float _nextAnticipationTime;

        private float _lastSquadBiasTime;
        private Vector3 _squadFormationBias;

        private float _nextAggressionOverlay;
        private Vector3 _lastAvoidVector;
        private float _lastAvoidUpdate;
        private const float AvoidUpdateInterval = 0.47f;

        private float _panicJitterEnd;
        private Vector3 _panicJitterVector;
        private float _panicJitterUpdate;

        private float _suppressionStressEnd;
        private Vector3 _suppressionJitter;
        private float _suppressionJitterUpdate;

        #endregion

        #region Construction

        public BotMovementTrajectoryPlanner(BotOwner bot, BotComponentCache cache)
        {
            if (!EFTPlayerUtil.IsValidBotOwner(bot) || cache == null || bot.GetPlayer == null)
                throw new ArgumentException("[BotMovementTrajectoryPlanner] invalid arguments.");

            _bot = bot;
            _cache = cache;
            _chaosOffset = Vector3.zero;
            _targetChaosOffset = Vector3.zero;
            _anticipationDir = Vector3.zero;
            _squadFormationBias = Vector3.zero;
            _lastAvoidVector = Vector3.zero;
            _panicJitterVector = Vector3.zero;
            _suppressionJitter = Vector3.zero;
        }

        #endregion

        #region Overlay Intent API

        /// <summary>
        /// Generates an event-only intent vector for overlays (never sets position or issues a move).
        /// Fully pooled, anti-NaN/Inf, squad/context/personality/panic/cover/role aware.
        /// </summary>
        public Vector3 GetOverlayIntent(Vector3 targetDir, float deltaTime)
        {
            try
            {
                const float MinMagnitude = 0.0001f;
                float now = Time.unscaledTime;
                var profile = _cache.PersonalityProfile ?? BotPersonalityProfile.Default;

                // Step 1: Base intent.
                Vector3 baseDir = (targetDir.sqrMagnitude > MinMagnitude) ? targetDir.normalized : Vector3.forward;
                Vector3 intent = baseDir;

                // Step 2: Chaos/jitter overlays (personality, panic, suppression, cover, anti-oscillation).
                if (now > _nextChaosUpdate)
                    UpdateTargetChaosOffset(now, profile);

                _chaosOffset = Vector3.Lerp(_chaosOffset, _targetChaosOffset, deltaTime * 5.2f);
                _chaosOffset.y = 0f;
                if (IsVectorValid(_chaosOffset))
                    intent += _chaosOffset;

                // Step 3: Persistent panic/suppression overlays.
                if (_cache.PanicHandler?.IsPanicking == true)
                {
                    if (now > _panicJitterUpdate)
                    {
                        _panicJitterVector = UnityEngine.Random.insideUnitSphere * UnityEngine.Random.Range(0.28f, 0.57f);
                        _panicJitterVector.y = 0f;
                        _panicJitterUpdate = now + UnityEngine.Random.Range(0.12f, 0.33f);
                        _panicJitterEnd = now + UnityEngine.Random.Range(0.6f, 1.1f);
                    }
                    if (now < _panicJitterEnd)
                        intent += _panicJitterVector;
                }
                else if (_cache.Suppression?.IsSuppressed() == true)
                {
                    if (now > _suppressionJitterUpdate)
                    {
                        _suppressionJitter = UnityEngine.Random.insideUnitSphere * UnityEngine.Random.Range(0.19f, 0.31f);
                        _suppressionJitter.y = 0f;
                        _suppressionJitterUpdate = now + UnityEngine.Random.Range(0.19f, 0.37f);
                        _suppressionStressEnd = now + UnityEngine.Random.Range(0.33f, 0.67f);
                    }
                    if (now < _suppressionStressEnd)
                        intent += _suppressionJitter;
                }

                // Step 4: Anticipation/fakeout overlays (peek/hesitation/follow-through overlays).
                TryAnticipationOverlay(baseDir, now, ref intent);

                // Step 5: Squad overlays (formation bias, role, stochastic slot jitter).
                if (_cache.SquadPath != null)
                {
                    Vector3 squadOffset = _cache.SquadPath.GetCurrentOffset();
                    if (squadOffset.sqrMagnitude > MinMagnitude && IsVectorValid(squadOffset))
                    {
                        squadOffset.y = 0f;
                        intent += squadOffset.normalized * 0.81f;
                    }
                    // Stochastic formation bias (role/slot-based random drift)
                    if (now - _lastSquadBiasTime > 1.33f)
                    {
                        _squadFormationBias = UnityEngine.Random.insideUnitSphere * 0.13f;
                        _squadFormationBias.y = 0f;
                        _lastSquadBiasTime = now;
                    }
                    intent += _squadFormationBias;
                }

                // Step 6: Anti-collision/repulsion overlays (group anti-clump).
                Vector3 avoidVector = (now > _lastAvoidUpdate + AvoidUpdateInterval) ? ComputeAvoidance(now) : _lastAvoidVector;
                if (avoidVector.sqrMagnitude > MinMagnitude && IsVectorValid(avoidVector))
                {
                    avoidVector.y = 0f;
                    intent += avoidVector.normalized * 1.14f;
                }

                // Step 7: Role-based overlays (slot left/right, squad leader bias, cover priority if leader).
                if (_bot.BotsGroup != null && _bot.BotsGroup.MembersCount > 1)
                {
                    int idx = -1;
                    for (int i = 0; i < _bot.BotsGroup.MembersCount; i++)
                        if (_bot.BotsGroup.Member(i) == _bot) { idx = i; break; }
                    if (idx >= 0)
                    {
                        float posBias = ((idx % 2 == 0) ? -1f : 1f) * 0.38f;
                        Vector3 roleOffset = Vector3.Cross(Vector3.up, baseDir) * posBias;
                        if (IsVectorValid(roleOffset))
                            intent += roleOffset;

                        // Overlay: leader gets forward micro-bias if at squad[0]
                        if (idx == 0 && UnityEngine.Random.value < 0.14f)
                            intent += baseDir * 0.13f;
                    }
                }

                // Step 8: Cover overlays (micro-align to cover edge, forward cover normal, fallback to forward).
                if (_cache.CoverPlanner != null && _cache.CoverPlanner.IsInCover)
                {
                    Vector3 coverNormal = _cache.CoverPlanner.CoverNormal;
                    if (!IsVectorValid(coverNormal) || coverNormal == Vector3.zero)
                        coverNormal = _bot.Transform != null ? _bot.Transform.right : Vector3.right;

                    Vector3 coverAlign = Vector3.ProjectOnPlane(coverNormal.normalized, Vector3.up) * 0.21f;
                    if (IsVectorValid(coverAlign))
                        intent += coverAlign;
                }

                // Step 9: Velocity/inertia overlays (carry through current movement, zero if stationary).
                Vector3 velocity = _bot.GetPlayer != null ? _bot.GetPlayer.Velocity : Vector3.zero;
                if (velocity.sqrMagnitude > MinMagnitude && IsVectorValid(velocity))
                {
                    velocity.y = 0f;
                    intent += velocity.normalized * 1.14f;
                }

                // Step 10: Micro-jitter overlay (tiny, always on, anti-macro-movement).
                Vector3 jitter = UnityEngine.Random.insideUnitSphere * 0.011f;
                jitter.y = 0f;
                intent += jitter;

                // Step 11: Aggression overlays (brief rare push forward, squad/role/personality weighted).
                float personalityAggro = Mathf.Clamp01(profile.AggressionLevel);
                if (personalityAggro > 0.57f && now > _nextAggressionOverlay && UnityEngine.Random.value < 0.11f)
                {
                    intent += baseDir * 0.11f * personalityAggro;
                    _nextAggressionOverlay = now + UnityEngine.Random.Range(2.2f, 6.7f);
                }

                // Step 12: Stuck overlay (short random nudge if mover flagged blocked).
                if (_bot.Mover?.Blocked ?? false)
                {
                    Vector3 wobble = UnityEngine.Random.insideUnitSphere * 0.23f;
                    wobble.y = 0f;
                    intent += wobble;
                }

                // Step 13: Final output clamp (anti-NaN/Inf, fallback to baseDir if <MinMag).
                if (!IsVectorValid(intent) || intent.sqrMagnitude < MinMagnitude)
                    return baseDir;
                return intent.normalized;
            }
            catch
            {
                return Vector3.forward;
            }
        }

        #endregion

        #region Internal Overlay Helpers

        private void UpdateTargetChaosOffset(float now, BotPersonalityProfile profile)
        {
            try
            {
                float chaosBase = 0.47f * (1f - Mathf.Clamp01(profile.Caution));
                float chaos = chaosBase;
                if (_cache.PanicHandler?.IsPanicking == true)
                    chaos += 0.79f;
                if (_cache.Suppression?.IsSuppressed() == true)
                    chaos += 0.33f;
                if (_cache.CoverPlanner?.IsInCover == true)
                    chaos *= 0.38f;
                chaos = Mathf.Clamp(chaos, 0.01f, 0.99f);

                float x = UnityEngine.Random.Range(-chaos * 0.47f, chaos * 0.47f);
                float z = UnityEngine.Random.Range(0.07f, chaos);
                _targetChaosOffset = new Vector3(x, 0f, z);

                _nextChaosUpdate = now + UnityEngine.Random.Range(0.19f, 0.39f);
            }
            catch
            {
                _targetChaosOffset = Vector3.zero;
                _nextChaosUpdate = now + UnityEngine.Random.Range(0.19f, 0.39f);
            }
        }

        private void TryAnticipationOverlay(Vector3 baseDir, float now, ref Vector3 adjusted)
        {
            if (now < _nextAnticipationTime)
            {
                adjusted += _anticipationDir * 0.13f;
                return;
            }

            float angle = Vector3.Angle(adjusted, baseDir);
            if (angle > 23f && UnityEngine.Random.value < 0.16f)
            {
                _anticipationDir = Quaternion.AngleAxis(UnityEngine.Random.Range(-12f, 12f), Vector3.up) * baseDir;
                _nextAnticipationTime = now + 0.36f;
                adjusted += _anticipationDir * 0.13f;
            }
        }

        private Vector3 ComputeAvoidance(float now)
        {
            try
            {
                BotsGroup group = _bot.BotsGroup;
                if (group == null || group.MembersCount <= 1)
                    return Vector3.zero;

                Vector3 self = _bot.Position;
                Vector3 repulsion = Vector3.zero;
                int count = 0;
                for (int i = 0; i < group.MembersCount; i++)
                {
                    BotOwner other = group.Member(i);
                    if (other == null || other == _bot || other.IsDead)
                        continue;

                    Vector3 offset = self - other.Position;
                    float dist = offset.magnitude;
                    if (dist < 2.13f && dist > 0.01f)
                    {
                        offset.y = 0f;
                        repulsion += offset.normalized / dist;
                        count++;
                    }
                }
                _lastAvoidVector = (count > 0) ? (repulsion / count) : Vector3.zero;
                _lastAvoidUpdate = now;
                return _lastAvoidVector;
            }
            catch
            {
                _lastAvoidVector = Vector3.zero;
                _lastAvoidUpdate = now;
                return Vector3.zero;
            }
        }

        private static bool IsVectorValid(Vector3 v)
        {
            return !float.IsNaN(v.x) && !float.IsNaN(v.y) && !float.IsNaN(v.z)
                && !float.IsInfinity(v.x) && !float.IsInfinity(v.y) && !float.IsInfinity(v.z);
        }

        #endregion
    }
}
