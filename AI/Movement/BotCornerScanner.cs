// <auto-generated>
//   This file is part of AI-Refactored, an open-source project focused on realistic AI behavior in Escape from Tarkov.
//   Licensed under the MIT License. See LICENSE in the repository root for more information.
//
//   THIS FILE IS SYSTEMATICALLY MANAGED.
//   Please follow strict StyleCop, ReSharper, and AI-Refactored code standards for all modifications.
// </auto-generated>

#nullable enable

namespace AIRefactored.AI.Movement
{
    using System;
    using AIRefactored.AI.Core;
    using AIRefactored.Core;
    using EFT;
    using UnityEngine;
    using UnityEngine.AI;

    /// <summary>
    /// Scans for edges and corners to trigger realistic lean, crouch, or pause behavior.
    /// Aggressive bots peek corners quickly, cautious bots crouch before engaging.
    /// </summary>
    public sealed class BotCornerScanner
    {
        #region Constants

        private const float BasePauseDuration = 0.4f;
        private const float BaseWallCheckDistance = 1.5f;
        private const float EdgeCheckDistance = 1.25f;
        private const float EdgeRaySpacing = 0.25f;
        private const float MinFallHeight = 2.2f;
        private const float PrepCrouchTime = 0.75f;
        private const float WallAngleThreshold = 0.7f;
        private const float WallCheckHeight = 1.5f;
        private const float NavSampleTolerance = 0.65f;

        #endregion

        #region Fields

        private BotOwner? _bot;
        private BotComponentCache? _cache;
        private BotPersonalityProfile? _profile;
        private float _pauseUntil;
        private float _prepCrouchUntil;

        private bool _isLeaning = false; // To prevent redundant lean actions
        private bool _isCrouching = false; // To prevent redundant crouch actions

        #endregion

        #region Initialization

        /// <summary>
        /// Initializes the corner scanner from the bot's component cache.
        /// </summary>
        /// <param name="cache">Bot component cache to use for context.</param>
        public void Initialize(BotComponentCache cache)
        {
            if (cache == null || cache.Bot == null || cache.AIRefactoredBotOwner == null || cache.AIRefactoredBotOwner.PersonalityProfile == null)
            {
                throw new ArgumentNullException(nameof(cache));
            }

            this._cache = cache;
            this._bot = cache.Bot;
            this._profile = cache.AIRefactoredBotOwner.PersonalityProfile;
        }

        #endregion

        #region Public Methods

        /// <summary>
        /// Scans forward edge and corners to pause, lean, or crouch tactically.
        /// </summary>
        /// <param name="time">World time for timing pauses and prep.</param>
        public void Tick(float time)
        {
            if (!this.IsEligible(time))
            {
                return;
            }

            if (this.IsApproachingEdge())
            {
                if (this._cache?.Tilt != null)
                {
                    this._cache.Tilt.Stop();
                }

                this.PauseMovement(time);
                return;
            }

            if (this.TryCornerPeekWithCrouch(time))
            {
                return;
            }

            this.ResetLean(time);
        }

        #endregion

        #region Internal Logic

        private bool IsEligible(float time)
        {
            return this._bot != null &&
                   !this._bot.IsDead &&
                   this._bot.Mover != null &&
                   this._bot.Transform != null &&
                   time >= this._pauseUntil &&
                   time >= this._prepCrouchUntil &&
                   this._bot.Memory != null &&
                   this._bot.Memory.GoalEnemy == null;
        }

        private void PauseMovement(float time)
        {
            if (this._bot == null || this._profile == null || this._bot.Mover == null)
            {
                return;
            }

            float duration = BasePauseDuration * Mathf.Clamp(0.5f + this._profile.Caution, 0.35f, 2.0f);
            this._bot.Mover.MovementPause(duration);
            this._pauseUntil = time + duration;
        }

        private bool IsApproachingEdge()
        {
            if (this._bot == null || this._bot.Transform == null)
            {
                return false;
            }

            Vector3 origin = this._bot.Position + (Vector3.up * 0.2f);
            Vector3 forward = this._bot.Transform.forward;
            Vector3 right = this._bot.Transform.right;
            int rays = Mathf.CeilToInt((EdgeCheckDistance * 2f) / EdgeRaySpacing);

            for (int i = 0; i < rays; i++)
            {
                float offset = (i - (rays / 2f)) * EdgeRaySpacing;
                Vector3 rayOrigin = origin + (right * offset) + (forward * EdgeCheckDistance);

                if (!Physics.Raycast(rayOrigin, Vector3.down, MinFallHeight, AIRefactoredLayerMasks.NavObstacleMask))
                {
                    Vector3 probe = rayOrigin + (Vector3.down * MinFallHeight);
                    NavMeshHit hit;

                    if (!NavMesh.SamplePosition(probe, out hit, 1.0f, NavMesh.AllAreas) || hit.distance > NavSampleTolerance)
                    {
                        return true;
                    }
                }
            }

            return false;
        }

        private bool TryCornerPeekWithCrouch(float time)
        {
            if (this._bot == null || this._bot.Transform == null || this._profile == null)
            {
                return false;
            }

            Vector3 origin = this._bot.Position + (Vector3.up * WallCheckHeight);
            Vector3 right = this._bot.Transform.right;
            Vector3 left = -right;
            float checkDistance = BaseWallCheckDistance + ((1f - this._profile.Caution) * 0.5f);

            if (this.CheckWall(origin, left, checkDistance))
            {
                if (!this._isCrouching && this.AttemptCrouch(time))
                {
                    this._isCrouching = true;
                    return true;
                }

                if (!this._isLeaning)
                {
                    this.TriggerLean(BotTiltType.left, time);
                    this._isLeaning = true;
                }
                return true;
            }

            if (this.CheckWall(origin, right, checkDistance))
            {
                if (!this._isCrouching && this.AttemptCrouch(time))
                {
                    this._isCrouching = true;
                    return true;
                }

                if (!this._isLeaning)
                {
                    this.TriggerLean(BotTiltType.right, time);
                    this._isLeaning = true;
                }
                return true;
            }

            return false;
        }

        private bool CheckWall(Vector3 origin, Vector3 dir, float distance)
        {
            RaycastHit hit;
            if (Physics.Raycast(origin, dir, out hit, distance, AIRefactoredLayerMasks.CoverRayMask))
            {
                return Vector3.Dot(hit.normal, dir) < WallAngleThreshold;
            }

            return false;
        }

        private bool AttemptCrouch(float time)
        {
            if (this._cache == null || this._cache.PoseController == null)
            {
                return false;
            }

            if (this._cache.PoseController.GetPoseLevel() > 30f)
            {
                this._cache.PoseController.SetCrouch();
                this._prepCrouchUntil = time + PrepCrouchTime;
                return true;
            }

            return false;
        }

        private void TriggerLean(BotTiltType side, float time)
        {
            if (this._cache?.Tilt != null)
            {
                this._cache.Tilt.Set(side);
                this.PauseMovement(time);
            }
        }

        private void ResetLean(float time)
        {
            if (this._cache != null && this._cache.Tilt != null && this._cache.Tilt._coreTilt)
            {
                this._cache.Tilt.tiltOff = time - 1f;
                this._cache.Tilt.ManualUpdate();
                this._isLeaning = false; // Reset the lean state after it's executed
            }
        }

        #endregion
    }
}
