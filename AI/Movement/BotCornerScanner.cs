// <auto-generated>
//   AI-Refactored: BotCornerScanner.cs (Supreme Arbitration Overlay/Event Edition – June 2025, Zero-Teleport Blueprint)
//   Overlay/event-only: human-like edge/corner scan and pose overlays. Arbitration-locked, pooled, multiplayer/headless-safe.
//   MIT License.
// </auto-generated>

namespace AIRefactored.AI.Movement
{
    using System;
    using AIRefactored.AI.Core;
    using AIRefactored.Core;
    using EFT;
    using UnityEngine;
    using UnityEngine.AI;

    /// <summary>
    /// Overlay/event-only: human-like lean/crouch overlays at corners/edges. Never moves/teleports/disables. Arbitration/lockout required.
    /// Fully bulletproof with max realism and squad awareness.
    /// </summary>
    public sealed class BotCornerScanner
    {
        #region Constants

        private const float WallCheckDistance = 1.5f;
        private const float EdgeCheckDistance = 1.18f;
        private const float EdgeRaySpacing = 0.26f;
        private const float MinFallHeight = 2.15f;
        private const float PrepCrouchTime = 0.75f;
        private const float WallAngleThreshold = 0.69f;
        private const float WallCheckHeight = 1.43f;
        private const float NavSampleTolerance = 0.67f;
        private const float SquadSpacing = 1.4f;
        private const float SquadScanDelay = 0.19f;
        private const float MaxScanAngle = 15f;
        private const float LeanCooldown = 0.64f;
        private const float ScanCooldown = 0.45f;

        #endregion

        #region Fields

        private BotOwner _bot;
        private BotComponentCache _cache;
        private BotPersonalityProfile _profile;

        private float _prepCrouchUntil;
        private float _lastSquadScan;
        private float _lastLeanTime;
        private float _lastScanTime;
        private bool _isLeaning;
        private bool _isCrouching;
        private bool _isInitialized;
        private float _scanTargetYaw;
        private float _scanStartTime;
        private bool _scanInProgress;

        #endregion

        #region Public API

        /// <summary>
        /// Attach and configure for this bot (called once per bot).
        /// </summary>
        public void Initialize(BotOwner bot, BotComponentCache cache)
        {
            if (!EFTPlayerUtil.IsValidBotOwner(bot) || cache == null || bot.Transform == null)
                return;

            var profile = cache.AIRefactoredBotOwner?.PersonalityProfile;
            if (profile == null)
                return;

            _bot = bot;
            _cache = cache;
            _profile = profile;
            _isInitialized = true;
        }

        /// <summary>
        /// Overlay/event: Try to apply edge/corner lean/crouch overlays (one-shot arbitration-locked).
        /// </summary>
        public void Tick(float now)
        {
            // Use BotOverlayType.Special (or assign a dedicated enum value for CornerScan if added)
            const BotOverlayType OverlayType = BotOverlayType.Special;

            try
            {
                if (!_isInitialized || _bot == null || _cache == null || _profile == null)
                    return;

                if (_bot.IsDead || _bot.Mover == null || _bot.Transform == null)
                    return;

                if (_cache.Tilt == null || _cache.PoseController == null)
                    return;

                // Arbitration: Only proceed if overlay slot is free or held by this overlay
                if (!BotOverlayManager.CanIssueMove(_bot, OverlayType))
                    return;

                // Release overlays if distracted (enemy goal or prepping crouch)
                if (_bot.Memory?.GoalEnemy != null || now < _prepCrouchUntil)
                {
                    ResetOverlays(now);
                    BotOverlayManager.ReleaseMove(_bot, OverlayType);
                    return;
                }

                // Anti-overlap: skip overlays if squad collision
                if (HandleSquadSpacing(now))
                {
                    ResetOverlays(now);
                    BotOverlayManager.ReleaseMove(_bot, OverlayType);
                    return;
                }

                bool didAny = false;

                // Lean/crouch at edge (no movement)
                if (IsApproachingEdge())
                {
                    TryEdgeLean(now);
                    didAny = true;
                }

                // Lean/crouch at corner (no movement)
                if (TryCornerPeekWithCrouch(now))
                    didAny = true;

                // Idle scan overlays (never movement)
                if (!_scanInProgress && now > _lastScanTime + ScanCooldown)
                    StartIdleScan(now);
                else if (_scanInProgress)
                    UpdateIdleScan(now);

                if (didAny)
                    BotOverlayManager.RegisterMove(_bot, OverlayType);

                // Always clean overlays & arbitration slot after execution
                ResetOverlays(now);
                BotOverlayManager.ReleaseMove(_bot, OverlayType);
            }
            catch (Exception ex)
            {
                Plugin.LoggerInstance.LogError("[BotCornerScanner] Overlay failed: " + ex);
                BotOverlayManager.ReleaseMove(_bot, OverlayType);
            }
        }

        #endregion

        #region Overlay/Scan Logic

        /// <summary>
        /// Squad collision/overlap check. Returns true if too close to squadmate (skip overlays).
        /// </summary>
        private bool HandleSquadSpacing(float now)
        {
            if (_bot?.BotsGroup == null || _bot.BotsGroup.MembersCount <= 1)
                return false;

            if (now - _lastSquadScan < SquadScanDelay)
                return false;

            Vector3 myPos = _bot.Position;

            for (int i = 0; i < _bot.BotsGroup.MembersCount; i++)
            {
                var mate = _bot.BotsGroup.Member(i);
                if (mate == null || mate == _bot || mate.IsDead)
                    continue;

                if ((mate.Position - myPos).sqrMagnitude < SquadSpacing * SquadSpacing)
                {
                    _lastSquadScan = now;
                    return true;
                }
            }
            _lastSquadScan = now;
            return false;
        }

        /// <summary>
        /// Detect if bot is at an edge/dropoff (no movement, overlay only).
        /// </summary>
        private bool IsApproachingEdge()
        {
            Vector3 origin = _bot.Position + Vector3.up * 0.2f;
            Vector3 forward = _bot.Transform.forward;
            Vector3 right = _bot.Transform.right;
            int rays = Mathf.CeilToInt((EdgeCheckDistance * 2f) / EdgeRaySpacing);

            for (int i = 0; i < rays; i++)
            {
                float offset = (i - (rays * 0.5f)) * EdgeRaySpacing;
                Vector3 rayOrigin = origin + (right * offset) + (forward * EdgeCheckDistance);

                if (!Physics.Raycast(rayOrigin, Vector3.down, MinFallHeight, AIRefactoredLayerMasks.NavObstacleMask))
                {
                    Vector3 navCheckPoint = rayOrigin + Vector3.down * MinFallHeight;
                    if (!NavMesh.SamplePosition(navCheckPoint, out NavMeshHit hit, 1.0f, NavMesh.AllAreas) || hit.distance > NavSampleTolerance)
                    {
                        if (UnityEngine.Random.value > 0.85f)
                            continue;
                        return true;
                    }
                }
            }
            return false;
        }

        /// <summary>
        /// Attempts to overlay a lean or crouch at corners, never moves.
        /// </summary>
        private bool TryCornerPeekWithCrouch(float now)
        {
            Vector3 origin = _bot.Position + Vector3.up * WallCheckHeight;
            Vector3 right = _bot.Transform.right;
            Vector3 left = -right;
            float dist = WallCheckDistance + ((1f - _profile.Caution) * 0.5f);

            if (CheckWall(origin, left, dist))
                return TriggerLeanOrCrouch(BotTiltType.left, now);

            if (CheckWall(origin, right, dist))
                return TriggerLeanOrCrouch(BotTiltType.right, now);

            return false;
        }

        /// <summary>
        /// Checks if a wall/corner is present for lean/crouch overlay.
        /// </summary>
        private bool CheckWall(Vector3 origin, Vector3 dir, float dist)
        {
            if (!Physics.Raycast(origin, dir, out RaycastHit hit, dist, AIRefactoredLayerMasks.CoverRayMask))
                return false;

            return Vector3.Dot(hit.normal, dir) < WallAngleThreshold;
        }

        /// <summary>
        /// Triggers lean or crouch overlay (rate-limited, never disables).
        /// </summary>
        private bool TriggerLeanOrCrouch(BotTiltType side, float now)
        {
            if (_profile.Caution > 0.52f && !_isCrouching && AttemptCrouch(now))
            {
                _isCrouching = true;
                return true;
            }
            if (!_isLeaning && _cache?.Tilt != null && now > _lastLeanTime + LeanCooldown)
            {
                _cache.Tilt.Set(side);
                _isLeaning = true;
                _lastLeanTime = now;
            }
            return true;
        }

        /// <summary>
        /// Attempts a crouch overlay for realistic peek (rate-limited).
        /// </summary>
        private bool AttemptCrouch(float now)
        {
            if (_cache?.PoseController != null && _cache.PoseController.GetPoseLevel() > 30f)
            {
                _cache.PoseController.SetCrouch();
                _prepCrouchUntil = now + PrepCrouchTime;
                return true;
            }
            return false;
        }

        /// <summary>
        /// Human-like idle scan/peek overlays (never moves).
        /// </summary>
        private void StartIdleScan(float now)
        {
            _scanTargetYaw = UnityEngine.Random.Range(-MaxScanAngle, MaxScanAngle);
            _scanStartTime = now;
            _scanInProgress = true;
            _lastScanTime = now;
        }

        /// <summary>
        /// Update/cancel scan overlay (no snap, never moves).
        /// </summary>
        private void UpdateIdleScan(float now)
        {
            _scanInProgress = false;
        }

        /// <summary>
        /// Small lean overlay at edge, if eligible (never disables).
        /// </summary>
        private void TryEdgeLean(float now)
        {
            if (!_isLeaning && _cache?.Tilt != null && now > _lastLeanTime + LeanCooldown)
            {
                BotTiltType side = UnityEngine.Random.value > 0.5f ? BotTiltType.left : BotTiltType.right;
                _cache.Tilt.Set(side);
                _isLeaning = true;
                _lastLeanTime = now;
            }
        }

        /// <summary>
        /// Reset overlays after scan cycle (or on arbitration release/error).
        /// </summary>
        private void ResetOverlays(float now)
        {
            try
            {
                if (_cache?.Tilt != null && _cache.Tilt._coreTilt)
                {
                    _cache.Tilt.tiltOff = now - 1f;
                    _cache.Tilt.ManualUpdate();
                }
            }
            catch { }
            _isLeaning = false;
            _isCrouching = false;
            _scanInProgress = false;
        }

        #endregion
    }
}
