// <auto-generated>
//   AI-Refactored: MovementIntentDispatcher.cs (Ultra-Realism Overlay/Intent-Only Dispatcher, Supreme Arbitration Edition – June 2025)
//   Overlay/event-only. No bot movement, no pathing, intent only. Bulletproof: squad/mission deduped, anti-loop, anti-cluster, error-shielded, mission/squad overlays, anti-spam. 
//   All state managed via BotMoveCache API. Zero alloc hot path. SPT/FIKA/headless safe.
//   MIT License.
// </auto-generated>

namespace AIRefactored.AI.Movement
{
    using AIRefactored.AI.Core;
    using AIRefactored.AI.Helpers;
    using AIRefactored.AI.Missions.Subsystems;
    using AIRefactored.AI.Threads;
    using AIRefactored.Pools;
    using BepInEx.Logging;
    using EFT;
    using System;
    using System.Collections.Generic;
    using UnityEngine;
    using UnityEngine.AI;

    /// <summary>
    /// Overlay/event intent dispatcher for bot movement overlays/intents.
    /// All requests deduped, anti-spam, squad/mission overlays enforced, bulletproof error isolation.
    /// All state/telemetry updated via BotMoveCache API. No navigation ever issued.
    /// </summary>
    public static class MovementIntentDispatcher
    {
        #region Internal State

        private static readonly Dictionary<BotOwner, IntentState> IntentQueue = new Dictionary<BotOwner, IntentState>(64);
        private static readonly ManualLogSource Logger = Plugin.LoggerInstance;

        #endregion

        #region Public API

        /// <summary>
        /// Request an overlay-only movement intent for a bot (never direct navigation).
        /// Dedupes, squad/mission overlays enforced, all logic is error-isolated.
        /// </summary>
        public static void RequestMove(BotOwner bot, Vector3 target, MoveType type, bool force = false)
        {
            if (!IsValidBot(bot)) return;
            var cache = bot.GetComponent<BotComponentCache>();
            if (cache == null || bot.IsDead) return;

            // Dedup/replace old, block redundant or lower-priority unless forced
            if (IntentQueue.TryGetValue(bot, out var prev))
            {
                if (!force && prev.Type >= type && (prev.Target - target).sqrMagnitude < 0.08f)
                    return;
                CancelIntent(bot, "Superseded by higher priority or new target.");
            }

            // All overlays validated pre-issue
            if (!PreValidateMove(bot, target, type, out string failReason, force))
            {
                Logger.LogDebug($"[MoveIntent] PreValidate failed for {bot.ProfileId}: {failReason}");
                return;
            }

            var intent = IntentState.Create(bot, target, type, force);
            IntentQueue[bot] = intent;

            float anticipation = GetAnticipationDelay(bot, type, force);
            BotBrain.ScheduleAfter(bot, anticipation, () => ProcessIntent(bot, intent));
        }

        /// <summary>
        /// Cancel any pending overlay-only intent for a bot.
        /// </summary>
        public static void CancelIntent(BotOwner bot, string reason = null)
        {
            if (bot == null) return;
            if (IntentQueue.Remove(bot) && reason != null)
                Logger.LogDebug($"[MoveIntent] Cancelled for {bot.ProfileId}: {reason}");
        }

        /// <summary>
        /// Clears all overlay-only intent states (e.g., on world teardown).
        /// </summary>
        public static void ClearAll() => IntentQueue.Clear();

        #endregion

        #region Intent Processing

        /// <summary>
        /// Overlay-only: On anticipation expiry, updates intent via BotMoveCache API. Never issues movement/GoTo.
        /// </summary>
        private static void ProcessIntent(BotOwner bot, IntentState intent)
        {
            if (bot == null || bot.IsDead) { IntentQueue.Remove(bot); return; }
            if (!IntentQueue.TryGetValue(bot, out var pending) || !ReferenceEquals(intent, pending))
                return;

            string squadBlockReason = "";
            if (IsMovementPaused(bot) || MovementBlockedBySquad(bot, intent, out squadBlockReason))
            {
                CancelIntent(bot, $"Paused or squad-blocked at anticipation expiry: {squadBlockReason}");
                return;
            }

            if (!PreValidateMove(bot, intent.Target, intent.Type, out string failReason, intent.Force))
            {
                CancelIntent(bot, $"Revalidate failed: {failReason}");
                return;
            }

            try
            {
                var cache = bot.GetComponent<BotComponentCache>();
                if (cache != null && cache.MoveCache != null)
                {
                    // Correct signature: (target, now, context, overlay, intentType, squadId, meta)
                    cache.MoveCache.AuditMove(
                        intent.Target,
                        Time.time,
                        intent.Type.ToString(),
                        GetOverlayTypeForMove(intent.Type),
                        (int)intent.Type,
                        bot.BotsGroup != null ? bot.BotsGroup.GetHashCode() : 0,
                        ""
                    );
                }

                // Trigger overlays: squad/voice if group-sensitive
                if (cache?.GroupComms != null && intent.Type == MoveType.Flank && UnityEngine.Random.value < 0.17f)
                    cache.GroupComms.Say(EPhraseTrigger.FollowMe);

                if (cache?.GroupComms != null && intent.Type == MoveType.Extract && UnityEngine.Random.value < 0.19f)
                    cache.GroupComms.Say(EPhraseTrigger.ExitLocated);

                Logger.LogDebug($"[MoveIntent] Overlay intent committed: {bot.ProfileId} → {intent.Target} ({intent.Type})");
            }
            catch (Exception ex)
            {
                Logger.LogError($"[MoveIntent] Exception on overlay intent: {ex}");
            }
            finally
            {
                IntentQueue.Remove(bot);
            }
        }

        #endregion

        #region Helpers & Validation

        private static bool IsValidBot(BotOwner bot)
        {
            return bot != null && !bot.IsDead && bot.GetPlayer != null;
        }

        private static bool PreValidateMove(BotOwner bot, Vector3 target, MoveType type, out string reason, bool force = false)
        {
            reason = "";
            var cache = bot.GetComponent<BotComponentCache>();
            if (cache == null) { reason = "No cache"; return false; }
            if (BotMovementHelper.IsMovementPaused(bot)) { reason = "Paused"; return false; }
            if (!force && (BotMovementHelper.GetPosition(bot) - target).sqrMagnitude < 0.057f)
            { reason = "Too close"; return false; }

            float cooldown = type == MoveType.Retreat ? 0.82f : 1.12f;
            if (!force && cache.MoveCache.HasRecentMove(Time.time, cooldown))
            { reason = "Cooldown"; return false; }

            if (!NavMesh.SamplePosition(target, out var navHit, 1.5f, NavMesh.AllAreas))
            { reason = "NavMesh invalid"; return false; }

            string squadBlockReason = "";
            if (!force && MovementBlockedBySquad(bot, IntentState.Temp(bot, target, type), out squadBlockReason))
            { reason = squadBlockReason; return false; }

            if (cache.MissionEvaluator != null && !cache.MissionEvaluator.IsGroupAligned())
            {
                reason = "Waiting for squad cohesion";
                return false;
            }

            return true;
        }

        private static float GetAnticipationDelay(BotOwner bot, MoveType type, bool force)
        {
            if (force) return UnityEngine.Random.Range(0.01f, 0.08f);
            float baseDelay = type == MoveType.Engage ? 0.19f : type == MoveType.Retreat ? 0.12f : 0.43f;
            var cache = bot.GetComponent<BotComponentCache>();
            float jitter = UnityEngine.Random.Range(0.0f, 0.21f);
            float personality = cache?.PersonalityProfile != null ? (1.17f - cache.PersonalityProfile.ReactionSpeed * 0.47f) : 1f;
            return Mathf.Clamp(baseDelay * personality + jitter, 0.1f, 1.17f);
        }

        private static bool IsMovementPaused(BotOwner bot)
        {
            return BotMovementHelper.IsMovementPaused(bot);
        }

        private static bool MovementBlockedBySquad(BotOwner bot, IntentState intent, out string reason)
        {
            reason = "";
            try
            {
                BotsGroup group = bot?.BotsGroup;
                if (group == null || group.MembersCount <= 1) return false;

                Vector3 intentPos = intent.Target;
                float minSpacing = 1.67f;

                for (int i = 0; i < group.MembersCount; i++)
                {
                    var mate = group.Member(i);
                    if (mate == null || mate == bot || mate.IsDead) continue;

                    if (IntentQueue.TryGetValue(mate, out var mateIntent))
                    {
                        if ((mateIntent.Target - intentPos).sqrMagnitude < minSpacing * minSpacing)
                        {
                            reason = $"Squad overlap with {mate.ProfileId}";
                            return true;
                        }
                    }
                    var mateCache = mate.GetComponent<BotComponentCache>();
                    if (mateCache != null && mateCache.MoveCache != null)
                    {
                        Vector3 lastTarget = mateCache.MoveCache.LastIssuedTarget;
                        if ((lastTarget - intentPos).sqrMagnitude < minSpacing * minSpacing)
                        {
                            reason = $"Squad overlap (recent move) with {mate.ProfileId}";
                            return true;
                        }
                    }
                }
            }
            catch (Exception ex)
            {
                reason = "Squad logic error: " + ex.Message;
                return true;
            }
            return false;
        }

        /// <summary>
        /// Maps MoveType to BotOverlayType for overlay arbitration and move cache auditing.
        /// </summary>
        private static BotOverlayType GetOverlayTypeForMove(MoveType type)
        {
            switch (type)
            {
                case MoveType.Idle: return BotOverlayType.Idle;
                case MoveType.Patrol: return BotOverlayType.Patrol;
                case MoveType.Engage: return BotOverlayType.Engage;
                case MoveType.Retreat: return BotOverlayType.Retreat;
                case MoveType.Flank: return BotOverlayType.Flank;
                case MoveType.Cover: return BotOverlayType.Cover;
                case MoveType.Extract: return BotOverlayType.Extract;
                default: return BotOverlayType.None;
            }
        }

        #endregion

        #region Intent State

        /// <summary>
        /// Overlay-only: tracks intended position/type for overlays, never for navigation.
        /// </summary>
        private sealed class IntentState
        {
            public BotOwner Bot;
            public Vector3 Target;
            public MoveType Type;
            public float Cohesion;
            public bool Force;

            private IntentState() { }

            public static IntentState Create(BotOwner bot, Vector3 target, MoveType type, bool force = false)
            {
                var state = new IntentState();
                state.Bot = bot;
                state.Target = target;
                state.Type = type;
                state.Cohesion = 1.0f;
                state.Force = force;
                return state;
            }

            public static IntentState Temp(BotOwner bot, Vector3 target, MoveType type)
            {
                var temp = new IntentState();
                temp.Bot = bot;
                temp.Target = target;
                temp.Type = type;
                temp.Cohesion = 1.0f;
                temp.Force = false;
                return temp;
            }
        }

        /// <summary>
        /// Overlay-only move intent types.
        /// </summary>
        public enum MoveType
        {
            Idle = 0,
            Patrol = 1,
            Engage = 2,
            Retreat = 3,
            Flank = 4,
            Cover = 5,
            Extract = 6
        }

        #endregion
    }
}
