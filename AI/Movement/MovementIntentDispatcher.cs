// <auto-generated>
//   AI-Refactored: MovementIntentDispatcher.cs (Ultra-Platinum++ Edition, June 2025)
//   Fully integrated MissionEvaluator overlays. All other overlays ready for future expansion. No missing registry references.
//   MIT License.
// </auto-generated>

namespace AIRefactored.AI.Movement
{
    using System;
    using System.Collections.Generic;
    using AIRefactored.AI.Core;
    using AIRefactored.AI.Helpers;
    using AIRefactored.AI.Missions.Subsystems;
    using AIRefactored.AI.Threads;
    using AIRefactored.Pools;
    using BepInEx.Logging;
    using EFT;
    using UnityEngine;
    using UnityEngine.AI;

    /// <summary>
    /// Event-driven, anti-spam, anticipation-based dispatcher for bot movement intents.
    /// Fully integrated with MissionEvaluator overlays. Future overlays are stubbed for safe expansion.
    /// </summary>
    public static class MovementIntentDispatcher
    {
        #region Internal State

        private static readonly Dictionary<BotOwner, IntentState> IntentQueue = new Dictionary<BotOwner, IntentState>(64);
        private static readonly ManualLogSource Logger = Plugin.LoggerInstance;

        #endregion

        #region Public API

        public static void RequestMove(BotOwner bot, Vector3 target, MoveType type, bool force = false)
        {
            if (!IsValidBot(bot)) return;
            var cache = bot.GetComponent<BotComponentCache>();
            if (cache == null || bot.IsDead) return;

            if (IntentQueue.TryGetValue(bot, out var prev))
            {
                if (!force && prev.Type >= type && (prev.Target - target).sqrMagnitude < 0.09f)
                    return;
                CancelIntent(bot, "Superseded by higher priority or new target.");
            }

            if (!PreValidateMove(bot, target, type, out string failReason, force))
            {
                Logger.LogDebug($"[MoveIntent] PreValidate failed: {failReason}");
                return;
            }

            var intent = IntentState.Create(bot, target, type, force);
            IntentQueue[bot] = intent;

            float anticipation = GetAnticipationDelay(bot, type, force);
            BotBrain.ScheduleAfter(bot, anticipation, () => ProcessIntent(bot, intent));
        }

        public static void CancelIntent(BotOwner bot, string reason = null)
        {
            if (bot == null) return;
            if (IntentQueue.Remove(bot) && reason != null)
                Logger.LogDebug($"[MoveIntent] Cancelled for {bot.ProfileId}: {reason}");
        }

        public static void ClearAll() => IntentQueue.Clear();

        #endregion

        #region Intent Processing

        private static void ProcessIntent(BotOwner bot, IntentState intent)
        {
            if (bot == null || bot.IsDead) { IntentQueue.Remove(bot); return; }
            if (!IntentQueue.TryGetValue(bot, out var pending) || !ReferenceEquals(intent, pending))
                return;

            string squadBlockReason = "";
            if (IsMovementPaused(bot) || MovementBlockedBySquad(bot, intent, out squadBlockReason))
            {
                CancelIntent(bot, $"Paused/squad-blocked at anticipation expiry: {squadBlockReason}");
                return;
            }

            if (!PreValidateMove(bot, intent.Target, intent.Type, out string failReason, intent.Force))
            {
                CancelIntent(bot, $"Revalidate failed: {failReason}");
                return;
            }

            try
            {
                BotMovementHelper.SmoothMoveToSafe(bot, intent.Target, slow: true, cohesion: intent.Cohesion);
                Logger.LogDebug($"[MoveIntent] Committed: {bot.ProfileId} → {intent.Target} ({intent.Type})");
            }
            catch (Exception ex)
            {
                Logger.LogError($"[MoveIntent] Exception on move commit: {ex}");
            }
            finally
            {
                IntentQueue.Remove(bot);
            }
        }

        #endregion

        #region Helpers & Validation

        private static bool IsValidBot(BotOwner bot)
        {
            return bot != null && !bot.IsDead && bot.GetPlayer != null;
        }

        /// <summary>
        /// Full validation: MissionEvaluator overlays enabled, all other overlays are stubbed out for safe future expansion.
        /// </summary>
        private static bool PreValidateMove(BotOwner bot, Vector3 target, MoveType type, out string reason, bool force = false)
        {
            reason = "";
            var cache = bot.GetComponent<BotComponentCache>();
            if (cache == null) { reason = "No cache"; return false; }

            if (BotMovementHelper.IsMovementPaused(bot)) { reason = "Paused"; return false; }
            if (!force && (BotMovementHelper.GetPosition(bot) - target).sqrMagnitude < 0.0625f)
            { reason = "Too close"; return false; }

            float cooldown = type == MoveType.Retreat ? 0.8f : 1.2f;
            if (!force && (Time.time - cache.MoveCache.LastMoveTime < cooldown))
            { reason = "Cooldown"; return false; }

            if (!NavMesh.SamplePosition(target, out var navHit, 1.5f, NavMesh.AllAreas)) { reason = "NavMesh invalid"; return false; }

            string squadBlockReason = "";
            if (!force && MovementBlockedBySquad(bot, IntentState.Temp(bot, target, type), out squadBlockReason))
            { reason = squadBlockReason; return false; }

            // MISSION OVERLAY: Use MissionEvaluator for squad/mission/intent checks
            if (cache.MissionEvaluator != null)
            {
                // Prevent movement if group is not aligned (prevents bots leaving squad behind)
                if (!cache.MissionEvaluator.IsGroupAligned())
                {
                    reason = "Waiting for squad cohesion";
                    return false;
                }
            }

            // --- Stubs for overlays you don't have. Uncomment/replace as you add registry systems ---
            // if (TryIsCoverSlotTaken(target, bot)) { reason = "Cover slot taken"; return false; }
            // if (TryIsExtractionOvercrowded(target, bot)) { reason = "Extraction blocked"; return false; }
            // if (TryIsInCrossfire(target)) { reason = "Crossfire risk"; return false; }
            // if (TryIsNearActiveGrenade(target)) { reason = "Grenade hazard"; return false; }

            return true;
        }

        private static float GetAnticipationDelay(BotOwner bot, MoveType type, bool force)
        {
            if (force) return UnityEngine.Random.Range(0.01f, 0.08f);
            float baseDelay = type == MoveType.Engage ? 0.2f : type == MoveType.Retreat ? 0.12f : 0.45f;
            var cache = bot.GetComponent<BotComponentCache>();
            float jitter = UnityEngine.Random.Range(0.0f, 0.25f);
            float personality = cache?.PersonalityProfile != null ? (1.2f - cache.PersonalityProfile.ReactionSpeed * 0.5f) : 1f;
            return Mathf.Clamp(baseDelay * personality + jitter, 0.1f, 1.2f);
        }

        private static bool IsMovementPaused(BotOwner bot)
        {
            return BotMovementHelper.IsMovementPaused(bot);
        }

        private static bool MovementBlockedBySquad(BotOwner bot, IntentState intent, out string reason)
        {
            reason = "";
            try
            {
                BotsGroup group = bot?.BotsGroup;
                if (group == null || group.MembersCount <= 1) return false;

                Vector3 intentPos = intent.Target;
                float minSpacing = 1.7f;

                for (int i = 0; i < group.MembersCount; i++)
                {
                    var mate = group.Member(i);
                    if (mate == null || mate == bot || mate.IsDead) continue;

                    if (IntentQueue.TryGetValue(mate, out var mateIntent))
                    {
                        if ((mateIntent.Target - intentPos).sqrMagnitude < minSpacing * minSpacing)
                        {
                            reason = $"Squad overlap with {mate.ProfileId}";
                            return true;
                        }
                    }
                    var mateCache = mate.GetComponent<BotComponentCache>();
                    if (mateCache != null)
                    {
                        Vector3 lastTarget = mateCache.MoveCache?.LastIssuedTarget ?? mate.Position;
                        if ((lastTarget - intentPos).sqrMagnitude < minSpacing * minSpacing)
                        {
                            reason = $"Squad overlap (recent move) with {mate.ProfileId}";
                            return true;
                        }
                    }
                }
            }
            catch (Exception ex)
            {
                reason = "Squad logic error: " + ex.Message;
                return true;
            }
            return false;
        }

        #endregion

        #region Intent State

        private sealed class IntentState
        {
            public BotOwner Bot;
            public Vector3 Target;
            public MoveType Type;
            public float Cohesion;
            public bool Force;

            private IntentState() { }

            public static IntentState Create(BotOwner bot, Vector3 target, MoveType type, bool force = false)
            {
                var state = new IntentState();
                state.Bot = bot;
                state.Target = target;
                state.Type = type;
                state.Cohesion = 1.0f;
                state.Force = force;
                return state;
            }

            public static IntentState Temp(BotOwner bot, Vector3 target, MoveType type)
            {
                var temp = new IntentState();
                temp.Bot = bot;
                temp.Target = target;
                temp.Type = type;
                temp.Cohesion = 1.0f;
                temp.Force = false;
                return temp;
            }
        }

        public enum MoveType
        {
            Idle = 0,
            Patrol = 1,
            Engage = 2,
            Retreat = 3,
            Flank = 4,
            Cover = 5,
            Extract = 6
        }

        #endregion
    }
}
