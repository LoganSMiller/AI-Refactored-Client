// <auto-generated>
//   AI-Refactored: MovementIntentDispatcher.cs (Ultra-Realism Overlay/Intent-Only Dispatcher, June 2025)
//   Never moves bots directly. Only overlay/event intent. 
//   Bulletproof: squad/mission deduped, anti-spam, squad/mission/cooldown/error isolated. 
//   MIT License.
// </auto-generated>

namespace AIRefactored.AI.Movement
{
    using System;
    using System.Collections.Generic;
    using AIRefactored.AI.Core;
    using AIRefactored.AI.Helpers;
    using AIRefactored.AI.Missions.Subsystems;
    using AIRefactored.AI.Threads;
    using AIRefactored.Pools;
    using BepInEx.Logging;
    using EFT;
    using UnityEngine;
    using UnityEngine.AI;

    /// <summary>
    /// Overlay/event intent dispatcher. No direct navigation or GoTo; intent only.
    /// All requests deduped, anti-spam, squad/mission safe, bulletproof error isolation.
    /// </summary>
    public static class MovementIntentDispatcher
    {
        #region Internal State

        private static readonly Dictionary<BotOwner, IntentState> IntentQueue = new Dictionary<BotOwner, IntentState>(64);
        private static readonly ManualLogSource Logger = Plugin.LoggerInstance;

        #endregion

        #region Public API

        /// <summary>
        /// Request an overlay-only movement intent for a bot (never direct navigation).
        /// Dedupes, squad/mission overlays enforced, all logic is error-isolated.
        /// </summary>
        public static void RequestMove(BotOwner bot, Vector3 target, MoveType type, bool force = false)
        {
            if (!IsValidBot(bot)) return;
            var cache = bot.GetComponent<BotComponentCache>();
            if (cache == null || bot.IsDead) return;

            if (IntentQueue.TryGetValue(bot, out var prev))
            {
                if (!force && prev.Type >= type && (prev.Target - target).sqrMagnitude < 0.09f)
                    return;
                CancelIntent(bot, "Superseded by higher priority or new target.");
            }

            if (!PreValidateMove(bot, target, type, out string failReason, force))
            {
                Logger.LogDebug($"[MoveIntent] PreValidate failed: {failReason}");
                return;
            }

            var intent = IntentState.Create(bot, target, type, force);
            IntentQueue[bot] = intent;

            float anticipation = GetAnticipationDelay(bot, type, force);
            BotBrain.ScheduleAfter(bot, anticipation, () => ProcessIntent(bot, intent));
        }

        /// <summary>
        /// Cancel any pending overlay-only intent for a bot.
        /// </summary>
        public static void CancelIntent(BotOwner bot, string reason = null)
        {
            if (bot == null) return;
            if (IntentQueue.Remove(bot) && reason != null)
                Logger.LogDebug($"[MoveIntent] Cancelled for {bot.ProfileId}: {reason}");
        }

        /// <summary>
        /// Clears all overlay-only intent states (e.g., on world teardown).
        /// </summary>
        public static void ClearAll() => IntentQueue.Clear();

        #endregion

        #region Intent Processing

        /// <summary>
        /// Overlay-only: On anticipation expiry, updates intent. Never issues movement/GoTo.
        /// </summary>
        private static void ProcessIntent(BotOwner bot, IntentState intent)
        {
            if (bot == null || bot.IsDead) { IntentQueue.Remove(bot); return; }
            if (!IntentQueue.TryGetValue(bot, out var pending) || !ReferenceEquals(intent, pending))
                return;

            string squadBlockReason = "";
            if (IsMovementPaused(bot) || MovementBlockedBySquad(bot, intent, out squadBlockReason))
            {
                CancelIntent(bot, $"Paused or squad-blocked at anticipation expiry: {squadBlockReason}");
                return;
            }

            if (!PreValidateMove(bot, intent.Target, intent.Type, out string failReason, intent.Force))
            {
                CancelIntent(bot, $"Revalidate failed: {failReason}");
                return;
            }

            // --------- OVERLAY INTENT ONLY (Never issues move!) ----------
            try
            {
                var cache = bot.GetComponent<BotComponentCache>();
                if (cache != null && cache.MoveCache != null)
                {
                    cache.MoveCache.LastIssuedTarget = intent.Target;
                    cache.MoveCache.LastMoveTime = Time.time;
                    cache.MoveCache.LastMoveContext = intent.Type.ToString();
                    cache.MoveCache.LastMoveIntentType = (int)intent.Type;
                }
                Logger.LogDebug($"[MoveIntent] Overlay intent committed: {bot.ProfileId} → {intent.Target} ({intent.Type})");
            }
            catch (Exception ex)
            {
                Logger.LogError($"[MoveIntent] Exception on overlay intent: {ex}");
            }
            finally
            {
                IntentQueue.Remove(bot);
            }
        }

        #endregion

        #region Helpers & Validation

        private static bool IsValidBot(BotOwner bot)
        {
            return bot != null && !bot.IsDead && bot.GetPlayer != null;
        }

        /// <summary>
        /// Overlay/intent-only: NavMesh/sample used for intent overlays only (never direct movement).
        /// </summary>
        private static bool PreValidateMove(BotOwner bot, Vector3 target, MoveType type, out string reason, bool force = false)
        {
            reason = "";
            var cache = bot.GetComponent<BotComponentCache>();
            if (cache == null) { reason = "No cache"; return false; }

            if (BotMovementHelper.IsMovementPaused(bot)) { reason = "Paused"; return false; }
            if (!force && (BotMovementHelper.GetPosition(bot) - target).sqrMagnitude < 0.0625f)
            { reason = "Too close"; return false; }

            float cooldown = type == MoveType.Retreat ? 0.8f : 1.2f;
            if (!force && (Time.time - cache.MoveCache.LastMoveTime < cooldown))
            { reason = "Cooldown"; return false; }

            if (!NavMesh.SamplePosition(target, out var navHit, 1.5f, NavMesh.AllAreas)) { reason = "NavMesh invalid"; return false; }

            string squadBlockReason = "";
            if (!force && MovementBlockedBySquad(bot, IntentState.Temp(bot, target, type), out squadBlockReason))
            { reason = squadBlockReason; return false; }

            if (cache.MissionEvaluator != null)
            {
                if (!cache.MissionEvaluator.IsGroupAligned())
                {
                    reason = "Waiting for squad cohesion";
                    return false;
                }
            }
            // TODO: Add more overlays (cover slot, extract crowd) as needed.

            return true;
        }

        /// <summary>
        /// Returns a context/personality adjusted anticipation delay (for overlay intent, never for movement).
        /// </summary>
        private static float GetAnticipationDelay(BotOwner bot, MoveType type, bool force)
        {
            if (force) return UnityEngine.Random.Range(0.01f, 0.08f);
            float baseDelay = type == MoveType.Engage ? 0.2f : type == MoveType.Retreat ? 0.12f : 0.45f;
            var cache = bot.GetComponent<BotComponentCache>();
            float jitter = UnityEngine.Random.Range(0.0f, 0.25f);
            float personality = cache?.PersonalityProfile != null ? (1.2f - cache.PersonalityProfile.ReactionSpeed * 0.5f) : 1f;
            return Mathf.Clamp(baseDelay * personality + jitter, 0.1f, 1.2f);
        }

        private static bool IsMovementPaused(BotOwner bot)
        {
            return BotMovementHelper.IsMovementPaused(bot);
        }

        /// <summary>
        /// Overlay-only: Checks if another squad member is already targeting this spot, or too close (anti-cluster).
        /// </summary>
        private static bool MovementBlockedBySquad(BotOwner bot, IntentState intent, out string reason)
        {
            reason = "";
            try
            {
                BotsGroup group = bot?.BotsGroup;
                if (group == null || group.MembersCount <= 1) return false;

                Vector3 intentPos = intent.Target;
                float minSpacing = 1.7f;

                for (int i = 0; i < group.MembersCount; i++)
                {
                    var mate = group.Member(i);
                    if (mate == null || mate == bot || mate.IsDead) continue;

                    if (IntentQueue.TryGetValue(mate, out var mateIntent))
                    {
                        if ((mateIntent.Target - intentPos).sqrMagnitude < minSpacing * minSpacing)
                        {
                            reason = $"Squad overlap with {mate.ProfileId}";
                            return true;
                        }
                    }
                    var mateCache = mate.GetComponent<BotComponentCache>();
                    if (mateCache != null)
                    {
                        Vector3 lastTarget = mateCache.MoveCache?.LastIssuedTarget ?? mate.Position;
                        if ((lastTarget - intentPos).sqrMagnitude < minSpacing * minSpacing)
                        {
                            reason = $"Squad overlap (recent move) with {mate.ProfileId}";
                            return true;
                        }
                    }
                }
            }
            catch (Exception ex)
            {
                reason = "Squad logic error: " + ex.Message;
                return true;
            }
            return false;
        }

        #endregion

        #region Intent State

        /// <summary>
        /// Overlay-only: tracks intended position/type for overlays, never for navigation.
        /// </summary>
        private sealed class IntentState
        {
            public BotOwner Bot;
            public Vector3 Target;
            public MoveType Type;
            public float Cohesion;
            public bool Force;

            private IntentState() { }

            public static IntentState Create(BotOwner bot, Vector3 target, MoveType type, bool force = false)
            {
                var state = new IntentState();
                state.Bot = bot;
                state.Target = target;
                state.Type = type;
                state.Cohesion = 1.0f;
                state.Force = force;
                return state;
            }

            public static IntentState Temp(BotOwner bot, Vector3 target, MoveType type)
            {
                var temp = new IntentState();
                temp.Bot = bot;
                temp.Target = target;
                temp.Type = type;
                temp.Cohesion = 1.0f;
                temp.Force = false;
                return temp;
            }
        }

        /// <summary>
        /// Overlay-only move intent types.
        /// </summary>
        public enum MoveType
        {
            Idle = 0,
            Patrol = 1,
            Engage = 2,
            Retreat = 3,
            Flank = 4,
            Cover = 5,
            Extract = 6
        }

        #endregion
    }
}
