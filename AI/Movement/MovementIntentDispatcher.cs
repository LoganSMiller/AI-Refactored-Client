// <auto-generated>
//   AI-Refactored: MovementIntentDispatcher.cs (Overlay/Intent-Only, June 2025)
//   Never directly moves bots. All requests are overlay/event intent only.
//   Squad/mission overlays enforced. Bulletproof, deduped, error-isolated. MIT License.
// </auto-generated>

namespace AIRefactored.AI.Movement
{
    using System;
    using System.Collections.Generic;
    using AIRefactored.AI.Core;
    using AIRefactored.AI.Helpers;
    using AIRefactored.AI.Missions.Subsystems;
    using AIRefactored.AI.Threads;
    using AIRefactored.Pools;
    using BepInEx.Logging;
    using EFT;
    using UnityEngine;
    using UnityEngine.AI;

    /// <summary>
    /// Overlay/event intent dispatcher. No direct navigation, GoTo, or movement.
    /// All requests are overlay-only, 100% intent, deduped, anti-spam, squad/mission validated.
    /// </summary>
    public static class MovementIntentDispatcher
    {
        #region Internal State

        // Overlay-only, never used for direct navigation. Tracks intent only.
        private static readonly Dictionary<BotOwner, IntentState> IntentQueue = new Dictionary<BotOwner, IntentState>(64);
        private static readonly ManualLogSource Logger = Plugin.LoggerInstance;

        #endregion

        #region Public API

        /// <summary>
        /// Request a movement overlay intent. Never directly moves the bot, only updates intent for overlay systems.
        /// </summary>
        public static void RequestMove(BotOwner bot, Vector3 target, MoveType type, bool force = false)
        {
            if (!IsValidBot(bot)) return;
            var cache = bot.GetComponent<BotComponentCache>();
            if (cache == null || bot.IsDead) return;

            if (IntentQueue.TryGetValue(bot, out var prev))
            {
                if (!force && prev.Type >= type && (prev.Target - target).sqrMagnitude < 0.09f)
                    return;
                CancelIntent(bot, "Superseded by higher priority or new target.");
            }

            if (!PreValidateMove(bot, target, type, out string failReason, force))
            {
                Logger.LogDebug($"[MoveIntent] PreValidate failed: {failReason}");
                return;
            }

            var intent = IntentState.Create(bot, target, type, force);
            IntentQueue[bot] = intent;

            float anticipation = GetAnticipationDelay(bot, type, force);
            BotBrain.ScheduleAfter(bot, anticipation, () => ProcessIntent(bot, intent));
        }

        public static void CancelIntent(BotOwner bot, string reason = null)
        {
            if (bot == null) return;
            if (IntentQueue.Remove(bot) && reason != null)
                Logger.LogDebug($"[MoveIntent] Cancelled for {bot.ProfileId}: {reason}");
        }

        public static void ClearAll() => IntentQueue.Clear();

        #endregion

        #region Intent Processing

        /// <summary>
        /// Overlay/event-only: On anticipation, updates intent only. No direct movement/GoTo ever.
        /// </summary>
        private static void ProcessIntent(BotOwner bot, IntentState intent)
        {
            if (bot == null || bot.IsDead) { IntentQueue.Remove(bot); return; }
            if (!IntentQueue.TryGetValue(bot, out var pending) || !ReferenceEquals(intent, pending))
                return;

            string squadBlockReason = "";
            if (IsMovementPaused(bot) || MovementBlockedBySquad(bot, intent, out squadBlockReason))
            {
                CancelIntent(bot, $"Paused/squad-blocked at anticipation expiry: {squadBlockReason}");
                return;
            }

            if (!PreValidateMove(bot, intent.Target, intent.Type, out string failReason, intent.Force))
            {
                CancelIntent(bot, $"Revalidate failed: {failReason}");
                return;
            }

            // ---- OVERLAY/INTENT ONLY ----
            // All overlays/systems are event-driven. Never GoTo or teleport the bot.
            // Instead, set the MoveIntent data on the cache for overlay system to act on.
            try
            {
                var cache = bot.GetComponent<BotComponentCache>();
                if (cache != null && cache.MoveCache != null)
                {
                    cache.MoveCache.LastIssuedTarget = intent.Target;
                    cache.MoveCache.LastMoveTime = Time.time;
                    cache.MoveCache.LastMoveContext = intent.Type.ToString();
                    cache.MoveCache.LastMoveIntentType = (int)intent.Type;
                }
                Logger.LogDebug($"[MoveIntent] Overlay intent committed: {bot.ProfileId} → {intent.Target} ({intent.Type})");
            }
            catch (Exception ex)
            {
                Logger.LogError($"[MoveIntent] Exception on overlay intent: {ex}");
            }
            finally
            {
                IntentQueue.Remove(bot);
            }
        }

        #endregion

        #region Helpers & Validation

        private static bool IsValidBot(BotOwner bot)
        {
            return bot != null && !bot.IsDead && bot.GetPlayer != null;
        }

        /// <summary>
        /// Only overlay/intent logic. NavMesh/sample used only for intent output, not direct movement.
        /// </summary>
        private static bool PreValidateMove(BotOwner bot, Vector3 target, MoveType type, out string reason, bool force = false)
        {
            reason = "";
            var cache = bot.GetComponent<BotComponentCache>();
            if (cache == null) { reason = "No cache"; return false; }

            if (BotMovementHelper.IsMovementPaused(bot)) { reason = "Paused"; return false; }
            if (!force && (BotMovementHelper.GetPosition(bot) - target).sqrMagnitude < 0.0625f)
            { reason = "Too close"; return false; }

            float cooldown = type == MoveType.Retreat ? 0.8f : 1.2f;
            if (!force && (Time.time - cache.MoveCache.LastMoveTime < cooldown))
            { reason = "Cooldown"; return false; }

            // NavMesh/sample for intent overlays only (never used for GoTo)
            if (!NavMesh.SamplePosition(target, out var navHit, 1.5f, NavMesh.AllAreas)) { reason = "NavMesh invalid"; return false; }

            string squadBlockReason = "";
            if (!force && MovementBlockedBySquad(bot, IntentState.Temp(bot, target, type), out squadBlockReason))
            { reason = squadBlockReason; return false; }

            if (cache.MissionEvaluator != null)
            {
                // Overlay: only allow movement intent if squad is aligned.
                if (!cache.MissionEvaluator.IsGroupAligned())
                {
                    reason = "Waiting for squad cohesion";
                    return false;
                }
            }
            // Placeholders for future overlays.
            // if (TryIsCoverSlotTaken(target, bot)) { reason = "Cover slot taken"; return false; }
            // if (TryIsExtractionOvercrowded(target, bot)) { reason = "Extraction blocked"; return false; }

            return true;
        }

        private static float GetAnticipationDelay(BotOwner bot, MoveType type, bool force)
        {
            if (force) return UnityEngine.Random.Range(0.01f, 0.08f);
            float baseDelay = type == MoveType.Engage ? 0.2f : type == MoveType.Retreat ? 0.12f : 0.45f;
            var cache = bot.GetComponent<BotComponentCache>();
            float jitter = UnityEngine.Random.Range(0.0f, 0.25f);
            float personality = cache?.PersonalityProfile != null ? (1.2f - cache.PersonalityProfile.ReactionSpeed * 0.5f) : 1f;
            return Mathf.Clamp(baseDelay * personality + jitter, 0.1f, 1.2f);
        }

        private static bool IsMovementPaused(BotOwner bot)
        {
            return BotMovementHelper.IsMovementPaused(bot);
        }

        private static bool MovementBlockedBySquad(BotOwner bot, IntentState intent, out string reason)
        {
            reason = "";
            try
            {
                BotsGroup group = bot?.BotsGroup;
                if (group == null || group.MembersCount <= 1) return false;

                Vector3 intentPos = intent.Target;
                float minSpacing = 1.7f;

                for (int i = 0; i < group.MembersCount; i++)
                {
                    var mate = group.Member(i);
                    if (mate == null || mate == bot || mate.IsDead) continue;

                    if (IntentQueue.TryGetValue(mate, out var mateIntent))
                    {
                        if ((mateIntent.Target - intentPos).sqrMagnitude < minSpacing * minSpacing)
                        {
                            reason = $"Squad overlap with {mate.ProfileId}";
                            return true;
                        }
                    }
                    var mateCache = mate.GetComponent<BotComponentCache>();
                    if (mateCache != null)
                    {
                        Vector3 lastTarget = mateCache.MoveCache?.LastIssuedTarget ?? mate.Position;
                        if ((lastTarget - intentPos).sqrMagnitude < minSpacing * minSpacing)
                        {
                            reason = $"Squad overlap (recent move) with {mate.ProfileId}";
                            return true;
                        }
                    }
                }
            }
            catch (Exception ex)
            {
                reason = "Squad logic error: " + ex.Message;
                return true;
            }
            return false;
        }

        #endregion

        #region Intent State

        /// <summary>
        /// Overlay-only: tracks intended position/type for overlays, never for navigation.
        /// </summary>
        private sealed class IntentState
        {
            public BotOwner Bot;
            public Vector3 Target;
            public MoveType Type;
            public float Cohesion;
            public bool Force;

            private IntentState() { }

            public static IntentState Create(BotOwner bot, Vector3 target, MoveType type, bool force = false)
            {
                var state = new IntentState();
                state.Bot = bot;
                state.Target = target;
                state.Type = type;
                state.Cohesion = 1.0f;
                state.Force = force;
                return state;
            }

            public static IntentState Temp(BotOwner bot, Vector3 target, MoveType type)
            {
                var temp = new IntentState();
                temp.Bot = bot;
                temp.Target = target;
                temp.Type = type;
                temp.Cohesion = 1.0f;
                temp.Force = false;
                return temp;
            }
        }

        public enum MoveType
        {
            Idle = 0,
            Patrol = 1,
            Engage = 2,
            Retreat = 3,
            Flank = 4,
            Cover = 5,
            Extract = 6
        }

        #endregion
    }
}
