// <auto-generated>
//   AI-Refactored: MovementIntentDispatcher.cs (Ultra-Realism Overlay/Intent-Only Dispatcher, Supreme Arbitration Edition – June 2025)
//   Never moves bots directly. Overlay/event intent only. Bulletproof: squad/mission deduped, anti-spam, anti-loop, anti-cluster, anti-oscillation, error-isolated.
//   All state managed via BotMoveCache API. Zero alloc hot path, SPT/FIKA/headless safe. MIT License.
// </auto-generated>

namespace AIRefactored.AI.Movement
{
    using System;
    using System.Collections.Generic;
    using AIRefactored.AI.Core;
    using AIRefactored.AI.Helpers;
    using AIRefactored.AI.Missions.Subsystems;
    using AIRefactored.AI.Threads;
    using AIRefactored.Pools;
    using BepInEx.Logging;
    using EFT;
    using UnityEngine;
    using UnityEngine.AI;

    /// <summary>
    /// Overlay/event intent dispatcher. No direct navigation/GoTo; intent only.
    /// All requests deduped, anti-spam, squad/mission overlays enforced, bulletproof error isolation.
    /// All state/telemetry updated via BotMoveCache API.
    /// </summary>
    public static class MovementIntentDispatcher
    {
        #region Internal State

        private static readonly Dictionary<BotOwner, IntentState> IntentQueue = new Dictionary<BotOwner, IntentState>(64);
        private static readonly ManualLogSource Logger = Plugin.LoggerInstance;

        #endregion

        #region Public API

        /// <summary>
        /// Request an overlay-only movement intent for a bot (never direct navigation).
        /// Dedupes, squad/mission overlays enforced, all logic is error-isolated.
        /// </summary>
        public static void RequestMove(BotOwner bot, Vector3 target, MoveType type, bool force = false)
        {
            if (!IsValidBot(bot)) return;
            var cache = bot.GetComponent<BotComponentCache>();
            if (cache == null || bot.IsDead) return;

            // Dedup/replace old
            if (IntentQueue.TryGetValue(bot, out var prev))
            {
                // Block redundant or lower-priority (e.g. avoid unnecessary Engage if Flank already queued)
                if (!force && prev.Type >= type && (prev.Target - target).sqrMagnitude < 0.09f)
                    return;
                CancelIntent(bot, "Superseded by higher priority or new target.");
            }

            // Pre-validate all overlays
            if (!PreValidateMove(bot, target, type, out string failReason, force))
            {
                Logger.LogDebug($"[MoveIntent] PreValidate failed for {bot.ProfileId}: {failReason}");
                return;
            }

            var intent = IntentState.Create(bot, target, type, force);
            IntentQueue[bot] = intent;

            float anticipation = GetAnticipationDelay(bot, type, force);
            BotBrain.ScheduleAfter(bot, anticipation, () => ProcessIntent(bot, intent));
        }

        /// <summary>
        /// Cancel any pending overlay-only intent for a bot.
        /// </summary>
        public static void CancelIntent(BotOwner bot, string reason = null)
        {
            if (bot == null) return;
            if (IntentQueue.Remove(bot) && reason != null)
                Logger.LogDebug($"[MoveIntent] Cancelled for {bot.ProfileId}: {reason}");
        }

        /// <summary>
        /// Clears all overlay-only intent states (e.g., on world teardown).
        /// </summary>
        public static void ClearAll() => IntentQueue.Clear();

        #endregion

        #region Intent Processing

        /// <summary>
        /// Overlay-only: On anticipation expiry, updates intent via BotMoveCache API. Never issues movement/GoTo.
        /// </summary>
        private static void ProcessIntent(BotOwner bot, IntentState intent)
        {
            if (bot == null || bot.IsDead) { IntentQueue.Remove(bot); return; }
            if (!IntentQueue.TryGetValue(bot, out var pending) || !ReferenceEquals(intent, pending))
                return;

            string squadBlockReason = "";
            if (IsMovementPaused(bot) || MovementBlockedBySquad(bot, intent, out squadBlockReason))
            {
                CancelIntent(bot, $"Paused or squad-blocked at anticipation expiry: {squadBlockReason}");
                return;
            }

            if (!PreValidateMove(bot, intent.Target, intent.Type, out string failReason, intent.Force))
            {
                CancelIntent(bot, $"Revalidate failed: {failReason}");
                return;
            }

            try
            {
                var cache = bot.GetComponent<BotComponentCache>();
                if (cache != null && cache.MoveCache != null)
                {
                    // Use AuditMove API for state/telemetry (never direct property sets)
                    cache.MoveCache.AuditMove(
                        intent.Target,
                        Time.time,
                        intent.Type.ToString(),
                        (int)intent.Type,
                        bot.BotsGroup != null ? bot.BotsGroup.GetHashCode() : 0,
                        ""
                    );
                }

                // Optional: Trigger squad/voice overlays if intent is group-sensitive (not actual movement!)
                if (cache?.GroupComms != null && intent.Type == MoveType.Flank && UnityEngine.Random.value < 0.16f)
                    cache.GroupComms.Say(EPhraseTrigger.FollowMe);

                // Realistic voice overlay for extraction/retreat
                if (cache?.GroupComms != null && intent.Type == MoveType.Extract && UnityEngine.Random.value < 0.18f)
                    cache.GroupComms.Say(EPhraseTrigger.ExitLocated);

                Logger.LogDebug($"[MoveIntent] Overlay intent committed: {bot.ProfileId} → {intent.Target} ({intent.Type})");
            }
            catch (Exception ex)
            {
                Logger.LogError($"[MoveIntent] Exception on overlay intent: {ex}");
            }
            finally
            {
                IntentQueue.Remove(bot);
            }
        }

        #endregion

        #region Helpers & Validation

        private static bool IsValidBot(BotOwner bot)
        {
            // SPT/FIKA/Headless safe, anti-null
            return bot != null && !bot.IsDead && bot.GetPlayer != null;
        }

        /// <summary>
        /// Overlay/intent-only: NavMesh/sample used for intent overlays only (never direct movement).
        /// </summary>
        private static bool PreValidateMove(BotOwner bot, Vector3 target, MoveType type, out string reason, bool force = false)
        {
            reason = "";
            var cache = bot.GetComponent<BotComponentCache>();
            if (cache == null) { reason = "No cache"; return false; }

            if (BotMovementHelper.IsMovementPaused(bot)) { reason = "Paused"; return false; }
            if (!force && (BotMovementHelper.GetPosition(bot) - target).sqrMagnitude < 0.0625f)
            { reason = "Too close"; return false; }

            float cooldown = type == MoveType.Retreat ? 0.8f : 1.2f;
            if (!force && cache.MoveCache.HasRecentMove(Time.time, cooldown))
            { reason = "Cooldown"; return false; }

            // Sample position (never moves, overlay only)
            if (!NavMesh.SamplePosition(target, out var navHit, 1.5f, NavMesh.AllAreas))
            { reason = "NavMesh invalid"; return false; }

            string squadBlockReason = "";
            if (!force && MovementBlockedBySquad(bot, IntentState.Temp(bot, target, type), out squadBlockReason))
            { reason = squadBlockReason; return false; }

            // Group/mission overlays (group cohesion, fallback/crowd, cover slotting, extraction crowd, world obstacles, etc.)
            if (cache.MissionEvaluator != null && !cache.MissionEvaluator.IsGroupAligned())
            {
                reason = "Waiting for squad cohesion";
                return false;
            }

            // Extraction/cover overlays (for expansion: check extract slots/cover slots in future)
            // TODO: Add overlays for cover slot crowding, extraction crowding, mission objectives, world obstacles.

            return true;
        }

        /// <summary>
        /// Returns a context/personality adjusted anticipation delay (for overlay intent, never for movement).
        /// </summary>
        private static float GetAnticipationDelay(BotOwner bot, MoveType type, bool force)
        {
            if (force) return UnityEngine.Random.Range(0.01f, 0.08f);
            float baseDelay = type == MoveType.Engage ? 0.2f : type == MoveType.Retreat ? 0.12f : 0.45f;
            var cache = bot.GetComponent<BotComponentCache>();
            float jitter = UnityEngine.Random.Range(0.0f, 0.23f);
            float personality = cache?.PersonalityProfile != null ? (1.16f - cache.PersonalityProfile.ReactionSpeed * 0.5f) : 1f;
            return Mathf.Clamp(baseDelay * personality + jitter, 0.1f, 1.18f);
        }

        private static bool IsMovementPaused(BotOwner bot)
        {
            return BotMovementHelper.IsMovementPaused(bot);
        }

        /// <summary>
        /// Overlay-only: Checks if another squad member is already targeting this spot, or too close (anti-cluster).
        /// </summary>
        private static bool MovementBlockedBySquad(BotOwner bot, IntentState intent, out string reason)
        {
            reason = "";
            try
            {
                BotsGroup group = bot?.BotsGroup;
                if (group == null || group.MembersCount <= 1) return false;

                Vector3 intentPos = intent.Target;
                float minSpacing = 1.67f; // Tuned for Tarkov's bot size

                for (int i = 0; i < group.MembersCount; i++)
                {
                    var mate = group.Member(i);
                    if (mate == null || mate == bot || mate.IsDead) continue;

                    if (IntentQueue.TryGetValue(mate, out var mateIntent))
                    {
                        if ((mateIntent.Target - intentPos).sqrMagnitude < minSpacing * minSpacing)
                        {
                            reason = $"Squad overlap with {mate.ProfileId}";
                            return true;
                        }
                    }
                    var mateCache = mate.GetComponent<BotComponentCache>();
                    if (mateCache != null && mateCache.MoveCache != null)
                    {
                        Vector3 lastTarget = mateCache.MoveCache.LastIssuedTarget;
                        if ((lastTarget - intentPos).sqrMagnitude < minSpacing * minSpacing)
                        {
                            reason = $"Squad overlap (recent move) with {mate.ProfileId}";
                            return true;
                        }
                    }
                }
            }
            catch (Exception ex)
            {
                reason = "Squad logic error: " + ex.Message;
                return true;
            }
            return false;
        }

        #endregion

        #region Intent State

        /// <summary>
        /// Overlay-only: tracks intended position/type for overlays, never for navigation.
        /// </summary>
        private sealed class IntentState
        {
            public BotOwner Bot;
            public Vector3 Target;
            public MoveType Type;
            public float Cohesion;
            public bool Force;

            private IntentState() { }

            public static IntentState Create(BotOwner bot, Vector3 target, MoveType type, bool force = false)
            {
                var state = new IntentState();
                state.Bot = bot;
                state.Target = target;
                state.Type = type;
                state.Cohesion = 1.0f;
                state.Force = force;
                return state;
            }

            public static IntentState Temp(BotOwner bot, Vector3 target, MoveType type)
            {
                var temp = new IntentState();
                temp.Bot = bot;
                temp.Target = target;
                temp.Type = type;
                temp.Cohesion = 1.0f;
                temp.Force = false;
                return temp;
            }
        }

        /// <summary>
        /// Overlay-only move intent types.
        /// </summary>
        public enum MoveType
        {
            Idle = 0,
            Patrol = 1,
            Engage = 2,
            Retreat = 3,
            Flank = 4,
            Cover = 5,
            Extract = 6
        }

        #endregion
    }
}
