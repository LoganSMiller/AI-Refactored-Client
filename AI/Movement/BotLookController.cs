// <auto-generated>
//   AI-Refactored: BotLookController.cs (Supreme Arbitration Overlay/Event Edition – June 2025, Ultra-Realism, Max Robustness/Feature Expansion/Finalized)
//   Overlay/event-only. Anti-robot, anti-stuck. Max realism, max safety, squad/personality/cover/idle aware, pooled, zero alloc, multiplayer/headless safe.
//   Arbitration-locked. All errors contained. Production/feature-complete. MIT License.
// </auto-generated>

namespace AIRefactored.AI.Movement
{
    using System;
    using AIRefactored.AI;
    using AIRefactored.AI.Core;
    using AIRefactored.Core;
    using BepInEx.Logging;
    using EFT;
    using UnityEngine;

    /// <summary>
    /// Arbitration/event-only, fully stabilized, robust, and lifelike look/aim/scan controller.
    /// Handles squad, panic/flash, voice comms, fallback, idle, micro-wobble, memory, stuck anti-patterns.
    /// Overlay/event-only. Fully bulletproof and error-isolated.
    /// </summary>
    public sealed class BotLookController
    {
        #region Constants

        private const float MaxTurnSpeedYaw = 6.6f;
        private const float MaxTurnSpeedPitch = 4.4f;
        private const float MaxDeltaYaw = 13.0f;
        private const float MaxDeltaPitch = 9.0f;
        private const float LookSwitchCooldown = 0.22f;
        private const float IdleScanCone = 22.0f;
        private const float IdleScanDurationMin = 1.2f, IdleScanDurationMax = 2.0f;
        private const float VisionBlockCheckDist = 38f;
        private const float LookFallbackDist = 1.55f;
        private const float MinLookDistanceSqr = 0.18f;
        private const float YawInertiaAccel = 0.10f, PitchInertiaAccel = 0.06f;
        private const float StabilityThresholdSqr = 0.33f;
        private const float OvershootAmountYaw = 5.7f, OvershootAmountPitch = 2.3f;
        private const float IdleHeadJitter = 2.1f;
        private const float BlindScanCooldown = 1.1f;
        private const float SquadFollowOffsetYaw = 5.0f;
        private const float LastSeenTimeout = 7.5f;
        private const float MaxLookHistory = 3f;
        private const float VoiceComCooldown = 1.5f;
        private const float FatigueDecayPerSecond = 0.11f;
        private const float FatigueWobbleAmount = 1.2f;
        private const float MicroCorrectionInterval = 2.6f;
        private const float MaxUnnaturalLookTime = 8.0f;
        private const float IdleLookRandomness = 0.21f;

        #endregion

        #region Fields

        private static readonly ManualLogSource Logger = Plugin.LoggerInstance;

        private readonly BotOwner _bot;
        private readonly BotComponentCache _cache;
        private readonly BotPersonalityProfile _personality;

        private float _currentYaw;
        private float _currentPitch;
        private float _yawVelocity, _pitchVelocity;
        private float _nextIdleScanTime, _idleTargetYaw;
        private Vector3 _fallbackLookTarget, _lastLookTarget;
        private float _lastLookSwitchTime;
        private float _nextHeadJitterTime;
        private bool _frozen;
        private bool _overshootPending;
        private float _overshootTargetYaw, _overshootTargetPitch;
        private float _nextBlindScanTime;
        private float _lastSquadLookUpdate;
        private Vector3 _squadLookTarget;
        private bool _hasSquadLook;

        // Fallback/Memory/Realism
        private float _lastSeenEnemyTime;
        private Vector3 _lastSeenEnemyPos;
        private Vector3 _lastSafeFallbackLook;
        private float _lastValidLookTime;
        private float _voiceCooldownUntil;
        private float _lookFatigue;
        private float _lastMicroCorrectionTime;
        private float _unnaturalLockStart;

        #endregion

        #region Construction

        public BotLookController(BotOwner bot, BotComponentCache cache)
        {
            if (!EFTPlayerUtil.IsValidBotOwner(bot) || cache == null)
            {
                Logger.LogError("[BotLookController] Null bot/cache at construction.");
                throw new ArgumentException("Invalid BotLookController parameters.");
            }

            _bot = bot;
            _cache = cache;
            _personality = cache.PersonalityProfile ?? BotPersonalityProfile.Default;

            Player player = EFTPlayerUtil.ResolvePlayer(bot);
            Transform body = EFTPlayerUtil.GetTransform(player);
            Vector3 forward = body != null ? body.forward : Vector3.forward;
            _currentYaw = body != null ? body.rotation.eulerAngles.y : 0f;
            _currentPitch = 0f;
            _yawVelocity = 0f;
            _pitchVelocity = 0f;
            _fallbackLookTarget = bot.Position + forward;
            _lastLookTarget = _fallbackLookTarget;
            _lastLookSwitchTime = Time.time;
            _nextIdleScanTime = Time.time + UnityEngine.Random.Range(IdleScanDurationMin, IdleScanDurationMax);
            _nextHeadJitterTime = Time.time + UnityEngine.Random.Range(0.7f, 1.5f);

            _lastSafeFallbackLook = _fallbackLookTarget;
            _lastValidLookTime = Time.time;
            _voiceCooldownUntil = 0f;
            _lookFatigue = 0f;
            _lastMicroCorrectionTime = Time.time;
            _unnaturalLockStart = 0f;
        }

        #endregion

        #region Overlay/Event Tick Integration

        /// <summary>
        /// Called by BotBrain or centralized tick dispatcher for overlay/event-based look arbitration.
        /// Fully pooled, zero per-frame move, max robustness. Safe to call every tick.
        /// </summary>
        public void Tick(float deltaTime)
        {
            TryOverlay(deltaTime);
        }

        #endregion

        #region Public API

        /// <summary>
        /// Overlay/event-only. Applies arbitration-driven, humanized look/aim transitions.
        /// Handles panic, flash, idle, squad, memory, micro-corrections, anti-stuck, and fatigue.
        /// </summary>
        public void TryOverlay(float deltaTime)
        {
            const BotOverlayType OverlayType = BotOverlayType.Special;
            try
            {
                if (_bot == null || _cache == null || _bot.IsDead || !GameWorldHandler.IsSafeToInitialize)
                    return;
                if (_frozen && Time.time - _lastLookSwitchTime < 1.0f)
                    return;
                if (!BotOverlayManager.CanIssueMove(_bot, OverlayType))
                    return;

                Player player = EFTPlayerUtil.ResolvePlayer(_bot);
                if (!EFTPlayerUtil.IsValid(player))
                {
                    BotOverlayManager.ReleaseMove(_bot, OverlayType);
                    return;
                }
                Transform body = EFTPlayerUtil.GetTransform(player);
                if (body == null)
                {
                    BotOverlayManager.ReleaseMove(_bot, OverlayType);
                    return;
                }
                Vector3 origin = body.position;

                // PANIC/BLIND/FLASH: scan/jitter overlays only, simulate "fatigue"
                if (_cache.IsBlinded || (_cache.PanicHandler?.IsPanicking ?? false))
                {
                    _lookFatigue += FatigueDecayPerSecond * deltaTime * (1.2f + UnityEngine.Random.value * 0.8f);
                    if (_lookFatigue > 1.9f) _lookFatigue = 1.9f;
                    if (Time.time > _nextBlindScanTime)
                    {
                        float blindYaw = _currentYaw + UnityEngine.Random.Range(-IdleScanCone, IdleScanCone) + UnityEngine.Random.Range(-_lookFatigue, _lookFatigue);
                        float blindPitch = _currentPitch + UnityEngine.Random.Range(-OvershootAmountPitch, OvershootAmountPitch) + UnityEngine.Random.Range(-_lookFatigue, _lookFatigue) * 0.7f;
                        _currentYaw = Mathf.Repeat(blindYaw, 360f);
                        _currentPitch = Mathf.Clamp(blindPitch, -32f, 42f);
                        _nextBlindScanTime = Time.time + BlindScanCooldown * UnityEngine.Random.Range(0.9f, 1.2f);
                    }
                    if (Time.time > _voiceCooldownUntil)
                    {
                        TrySay("confused");
                        _voiceCooldownUntil = Time.time + VoiceComCooldown;
                    }
                    _lastValidLookTime = Time.time;
                    BotOverlayManager.RegisterMove(_bot, OverlayType);
                    BotOverlayManager.ReleaseMove(_bot, OverlayType);
                    return;
                }

                // SQUAD LOOK FOLLOW/COMMUNICATION: pseudo-leader mimic and "LookAt" overlays
                bool squadLookThisFrame = false;
                if (_bot.BotsGroup != null && _bot.BotsGroup.MembersCount > 1 && Time.time - _lastSquadLookUpdate > 0.77f)
                {
                    int leaderIdx = 0;
                    float minId = float.MaxValue;
                    for (int i = 0; i < _bot.BotsGroup.MembersCount; i++)
                    {
                        var m = _bot.BotsGroup.Member(i);
                        if (m != null && m.Profile != null && float.TryParse(m.Profile.Id, out float parsed) && parsed < minId)
                        {
                            minId = parsed;
                            leaderIdx = i;
                        }
                    }
                    var leader = _bot.BotsGroup.Member(leaderIdx);
                    if (leader != null && leader != _bot)
                    {
                        Player squadLeadPlayer = EFTPlayerUtil.ResolvePlayer(leader);
                        if (EFTPlayerUtil.IsValid(squadLeadPlayer))
                        {
                            Transform leaderBody = EFTPlayerUtil.GetTransform(squadLeadPlayer);
                            if (leaderBody != null)
                            {
                                Vector3 leadDir = leaderBody.forward;
                                _squadLookTarget = leaderBody.position + leadDir * 2.25f;
                                _lastSquadLookUpdate = Time.time;
                                _hasSquadLook = true;
                                squadLookThisFrame = true;
                            }
                        }
                    }
                }

                Vector3 nextTarget = _fallbackLookTarget;
                bool switching = false;

                // ENEMY THREAT TRACKING, MEMORY, OVERSHOOT, communication
                if (_cache.ThreatSelector != null)
                {
                    string id = _cache.ThreatSelector.GetTargetProfileId();
                    Player enemy = EFTPlayerUtil.ResolvePlayerById(id);
                    if (EFTPlayerUtil.IsValid(enemy))
                    {
                        Vector3 enemyPos = EFTPlayerUtil.GetPosition(enemy);
                        _lastSeenEnemyTime = Time.time;
                        _lastSeenEnemyPos = enemyPos;
                        nextTarget = enemyPos;
                        _unnaturalLockStart = Time.time;

                        if (_hasSquadLook && squadLookThisFrame && UnityEngine.Random.value < 0.22f)
                        {
                            float offset = UnityEngine.Random.Range(-SquadFollowOffsetYaw, SquadFollowOffsetYaw);
                            nextTarget = Quaternion.Euler(0f, offset, 0f) * (nextTarget - origin) + origin;
                            if (Time.time > _voiceCooldownUntil)
                            {
                                TrySay("squad_look");
                                _voiceCooldownUntil = Time.time + VoiceComCooldown;
                            }
                        }
                        else if (Time.time > _voiceCooldownUntil && UnityEngine.Random.value < 0.045f)
                        {
                            TrySay("see_enemy");
                            _voiceCooldownUntil = Time.time + VoiceComCooldown;
                        }

                        if ((nextTarget - _lastLookTarget).sqrMagnitude > StabilityThresholdSqr)
                        {
                            if (Time.time - _lastLookSwitchTime > LookSwitchCooldown)
                            {
                                switching = true;
                                _lastLookSwitchTime = Time.time;
                                if (!_overshootPending)
                                {
                                    _overshootPending = true;
                                    float sign = UnityEngine.Random.value > 0.5f ? 1f : -1f;
                                    _overshootTargetYaw = _currentYaw + sign * OvershootAmountYaw * UnityEngine.Random.Range(0.7f, 1.25f);
                                    _overshootTargetPitch = _currentPitch + UnityEngine.Random.Range(-OvershootAmountPitch, OvershootAmountPitch);
                                }
                                _lastLookTarget = nextTarget;
                                _lastValidLookTime = Time.time;
                            }
                            else
                            {
                                nextTarget = _lastLookTarget;
                            }
                        }
                        else
                        {
                            nextTarget = _lastLookTarget;
                        }
                    }
                    else if (Time.time - _lastSeenEnemyTime < LastSeenTimeout)
                    {
                        nextTarget = _lastSeenEnemyPos;
                        _lastLookTarget = nextTarget;
                        switching = true;
                        _lookFatigue += FatigueDecayPerSecond * deltaTime * 0.5f;
                        if (_lookFatigue > 1.4f) _lookFatigue = 1.4f;
                    }
                }

                // MICRO-CORRECTIONS / HEAD MOVEMENT / UNNATURAL LOOK RELAX
                if (Time.time - _unnaturalLockStart > MaxUnnaturalLookTime && !hasRecentlyMicroCorrected())
                {
                    _currentYaw += UnityEngine.Random.Range(-FatigueWobbleAmount, FatigueWobbleAmount);
                    _currentPitch += UnityEngine.Random.Range(-FatigueWobbleAmount * 0.45f, FatigueWobbleAmount * 0.23f);
                    _lastMicroCorrectionTime = Time.time;
                    _unnaturalLockStart = Time.time;
                }

                // IDLE/SCAN/LOOT: random scan overlays, fatigue reset
                string threatId = _cache.ThreatSelector?.GetTargetProfileId();
                bool hasThreat = !string.IsNullOrEmpty(threatId);
                if (!switching && !hasThreat)
                {
                    if (Time.time > _nextIdleScanTime)
                    {
                        _idleTargetYaw = _currentYaw + UnityEngine.Random.Range(-IdleScanCone, IdleScanCone);
                        _nextIdleScanTime = Time.time + UnityEngine.Random.Range(IdleScanDurationMin, IdleScanDurationMax);

                        Vector3 idleDir = Quaternion.Euler(0f, _idleTargetYaw, 0f) * Vector3.forward;
                        float randomness = IdleLookRandomness * UnityEngine.Random.value;
                        nextTarget = origin + idleDir * (2.2f + randomness);
                        _lastLookSwitchTime = Time.time;
                        _lastLookTarget = nextTarget;
                        _lastValidLookTime = Time.time;
                        _lookFatigue *= 0.67f;
                        if (Time.time > _voiceCooldownUntil && UnityEngine.Random.value < 0.032f)
                        {
                            TrySay("idle_scan");
                            _voiceCooldownUntil = Time.time + VoiceComCooldown;
                        }
                    }
                    else
                    {
                        if (Time.time > _nextHeadJitterTime)
                        {
                            float jitter = UnityEngine.Random.Range(-IdleHeadJitter, IdleHeadJitter);
                            _currentYaw += jitter * 0.13f * (0.88f + _personality.Awareness * 0.26f);
                            _currentPitch += UnityEngine.Random.Range(-IdleHeadJitter * 0.19f, IdleHeadJitter * 0.13f);
                            _nextHeadJitterTime = Time.time + UnityEngine.Random.Range(0.7f, 1.5f);
                        }
                        nextTarget = _lastLookTarget;
                    }
                }

                // FALLBACK if invalid or stale
                if (!IsValid(nextTarget))
                {
                    Vector3 lookDir = _bot.LookDirection.sqrMagnitude > 0.01f ? _bot.LookDirection.normalized : Vector3.forward;
                    nextTarget = _bot.Position + lookDir * LookFallbackDist;
                    _lastSafeFallbackLook = nextTarget;
                    _lastValidLookTime = Time.time;
                }
                if (Time.time - _lastValidLookTime > MaxLookHistory)
                {
                    nextTarget = _lastSafeFallbackLook;
                    _lastValidLookTime = Time.time;
                }

                nextTarget = ValidateLookTarget(origin, nextTarget);

                Vector3 lookVec = nextTarget - origin;
                if (lookVec.sqrMagnitude < MinLookDistanceSqr)
                {
                    lookVec = _bot.LookDirection.sqrMagnitude > 0.01f
                        ? _bot.LookDirection.normalized
                        : Vector3.forward;
                }

                float targetYaw = Mathf.Atan2(lookVec.x, lookVec.z) * Mathf.Rad2Deg;
                float targetPitch = -Mathf.Atan2(lookVec.y, new Vector2(lookVec.x, lookVec.z).magnitude) * Mathf.Rad2Deg;

                // OVERSHOOT/follow-through
                if (_overshootPending)
                {
                    targetYaw = Mathf.Lerp(targetYaw, _overshootTargetYaw, 0.29f + UnityEngine.Random.Range(0.13f, 0.26f));
                    targetPitch = Mathf.Lerp(targetPitch, _overshootTargetPitch, 0.16f + UnityEngine.Random.Range(0.09f, 0.22f));
                    _overshootPending = false;
                }

                float yawDiff = Mathf.DeltaAngle(_currentYaw, targetYaw);
                float pitchDiff = Mathf.DeltaAngle(_currentPitch, targetPitch);

                // Ultra-strict smoothing with personality influence, fatigue
                float yawAccel = YawInertiaAccel * (0.82f + UnityEngine.Random.value * 0.26f) * Mathf.Lerp(0.72f, 1.21f, _personality.Awareness) * (1.0f - _lookFatigue * 0.18f);
                float pitchAccel = PitchInertiaAccel * (0.88f + UnityEngine.Random.value * 0.17f) * Mathf.Lerp(0.93f, 1.14f, _personality.Caution) * (1.0f - _lookFatigue * 0.11f);
                _yawVelocity += Mathf.Clamp(yawDiff, -MaxDeltaYaw, MaxDeltaYaw) * yawAccel * deltaTime;
                _pitchVelocity += Mathf.Clamp(pitchDiff, -MaxDeltaPitch, MaxDeltaPitch) * pitchAccel * deltaTime;
                _yawVelocity = Mathf.Clamp(_yawVelocity, -MaxTurnSpeedYaw, MaxTurnSpeedYaw);
                _pitchVelocity = Mathf.Clamp(_pitchVelocity, -MaxTurnSpeedPitch, MaxTurnSpeedPitch);

                float deltaYaw = _yawVelocity * deltaTime * 60f;
                float deltaPitch = _pitchVelocity * deltaTime * 60f;
                deltaYaw = Mathf.Clamp(deltaYaw, -MaxDeltaYaw, MaxDeltaYaw);
                deltaPitch = Mathf.Clamp(deltaPitch, -MaxDeltaPitch, MaxDeltaPitch);

                _currentYaw = Mathf.Repeat(_currentYaw + deltaYaw, 360f);
                _currentPitch = Mathf.Clamp(_currentPitch + deltaPitch, -42f, 56f);

                // Apply rotation as overlay, never tick/coroutine
                Quaternion targetRot = Quaternion.Euler(_currentPitch, _currentYaw, 0f);
                if (!float.IsNaN(targetRot.x) && !float.IsNaN(targetRot.y) && !float.IsNaN(targetRot.z))
                {
                    if (Mathf.Abs(_currentPitch) > 63f)
                        _currentPitch = Mathf.Clamp(_currentPitch, -32f, 48f);
                    body.rotation = targetRot;
                }

                BotOverlayManager.RegisterMove(_bot, OverlayType);
                BotOverlayManager.ReleaseMove(_bot, OverlayType);

                // Decay fatigue over time if not panicked
                if (!_cache.IsBlinded && !(_cache.PanicHandler?.IsPanicking ?? false) && _lookFatigue > 0f)
                    _lookFatigue -= FatigueDecayPerSecond * deltaTime * 0.8f;
                if (_lookFatigue < 0f) _lookFatigue = 0f;
            }
            catch (Exception ex)
            {
                Logger.LogError("[BotLookController] TryOverlay failed: " + ex);
                BotOverlayManager.ReleaseMove(_bot, OverlayType);
            }
        }

        /// <summary>
        /// Sets an external fallback look target for overlays (idle/scan/squad).
        /// </summary>
        public void SetLookTarget(Vector3 worldPos)
        {
            if (IsValid(worldPos))
            {
                _fallbackLookTarget = worldPos;
                _lastLookTarget = worldPos;
                _lastSafeFallbackLook = worldPos;
                _lastValidLookTime = Time.time;
            }
        }

        public void FreezeLook() => _frozen = true;
        public void ResumeLook() => _frozen = false;
        public Vector3 GetLookDirection() => _bot != null ? _bot.LookDirection : Vector3.forward;

        #endregion

        #region Internal Look Logic

        private Vector3 ValidateLookTarget(Vector3 origin, Vector3 rawTarget)
        {
            Vector3 dir = rawTarget - origin;
            float dist = dir.magnitude;
            if (dist < 0.1f)
                return rawTarget;

            if (Physics.Raycast(origin + Vector3.up * 1.44f, dir.normalized, out RaycastHit hit, Mathf.Min(dist, VisionBlockCheckDist), AIRefactoredLayerMasks.VisionBlockers))
            {
                return hit.point - dir.normalized * 0.23f;
            }
            return rawTarget;
        }

        private static bool IsValid(Vector3 pos)
        {
            return !float.IsNaN(pos.x) && !float.IsNaN(pos.y) && !float.IsNaN(pos.z);
        }

        private void TrySay(string eventId)
        {
            // Example: Plug into squad comms or bot voice overlays.
        }

        private bool hasRecentlyMicroCorrected()
        {
            return (Time.time - _lastMicroCorrectionTime) < MicroCorrectionInterval;
        }

        #endregion
    }
}
