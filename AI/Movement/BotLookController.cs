// <auto-generated>
//   This file is part of AI-Refactored, an open-source project focused on realistic AI behavior in Escape from Tarkov.
//   Licensed under the MIT License. See LICENSE in the repository root for more information.
//
//   THIS FILE IS SYSTEMATICALLY MANAGED.
//   Please follow strict StyleCop, ReSharper, and AI-Refactored code standards for all modifications.
// </auto-generated>

#nullable enable

namespace AIRefactored.AI.Movement
{
    using System;
    using AIRefactored.AI.Components;
    using AIRefactored.AI.Core;
    using AIRefactored.Core;
    using EFT;
    using UnityEngine;

    /// <summary>
    /// Controls bot look direction using smooth rotation logic and realistic perception response.
    /// Integrates panic, blindness, sound, and enemy awareness.
    /// </summary>
    public sealed class BotLookController
    {
        private const float MaxTurnSpeed = 7.5f;
        private const float MinLookDistanceSqr = 0.25f;

        private readonly BotOwner _bot;
        private readonly BotComponentCache _cache;

        private Vector3 _fallbackLookTarget;
        private bool _frozen;

        /// <summary>
        /// Initializes a new instance of the <see cref="BotLookController"/> class.
        /// </summary>
        /// <param name="bot">BotOwner reference.</param>
        /// <param name="cache">Component cache reference.</param>
        public BotLookController(BotOwner bot, BotComponentCache cache)
        {
            this._bot = bot ?? throw new ArgumentNullException(nameof(bot));
            this._cache = cache ?? throw new ArgumentNullException(nameof(cache));
            this._fallbackLookTarget = bot.Position + bot.LookDirection;
        }

        /// <summary>
        /// Called every frame to update bot's look direction.
        /// </summary>
        /// <param name="deltaTime">Time since last frame.</param>
        public void Tick(float deltaTime)
        {
            if (this._frozen || this._bot.IsDead || FikaHeadlessDetector.IsHeadless)
            {
                return;
            }

            Vector3 origin = this._bot.Position;
            Vector3 lookTarget = this.ResolveLookTarget(origin);
            Vector3 direction = lookTarget - origin;
            direction.y = 0f;

            if (direction.sqrMagnitude < MinLookDistanceSqr)
            {
                return;
            }

            PlayerBones? bones = this._bot.GetPlayer?.PlayerBones;
            if (bones == null || bones.Head == null)
            {
                return;
            }

            Quaternion current = bones.Head.rotation;
            Quaternion desired = Quaternion.LookRotation(direction);

            bones.Head.rotation = Quaternion.Slerp(current, desired, Mathf.Clamp01(MaxTurnSpeed * deltaTime));
        }

        /// <summary>
        /// Overrides the bot's default look direction.
        /// </summary>
        /// <param name="worldPos">World-space target.</param>
        public void SetLookTarget(Vector3 worldPos)
        {
            this._fallbackLookTarget = worldPos;
        }

        /// <summary>
        /// Freezes bot rotation (e.g. stunned).
        /// </summary>
        public void FreezeLook()
        {
            this._frozen = true;
        }

        /// <summary>
        /// Resumes rotation behavior.
        /// </summary>
        public void ResumeLook()
        {
            this._frozen = false;
        }

        /// <summary>
        /// Gets current world look direction.
        /// </summary>
        public Vector3 GetLookDirection()
        {
            return this._bot.LookDirection;
        }

        private Vector3 ResolveLookTarget(Vector3 origin)
        {
            float now = Time.time;

            if (this._cache.IsBlinded && now < this._cache.BlindUntilTime)
            {
                return origin + UnityEngine.Random.insideUnitSphere.normalized * 4f;
            }

            if (this._cache.Panic?.IsPanicking == true)
            {
                if (this._cache.LastHeardDirection.HasValue)
                {
                    return origin + this._cache.LastHeardDirection.Value.normalized * 6f;
                }

                return origin + this._bot.LookDirection;
            }

            if (this._cache.ThreatSelector?.CurrentTarget != null)
            {
                return EFTPlayerUtil.GetPosition(this._cache.ThreatSelector.CurrentTarget);
            }

            if (this._cache.LastHeardDirection.HasValue && now - this._cache.LastHeardTime < 4f)
            {
                return origin + this._cache.LastHeardDirection.Value.normalized * 6f;
            }

            return this._fallbackLookTarget;
        }
    }
}
