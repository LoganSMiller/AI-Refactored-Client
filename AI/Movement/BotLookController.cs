// <auto-generated>
//   AI-Refactored: BotLookController.cs (Ultra-Platinum++ Safe Edition – June 2025)
//   Overlay/event-driven only, anti-spam, hard-capped, error/bounce/NaN proof, no snap, no look-loop bugs.
//   MIT License.
// </auto-generated>

namespace AIRefactored.AI.Movement
{
    using System;
    using AIRefactored.AI.Core;
    using AIRefactored.Core;
    using BepInEx.Logging;
    using EFT;
    using UnityEngine;

    public sealed class BotLookController
    {
        #region Constants

        private const float MaxTurnSpeedYaw = 8.1f;
        private const float MaxTurnSpeedPitch = 5.8f;
        private const float MaxDeltaYaw = 20.0f;   // Hard cap, prevents snap
        private const float MaxDeltaPitch = 16.0f; // Hard cap, prevents snap
        private const float TargetSwitchDampenTime = 0.24f;
        private const float LookStabilityCooldown = 0.18f; // min time between target commits
        private const float IdleScanCone = 28.0f;
        private const float IdleScanDurationMin = 2.0f, IdleScanDurationMax = 3.3f;
        private const float SaccadeAngleMax = 3.1f;
        private const float VisionBlockCheckDist = 48f;
        private const float LookFallbackDist = 1.4f;
        private const float MinLookDistanceSqr = 0.13f;
        private const float YawInertiaAccel = 0.13f, PitchInertiaAccel = 0.07f;
        private const float NaNRecoveryYaw = 0f, NaNRecoveryPitch = 0f;

        #endregion

        #region Fields

        private static readonly ManualLogSource Logger = Plugin.LoggerInstance;

        private readonly BotOwner _bot;
        private readonly BotComponentCache _cache;

        private float _currentYaw;
        private float _currentPitch;
        private float _yawVelocity, _pitchVelocity;
        private float _lastYawSign;
        private float _nextSaccadeTime, _saccadeOffset;
        private float _nextIdleScanTime, _idleTargetYaw;
        private Vector3 _fallbackLookTarget, _lastResolvedTarget;
        private float _lastLookSwitchTime;
        private float _lastStabilityCheck;
        private bool _frozen;

        #endregion

        #region Construction

        public BotLookController(BotOwner bot, BotComponentCache cache)
        {
            if (!EFTPlayerUtil.IsValidBotOwner(bot) || cache == null)
            {
                Logger.LogError("[BotLookController] Null bot/cache at construction.");
                throw new ArgumentException("Invalid BotLookController parameters.");
            }

            _bot = bot;
            _cache = cache;

            Player player = EFTPlayerUtil.ResolvePlayer(bot);
            Transform body = EFTPlayerUtil.GetTransform(player);
            Vector3 forward = body != null ? body.forward : Vector3.forward;
            _currentYaw = body != null ? body.rotation.eulerAngles.y : 0f;
            _currentPitch = 0f;
            _yawVelocity = 0f; _pitchVelocity = 0f;
            _lastYawSign = 0f;
            _fallbackLookTarget = bot.Position + forward;
            _lastResolvedTarget = _fallbackLookTarget;
            _lastLookSwitchTime = Time.time;
            _nextIdleScanTime = Time.time + UnityEngine.Random.Range(1.4f, 2.8f);
            _lastStabilityCheck = 0f;
        }

        #endregion

        #region Public API

        public void Tick(float deltaTime)
        {
            try
            {
                if (_bot == null || _cache == null || _bot.IsDead || !GameWorldHandler.IsSafeToInitialize)
                    return;
                if (_frozen && Time.time - _lastLookSwitchTime < 1.25f)
                    return;

                Player player = EFTPlayerUtil.ResolvePlayer(_bot);
                if (!EFTPlayerUtil.IsValid(player))
                    return;

                Transform body = EFTPlayerUtil.GetTransform(player);
                if (body == null)
                    return;

                Vector3 origin = body.position;

                // Look target update: Only allow a target change if cooldown expired or forced by enemy switch.
                bool forcedSwitch = false;
                Vector3 lookTarget = _fallbackLookTarget;

                // If threat exists, lock in, else idle scan/forward.
                if (_cache?.ThreatSelector != null)
                {
                    string id = _cache.ThreatSelector.GetTargetProfileId();
                    Player enemy = EFTPlayerUtil.ResolvePlayerById(id);
                    if (EFTPlayerUtil.IsValid(enemy))
                    {
                        lookTarget = EFTPlayerUtil.GetPosition(enemy);
                        forcedSwitch = (lookTarget - _lastResolvedTarget).sqrMagnitude > 2.1f; // Only commit to large changes immediately
                    }
                }

                bool canIdleScan = _cache?.Combat?.IsInCombatState() == false
                                   && _cache.PanicHandler?.IsPanicking == false
                                   && !_cache.IsBlinded;

                // Only allow idle scan to move target at timer
                if (!forcedSwitch && canIdleScan && Time.time > _nextIdleScanTime)
                {
                    _idleTargetYaw = _currentYaw + UnityEngine.Random.Range(-IdleScanCone, IdleScanCone);
                    _nextIdleScanTime = Time.time + UnityEngine.Random.Range(IdleScanDurationMin, IdleScanDurationMax);
                    Vector3 idleDir = Quaternion.Euler(0f, _idleTargetYaw, 0f) * Vector3.forward;
                    lookTarget = origin + idleDir * 2.1f;
                }

                // If no valid target, gently look forward
                if (!IsValid(lookTarget))
                {
                    Vector3 lookDir = _bot.LookDirection.sqrMagnitude > 0.01f ? _bot.LookDirection.normalized : Vector3.forward;
                    lookTarget = _bot.Position + lookDir * LookFallbackDist;
                }

                // Throttle look target commits
                if ((lookTarget - _lastResolvedTarget).sqrMagnitude > 0.65f)
                {
                    if (Time.time - _lastStabilityCheck < LookStabilityCooldown && !forcedSwitch)
                        lookTarget = _lastResolvedTarget; // do not switch target
                    else
                    {
                        _lastLookSwitchTime = Time.time;
                        _lastResolvedTarget = lookTarget;
                        _lastStabilityCheck = Time.time;
                    }
                }

                lookTarget = ValidateLookTarget(origin, lookTarget);

                Vector3 lookVec = lookTarget - origin;
                if (lookVec.sqrMagnitude < MinLookDistanceSqr)
                {
                    lookVec = _bot.LookDirection.sqrMagnitude > 0.01f
                        ? _bot.LookDirection.normalized
                        : Vector3.forward;
                }

                float targetYaw = Mathf.Atan2(lookVec.x, lookVec.z) * Mathf.Rad2Deg;
                float targetPitch = -Mathf.Atan2(lookVec.y, new Vector2(lookVec.x, lookVec.z).magnitude) * Mathf.Rad2Deg;

                float yawDiff = Mathf.DeltaAngle(_currentYaw, targetYaw);
                float pitchDiff = Mathf.DeltaAngle(_currentPitch, targetPitch);
                float yawSign = Mathf.Sign(yawDiff);

                _lastYawSign = yawSign;

                // Inertia/velocity-based smoothing, with hard cap
                _yawVelocity += Mathf.Clamp(yawDiff, -MaxDeltaYaw, MaxDeltaYaw) * YawInertiaAccel * deltaTime;
                _pitchVelocity += Mathf.Clamp(pitchDiff, -MaxDeltaPitch, MaxDeltaPitch) * PitchInertiaAccel * deltaTime;

                _yawVelocity = Mathf.Clamp(_yawVelocity, -MaxTurnSpeedYaw, MaxTurnSpeedYaw);
                _pitchVelocity = Mathf.Clamp(_pitchVelocity, -MaxTurnSpeedPitch, MaxTurnSpeedPitch);

                float deltaYaw = _yawVelocity * deltaTime * 60f;
                float deltaPitch = _pitchVelocity * deltaTime * 60f;

                deltaYaw = Mathf.Clamp(deltaYaw, -MaxDeltaYaw, MaxDeltaYaw);
                deltaPitch = Mathf.Clamp(deltaPitch, -MaxDeltaPitch, MaxDeltaPitch);

                _currentYaw = Mathf.Repeat(_currentYaw + deltaYaw, 360f);
                _currentPitch = Mathf.Clamp(_currentPitch + deltaPitch, -45f, 60f);

                Quaternion targetRot = Quaternion.Euler(_currentPitch, _currentYaw, 0f);
                if (!float.IsNaN(targetRot.x) && !float.IsNaN(targetRot.y) && !float.IsNaN(targetRot.z))
                {
                    // Extra harden: if this frame would "look up/down" more than ~65 deg, clamp to previous
                    if (Mathf.Abs(_currentPitch) > 65f)
                        _currentPitch = Mathf.Clamp(_currentPitch, -30f, 48f);
                    body.rotation = targetRot;
                }
            }
            catch (Exception ex)
            {
                Logger.LogError("[BotLookController] Tick failed: " + ex);
            }
        }

        public void SetLookTarget(Vector3 worldPos)
        {
            if (IsValid(worldPos))
                _fallbackLookTarget = worldPos;
        }

        public void FreezeLook() => _frozen = true;
        public void ResumeLook() => _frozen = false;
        public Vector3 GetLookDirection() => _bot != null ? _bot.LookDirection : Vector3.forward;

        #endregion

        #region Internal Look Logic

        private Vector3 ValidateLookTarget(Vector3 origin, Vector3 rawTarget)
        {
            Vector3 dir = rawTarget - origin;
            float dist = dir.magnitude;
            if (dist < 0.1f)
                return rawTarget;

            if (Physics.Raycast(origin + Vector3.up * 1.44f, dir.normalized, out RaycastHit hit, Mathf.Min(dist, VisionBlockCheckDist), AIRefactoredLayerMasks.VisionBlockers))
            {
                return hit.point - dir.normalized * 0.2f;
            }
            return rawTarget;
        }

        private static bool IsValid(Vector3 pos)
        {
            return !float.IsNaN(pos.x) && !float.IsNaN(pos.y) && !float.IsNaN(pos.z);
        }

        #endregion
    }
}
