// <auto-generated>
//   AI-Refactored: BotLookController.cs (Supreme Arbitration Overlay/Event Edition – June 2025, Ultra-Realism, All-System-Integrated, Zero-Alloc, SPT/FIKA/Client Safe)
//   Arbitration/event-only. Anti-robot, anti-stuck, squad/personality/cover/idle/flash/edge/vision aware, pooled, zero alloc, multiplayer/headless safe.
//   Deep integration with perception, vision, flash, and cover systems. All errors contained. Production/feature-complete. MIT License.
// </auto-generated>

namespace AIRefactored.AI.Movement
{
    using System;
    using AIRefactored.AI;
    using AIRefactored.AI.Core;
    using AIRefactored.AI.Helpers;
    using AIRefactored.AI.Perception;
    using AIRefactored.Core;
    using EFT;
    using UnityEngine;

    /// <summary>
    /// Arbitration/event-only, stabilized, robust, lifelike look/aim/scan controller.
    /// Handles squad, panic/flash/vision/perception, fallback, idle, micro-wobble, edge, memory, anti-stuck.
    /// Overlay/event-only. Bulletproof and error-isolated.
    /// </summary>
    public sealed class BotLookController
    {
        #region Constants

        private const float MaxTurnSpeedYaw = 6.8f;
        private const float MaxTurnSpeedPitch = 4.8f;
        private const float MaxDeltaYaw = 13.0f;
        private const float MaxDeltaPitch = 9.0f;
        private const float LookSwitchCooldown = 0.18f;
        private const float IdleScanCone = 22.0f;
        private const float IdleScanDurationMin = 1.05f, IdleScanDurationMax = 2.2f;
        private const float VisionBlockCheckDist = 41f;
        private const float LookFallbackDist = 1.65f;
        private const float MinLookDistanceSqr = 0.18f;
        private const float YawInertiaAccel = 0.10f, PitchInertiaAccel = 0.06f;
        private const float StabilityThresholdSqr = 0.29f;
        private const float OvershootAmountYaw = 5.7f, OvershootAmountPitch = 2.3f;
        private const float IdleHeadJitter = 2.1f;
        private const float BlindScanCooldown = 1.05f;
        private const float SquadFollowOffsetYaw = 6.2f;
        private const float LastSeenTimeout = 7.5f;
        private const float MaxLookHistory = 3.6f;
        private const float VoiceComCooldown = 1.5f;
        private const float FatigueDecayPerSecond = 0.13f;
        private const float FatigueWobbleAmount = 1.2f;
        private const float MicroCorrectionInterval = 2.3f;
        private const float MaxUnnaturalLookTime = 7.6f;
        private const float IdleLookRandomness = 0.25f;
        private const float EdgeScanCooldown = 2.3f;
        private const float EdgeLookOffset = 0.39f;
        private const float FlashBlindPenaltyYaw = 18f;
        private const float FlashBlindPenaltyPitch = 7.7f;
        private const float FlashSuppressCooldown = 2.1f;

        #endregion

        #region Fields

        private static readonly BepInEx.Logging.ManualLogSource Logger = Plugin.LoggerInstance;

        private readonly BotOwner _bot;
        private readonly BotComponentCache _cache;
        private readonly BotPersonalityProfile _personality;

        private float _currentYaw, _currentPitch;
        private float _yawVelocity, _pitchVelocity;
        private float _nextIdleScanTime, _idleTargetYaw;
        private float _lastLookSwitchTime;
        private float _nextHeadJitterTime;
        private bool _frozen, _overshootPending, _hasSquadLook;
        private float _overshootTargetYaw, _overshootTargetPitch;
        private float _nextBlindScanTime, _lastSquadLookUpdate;
        private float _lastSeenEnemyTime, _lastValidLookTime, _voiceCooldownUntil, _lookFatigue, _lastMicroCorrectionTime, _unnaturalLockStart, _lastEdgeScanTime, _flashSuppressUntil;
        private Vector3 _fallbackLookTarget, _lastLookTarget, _lastSeenEnemyPos, _squadLookTarget, _lastSafeFallbackLook;

        #endregion

        #region Construction

        public BotLookController(BotOwner bot, BotComponentCache cache)
        {
            if (!EFTPlayerUtil.IsValidBotOwner(bot) || cache == null)
            {
                Logger.LogError("[BotLookController] Null bot/cache at construction.");
                throw new ArgumentException("Invalid BotLookController parameters.");
            }
            _bot = bot;
            _cache = cache;
            _personality = cache.PersonalityProfile ?? BotPersonalityProfile.Default;
            Player player = EFTPlayerUtil.ResolvePlayer(bot);
            Transform body = EFTPlayerUtil.GetTransform(player);
            Vector3 forward = body != null ? body.forward : Vector3.forward;
            _currentYaw = body != null ? body.rotation.eulerAngles.y : 0f;
            _currentPitch = 0f;
            _yawVelocity = 0f;
            _pitchVelocity = 0f;
            _fallbackLookTarget = bot.Position + forward;
            _lastLookTarget = _fallbackLookTarget;
            _lastLookSwitchTime = Time.time;
            _nextIdleScanTime = Time.time + UnityEngine.Random.Range(IdleScanDurationMin, IdleScanDurationMax);
            _nextHeadJitterTime = Time.time + UnityEngine.Random.Range(0.7f, 1.5f);
            _lastSafeFallbackLook = _fallbackLookTarget;
            _lastValidLookTime = Time.time;
            _voiceCooldownUntil = 0f;
            _lookFatigue = 0f;
            _lastMicroCorrectionTime = Time.time;
            _unnaturalLockStart = 0f;
            _lastEdgeScanTime = -EdgeScanCooldown;
            _flashSuppressUntil = -FlashSuppressCooldown;
        }

        #endregion

        #region Overlay/Event Tick Integration

        public void Tick(float deltaTime)
        {
            TryOverlay(deltaTime);
        }

        #endregion

        #region Public API

        public void TryOverlay(float deltaTime)
        {
            const BotOverlayType OverlayType = BotOverlayType.Special;
            try
            {
                if (_bot == null || _cache == null || _bot.IsDead || !GameWorldHandler.IsSafeToInitialize)
                    return;
                if (_frozen && Time.time - _lastLookSwitchTime < 1.0f)
                    return;
                if (!BotOverlayManager.CanIssueMove(_bot, OverlayType))
                    return;

                Player player = EFTPlayerUtil.ResolvePlayer(_bot);
                if (!EFTPlayerUtil.IsValid(player))
                {
                    BotOverlayManager.ReleaseMove(_bot, OverlayType);
                    return;
                }
                Transform body = EFTPlayerUtil.GetTransform(player);
                if (body == null)
                {
                    BotOverlayManager.ReleaseMove(_bot, OverlayType);
                    return;
                }
                Vector3 origin = body.position;

                // === 1. FLASH/BLIND/PANIC/SUPPRESSION/EDGE SUPPRESSION HANDLING ===

                bool isPanic = _cache.PanicHandler?.IsPanicking ?? false;
                bool isSuppressed = _cache.PanicHandler != null && _cache.PanicHandler.GetComposureLevel() < 0.22f;
                bool isBlinded = _cache.FlashGrenade != null && _cache.FlashGrenade.IsFlashed();
                bool isPerceptionSuppressed = _cache.Perception != null && _cache.Perception.IsSuppressed;

                bool flashOrBlind = isBlinded;
                bool suppressed = isSuppressed || isPerceptionSuppressed || isPanic;

                bool isEdge = EdgeCheck(out Vector3 edgeLookTarget);

                if ((flashOrBlind || suppressed) && Time.time < _flashSuppressUntil)
                {
                    float penaltyYaw = UnityEngine.Random.Range(-FlashBlindPenaltyYaw, FlashBlindPenaltyYaw);
                    float penaltyPitch = UnityEngine.Random.Range(-FlashBlindPenaltyPitch, FlashBlindPenaltyPitch);
                    _currentYaw += penaltyYaw;
                    _currentPitch += penaltyPitch;
                    _lookFatigue = Mathf.Min(_lookFatigue + FatigueDecayPerSecond * deltaTime * 3.2f, 2.3f);

                    if (Time.time > _voiceCooldownUntil)
                    {
                        TrySay("suppressed_flash");
                        _voiceCooldownUntil = Time.time + VoiceComCooldown;
                    }

                    if (isEdge)
                        SetLookTarget(edgeLookTarget + Vector3.up * 0.22f);
                    else
                        _fallbackLookTarget = origin + Quaternion.Euler(0, UnityEngine.Random.Range(-120f, 120f), 0) * Vector3.forward * 2.5f;

                    _lastValidLookTime = Time.time;
                    _lastSafeFallbackLook = _fallbackLookTarget;
                    BotOverlayManager.RegisterMove(_bot, OverlayType);
                    BotOverlayManager.ReleaseMove(_bot, OverlayType);
                    return;
                }
                if (flashOrBlind || suppressed)
                    _flashSuppressUntil = Time.time + FlashSuppressCooldown;

                // === 2. SQUAD LOOK SYNC, EDGE AWARENESS, LEAN/POSING, HUMANIZED ANTICIPATION ===

                bool squadLookThisFrame = false;
                bool squadHasValidLeader = false;
                Vector3 leaderLookTarget = Vector3.zero;

                if (_bot.BotsGroup != null && _bot.BotsGroup.MembersCount > 1 && Time.time - _lastSquadLookUpdate > 0.77f)
                {
                    int leaderIdx = 0;
                    float minId = float.MaxValue;
                    for (int i = 0; i < _bot.BotsGroup.MembersCount; i++)
                    {
                        var m = _bot.BotsGroup.Member(i);
                        if (m != null && m.Profile != null && float.TryParse(m.Profile.Id, out float parsed) && parsed < minId)
                        {
                            minId = parsed;
                            leaderIdx = i;
                        }
                    }
                    var leader = _bot.BotsGroup.Member(leaderIdx);
                    if (leader != null && leader != _bot)
                    {
                        Player squadLeadPlayer = EFTPlayerUtil.ResolvePlayer(leader);
                        if (EFTPlayerUtil.IsValid(squadLeadPlayer))
                        {
                            Transform leaderBody = EFTPlayerUtil.GetTransform(squadLeadPlayer);
                            if (leaderBody != null)
                            {
                                Vector3 leadDir = leaderBody.forward;
                                Vector3 baseLook = leaderBody.position + leadDir * 2.3f;
                                float variance = UnityEngine.Random.Range(-6.3f, 7.3f) * (0.19f + _personality.Awareness * 0.22f);
                                float angle = Mathf.Deg2Rad * (variance + leaderBody.rotation.eulerAngles.y);
                                Vector3 offset = new Vector3(Mathf.Sin(angle), 0, Mathf.Cos(angle)) * (0.25f + 0.13f * leaderIdx);

                                leaderLookTarget = baseLook + offset;
                                _squadLookTarget = leaderLookTarget;
                                squadHasValidLeader = true;
                                _lastSquadLookUpdate = Time.time;
                                _hasSquadLook = true;
                                squadLookThisFrame = true;

                                if (UnityEngine.Random.value < 0.13f * _personality.Awareness && _cache.PoseController != null)
                                {
                                    _cache.PoseController.SetAnticipationPose();
                                }

                                if (UnityEngine.Random.value < 0.17f * _personality.Caution && _cache.Tilt != null)
                                {
                                    BotTiltType leanDir = leaderIdx % 2 == 0 ? BotTiltType.left : BotTiltType.right;
                                    _cache.Tilt.Set(leanDir);
                                }

                                if (Time.time > _voiceCooldownUntil && UnityEngine.Random.value < 0.055f)
                                {
                                    TrySay("squad_sync");
                                    _voiceCooldownUntil = Time.time + VoiceComCooldown * (0.85f + UnityEngine.Random.value * 0.22f);
                                }
                            }
                        }
                    }
                }

                if (squadHasValidLeader && squadLookThisFrame)
                {
                    Vector3 toSquadLook = _squadLookTarget - origin;
                    float squadYawTarget = Mathf.Atan2(toSquadLook.x, toSquadLook.z) * Mathf.Rad2Deg;
                    float blendFactor = 0.72f + UnityEngine.Random.value * 0.19f;
                    _currentYaw = Mathf.LerpAngle(_currentYaw, squadYawTarget, blendFactor * deltaTime);
                }

                if (EdgeCheck(out Vector3 edgeLookTarget2))
                {
                    float edgeVariance = UnityEngine.Random.Range(-3.5f, 3.5f);
                    Vector3 edgeTarget = edgeLookTarget2 + Vector3.up * 0.18f + Vector3.right * edgeVariance * 0.07f;
                    SetLookTarget(edgeTarget);

                    if (_cache.Tilt != null && UnityEngine.Random.value < 0.21f * _personality.Caution)
                    {
                        BotTiltType edgeLean = UnityEngine.Random.value > 0.5f ? BotTiltType.left : BotTiltType.right;
                        _cache.Tilt.Set(edgeLean);
                    }
                    if (_cache.PoseController != null && UnityEngine.Random.value < 0.13f * _personality.Awareness)
                    {
                        _cache.PoseController.SetCrouch();
                    }
                }

                Vector3 nextTarget = _fallbackLookTarget;
                bool switching = false;

                // === 3. ENEMY TRACKING, MEMORY, OVERSHOOT, VOICE ===
                string id = _cache.ThreatSelector?.GetTargetProfileId();
                Player enemy = EFTPlayerUtil.ResolvePlayerById(id);
                if (EFTPlayerUtil.IsValid(enemy))
                {
                    Vector3 enemyPos = EFTPlayerUtil.GetPosition(enemy);
                    _lastSeenEnemyTime = Time.time;
                    _lastSeenEnemyPos = enemyPos;
                    nextTarget = enemyPos;
                    _unnaturalLockStart = Time.time;

                    if (_hasSquadLook && squadLookThisFrame && UnityEngine.Random.value < 0.19f)
                    {
                        float offset = UnityEngine.Random.Range(-SquadFollowOffsetYaw, SquadFollowOffsetYaw);
                        nextTarget = Quaternion.Euler(0f, offset, 0f) * (nextTarget - origin) + origin;
                        if (Time.time > _voiceCooldownUntil)
                        {
                            TrySay("squad_look");
                            _voiceCooldownUntil = Time.time + VoiceComCooldown;
                        }
                    }
                    else if (Time.time > _voiceCooldownUntil && UnityEngine.Random.value < 0.07f)
                    {
                        TrySay("see_enemy");
                        _voiceCooldownUntil = Time.time + VoiceComCooldown;
                    }

                    if ((nextTarget - _lastLookTarget).sqrMagnitude > StabilityThresholdSqr)
                    {
                        if (Time.time - _lastLookSwitchTime > LookSwitchCooldown)
                        {
                            switching = true;
                            _lastLookSwitchTime = Time.time;
                            if (!_overshootPending)
                            {
                                _overshootPending = true;
                                float sign = UnityEngine.Random.value > 0.5f ? 1f : -1f;
                                _overshootTargetYaw = _currentYaw + sign * OvershootAmountYaw * UnityEngine.Random.Range(0.6f, 1.19f);
                                _overshootTargetPitch = _currentPitch + UnityEngine.Random.Range(-OvershootAmountPitch, OvershootAmountPitch);
                            }
                            _lastLookTarget = nextTarget;
                            _lastValidLookTime = Time.time;
                        }
                        else
                        {
                            nextTarget = _lastLookTarget;
                        }
                    }
                    else
                    {
                        nextTarget = _lastLookTarget;
                    }
                }
                else if (Time.time - _lastSeenEnemyTime < LastSeenTimeout)
                {
                    nextTarget = _lastSeenEnemyPos;
                    _lastLookTarget = nextTarget;
                    switching = true;
                    _lookFatigue += FatigueDecayPerSecond * deltaTime * 0.5f;
                    if (_lookFatigue > 1.4f) _lookFatigue = 1.4f;
                }

                // === 4. EDGE-AWARE LOOKING ===
                if (isEdge && Time.time - _lastEdgeScanTime > EdgeScanCooldown)
                {
                    nextTarget = edgeLookTarget + Vector3.up * EdgeLookOffset;
                    _lastEdgeScanTime = Time.time;
                }

                // === 5. MICRO-CORRECTIONS / HEAD MOVEMENT / UNNATURAL LOOK RELAX ===
                if (Time.time - _unnaturalLockStart > MaxUnnaturalLookTime && !HasRecentlyMicroCorrected())
                {
                    _currentYaw += UnityEngine.Random.Range(-FatigueWobbleAmount, FatigueWobbleAmount);
                    _currentPitch += UnityEngine.Random.Range(-FatigueWobbleAmount * 0.45f, FatigueWobbleAmount * 0.23f);
                    _lastMicroCorrectionTime = Time.time;
                    _unnaturalLockStart = Time.time;
                }

                // === 6. IDLE/SCAN/LOOT ===
                bool hasThreat = !string.IsNullOrEmpty(id);
                if (!switching && !hasThreat)
                {
                    if (Time.time > _nextIdleScanTime)
                    {
                        _idleTargetYaw = _currentYaw + UnityEngine.Random.Range(-IdleScanCone, IdleScanCone);
                        _nextIdleScanTime = Time.time + UnityEngine.Random.Range(IdleScanDurationMin, IdleScanDurationMax);

                        Vector3 idleDir = Quaternion.Euler(0f, _idleTargetYaw, 0f) * Vector3.forward;
                        float randomness = IdleLookRandomness * UnityEngine.Random.value;
                        nextTarget = origin + idleDir * (2.3f + randomness);
                        _lastLookSwitchTime = Time.time;
                        _lastLookTarget = nextTarget;
                        _lastValidLookTime = Time.time;
                        _lookFatigue *= 0.67f;
                        if (Time.time > _voiceCooldownUntil && UnityEngine.Random.value < 0.04f)
                        {
                            TrySay("idle_scan");
                            _voiceCooldownUntil = Time.time + VoiceComCooldown;
                        }
                    }
                    else
                    {
                        if (Time.time > _nextHeadJitterTime)
                        {
                            float jitter = UnityEngine.Random.Range(-IdleHeadJitter, IdleHeadJitter);
                            _currentYaw += jitter * 0.13f * (0.88f + _personality.Awareness * 0.26f);
                            _currentPitch += UnityEngine.Random.Range(-IdleHeadJitter * 0.19f, IdleHeadJitter * 0.13f);
                            _nextHeadJitterTime = Time.time + UnityEngine.Random.Range(0.7f, 1.5f);
                        }
                        nextTarget = _lastLookTarget;
                    }
                }

                // === 7. FALLBACK if invalid or stale ===
                if (!IsValid(nextTarget))
                {
                    Vector3 lookDir = _bot.LookDirection.sqrMagnitude > 0.01f ? _bot.LookDirection.normalized : Vector3.forward;
                    nextTarget = _bot.Position + lookDir * LookFallbackDist;
                    _lastSafeFallbackLook = nextTarget;
                    _lastValidLookTime = Time.time;
                }
                if (Time.time - _lastValidLookTime > MaxLookHistory)
                {
                    nextTarget = _lastSafeFallbackLook;
                    _lastValidLookTime = Time.time;
                }

                nextTarget = ValidateLookTarget(origin, nextTarget);

                Vector3 lookVec = nextTarget - origin;
                if (lookVec.sqrMagnitude < MinLookDistanceSqr)
                {
                    lookVec = _bot.LookDirection.sqrMagnitude > 0.01f
                        ? _bot.LookDirection.normalized
                        : Vector3.forward;
                }

                float targetYaw = Mathf.Atan2(lookVec.x, lookVec.z) * Mathf.Rad2Deg;
                float targetPitch = -Mathf.Atan2(lookVec.y, new Vector2(lookVec.x, lookVec.z).magnitude) * Mathf.Rad2Deg;

                if (_overshootPending)
                {
                    targetYaw = Mathf.Lerp(targetYaw, _overshootTargetYaw, 0.28f + UnityEngine.Random.Range(0.12f, 0.24f));
                    targetPitch = Mathf.Lerp(targetPitch, _overshootTargetPitch, 0.15f + UnityEngine.Random.Range(0.08f, 0.19f));
                    _overshootPending = false;
                }

                float yawDiff = Mathf.DeltaAngle(_currentYaw, targetYaw);
                float pitchDiff = Mathf.DeltaAngle(_currentPitch, targetPitch);

                float yawAccel = YawInertiaAccel * (0.83f + UnityEngine.Random.value * 0.27f) * Mathf.Lerp(0.72f, 1.22f, _personality.Awareness) * (1.0f - _lookFatigue * 0.18f);
                float pitchAccel = PitchInertiaAccel * (0.89f + UnityEngine.Random.value * 0.17f) * Mathf.Lerp(0.91f, 1.17f, _personality.Caution) * (1.0f - _lookFatigue * 0.13f);

                _yawVelocity += Mathf.Clamp(yawDiff, -MaxDeltaYaw, MaxDeltaYaw) * yawAccel * deltaTime;
                _pitchVelocity += Mathf.Clamp(pitchDiff, -MaxDeltaPitch, MaxDeltaPitch) * pitchAccel * deltaTime;
                _yawVelocity = Mathf.Clamp(_yawVelocity, -MaxTurnSpeedYaw, MaxTurnSpeedYaw);
                _pitchVelocity = Mathf.Clamp(_pitchVelocity, -MaxTurnSpeedPitch, MaxTurnSpeedPitch);

                float deltaYaw = _yawVelocity * deltaTime * 60f;
                float deltaPitch = _pitchVelocity * deltaTime * 60f;
                deltaYaw = Mathf.Clamp(deltaYaw, -MaxDeltaYaw, MaxDeltaYaw);
                deltaPitch = Mathf.Clamp(deltaPitch, -MaxDeltaPitch, MaxDeltaPitch);

                _currentYaw = Mathf.Repeat(_currentYaw + deltaYaw, 360f);
                _currentPitch = Mathf.Clamp(_currentPitch + deltaPitch, -42f, 56f);

                Quaternion targetRot = Quaternion.Euler(_currentPitch, _currentYaw, 0f);
                if (!float.IsNaN(targetRot.x) && !float.IsNaN(targetRot.y) && !float.IsNaN(targetRot.z))
                {
                    if (Mathf.Abs(_currentPitch) > 63f)
                        _currentPitch = Mathf.Clamp(_currentPitch, -32f, 48f);
                    body.rotation = targetRot;
                }

                BotOverlayManager.RegisterMove(_bot, OverlayType);
                BotOverlayManager.ReleaseMove(_bot, OverlayType);

                if (!(isPanic || isSuppressed || isBlinded) && _lookFatigue > 0f)
                    _lookFatigue -= FatigueDecayPerSecond * deltaTime * 0.84f;
                if (_lookFatigue < 0f) _lookFatigue = 0f;
            }
            catch (Exception ex)
            {
                Logger.LogError("[BotLookController] TryOverlay failed: " + ex);
                BotOverlayManager.ReleaseMove(_bot, OverlayType);
            }
        }

        public void SetLookTarget(Vector3 worldPos)
        {
            if (IsValid(worldPos))
            {
                _fallbackLookTarget = worldPos;
                _lastLookTarget = worldPos;
                _lastSafeFallbackLook = worldPos;
                _lastValidLookTime = Time.time;
            }
        }
        public void FreezeLook() => _frozen = true;
        public void ResumeLook() => _frozen = false;
        public Vector3 GetLookDirection() => _bot != null ? _bot.LookDirection : Vector3.forward;

        #endregion

        #region Internal Look/Perception/Edge Logic

        private Vector3 ValidateLookTarget(Vector3 origin, Vector3 rawTarget)
        {
            Vector3 dir = rawTarget - origin;
            float dist = dir.magnitude;
            if (dist < 0.1f)
                return rawTarget;
            if (Physics.Raycast(origin + Vector3.up * 1.44f, dir.normalized, out RaycastHit hit, Mathf.Min(dist, VisionBlockCheckDist), AIRefactoredLayerMasks.VisionBlockers))
            {
                return hit.point - dir.normalized * 0.18f;
            }
            return rawTarget;
        }

        private static bool IsValid(Vector3 pos)
        {
            return !float.IsNaN(pos.x) && !float.IsNaN(pos.y) && !float.IsNaN(pos.z);
        }

        private bool EdgeCheck(out Vector3 edgeLook)
        {
            edgeLook = Vector3.zero;
            if (_bot == null || _bot.Transform == null)
                return false;
            Vector3 origin = _bot.Position + Vector3.up * 0.15f;
            Vector3 forward = _bot.Transform.forward;
            float scanDist = 1.25f + UnityEngine.Random.value * 0.21f;
            for (float offset = -0.31f; offset <= 0.31f; offset += 0.31f)
            {
                Vector3 scanPoint = origin + _bot.Transform.right * offset;
                if (!Physics.Raycast(scanPoint, forward, out RaycastHit hit, scanDist, AIRefactoredLayerMasks.NavObstacleMask))
                {
                    edgeLook = scanPoint + forward * scanDist;
                    return true;
                }
            }
            return false;
        }

        private void TrySay(string eventId)
        {
            // Extend: plug into AIRefactored voice/overlay/squad system here.
        }

        private bool HasRecentlyMicroCorrected()
        {
            return (Time.time - _lastMicroCorrectionTime) < MicroCorrectionInterval;
        }

        #endregion
    }
}
