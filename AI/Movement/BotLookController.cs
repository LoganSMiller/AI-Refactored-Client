// <auto-generated>
//   This file is part of AI-Refactored, an open-source project focused on realistic AI behavior in Escape from Tarkov.
//   Licensed under the MIT License. See LICENSE in the repository root for more information.
//
//   THIS FILE IS SYSTEMATICALLY MANAGED.
//   Please follow strict StyleCop, ReSharper, and AI-Refactored code standards for all modifications.
// </auto-generated>

namespace AIRefactored.AI.Movement
{
    using System;
    using AIRefactored.AI.Core;
    using AIRefactored.Core;
    using EFT;
    using UnityEngine;

    /// <summary>
    /// Controls bot look direction using smooth rotation logic and realistic perception response.
    /// Integrates panic, blindness, sound, and enemy awareness.
    /// </summary>
    public sealed class BotLookController
    {
        #region Constants

        private const float MaxTurnSpeed = 7.5f;
        private const float MinLookDistanceSqr = 0.25f;
        private const float BlindLookRadius = 4f;
        private const float HeardDirectionWeight = 6f;
        private const float SoundMemoryDuration = 4f;

        #endregion

        #region Fields

        private readonly BotOwner _bot;
        private readonly BotComponentCache _cache;
        private Vector3 _fallbackLookTarget;
        private bool _frozen;

        #endregion

        #region Constructor

        public BotLookController(BotOwner bot, BotComponentCache cache)
        {
            if (bot == null || cache == null)
            {
                throw new ArgumentException("[BotLookController] Invalid bot or cache.");
            }

            _bot = bot;
            _cache = cache;
            _fallbackLookTarget = bot.Position + bot.LookDirection;
        }

        #endregion

        #region Public Methods

        /// <summary>
        /// Updates the look direction every frame unless frozen or blocked.
        /// </summary>
        public void Tick(float deltaTime)
        {
            if (_frozen || _bot == null || _cache == null || _bot.IsDead || !GameWorldHandler.IsSafeToInitialize)
            {
                return;
            }

            Player player = EFTPlayerUtil.ResolvePlayer(_bot);
            if (!EFTPlayerUtil.IsValid(player))
            {
                return;
            }

            Transform bodyTransform = EFTPlayerUtil.GetTransform(player);
            if (bodyTransform == null)
            {
                return;
            }

            Vector3 origin = bodyTransform.position;
            Vector3 lookTarget = ResolveLookTarget(origin);
            Vector3 direction = lookTarget - origin;
            direction.y = 0f;

            if (direction.sqrMagnitude < MinLookDistanceSqr)
            {
                return;
            }

            Quaternion current = bodyTransform.rotation;
            Quaternion target = Quaternion.LookRotation(direction);
            bodyTransform.rotation = Quaternion.Slerp(current, target, Mathf.Clamp01(MaxTurnSpeed * deltaTime));
        }

        /// <summary>
        /// Sets a fallback target to look toward when no threats or distractions are present.
        /// </summary>
        public void SetLookTarget(Vector3 worldPos)
        {
            _fallbackLookTarget = worldPos;
        }

        /// <summary>
        /// Disables all look control (used during animations or forced behavior).
        /// </summary>
        public void FreezeLook()
        {
            _frozen = true;
        }

        /// <summary>
        /// Re-enables look control if previously frozen.
        /// </summary>
        public void ResumeLook()
        {
            _frozen = false;
        }

        /// <summary>
        /// Gets the bot's current look direction vector.
        /// </summary>
        public Vector3 GetLookDirection()
        {
            return _bot.LookDirection;
        }

        #endregion

        #region Internal Logic

        private Vector3 ResolveLookTarget(Vector3 origin)
        {
            float now = Time.time;

            if (_cache.IsBlinded && now < _cache.BlindUntilTime)
            {
                Vector3 offset = UnityEngine.Random.insideUnitSphere;
                offset.y = 0f;
                return origin + offset.normalized * BlindLookRadius;
            }

            if (_cache.Panic != null && _cache.Panic.IsPanicking)
            {
                if (_cache.HasHeardDirection)
                {
                    return origin + _cache.LastHeardDirection.normalized * HeardDirectionWeight;
                }

                return origin + _bot.LookDirection;
            }

            if (_cache.ThreatSelector != null)
            {
                string profileId = _cache.ThreatSelector.GetTargetProfileId();
                if (profileId.Length != 0)
                {
                    Player player = EFTPlayerUtil.ResolvePlayerById(profileId);
                    if (EFTPlayerUtil.IsValid(player))
                    {
                        Vector3 pos = EFTPlayerUtil.GetPosition(player);
                        if (pos.sqrMagnitude > 0.01f)
                        {
                            return pos;
                        }
                    }
                }
            }

            if (_cache.HasHeardDirection && (now - _cache.LastHeardTime) < SoundMemoryDuration)
            {
                return origin + _cache.LastHeardDirection.normalized * HeardDirectionWeight;
            }

            return _fallbackLookTarget;
        }

        #endregion
    }
}
