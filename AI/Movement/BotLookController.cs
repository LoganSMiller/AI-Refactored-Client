// <auto-generated>
//   This file is part of AI-Refactored, an open-source project focused on realistic AI behavior in Escape from Tarkov.
//   Licensed under the MIT License. See LICENSE in the repository root for more information.
//
//   THIS FILE IS SYSTEMATICALLY MANAGED.
//   Bulletproof: No fallback logic. All look direction and update failures are locally logged and isolated only.
//   Realism Pass: Human-like micro-scanning, distraction, and organic idle head/eye movement.
// </auto-generated>

namespace AIRefactored.AI.Movement
{
    using System;
    using AIRefactored.AI.Core;
    using AIRefactored.Core;
    using BepInEx.Logging;
    using EFT;
    using UnityEngine;

    /// <summary>
    /// Controls bot look direction using smooth rotation logic and realistic perception response.
    /// Integrates panic, blindness, sound, and enemy awareness.
    /// All failures are locally isolated; cannot break or cascade into other systems.
    /// </summary>
    public sealed class BotLookController
    {
        #region Constants

        private const float MaxTurnSpeed = 7.5f;
        private const float MinLookDistanceSqr = 0.25f;
        private const float BlindLookRadius = 4f;
        private const float HeardDirectionWeight = 6f;
        private const float SoundMemoryDuration = 4f;
        private const float IdleScanInterval = 2.4f;
        private const float IdleScanAngleMax = 65f;
        private const float IdleScanJitter = 7f;
        private const float IdleMissChance = 0.02f;

        #endregion

        #region Fields

        private static readonly ManualLogSource Logger = Plugin.LoggerInstance;

        private readonly BotOwner _bot;
        private readonly BotComponentCache _cache;

        private Vector3 _fallbackLookTarget;
        private bool _frozen;

        private float _nextIdleScanTime;
        private float _currentIdleAngle;
        private int _idleScanDirection;
        private float _idleJitterOffset;

        #endregion

        #region Constructor

        public BotLookController(BotOwner bot, BotComponentCache cache)
        {
            if (!EFTPlayerUtil.IsValidBotOwner(bot) || cache == null)
            {
                Logger.LogError("[BotLookController] Constructor failed — null bot or cache.");
                throw new ArgumentException("Invalid BotLookController parameters.");
            }

            _bot = bot;
            _cache = cache;
            _fallbackLookTarget = bot.Position + bot.LookDirection;
            _nextIdleScanTime = Time.time + UnityEngine.Random.Range(0.5f, 2.2f);
            _currentIdleAngle = 0f;
            _idleScanDirection = UnityEngine.Random.value > 0.5f ? 1 : -1;
            _idleJitterOffset = UnityEngine.Random.Range(-IdleScanJitter, IdleScanJitter);
        }

        #endregion

        #region Public Methods

        /// <summary>
        /// Updates look direction every tick, enforcing smooth and realistic behavior.
        /// All failures are locally isolated and logged; system cannot break.
        /// </summary>
        public void Tick(float deltaTime)
        {
            try
            {
                if (_frozen || _bot == null || _cache == null || _bot.IsDead || !GameWorldHandler.IsSafeToInitialize)
                    return;

                Player player = EFTPlayerUtil.ResolvePlayer(_bot);
                if (!EFTPlayerUtil.IsValid(player))
                    return;

                Transform body = EFTPlayerUtil.GetTransform(player);
                if (body == null)
                    return;

                Vector3 origin = body.position;
                Vector3 target = ResolveLookTarget(origin, deltaTime);
                Vector3 dir = target - origin;
                dir.y = 0f;

                if (dir.sqrMagnitude < MinLookDistanceSqr)
                    return;

                Quaternion from = body.rotation;
                Quaternion to = Quaternion.LookRotation(dir.normalized);
                body.rotation = Quaternion.Slerp(from, to, Mathf.Clamp01(MaxTurnSpeed * deltaTime));
            }
            catch (Exception ex)
            {
                Logger.LogError("[BotLookController] Tick failed: " + ex);
            }
        }

        /// <summary>
        /// Explicitly set the next look target (usually for combat or investigation).
        /// </summary>
        public void SetLookTarget(Vector3 worldPos)
        {
            try
            {
                if (IsValid(worldPos))
                {
                    _fallbackLookTarget = worldPos;
                }
            }
            catch (Exception ex)
            {
                Logger.LogError("[BotLookController] SetLookTarget failed: " + ex);
            }
        }

        /// <summary>
        /// Freeze all look updates (used for specific animations or critical actions).
        /// </summary>
        public void FreezeLook() { _frozen = true; }

        /// <summary>
        /// Resume normal look control after freeze.
        /// </summary>
        public void ResumeLook() { _frozen = false; }

        /// <summary>
        /// Returns the last known look direction of the bot.
        /// </summary>
        public Vector3 GetLookDirection()
        {
            try
            {
                return _bot != null ? _bot.LookDirection : Vector3.forward;
            }
            catch
            {
                return Vector3.forward;
            }
        }

        #endregion

        #region Private Methods

        /// <summary>
        /// Computes the next look target, considering blindness, panic, sound, and enemy threat.
        /// Also simulates realistic idle scanning/head rotation like a real player.
        /// All failures are locally isolated and fallback target is always valid.
        /// </summary>
        private Vector3 ResolveLookTarget(Vector3 origin, float deltaTime)
        {
            float now = Time.time;

            // Blinded: look around randomly, don't lock to any target.
            if (_cache != null && _cache.IsBlinded && now < _cache.BlindUntilTime)
            {
                Vector3 offset = UnityEngine.Random.insideUnitSphere;
                offset.y = 0f;
                return origin + offset.normalized * BlindLookRadius;
            }

            // Panic state: look in the last heard direction or hold current look.
            if (_cache?.Panic?.IsPanicking == true)
            {
                if (_cache.HasHeardDirection)
                    return origin + _cache.LastHeardDirection.normalized * HeardDirectionWeight;
                return origin + _bot.LookDirection;
            }

            // Threat selector: actively track enemy if available.
            if (_cache?.ThreatSelector != null)
            {
                string id = _cache.ThreatSelector.GetTargetProfileId();
                if (!string.IsNullOrEmpty(id))
                {
                    Player enemy = EFTPlayerUtil.ResolvePlayerById(id);
                    if (EFTPlayerUtil.IsValid(enemy))
                    {
                        Vector3 pos = EFTPlayerUtil.GetPosition(enemy);
                        if (pos.sqrMagnitude > 0.01f)
                            return pos;
                    }
                }
            }

            // Sound: look toward the last heard sound direction if within memory duration.
            if (_cache != null && _cache.HasHeardDirection && now - _cache.LastHeardTime < SoundMemoryDuration)
            {
                return origin + _cache.LastHeardDirection.normalized * HeardDirectionWeight;
            }

            // Idle scanning: perform subtle head turns and scan arcs as a real player would.
            if (now > _nextIdleScanTime)
            {
                _idleScanDirection = UnityEngine.Random.value > 0.5f ? 1 : -1;
                _nextIdleScanTime = now + IdleScanInterval + UnityEngine.Random.Range(-0.5f, 0.7f);
                _idleJitterOffset = UnityEngine.Random.Range(-IdleScanJitter, IdleScanJitter);
            }

            if (UnityEngine.Random.value < IdleMissChance)
                _currentIdleAngle += UnityEngine.Random.Range(-5f, 5f);

            float baseAngle = IdleScanAngleMax * _idleScanDirection * deltaTime * 0.5f;
            _currentIdleAngle = Mathf.Clamp(_currentIdleAngle + baseAngle + _idleJitterOffset * deltaTime * 0.15f, -IdleScanAngleMax, IdleScanAngleMax);

            Vector3 fwd = _bot.LookDirection.sqrMagnitude > 0.5f ? _bot.LookDirection.normalized : Vector3.forward;
            Quaternion idleYaw = Quaternion.AngleAxis(_currentIdleAngle, Vector3.up);
            Vector3 idleLook = idleYaw * fwd;

            return origin + idleLook * BlindLookRadius;
        }

        private static bool IsValid(Vector3 pos)
        {
            return !float.IsNaN(pos.x) && !float.IsNaN(pos.y) && !float.IsNaN(pos.z);
        }

        #endregion
    }
}
