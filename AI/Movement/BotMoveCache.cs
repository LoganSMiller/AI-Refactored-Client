// <auto-generated>
//   AI-Refactored: BotMoveCache.cs (Supreme Arbitration/Overlay Edition – June 2025, Max Robustness/Feature Expansion)
//   Hardened: anti-spam, anti-loop, anti-micro, anti-NaN/Inf, squad/intent/event parity, audit logging, zero alloc, pooled, multiplayer/headless safe.
//   MIT License.
// </auto-generated>

namespace AIRefactored.AI.Movement
{
    using System;
    using UnityEngine;

    /// <summary>
    /// Move intent audit record (public for telemetry/debug).
    /// </summary>
    public readonly struct MoveAudit
    {
        public readonly Vector3 Target;
        public readonly float Time;
        public readonly string Context;

        public MoveAudit(Vector3 target, float time, string context)
        {
            Target = target;
            Time = time;
            Context = context ?? "";
        }
    }

    /// <summary>
    /// Centralized arbitration/event-driven move cache.
    /// Tracks, dedupes, and audits all overlay/event bot movement.
    /// Bulletproof: anti-spam, anti-oscillation, anti-micro, anti-NaN/Inf, squad/event overlay aware.
    /// Pooled, error-guarded, multiplayer/headless robust, SPT/FIKA/vanilla safe.
    /// </summary>
    public sealed class BotMoveCache
    {
        #region Constants

        private const float MoveCooldown = 1.5f;
        private const float MinMoveDeltaSqr = 0.25f;
        private const float AntiOscillationWindow = 2.5f;
        private const int MaxOscillationCount = 3;
        private const float MinYDeltaForNewMove = 0.5f;
        private const int AuditHistorySize = 8;

        #endregion

        #region Fields

        public static BotMoveCache Zero { get; } = new BotMoveCache();

        public Vector3 LastIssuedTarget { get; private set; } = Vector3.zero;
        public float LastMoveTime { get; private set; } = -1000f;
        public string LastMoveContext { get; private set; } = "";
        public int LastMoveIntentType { get; private set; } = 0;
        public bool AnticipationActive { get; set; } = false;
        public bool EventLockoutActive { get; set; } = false;
        public int LastSquadGroupId { get; private set; } = 0;
        public string LastMoveMeta { get; private set; } = "";

        // Internal anti-oscillation and safety
        private Vector3 _prevIssuedTarget = Vector3.zero;
        private float _lastSwapTime = -1000f;
        private int _oscillationCount = 0;

        // Move audit ring buffer
        private readonly MoveAudit[] _moveHistory = new MoveAudit[AuditHistorySize];
        private int _moveHistoryPos = 0;

        #endregion

        #region Public API

        /// <summary>
        /// Resets all state for this cache (pool/reuse/squad/overlay).
        /// </summary>
        public void Reset()
        {
            LastIssuedTarget = Vector3.zero;
            _prevIssuedTarget = Vector3.zero;
            LastMoveTime = -1000f;
            LastMoveContext = "";
            LastMoveIntentType = 0;
            AnticipationActive = false;
            EventLockoutActive = false;
            LastSquadGroupId = 0;
            LastMoveMeta = "";
            _oscillationCount = 0;
            _lastSwapTime = -1000f;
            _moveHistoryPos = 0;
            for (int i = 0; i < _moveHistory.Length; i++)
                _moveHistory[i] = new MoveAudit(Vector3.zero, -1000f, "");
        }

        /// <summary>
        /// True if a move was issued within the cooldown period (anti-spam).
        /// </summary>
        public bool HasRecentMove(float now, float threshold = MoveCooldown)
        {
            if (threshold < 0.01f) threshold = MoveCooldown;
            return (now - LastMoveTime) <= threshold;
        }

        /// <summary>
        /// True if candidate is a new target (distance or Y-delta). Guards against NaN/Inf.
        /// </summary>
        public bool IsNewTarget(Vector3 candidate, float minDeltaSqr = MinMoveDeltaSqr)
        {
            if (!IsValid(candidate)) return false;
            if (!IsValid(LastIssuedTarget)) return true;
            float distSqr = (candidate - LastIssuedTarget).sqrMagnitude;
            float yDelta = Mathf.Abs(candidate.y - LastIssuedTarget.y);
            return distSqr > minDeltaSqr || yDelta > MinYDeltaForNewMove;
        }

        /// <summary>
        /// Returns true if this move can be issued (anti-loop, arbitration, dedupe, event lock, anti-oscillation).
        /// </summary>
        public bool CanIssueMove(Vector3 candidate, float now, float minDeltaSqr = MinMoveDeltaSqr, float cooldown = MoveCooldown)
        {
            if (!IsValid(candidate)) return false;
            if (AnticipationActive || EventLockoutActive) return false;
            if (cooldown < 0.01f) cooldown = MoveCooldown;
            if (HasRecentMove(now, cooldown) && !IsNewTarget(candidate, minDeltaSqr))
                return false;

            // Block move if oscillating/swapping targets repeatedly
            if (_oscillationCount > MaxOscillationCount && (now - _lastSwapTime) < AntiOscillationWindow)
                return false;

            return true;
        }

        /// <summary>
        /// Audits and records a new move request.
        /// Updates context, intent, squad ID, and audit log. Never throws on invalid input.
        /// </summary>
        public void AuditMove(Vector3 target, float now, string context, int intentType = 0, int squadId = 0, string meta = "")
        {
            if (!IsValid(target)) return;

            // Oscillation detection
            if (_prevIssuedTarget != Vector3.zero && (target - _prevIssuedTarget).sqrMagnitude < MinMoveDeltaSqr)
            {
                if ((now - _lastSwapTime) < AntiOscillationWindow)
                    _oscillationCount++;
                else
                    _oscillationCount = 1;
                _lastSwapTime = now;
            }
            else
            {
                _oscillationCount = 0;
            }
            _prevIssuedTarget = LastIssuedTarget;

            LastIssuedTarget = target;
            LastMoveTime = now;
            LastMoveContext = context ?? "";
            LastMoveIntentType = intentType;
            LastSquadGroupId = squadId;
            LastMoveMeta = meta ?? "";

            _moveHistory[_moveHistoryPos] = new MoveAudit(target, now, context ?? "");
            _moveHistoryPos = (_moveHistoryPos + 1) % _moveHistory.Length;
        }

        /// <summary>
        /// Returns move audit history for debug/telemetry (last X moves, oldest first).
        /// </summary>
        public MoveAudit[] GetMoveHistory()
        {
            MoveAudit[] result = new MoveAudit[_moveHistory.Length];
            int len = _moveHistory.Length;
            int idx = 0, cursor = _moveHistoryPos;
            for (; idx < len; idx++, cursor = (cursor + 1) % len)
                result[idx] = _moveHistory[cursor];
            return result;
        }

        /// <summary>
        /// Returns true if a candidate vector is valid for movement (not NaN/Inf/zero).
        /// </summary>
        public static bool IsValid(Vector3 v)
        {
            return !float.IsNaN(v.x) && !float.IsNaN(v.y) && !float.IsNaN(v.z)
                && !float.IsInfinity(v.x) && !float.IsInfinity(v.y) && !float.IsInfinity(v.z)
                && (v.sqrMagnitude > 0.001f);
        }

        /// <summary>
        /// Returns true if move oscillation guard is currently active.
        /// </summary>
        public bool IsOscillationBlocked(float now)
        {
            return (_oscillationCount > MaxOscillationCount) && ((now - _lastSwapTime) < AntiOscillationWindow);
        }

        /// <summary>
        /// Returns the number of oscillation events in the current window.
        /// </summary>
        public int GetOscillationCount() => _oscillationCount;

        /// <summary>
        /// Returns the timestamp of the last move swap (for debugging/metrics).
        /// </summary>
        public float GetLastSwapTime() => _lastSwapTime;

        #endregion
    }
}
