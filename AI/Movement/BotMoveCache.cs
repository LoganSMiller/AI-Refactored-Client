// <auto-generated>
//   AI-Refactored: BotMoveCache.cs (Ultra-Platinum++ – Overlay/Event, Deduped, Intent-Driven, June 2025)
//   Hardened: anti-spam, anti-oscillation, anti-micro, anti-NaN/Inf, intent/move auditing, full event overlay parity.
//   MIT License.
// </auto-generated>

namespace AIRefactored.AI.Movement
{
    using UnityEngine;

    /// <summary>
    /// Tracks, dedupes, and audits all overlay/event-driven bot movement.
    /// Bulletproof: anti-move-spam, anti-oscillation, anti-micro, anti-NaN, anti-Inf, squad/event overlay aware.
    /// Never used for direct movement. Only overlays/intents update or query this state.
    /// </summary>
    public sealed class BotMoveCache
    {
        private const float MoveCooldown = 1.5f;      // Minimum time between moves (seconds)
        private const float MinMoveDeltaSqr = 0.25f;  // Minimum squared distance to consider a target "new"

        /// <summary>
        /// Last valid worldspace move target issued for this bot.
        /// </summary>
        public Vector3 LastIssuedTarget { get; set; } = Vector3.zero;

        /// <summary>
        /// Last wallclock time (Time.time) that a move was issued.
        /// </summary>
        public float LastMoveTime { get; set; } = -1000f;

        /// <summary>
        /// Last move context string (optional, for diagnostics/audit).
        /// </summary>
        public string LastMoveContext { get; set; } = "";

        /// <summary>
        /// Last move intent type (optional, for future expansion/squad).
        /// </summary>
        public int LastMoveIntentType { get; set; } = 0;

        /// <summary>
        /// Overlay anticipation guard: set by overlays when anticipation/fakeout active.
        /// </summary>
        public bool AnticipationActive { get; set; } = false;

        /// <summary>
        /// Overlay lockout guard: set by overlays during event/squad lockouts.
        /// </summary>
        public bool EventLockoutActive { get; set; } = false;

        /// <summary>
        /// Optional: Last issued squad movement group ID (future-proof for squad sync).
        /// </summary>
        public int LastSquadGroupId { get; set; } = 0;

        /// <summary>
        /// Optional: Custom move meta for event/audit/voice overlays (future-proof).
        /// </summary>
        public string LastMoveMeta { get; set; } = "";

        /// <summary>
        /// Resets all state for this cache (pool/reuse/squad/overlay).
        /// </summary>
        public void Reset()
        {
            LastIssuedTarget = Vector3.zero;
            LastMoveTime = -1000f;
            LastMoveContext = "";
            LastMoveIntentType = 0;
            AnticipationActive = false;
            EventLockoutActive = false;
            LastSquadGroupId = 0;
            LastMoveMeta = "";
        }

        /// <summary>
        /// True if a move was issued within the cooldown period.
        /// </summary>
        public bool HasRecentMove(float now, float threshold = MoveCooldown)
        {
            return (now - LastMoveTime) <= threshold;
        }

        /// <summary>
        /// True if the candidate is a new target, sufficiently far from previous.
        /// </summary>
        public bool IsNewTarget(Vector3 candidate, float minDeltaSqr = MinMoveDeltaSqr)
        {
            if (!IsValid(candidate)) return false;
            if (!IsValid(LastIssuedTarget)) return true;
            return (candidate - LastIssuedTarget).sqrMagnitude > minDeltaSqr;
        }

        /// <summary>
        /// True if both time and distance thresholds are satisfied (issue move if new or cooldown expired).
        /// </summary>
        public bool CanIssueMove(Vector3 candidate, float now, float minDeltaSqr = MinMoveDeltaSqr, float cooldown = MoveCooldown)
        {
            if (!IsValid(candidate)) return false;
            if (AnticipationActive || EventLockoutActive) return false;
            return !HasRecentMove(now, cooldown) || IsNewTarget(candidate, minDeltaSqr);
        }

        /// <summary>
        /// Audits a new move request and records context/intent for event/overlay analytics.
        /// </summary>
        public void AuditMove(Vector3 target, float now, string context, int intentType = 0, int squadId = 0, string meta = "")
        {
            LastIssuedTarget = target;
            LastMoveTime = now;
            LastMoveContext = context;
            LastMoveIntentType = intentType;
            LastSquadGroupId = squadId;
            LastMoveMeta = meta;
        }

        /// <summary>
        /// Validates that a Vector3 is usable for movement (not NaN/Inf/zero).
        /// </summary>
        public static bool IsValid(Vector3 v)
        {
            return !float.IsNaN(v.x) && !float.IsNaN(v.y) && !float.IsNaN(v.z)
                && !float.IsInfinity(v.x) && !float.IsInfinity(v.y) && !float.IsInfinity(v.z)
                && (v.sqrMagnitude > 0.001f); // Not zero
        }
    }
}
