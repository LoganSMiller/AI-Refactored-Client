// <auto-generated>
//   AI-Refactored: BotMoveCache.cs (Supreme Arbitration/Overlay Edition – June 2025, Max Robustness/Feature Expansion)
//   Hardened: anti-spam, anti-loop, anti-micro, anti-NaN/Inf, squad/intent/event parity, audit logging, zero alloc, pooled, multiplayer/headless safe.
//   MIT License.
// </auto-generated>

namespace AIRefactored.AI.Movement
{
    using AIRefactored.AI.Core;
    using AIRefactored.AI.Helpers;
    using EFT;
    using System;
    using UnityEngine;

    /// <summary>
    /// Move intent audit record (public for telemetry/debug).
    /// </summary>
    public struct MoveAudit
    {
        public readonly Vector3 Target;
        public readonly float Time;
        public readonly string Context;
        public readonly BotOverlayType Overlay;
        public readonly int SquadId;
        public readonly int IntentType;
        public readonly string Meta;

        public MoveAudit(Vector3 target, float time, string context, BotOverlayType overlay, int squadId, int intentType, string meta)
        {
            Target = target;
            Time = time;
            Context = context ?? string.Empty;
            Overlay = overlay;
            SquadId = squadId;
            IntentType = intentType;
            Meta = meta ?? string.Empty;
        }
    }

    /// <summary>
    /// Centralized arbitration/event-driven move cache for overlay-driven bot movement.
    /// Bulletproof: anti-spam, anti-loop, anti-oscillation, anti-NaN/Inf/Y, audit, squad/event/intent parity, zero alloc, pooled, error-shielded.
    /// </summary>
    public sealed class BotMoveCache
    {
        #region Constants

        private const float MoveCooldown = 1.45f;
        private const float MinMoveDeltaSqr = 0.20f;
        private const float AntiOscillationWindow = 2.7f;
        private const int MaxOscillationCount = 3;
        private const float MinYDeltaForNewMove = 0.49f;
        private const int AuditHistorySize = 12;

        #endregion

        #region Fields

        public static BotMoveCache Zero { get; } = new BotMoveCache();

        public Vector3 LastIssuedTarget { get; private set; } = Vector3.zero;
        public float LastMoveTime { get; private set; } = -1000f;
        public string LastMoveContext { get; private set; } = "";
        public int LastMoveIntentType { get; private set; } = 0;
        public BotOverlayType LastOverlayType { get; private set; } = BotOverlayType.None;
        public bool AnticipationActive { get; set; } = false;
        public bool EventLockoutActive { get; set; } = false;
        public int LastSquadGroupId { get; private set; } = 0;
        public string LastMoveMeta { get; private set; } = "";

        // Internal anti-oscillation and safety
        private Vector3 _prevIssuedTarget = Vector3.zero;
        private float _lastSwapTime = -1000f;
        private int _oscillationCount = 0;

        // Move audit ring buffer
        private readonly MoveAudit[] _moveHistory = new MoveAudit[AuditHistorySize];
        private int _moveHistoryPos = 0;

        #endregion

        #region Public API

        /// <summary>
        /// Resets all state for this cache (pool/reuse/squad/overlay).
        /// </summary>
        public void Reset()
        {
            LastIssuedTarget = Vector3.zero;
            _prevIssuedTarget = Vector3.zero;
            LastMoveTime = -1000f;
            LastMoveContext = "";
            LastMoveIntentType = 0;
            LastOverlayType = BotOverlayType.None;
            AnticipationActive = false;
            EventLockoutActive = false;
            LastSquadGroupId = 0;
            LastMoveMeta = "";
            _oscillationCount = 0;
            _lastSwapTime = -1000f;
            _moveHistoryPos = 0;
            for (int i = 0; i < _moveHistory.Length; i++)
                _moveHistory[i] = new MoveAudit(Vector3.zero, -1000f, "", BotOverlayType.None, 0, 0, "");
        }

        /// <summary>
        /// True if a move was issued within the cooldown period (anti-spam).
        /// </summary>
        public bool HasRecentMove(float now, float threshold = MoveCooldown)
        {
            if (threshold < 0.01f) threshold = MoveCooldown;
            return (now - LastMoveTime) <= threshold;
        }

        /// <summary>
        /// True if candidate is a new target (distance or Y-delta). Guards against NaN/Inf.
        /// </summary>
        public bool IsNewTarget(Vector3 candidate, float minDeltaSqr = MinMoveDeltaSqr)
        {
            if (!IsValid(candidate)) return false;
            if (!IsValid(LastIssuedTarget)) return true;
            float distSqr = (candidate - LastIssuedTarget).sqrMagnitude;
            float yDelta = Mathf.Abs(candidate.y - LastIssuedTarget.y);
            return distSqr > minDeltaSqr || yDelta > MinYDeltaForNewMove;
        }

        /// <summary>
        /// Returns true if this move can be issued (anti-loop, arbitration, dedupe, event lock, anti-oscillation).
        /// </summary>
        public bool CanIssueMove(Vector3 candidate, float now, float minDeltaSqr = MinMoveDeltaSqr, float cooldown = MoveCooldown)
        {
            if (!IsValid(candidate)) return false;
            if (AnticipationActive || EventLockoutActive) return false;
            if (cooldown < 0.01f) cooldown = MoveCooldown;
            if (HasRecentMove(now, cooldown) && !IsNewTarget(candidate, minDeltaSqr))
                return false;

            // Block move if oscillating/swapping targets repeatedly
            if (_oscillationCount > MaxOscillationCount && (now - _lastSwapTime) < AntiOscillationWindow)
                return false;

            return true;
        }

        /// <summary>
        /// Audits and records a new move request.
        /// Updates context, intent, squad ID, overlay, and audit log. Never throws on invalid input.
        /// </summary>
        public void AuditMove(
            Vector3 target, float now, string context,
            BotOverlayType overlay = BotOverlayType.None,
            int intentType = 0,
            int squadId = 0,
            string meta = "")
        {
            if (!IsValid(target)) return;

            // Oscillation detection
            if (_prevIssuedTarget != Vector3.zero && (target - _prevIssuedTarget).sqrMagnitude < MinMoveDeltaSqr)
            {
                if ((now - _lastSwapTime) < AntiOscillationWindow)
                    _oscillationCount++;
                else
                    _oscillationCount = 1;
                _lastSwapTime = now;
            }
            else
            {
                _oscillationCount = 0;
            }
            _prevIssuedTarget = LastIssuedTarget;

            LastIssuedTarget = target;
            LastMoveTime = now;
            LastMoveContext = context ?? "";
            LastMoveIntentType = intentType;
            LastOverlayType = overlay;
            LastSquadGroupId = squadId;
            LastMoveMeta = meta ?? "";

            _moveHistory[_moveHistoryPos] = new MoveAudit(target, now, context ?? "", overlay, squadId, intentType, meta ?? "");
            _moveHistoryPos = (_moveHistoryPos + 1) % _moveHistory.Length;
        }

        /// <summary>
        /// Returns move audit history for debug/telemetry (last X moves, oldest first).
        /// </summary>
        public MoveAudit[] GetMoveHistory()
        {
            MoveAudit[] result = new MoveAudit[_moveHistory.Length];
            int len = _moveHistory.Length;
            int idx = 0, cursor = _moveHistoryPos;
            for (; idx < len; idx++, cursor = (cursor + 1) % len)
                result[idx] = _moveHistory[cursor];
            return result;
        }

        /// <summary>
        /// Returns true if a candidate vector is valid for movement (not NaN/Inf/zero).
        /// </summary>
        public static bool IsValid(Vector3 v)
        {
            return !float.IsNaN(v.x) && !float.IsNaN(v.y) && !float.IsNaN(v.z)
                && !float.IsInfinity(v.x) && !float.IsInfinity(v.y) && !float.IsInfinity(v.z)
                && (v.sqrMagnitude > 0.001f);
        }

        /// <summary>
        /// Returns true if move oscillation guard is currently active.
        /// </summary>
        public bool IsOscillationBlocked(float now)
        {
            return (_oscillationCount > MaxOscillationCount) && ((now - _lastSwapTime) < AntiOscillationWindow);
        }

        /// <summary>
        /// Returns the number of oscillation events in the current window.
        /// </summary>
        public int GetOscillationCount() => _oscillationCount;

        /// <summary>
        /// Returns the timestamp of the last move swap (for debugging/metrics).
        /// </summary>
        public float GetLastSwapTime() => _lastSwapTime;

        /// <summary>
        /// Returns true if a candidate move is redundant (already issued, not oscillating).
        /// </summary>
        public bool IsMoveRedundant(Vector3 candidate, BotOverlayType overlayType, float now = -1f)
        {
            if (!IsValid(candidate)) return true;
            if (!IsValid(LastIssuedTarget)) return false;
            if ((candidate - LastIssuedTarget).sqrMagnitude < MinMoveDeltaSqr)
            {
                // Still check if oscillation block is active
                if (now < 0f) now = Time.time;
                return !IsOscillationBlocked(now);
            }
            return false;
        }

        /// <summary>
        /// Registers a new move for anti-spam/oscillation and audit.
        /// </summary>
        public void RegisterMove(
            Vector3 candidate,
            BotOverlayType overlayType,
            float now,
            string context = "",
            int intentType = 0,
            int squadId = 0,
            string meta = "")
        {
            AuditMove(candidate, now, context, overlayType, intentType, squadId, meta);
        }

        /// <summary>
        /// Static helper: registers a new move for a bot owner and overlay type.
        /// </summary>
        public static void RegisterMove(
            BotOwner bot,
            Vector3 candidate,
            BotOverlayType overlayType,
            float now,
            string context = "",
            int intentType = 0,
            int squadId = 0,
            string meta = "")
        {
            var cache = BotCacheUtility.GetCache(bot);
            cache?.MoveCache?.RegisterMove(candidate, overlayType, now, context, intentType, squadId, meta);
        }

        /// <summary>
        /// Static helper: checks if a move for a bot is redundant.
        /// </summary>
        public static bool IsMoveRedundant(BotOwner bot, Vector3 candidate, BotOverlayType overlayType)
        {
            var cache = BotCacheUtility.GetCache(bot);
            return cache?.MoveCache?.IsMoveRedundant(candidate, overlayType) ?? false;
        }

        /// <summary>
        /// Static helper: fetches last move target for a bot (or Vector3.zero).
        /// </summary>
        public static Vector3 GetLastMoveTarget(BotOwner bot)
        {
            var cache = BotCacheUtility.GetCache(bot);
            return cache?.MoveCache?.LastIssuedTarget ?? Vector3.zero;
        }

        #endregion
    }
}
