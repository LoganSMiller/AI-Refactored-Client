// <auto-generated>
//   AI-Refactored: BotMoveCache.cs (Ultra-Platinum++ – Overlay/Event, Deduped, Intent-Driven, June 2025)
//   Hardened: anti-spam, anti-oscillation, anti-micro, anti-NaN/Inf, intent/move auditing.
//   MIT License.
// </auto-generated>

namespace AIRefactored.AI.Movement
{
    using UnityEngine;

    /// <summary>
    /// Tracks and audits bot movement targets/timing.
    /// Intent/event-driven only. Bulletproof against move spam, jitter, oscillation, micro-move, and NaN.
    /// </summary>
    public sealed class BotMoveCache
    {
        private const float MoveCooldown = 1.5f;      // Minimum time between moves (seconds)
        private const float MinMoveDeltaSqr = 0.25f;  // Minimum squared distance to consider a target "new"

        /// <summary>
        /// Last valid worldspace move target issued for this bot.
        /// </summary>
        public Vector3 LastIssuedTarget { get; set; } = Vector3.zero;

        /// <summary>
        /// Last wallclock time (Time.time) that a move was issued.
        /// </summary>
        public float LastMoveTime { get; set; } = -1000f;

        /// <summary>
        /// Last move context string (optional, for diagnostics).
        /// </summary>
        public string LastMoveContext { get; set; } = "";

        /// <summary>
        /// Last move intent type (optional, for future expansion).
        /// </summary>
        public int LastMoveIntentType { get; set; } = 0;

        /// <summary>
        /// Overlay/anticipation guard: set by event overlays when anticipation/fakeout is active.
        /// </summary>
        public bool AnticipationActive { get; set; } = false;

        /// <summary>
        /// Overlay lockout guard: set by overlays to block move during event lockouts (e.g., anticipation, suppression, door waits).
        /// </summary>
        public bool EventLockoutActive { get; set; } = false;

        /// <summary>
        /// Resets all move state for this cache (pool/reuse/squad).
        /// </summary>
        public void Reset()
        {
            LastIssuedTarget = Vector3.zero;
            LastMoveTime = -1000f;
            LastMoveContext = "";
            LastMoveIntentType = 0;
            AnticipationActive = false;
            EventLockoutActive = false;
        }

        /// <summary>
        /// True if a move was issued within the cooldown period.
        /// </summary>
        public bool HasRecentMove(float now, float threshold = MoveCooldown)
        {
            return (now - LastMoveTime) <= threshold;
        }

        /// <summary>
        /// True if the candidate is a new target, sufficiently far from previous.
        /// </summary>
        public bool IsNewTarget(Vector3 candidate, float minDeltaSqr = MinMoveDeltaSqr)
        {
            if (!IsValid(candidate)) return false;
            if (!IsValid(LastIssuedTarget)) return true;
            return (candidate - LastIssuedTarget).sqrMagnitude > minDeltaSqr;
        }

        /// <summary>
        /// True if both time and distance thresholds are satisfied (issue move if new or cooldown expired).
        /// </summary>
        public bool CanIssueMove(Vector3 candidate, float now, float minDeltaSqr = MinMoveDeltaSqr, float cooldown = MoveCooldown)
        {
            if (!IsValid(candidate)) return false;
            return !HasRecentMove(now, cooldown) || IsNewTarget(candidate, minDeltaSqr);
        }

        /// <summary>
        /// Validates that a Vector3 is usable for movement (not NaN/Inf/zero).
        /// </summary>
        public static bool IsValid(Vector3 v)
        {
            return !float.IsNaN(v.x) && !float.IsNaN(v.y) && !float.IsNaN(v.z)
                && !float.IsInfinity(v.x) && !float.IsInfinity(v.y) && !float.IsInfinity(v.z)
                && (v.sqrMagnitude > 0.001f); // Not zero
        }
    }
}
