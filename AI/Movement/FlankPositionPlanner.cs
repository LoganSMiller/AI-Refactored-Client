// <auto-generated>
//   This file is part of AI-Refactored, an open-source project focused on realistic AI behavior in Escape from Tarkov.
//   Licensed under the MIT License. See LICENSE in the repository root for more information.
//
//   THIS FILE IS SYSTEMATICALLY MANAGED.
//   Please follow strict StyleCop, ReSharper, and AI-Refactored code standards for all modifications.
// </auto-generated>

#nullable enable

namespace AIRefactored.AI.Movement
{
    using UnityEngine;
    using UnityEngine.AI;

    /// <summary>
    /// Calculates realistic flank positions around enemies.
    /// Uses NavMesh validation and dynamic spacing based on enemy distance and vertical tolerance.
    /// </summary>
    public static class FlankPositionPlanner
    {
        #region Constants

        private const float BaseOffset = 4.0f;
        private const float DistanceVariation = 1.5f;
        private const int MaxAttemptsPerSide = 3;
        private const float MaxDistance = 12f;
        private const float MinDistance = 2f;
        private const float NavSampleRadius = 1.5f;
        private const float OffsetVariation = 0.4f;
        private const float VerticalTolerance = 1.85f;

        #endregion

        #region Public Types

        /// <summary>
        /// Represents a preferred side to flank from relative to the enemy.
        /// </summary>
        public enum Side
        {
            /// <summary>Flank from the enemy's left side.</summary>
            Left,

            /// <summary>Flank from the enemy's right side.</summary>
            Right
        }

        #endregion

        #region Public API

        /// <summary>
        /// Attempts to find a valid flank point on a preferred side of the enemy.
        /// Falls back to the opposite side if preferred side fails.
        /// </summary>
        /// <param name="botPos">The position of the bot.</param>
        /// <param name="enemyPos">The position of the enemy.</param>
        /// <param name="flankPoint">The resulting flank point, if successful.</param>
        /// <param name="preferred">The preferred side to flank.</param>
        /// <returns>True if a valid flank point was found; otherwise, false.</returns>
        public static bool TryFindFlankPosition(
            Vector3 botPos,
            Vector3 enemyPos,
            out Vector3 flankPoint,
            Side preferred = Side.Left)
        {
            flankPoint = Vector3.zero;

            Vector3 toEnemy = enemyPos - botPos;
            if (toEnemy.sqrMagnitude < 0.01f)
            {
                return false;
            }

            toEnemy.y = 0f;
            toEnemy.Normalize();

            // Try preferred side first
            if (TrySide(botPos, toEnemy, preferred, out flankPoint))
            {
                return true;
            }

            // Fallback to opposite side
            Side fallback = preferred == Side.Left ? Side.Right : Side.Left;
            return TrySide(botPos, toEnemy, fallback, out flankPoint);
        }

        /// <summary>
        /// Uses enemy forward vector and bot position to smartly pick a flank side.
        /// </summary>
        /// <param name="botPos">The position of the bot.</param>
        /// <param name="enemyPos">The position of the enemy.</param>
        /// <param name="enemyForward">The forward vector of the enemy.</param>
        /// <param name="flankPoint">The resulting flank point, if successful.</param>
        /// <returns>True if a valid flank point was found; otherwise, false.</returns>
        public static bool TrySmartFlank(Vector3 botPos, Vector3 enemyPos, Vector3 enemyForward, out Vector3 flankPoint)
        {
            Vector3 toBot = (botPos - enemyPos).normalized;
            float dot = Vector3.Dot(Vector3.Cross(enemyForward, Vector3.up), toBot);
            Side smartSide = dot >= 0f ? Side.Right : Side.Left;

            return TryFindFlankPosition(botPos, enemyPos, out flankPoint, smartSide);
        }

        #endregion

        #region Private Helpers

        /// <summary>
        /// Checks if a candidate flank point is valid on the NavMesh and within combat spacing tolerances.
        /// </summary>
        /// <param name="candidate">The candidate world position.</param>
        /// <param name="origin">The bot's position.</param>
        /// <param name="final">Validated position on NavMesh.</param>
        /// <returns>True if candidate is valid.</returns>
        private static bool IsValidFlankPoint(Vector3 candidate, Vector3 origin, out Vector3 final)
        {
            final = Vector3.zero;

            NavMeshHit hit;
            if (!NavMesh.SamplePosition(candidate, out hit, NavSampleRadius, NavMesh.AllAreas))
            {
                return false;
            }

            float verticalDelta = Mathf.Abs(origin.y - hit.position.y);
            float sqrDistance = (origin - hit.position).sqrMagnitude;

            if (sqrDistance < MinDistance * MinDistance || sqrDistance > MaxDistance * MaxDistance)
            {
                return false;
            }

            if (verticalDelta > VerticalTolerance)
            {
                return false;
            }

            final = hit.position;
            return true;
        }

        /// <summary>
        /// Attempts to find a flank position on the given side relative to enemy direction.
        /// </summary>
        /// <param name="origin">Bot position.</param>
        /// <param name="toEnemy">Normalized direction to enemy.</param>
        /// <param name="side">Side to try (Left or Right).</param>
        /// <param name="result">Resulting flank point.</param>
        /// <returns>True if successful.</returns>
        private static bool TrySide(Vector3 origin, Vector3 toEnemy, Side side, out Vector3 result)
        {
            result = Vector3.zero;

            Vector3 perpendicular = Vector3.Cross(Vector3.up, toEnemy) * (side == Side.Left ? -1f : 1f);

            for (int i = 0; i < MaxAttemptsPerSide; i++)
            {
                float offset = BaseOffset + Random.Range(-OffsetVariation, OffsetVariation);
                float distance = Random.Range(MinDistance, MaxDistance);

                Vector3 candidate = origin + perpendicular * offset + toEnemy * distance;

                Vector3 validated;
                if (IsValidFlankPoint(candidate, origin, out validated))
                {
                    result = validated;
                    return true;
                }
            }

            return false;
        }

        #endregion
    }
}
