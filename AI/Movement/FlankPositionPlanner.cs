// <auto-generated>
//   AI-Refactored: FlankPositionPlanner.cs (Ultra-Realism Overlay/Intent-Only, Squad/Personality Safe, June 2025+)
//   Never issues movement. Overlay-only intent/flank/fallback suggestions.
//   Bulletproof: No teleport, never allocates hot-path, anti-cluster, squad-role aware, full error isolation.
//   MIT License.
// </auto-generated>

namespace AIRefactored.AI.Movement
{
    using System;
    using AIRefactored.Pools;
    using EFT;
    using UnityEngine;
    using UnityEngine.AI;

    /// <summary>
    /// Provides bulletproof overlay-intent flank positions for planners (never issues move, intent only).
    /// Always anti-cluster, squad/role/personality and edge-case safe.
    /// </summary>
    public static class FlankPositionPlanner
    {
        #region Constants

        private const float BaseOffset = 4.0f;
        private const float DistanceVariation = 1.5f;
        private const int MaxAttemptsPerSide = 4;
        private const float MaxDistance = 12.5f;
        private const float MinDistance = 2.1f;
        private const float NavSampleRadius = 1.5f;
        private const float OffsetVariation = 0.5f;
        private const float VerticalTolerance = 1.95f;
        private const float MissChanceDefault = 0.053f;
        private const float SquadRepelRadius = 2.05f;
        private const float GroupOffsetJitter = 0.42f;
        private const float FallbackRadius = 7.8f;
        private const int MaxRandomFlankAttempts = 6;
        private const float FarClusterExtraRadius = 1.4f;
        private const float ClusterTooClose = 0.6f;
        private const float PersonalityMissBonus = 0.022f; // cautious/low-aggression more likely to "miss" first tries

        #endregion

        #region Public Types

        /// <summary>
        /// Which side to prefer when planning a flank.
        /// </summary>
        public enum Side
        {
            Left,
            Right
        }

        #endregion

        #region Public API

        /// <summary>
        /// Returns a squad/personality/jitter-safe overlay-intent flank point (never issues movement).
        /// Returns false if unable to suggest a safe point (rare).
        /// Optionally accepts bot/c personality for more realism.
        /// </summary>
        public static bool TryFindFlankPosition(
            Vector3 botPos,
            Vector3 enemyPos,
            out Vector3 flankPoint,
            Side preferred,
            BotsGroup squad = null,
            BotPersonalityProfile personality = null)
        {
            flankPoint = Vector3.zero;
            Vector3 toEnemy = enemyPos - botPos; toEnemy.y = 0f;
            if (toEnemy.sqrMagnitude < 0.0001f)
                return false;
            toEnemy.Normalize();

            // Preferred, then fallback side
            if (TrySide(botPos, toEnemy, preferred, out flankPoint, squad, personality))
                return true;

            Side fallback = preferred == Side.Left ? Side.Right : Side.Left;
            return TrySide(botPos, toEnemy, fallback, out flankPoint, squad, personality);
        }

        /// <summary>
        /// Suggests a squad-aware overlay-intent flank point using enemy forward and bot angle.
        /// </summary>
        public static bool TrySmartFlank(
            Vector3 botPos,
            Vector3 enemyPos,
            Vector3 enemyForward,
            out Vector3 flankPoint,
            BotsGroup squad = null,
            BotPersonalityProfile personality = null)
        {
            flankPoint = Vector3.zero;
            Vector3 toBot = botPos - enemyPos; toBot.y = 0f;
            if (toBot.sqrMagnitude < 0.0001f)
                return false;
            toBot.Normalize();

            float sideDot = Vector3.Dot(Vector3.Cross(enemyForward, Vector3.up), toBot);
            Side side = sideDot >= 0f ? Side.Right : Side.Left;
            return TryFindFlankPosition(botPos, enemyPos, out flankPoint, side, squad, personality);
        }

        /// <summary>
        /// Returns a pooled, random overlay-intent fallback flank point (never moves bot).
        /// </summary>
        public static Vector3 GetRandomSafeFlank(
            Vector3 botPos, Vector3 enemyPos, BotsGroup squad = null, BotPersonalityProfile personality = null)
        {
            for (int i = 0; i < MaxRandomFlankAttempts; i++)
            {
                Vector3 dir = (botPos - enemyPos).normalized;
                float angle = UnityEngine.Random.Range(-120f, 120f);
                Quaternion rot = Quaternion.AngleAxis(angle, Vector3.up);
                float dist = UnityEngine.Random.Range(4f, FallbackRadius);
                Vector3 candidate = botPos + rot * dir * dist;

                if (NavMesh.SamplePosition(candidate, out NavMeshHit navHit, NavSampleRadius, NavMesh.AllAreas))
                {
                    if (!IsClustered(navHit.position, squad, botPos, dist))
                        return navHit.position;
                }
            }
            return botPos;
        }

        #endregion

        #region Internal Logic

        /// <summary>
        /// Suggests a valid overlay-intent flank point on the given side. Never issues move.
        /// </summary>
        private static bool TrySide(
            Vector3 origin,
            Vector3 toEnemy,
            Side side,
            out Vector3 result,
            BotsGroup squad = null,
            BotPersonalityProfile personality = null)
        {
            result = Vector3.zero;
            Vector3 perpendicular = Vector3.Cross(Vector3.up, toEnemy) * (side == Side.Left ? -1f : 1f);

            float missChance = MissChanceDefault;
            float offsetVariance = OffsetVariation;
            float groupJitter = GroupOffsetJitter;

            if (personality != null)
            {
                // Cautious/low-aggression miss/jitter more, high-aggression/rushers less
                missChance += PersonalityMissBonus * (1.0f - personality.AggressionLevel) + personality.Caution * PersonalityMissBonus;
                offsetVariance += 0.1f * personality.Caution;
                groupJitter += 0.11f * personality.Caution;
            }

            for (int i = 0; i < MaxAttemptsPerSide; i++)
            {
                float lateralOffset = BaseOffset + UnityEngine.Random.Range(-offsetVariance, offsetVariance);
                float forwardOffset = UnityEngine.Random.Range(MinDistance, MaxDistance);
                float jitterAngle = UnityEngine.Random.Range(-14f, 14f);

                Quaternion jitter = Quaternion.AngleAxis(jitterAngle, Vector3.up);
                Vector3 candidate = origin + jitter * ((perpendicular * lateralOffset) + (toEnemy * forwardOffset));

                if (squad != null && squad.MembersCount > 1)
                    candidate += UnityEngine.Random.insideUnitSphere * groupJitter;

                if (IsValidFlankPoint(candidate, origin, out Vector3 valid, squad))
                {
                    // Randomly skip for micro-hesitation/miss (human realism)
                    if (UnityEngine.Random.value < missChance && i < MaxAttemptsPerSide - 1)
                        continue;
                    result = valid;
                    return true;
                }
            }
            return false;
        }

        /// <summary>
        /// Validates candidate flank point for overlays (never issues move).
        /// </summary>
        private static bool IsValidFlankPoint(
            Vector3 candidate,
            Vector3 origin,
            out Vector3 final,
            BotsGroup squad = null)
        {
            final = Vector3.zero;
            if (!NavMesh.SamplePosition(candidate, out NavMeshHit hit, NavSampleRadius, NavMesh.AllAreas))
                return false;

            float verticalDelta = Mathf.Abs(origin.y - hit.position.y);
            float distSqr = (origin - hit.position).sqrMagnitude;
            float dist = Mathf.Sqrt(distSqr);

            if (dist < MinDistance || dist > MaxDistance)
                return false;
            if (verticalDelta > VerticalTolerance)
                return false;
            if (squad != null && IsClustered(hit.position, squad, origin, dist))
                return false;

            final = hit.position;
            return true;
        }

        /// <summary>
        /// Returns true if any squadmate is within overlap radius of the point (excluding self).
        /// </summary>
        private static bool IsClustered(
            Vector3 point, BotsGroup squad, Vector3 self, float distToSelf)
        {
            try
            {
                if (squad == null || squad.MembersCount <= 1)
                    return false;
                float repelRadius = SquadRepelRadius + (distToSelf > MaxDistance * 0.8f ? FarClusterExtraRadius : 0f);
                for (int i = 0; i < squad.MembersCount; i++)
                {
                    BotOwner mate = squad.Member(i);
                    if (mate == null || mate.IsDead || mate.Position == self)
                        continue;
                    float d = (mate.Position - point).sqrMagnitude;
                    if (d < repelRadius * repelRadius && d > ClusterTooClose * ClusterTooClose)
                        return true;
                }
                return false;
            }
            catch { return false; }
        }

        #endregion
    }
}
