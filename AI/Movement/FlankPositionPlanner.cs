// <auto-generated>
//   AI-Refactored: FlankPositionPlanner.cs (Ultra-Realism Overlay/Intent-Only, Squad/Personality Safe, June 2025+)
//   Never issues movement. Overlay-only intent/flank/fallback suggestions. 
//   Bulletproof: No teleport, never allocates hot-path, anti-cluster, squad-role aware, full error isolation.
//   MIT License.
// </auto-generated>

namespace AIRefactored.AI.Movement
{
    using System;
    using AIRefactored.Pools;
    using EFT;
    using UnityEngine;
    using UnityEngine.AI;

    /// <summary>
    /// Provides bulletproof overlay-intent flank positions for planners (never issues move, intent only).
    /// Always anti-cluster, squad/role/personality and edge-case safe. 
    /// </summary>
    public static class FlankPositionPlanner
    {
        #region Constants

        private const float BaseOffset = 4.0f;
        private const float DistanceVariation = 1.5f;
        private const int MaxAttemptsPerSide = 4;
        private const float MaxDistance = 12.5f;
        private const float MinDistance = 2.1f;
        private const float NavSampleRadius = 1.5f;
        private const float OffsetVariation = 0.5f;
        private const float VerticalTolerance = 1.95f;
        private const float MissChance = 0.053f;
        private const float SquadRepelRadius = 2.05f;
        private const float GroupOffsetJitter = 0.42f;
        private const float FallbackRadius = 7.8f;
        private const int MaxRandomFlankAttempts = 6;

        #endregion

        #region Public Types

        /// <summary>
        /// Which side to prefer when planning a flank.
        /// </summary>
        public enum Side
        {
            Left,
            Right
        }

        #endregion

        #region Public API

        /// <summary>
        /// Returns a squad/personality/jitter-safe overlay-intent flank point (never issues movement).
        /// Returns false if unable to suggest a safe point (rare).
        /// </summary>
        /// <param name="botPos">Bot's current position</param>
        /// <param name="enemyPos">Enemy's current position</param>
        /// <param name="flankPoint">Output: intent flank point (no move issued)</param>
        /// <param name="preferred">Side to try first</param>
        /// <param name="squad">Squad (if any), for anti-cluster logic</param>
        public static bool TryFindFlankPosition(
            Vector3 botPos, Vector3 enemyPos, out Vector3 flankPoint, Side preferred, BotsGroup squad = null)
        {
            flankPoint = Vector3.zero;
            Vector3 toEnemy = enemyPos - botPos; toEnemy.y = 0f;
            if (toEnemy.sqrMagnitude < 0.0001f)
                return false;
            toEnemy.Normalize();

            // Try preferred, then fallback
            if (TrySide(botPos, toEnemy, preferred, out flankPoint, squad))
                return true;

            Side fallback = preferred == Side.Left ? Side.Right : Side.Left;
            return TrySide(botPos, toEnemy, fallback, out flankPoint, squad);
        }

        /// <summary>
        /// Suggests a squad-aware overlay-intent flank point using enemy forward and bot angle.
        /// </summary>
        public static bool TrySmartFlank(
            Vector3 botPos, Vector3 enemyPos, Vector3 enemyForward, out Vector3 flankPoint, BotsGroup squad = null)
        {
            flankPoint = Vector3.zero;
            Vector3 toBot = botPos - enemyPos; toBot.y = 0f;
            if (toBot.sqrMagnitude < 0.0001f)
                return false;
            toBot.Normalize();

            float sideDot = Vector3.Dot(Vector3.Cross(enemyForward, Vector3.up), toBot);
            Side side = sideDot >= 0f ? Side.Right : Side.Left;
            return TryFindFlankPosition(botPos, enemyPos, out flankPoint, side, squad);
        }

        /// <summary>
        /// Returns a pooled, random overlay-intent fallback flank point (never moves bot).
        /// </summary>
        public static Vector3 GetRandomSafeFlank(
            Vector3 botPos, Vector3 enemyPos, BotsGroup squad = null)
        {
            for (int i = 0; i < MaxRandomFlankAttempts; i++)
            {
                Vector3 dir = (botPos - enemyPos).normalized;
                float angle = UnityEngine.Random.Range(-120f, 120f);
                Quaternion rot = Quaternion.AngleAxis(angle, Vector3.up);
                float dist = UnityEngine.Random.Range(4f, FallbackRadius);
                Vector3 candidate = botPos + rot * dir * dist;

                if (NavMesh.SamplePosition(candidate, out NavMeshHit navHit, NavSampleRadius, NavMesh.AllAreas))
                {
                    if (!IsClustered(navHit.position, squad, botPos))
                        return navHit.position;
                }
            }
            return botPos; // Fallback to own pos (never issues move!)
        }

        #endregion

        #region Internal Logic

        /// <summary>
        /// Suggests a valid overlay-intent flank point on the given side. Never issues move.
        /// </summary>
        private static bool TrySide(Vector3 origin, Vector3 toEnemy, Side side, out Vector3 result, BotsGroup squad = null)
        {
            result = Vector3.zero;
            Vector3 perpendicular = Vector3.Cross(Vector3.up, toEnemy) * (side == Side.Left ? -1f : 1f);

            for (int i = 0; i < MaxAttemptsPerSide; i++)
            {
                float lateralOffset = BaseOffset + UnityEngine.Random.Range(-OffsetVariation, OffsetVariation);
                float forwardOffset = UnityEngine.Random.Range(MinDistance, MaxDistance);
                float jitterAngle = UnityEngine.Random.Range(-14f, 14f);

                Quaternion jitter = Quaternion.AngleAxis(jitterAngle, Vector3.up);
                Vector3 candidate = origin + jitter * ((perpendicular * lateralOffset) + (toEnemy * forwardOffset));

                if (squad != null && squad.MembersCount > 1)
                    candidate += UnityEngine.Random.insideUnitSphere * GroupOffsetJitter;

                if (IsValidFlankPoint(candidate, origin, out Vector3 valid, squad))
                {
                    if (UnityEngine.Random.value < MissChance && i < MaxAttemptsPerSide - 1)
                        continue; // Simulate "miss" (human error/hesitation)

                    result = valid;
                    return true;
                }
            }
            return false;
        }

        /// <summary>
        /// Validates candidate flank point for overlays (never issues move).
        /// </summary>
        private static bool IsValidFlankPoint(Vector3 candidate, Vector3 origin, out Vector3 final, BotsGroup squad = null)
        {
            final = Vector3.zero;
            if (!NavMesh.SamplePosition(candidate, out NavMeshHit hit, NavSampleRadius, NavMesh.AllAreas))
                return false;

            float verticalDelta = Mathf.Abs(origin.y - hit.position.y);
            float distSqr = (origin - hit.position).sqrMagnitude;

            if (distSqr < MinDistance * MinDistance || distSqr > MaxDistance * MaxDistance)
                return false;
            if (verticalDelta > VerticalTolerance)
                return false;
            if (squad != null && IsClustered(hit.position, squad, origin))
                return false;

            final = hit.position;
            return true;
        }

        /// <summary>
        /// Returns true if any squadmate is within overlap radius of the point (excluding self).
        /// </summary>
        private static bool IsClustered(Vector3 point, BotsGroup squad, Vector3 self)
        {
            try
            {
                if (squad == null || squad.MembersCount <= 1)
                    return false;
                for (int i = 0; i < squad.MembersCount; i++)
                {
                    BotOwner mate = squad.Member(i);
                    if (mate == null || mate.IsDead || mate.Position == self)
                        continue;
                    if ((mate.Position - point).sqrMagnitude < SquadRepelRadius * SquadRepelRadius)
                        return true;
                }
                return false;
            }
            catch { return false; }
        }

        #endregion
    }
}
