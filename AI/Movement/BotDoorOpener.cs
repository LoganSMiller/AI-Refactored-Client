// <auto-generated>
//   This file is part of AI-Refactored, an open-source project focused on realistic AI behavior in Escape from Tarkov.
//   Licensed under the MIT License. See LICENSE in the repository root for more information.
//
//   THIS FILE IS SYSTEMATICALLY MANAGED.
//   Please follow strict StyleCop, ReSharper, and AI-Refactored code standards for all modifications.
// </auto-generated>

namespace AIRefactored.AI.Movement
{
    using System;
    using System.Collections.Generic;
    using AIRefactored.AI.Core;
    using AIRefactored.Core;
    using AIRefactored.Pools;
    using BepInEx.Logging;
    using EFT;
    using EFT.Interactive;
    using UnityEngine;

    /// <summary>
    /// Handles door interaction logic for AI bots, including retries and deadlock prevention.
    /// </summary>
    public sealed class BotDoorOpener
    {
        private const float RetryCooldown = 2.5f;
        private const float InteractionRange = 1.8f;
        private const float StuckDistance = 0.3f;

        private readonly BotOwner _bot;
        private readonly ManualLogSource _log;

        private float _lastAttemptTime;
        private Door _currentTarget;
        private Vector3 _lastBotPos;
        private float _lastMoveTime;

        /// <summary>
        /// Initializes a new instance of the <see cref="BotDoorOpener"/> class.
        /// </summary>
        /// <param name="bot">Owning bot.</param>
        public BotDoorOpener(BotOwner bot)
        {
            if (bot == null)
            {
                throw new ArgumentNullException(nameof(bot));
            }

            _bot = bot;
            _log = Plugin.LoggerInstance;
            _lastBotPos = bot.Position;
            _lastMoveTime = Time.time;
        }

        /// <summary>
        /// Processes door interaction each frame.
        /// </summary>
        public void Tick(float time)
        {
            if (_bot == null || _bot.IsDead || _bot.GetPlayer == null || !_bot.GetPlayer.IsAI)
            {
                return;
            }

            Vector3 pos = _bot.Position;
            float moved = (pos - _lastBotPos).sqrMagnitude;
            if (moved > StuckDistance * StuckDistance)
            {
                _lastBotPos = pos;
                _lastMoveTime = time;
            }

            if (_currentTarget == null || !_currentTarget.enabled)
            {
                _currentTarget = FindNearbyDoor();
            }

            if (_currentTarget == null)
            {
                return;
            }

            if ((time - _lastAttemptTime) < RetryCooldown)
            {
                return;
            }

            Vector3 doorPos = _currentTarget.transform.position;
            float dist = Vector3.Distance(pos, doorPos);

            if (dist > InteractionRange)
            {
                return;
            }

            EDoorState state = _currentTarget.DoorState;
            if ((state & EDoorState.Locked) != 0 || (state & EDoorState.Breaching) != 0)
            {
                _log.LogDebug("[BotDoorOpener] Door locked or breaching — skipping.");
                return;
            }

            if ((state & EDoorState.Open) == 0)
            {
                InteractionResult result = new InteractionResult(EInteractionType.Open);
                _bot.GetPlayer.CurrentManagedState.StartDoorInteraction(_currentTarget, result, null);
                _lastAttemptTime = time;
                _log.LogDebug("[BotDoorOpener] Interacted with door.");
            }
        }

        /// <summary>
        /// Returns true if a door is currently blocking progress.
        /// </summary>
        public bool IsDoorBlocking()
        {
            return _currentTarget != null;
        }

        /// <summary>
        /// Clears current door state.
        /// </summary>
        public void Clear()
        {
            _currentTarget = null;
            _lastAttemptTime = 0f;
        }

        private Door FindNearbyDoor()
        {
            List<Door> candidates = TempListPool.Rent<Door>();
            Door[] all = UnityEngine.Object.FindObjectsOfType<Door>();

            Vector3 botPos = _bot.Position;
            for (int i = 0; i < all.Length; i++)
            {
                Door door = all[i];
                if (door == null || !door.enabled)
                {
                    continue;
                }

                float dist = Vector3.Distance(botPos, door.transform.position);
                if (dist < InteractionRange + 0.5f)
                {
                    candidates.Add(door);
                }
            }

            Door best = null;
            float closest = float.MaxValue;
            for (int i = 0; i < candidates.Count; i++)
            {
                float dist = Vector3.Distance(botPos, candidates[i].transform.position);
                if (dist < closest)
                {
                    closest = dist;
                    best = candidates[i];
                }
            }

            TempListPool.Return(candidates);
            return best;
        }
    }
}
