// <auto-generated>
//   AI-Refactored: BotMovementController.cs (Overlay-Only, Zero-Spam, Ultimate Realism, June 2025)
//   All overlays: formation/cover/lean/anticipation/strafe—never tick-move. Only BotMovementHelper issues real moves, with dedup/cooldown checks.
//   No overlay triggers path movement. No tick-move, no teleport, no snap. Robust, pooled, multiplayer/headless safe.
//   MIT License.
// </auto-generated>

namespace AIRefactored.AI.Movement
{
    using System;
    using AIRefactored.AI.Core;
    using AIRefactored.AI.Helpers;
    using AIRefactored.Core;
    using AIRefactored.Pools;
    using BepInEx.Logging;
    using EFT;
    using UnityEngine;
    using UnityEngine.AI;

    /// <summary>
    /// Handles all overlay/pose logic: squad formation, cover, lean, strafe, anticipation.
    /// All movement is event/overlay only—never ticked—always routed via BotMovementHelper.
    /// No overlay logic issues move commands except on real path/intent changes.
    /// Fully null-guarded, pooled, multiplayer/headless safe, and error isolated.
    /// </summary>
    public sealed class BotMovementController
    {
        private static readonly ManualLogSource Logger = Plugin.LoggerInstance;

        private BotOwner _bot;
        private BotComponentCache _cache;
        private BotMoveCache _moveCache;

        private float _nextLeanTime, _leanHoldUntil, _leanLockoutUntil;
        private BotTiltType _currentLean;

        private const float LeanCooldownMin = 0.85f, LeanCooldownMax = 1.4f;
        private const float LeanHoldMin = 1.0f, LeanHoldMax = 1.6f;
        private const float CoverRayLength = 1.8f;

        public void Initialize(BotComponentCache cache)
        {
            _cache = cache ?? throw new ArgumentNullException(nameof(cache));
            _bot = cache.Bot ?? throw new ArgumentException("[BotMovementController] Bot missing.");
            _moveCache = _cache.MoveCache ?? new BotMoveCache();

            _nextLeanTime = Time.time + UnityEngine.Random.Range(LeanCooldownMin, LeanCooldownMax);
            _currentLean = BotTiltType.right;

            BotMovementHelper.Reset(_bot);
        }

        /// <summary>
        /// Tick only handles overlays—NEVER issues movement. All movement is event/intent-only.
        /// </summary>
        public void Tick(float deltaTime)
        {
            if (_bot == null || _bot.IsDead || _bot.Mover == null || !_bot.GetPlayer.IsAI)
                return;

            TryLean();
            TryLookOverlay();
        }

        /// <summary>
        /// Overlay-only: Lean logic based on cover and intent, never triggers a move.
        /// </summary>
        private void TryLean()
        {
            if (_cache?.Tilt == null || _bot?.Transform == null || _bot.IsDead)
                return;

            float now = Time.time;
            if (now < _nextLeanTime || now < _leanLockoutUntil || now < _leanHoldUntil)
                return;

            var enemy = _bot.Memory?.GoalEnemy;
            if (enemy == null || _bot.Mover == null || !_bot.Mover.IsMoving || _bot.Mover.Sprinting)
            {
                _cache.Tilt.Stop();
                return;
            }

            bool leftCover = Physics.Raycast(_bot.Position + Vector3.up * 1.5f, -_bot.Transform.right, CoverRayLength, AIRefactoredLayerMasks.CoverRayMask);
            bool rightCover = Physics.Raycast(_bot.Position + Vector3.up * 1.5f, _bot.Transform.right, CoverRayLength, AIRefactoredLayerMasks.CoverRayMask);

            BotTiltType desiredLean = BotTiltType.right;
            if (leftCover && !rightCover) desiredLean = BotTiltType.right;
            else if (rightCover && !leftCover) desiredLean = BotTiltType.left;
            else
            {
                Vector3 toEnemy = enemy.CurrPosition - _bot.Position;
                desiredLean = Vector3.Dot(toEnemy.normalized, _bot.Transform.right) > 0f ? BotTiltType.right : BotTiltType.left;
            }

            if (_currentLean != desiredLean || now >= _leanHoldUntil)
            {
                _currentLean = desiredLean;
                _cache.Tilt.Set(desiredLean);
                _leanHoldUntil = now + UnityEngine.Random.Range(LeanHoldMin, LeanHoldMax);
            }

            _nextLeanTime = now + UnityEngine.Random.Range(LeanCooldownMin, LeanCooldownMax);
            _leanLockoutUntil = now + UnityEngine.Random.Range(0.3f, 0.6f);
        }

        /// <summary>
        /// Overlay-only: Adjusts look direction for pose—never issues a move.
        /// </summary>
        private void TryLookOverlay()
        {
            if (_bot?.Transform == null || _bot.Mover == null || _bot.Mover._pathController == null)
                return;

            Vector3 lookTarget;
            try { lookTarget = _bot.Mover._pathController.LastTargetPoint(1f); }
            catch { return; }

            if (!NavMesh.SamplePosition(lookTarget, out NavMeshHit hit, 1.5f, NavMesh.AllAreas))
                return;

            Vector3 direction = hit.position - (_bot.Position + Vector3.up * 1.5f);
            if (direction.sqrMagnitude < 0.01f) return;

            BotMovementHelper.SmoothLookTo(_bot, hit.position, 0.89f);
        }

        /// <summary>
        /// Issues a move command ONLY for real new intent/path (never called by overlays/tick).
        /// Always deduped and cooldown-gated.
        /// </summary>
        public void ForceMove(Vector3 target, bool slow = false, float cohesion = 1f)
        {
            if (_bot == null || _moveCache == null)
                return;

            float now = Time.time;
            // Use global dedupe/cooldown logic (always matches BotMoveCache.cs and BotMovementHelper)
            if (_moveCache.CanIssueMove(target, now))
            {
                _moveCache.LastIssuedTarget = target;
                _moveCache.LastMoveTime = now;
                BotMovementHelper.SmoothMoveToSafe(_bot, target, slow, cohesion);
            }
        }

        #region Looting Mode Compatibility

        public void EnterLootingMode() { }
        public void ExitLootingMode() { }
        public bool IsInLootingMode() => false;

        #endregion
    }
}
