// <auto-generated>
//   This file is part of AI-Refactored, an open-source project focused on realistic AI behavior in Escape from Tarkov.
//   Licensed under the MIT License. See LICENSE in the repository root for more information.
//
//   THIS FILE IS SYSTEMATICALLY MANAGED.
//   Please follow strict StyleCop, ReSharper, and AI-Refactored code standards for all modifications.
// </auto-generated>

#nullable enable

namespace AIRefactored.AI.Movement
{
    using System;
    using AIRefactored.AI.Core;
    using AIRefactored.AI.Helpers;
    using AIRefactored.Core;
    using AIRefactored.Runtime;
    using BepInEx.Logging;
    using EFT;
    using UnityEngine;
    using UnityEngine.AI;

    /// <summary>
    /// Controls advanced bot movement logic including inertia, smooth look, combat strafe, lean, jump, and flank
    /// mechanics. Designed for natural, player-like behavior and fluid real-time responsiveness.
    /// </summary>
    public class BotMovementController
    {
        #region Constants

        private const float CornerScanInterval = 1.2f;
        private const float InertiaWeight = 8f;
        private const float LeanCooldown = 1.5f;
        private const float LookSmoothSpeed = 6f;
        private const float MaxStuckDuration = 1.5f;
        private const float MinMoveThreshold = 0.05f;
        private const float ScanDistance = 2.5f;
        private const float ScanRadius = 0.25f;
        private const float StuckThreshold = 0.1f;

        #endregion

        #region Fields

        private static readonly ManualLogSource Logger = AIRefactoredController.Logger;

        private BotOwner? _bot;
        private BotComponentCache? _cache;
        private BotJumpController? _jump;
        private BotMovementTrajectoryPlanner? _trajectory;

        private Vector3 _lastVelocity = Vector3.zero;
        private float _nextLeanAllowed;
        private float _nextScanTime;
        private float _strafeTimer;
        private float _stuckTimer;
        private bool _inLootingMode;
        private bool _isStrafingRight = true;

        #endregion

        #region Public API

        /// <summary>
        /// Puts the bot into looting stance (disabling combat/lean logic).
        /// </summary>
        public void EnterLootingMode()
        {
            this._inLootingMode = true;
        }

        /// <summary>
        /// Exits looting stance and resumes combat movement logic.
        /// </summary>
        public void ExitLootingMode()
        {
            this._inLootingMode = false;
        }

        /// <summary>
        /// Initializes movement subsystems with bot and shared component references.
        /// </summary>
        /// <param name="cache">Bot component cache.</param>
        public void Initialize(BotComponentCache cache)
        {
            if (cache == null || cache.Bot == null)
            {
                throw new ArgumentNullException(nameof(cache));
            }

            this._cache = cache;
            this._bot = cache.Bot;
            this._trajectory = new BotMovementTrajectoryPlanner(this._bot, cache);
            this._jump = new BotJumpController(this._bot, cache);
            this._nextScanTime = Time.time;
        }

        /// <summary>
        /// Executes real-time bot movement logic every frame.
        /// </summary>
        /// <param name="deltaTime">Time since last frame.</param>
        public void Tick(float deltaTime)
        {
            if (this._bot == null || this._cache == null || this._bot.GetPlayer == null || !this._bot.GetPlayer.IsAI)
            {
                return;
            }

            if (this._bot.IsDead || this._bot.GetPlayer.HealthController == null || !this._bot.GetPlayer.HealthController.IsAlive)
            {
                return;
            }

            if (this._cache.PanicHandler != null && this._cache.PanicHandler.IsPanicking)
            {
                return;
            }

            if (this._jump != null)
            {
                this._jump.Tick(deltaTime);
            }

            if (this._cache.DoorOpener != null && !this._cache.DoorOpener.Update())
            {
                Logger.LogDebug($"[Movement] {this._bot.Profile.Info.Nickname} is blocked by door.");
                return;
            }

            if (Time.time >= this._nextScanTime)
            {
                this.ScanAhead();
                this._nextScanTime = Time.time + CornerScanInterval;
            }

            if (this._bot.Mover != null)
            {
                Vector3 target = this._bot.Mover.LastTargetPoint(1.0f);
                this.SmoothLookTo(target, deltaTime);
            }

            this.ApplyInertia(deltaTime);

            if (!this._inLootingMode && this._bot.Memory != null && this._bot.Memory.GoalEnemy != null &&
                this._bot.WeaponManager != null && this._bot.WeaponManager.IsReady)
            {
                this.CombatStrafe(deltaTime);
                this.TryCombatLean();
                this.TryFlankAroundEnemy();
            }

            this.DetectStuck(deltaTime);
        }

        #endregion

        #region Helpers

        private void ApplyInertia(float deltaTime)
        {
            if (this._bot == null || this._bot.Mover == null || this._trajectory == null || this._bot.GetPlayer == null)
            {
                return;
            }

            Vector3 target = this._bot.Mover.LastTargetPoint(1.0f);
            Vector3 direction = target - this._bot.Position;
            direction.y = 0f;

            if (direction.magnitude < MinMoveThreshold)
            {
                return;
            }

            Vector3 adjusted = this._trajectory.ModifyTrajectory(direction, deltaTime);
            Vector3 velocity = adjusted.normalized * 1.65f;
            this._lastVelocity = Vector3.Lerp(this._lastVelocity, velocity, InertiaWeight * deltaTime);

            this._bot.GetPlayer.CharacterController?.Move(this._lastVelocity * deltaTime, deltaTime);
        }

        private void SmoothLookTo(Vector3 target, float deltaTime)
        {
            if (this._bot == null || this._bot.Transform == null)
            {
                return;
            }

            Vector3 direction = target - this._bot.Transform.position;
            direction.y = 0f;

            if (direction.sqrMagnitude < 0.01f)
            {
                return;
            }

            if (this._cache != null && this._cache.Tilt != null && this._cache.Tilt._coreTilt &&
                Vector3.Angle(this._bot.Transform.forward, direction) > 80f)
            {
                return;
            }

            Quaternion desired = Quaternion.LookRotation(direction);
            this._bot.Transform.rotation = Quaternion.Lerp(this._bot.Transform.rotation, desired, LookSmoothSpeed * deltaTime);
        }

        private void ScanAhead()
        {
            if (this._bot == null)
            {
                return;
            }

            Vector3 origin = this._bot.Position + Vector3.up * 1.5f;
            Vector3 direction = this._bot.LookDirection;

            if (Physics.SphereCast(origin, ScanRadius, direction, out _, ScanDistance, AIRefactoredLayerMasks.VisionBlockers))
            {
                if (UnityEngine.Random.value < 0.2f && this._bot.BotTalk != null)
                {
                    this._bot.BotTalk.TrySay(EPhraseTrigger.Look);
                }
            }
        }

        private void CombatStrafe(float deltaTime)
        {
            if (this._bot == null || this._bot.GetPlayer == null)
            {
                return;
            }

            this._strafeTimer -= deltaTime;
            if (this._strafeTimer <= 0f)
            {
                this._isStrafingRight = UnityEngine.Random.value > 0.5f;
                this._strafeTimer = UnityEngine.Random.Range(0.4f, 0.7f);
            }

            Vector3 baseStrafe = this._isStrafingRight ? this._bot.Transform.right : -this._bot.Transform.right;
            Vector3 avoid = Vector3.zero;

            BotsGroup? group = this._bot.BotsGroup;
            if (group != null)
            {
                for (int i = 0; i < group.MembersCount; i++)
                {
                    BotOwner? other = group.Member(i);
                    if (other != null && !other.IsDead && other != this._bot)
                    {
                        float distance = Vector3.Distance(this._bot.Position, other.Position);
                        if (distance < 2f && distance > 0.01f)
                        {
                            avoid += (this._bot.Position - other.Position).normalized / distance;
                        }
                    }
                }
            }

            Vector3 strafeDir = (baseStrafe + avoid * 1.2f).normalized;
            float strafeSpeed = 1.2f + UnityEngine.Random.Range(-0.1f, 0.15f);
            this._bot.GetPlayer.CharacterController?.Move(strafeDir * strafeSpeed * deltaTime, deltaTime);
        }

        private void TryCombatLean()
        {
            if (this._bot == null || this._cache == null || this._cache.Tilt == null ||
                Time.time < this._nextLeanAllowed)
            {
                return;
            }

            BotPersonalityProfile? profile = this._cache.AIRefactoredBotOwner?.PersonalityProfile;
            if (profile == null || profile.LeaningStyle == LeanPreference.Never ||
                this._bot.Memory == null || this._bot.Memory.GoalEnemy == null)
            {
                return;
            }

            Vector3 origin = this._bot.Position + Vector3.up * 1.5f;
            bool wallLeft = Physics.Raycast(origin, -this._bot.Transform.right, 1.5f, AIRefactoredLayerMasks.VisionBlockers);
            bool wallRight = Physics.Raycast(origin, this._bot.Transform.right, 1.5f, AIRefactoredLayerMasks.VisionBlockers);

            Vector3? cover = this._bot.Memory.BotCurrentCoverInfo?.LastCover?.Position;

            if (profile.LeaningStyle == LeanPreference.Conservative && !cover.HasValue && !wallLeft && !wallRight)
            {
                return;
            }

            if (cover.HasValue && !BotCoverHelper.WasRecentlyUsed(cover.Value))
            {
                BotCoverHelper.MarkUsed(cover.Value);
                float side = Vector3.Dot((this._bot.Position - cover.Value).normalized, this._bot.Transform.right);
                this._cache.Tilt.Set(side > 0f ? BotTiltType.right : BotTiltType.left);
            }
            else if (wallLeft && !wallRight)
            {
                this._cache.Tilt.Set(BotTiltType.right);
            }
            else if (wallRight && !wallLeft)
            {
                this._cache.Tilt.Set(BotTiltType.left);
            }
            else if (this._bot.Memory.GoalEnemy != null)
            {
                Vector3 toEnemy = this._bot.Memory.GoalEnemy.CurrPosition - this._bot.Position;
                float dot = Vector3.Dot(toEnemy.normalized, this._bot.Transform.right);
                this._cache.Tilt.Set(dot > 0f ? BotTiltType.right : BotTiltType.left);
            }

            this._nextLeanAllowed = Time.time + LeanCooldown;
        }

        private void TryFlankAroundEnemy()
        {
            if (this._bot == null || this._bot.Memory == null || this._bot.Memory.GoalEnemy == null)
            {
                return;
            }

            Vector3 self = this._bot.Position;
            Vector3 enemy = this._bot.Memory.GoalEnemy.CurrPosition;

            float aggression = this._cache?.AIRefactoredBotOwner?.PersonalityProfile.AggressionLevel ?? 0.5f;
            float flankDist = aggression > 0.7f ? 30f : 22f;

            if (Vector3.Distance(self, enemy) < flankDist &&
                FlankPositionPlanner.TryFindFlankPosition(self, enemy, out Vector3 flank))
            {
                BotMovementHelper.SmoothMoveTo(this._bot, flank, false);
                Logger.LogDebug($"[Movement] {this._bot.Profile.Info.Nickname} flanking to {flank}");
            }
        }

        private void DetectStuck(float deltaTime)
        {
            if (this._bot == null || this._bot.Mover == null || this._bot.GetPlayer == null || this._inLootingMode)
            {
                return;
            }

            Vector3 target = this._bot.Mover.LastTargetPoint(1.0f);
            if (!this.ValidateNavMeshTarget(target))
            {
                return;
            }

            Vector3 velocity = this._bot.GetPlayer.Velocity;
            if (velocity.sqrMagnitude < StuckThreshold * StuckThreshold)
            {
                this._stuckTimer += deltaTime;
                if (this._stuckTimer > MaxStuckDuration)
                {
                    Vector3 retry = target + UnityEngine.Random.insideUnitSphere * 1.0f;
                    retry.y = target.y;
                    BotMovementHelper.SmoothMoveTo(this._bot, retry, false);
                    Logger.LogDebug($"[Movement] {this._bot.Profile.Info.Nickname} triggered fallback.");
                    this._stuckTimer = 0f;
                }
            }
            else
            {
                this._stuckTimer = 0f;
            }
        }

        private bool ValidateNavMeshTarget(Vector3 position)
        {
            NavMeshHit hit;
            if (NavMesh.SamplePosition(position, out hit, 1.5f, NavMesh.AllAreas))
            {
                return (hit.position - position).sqrMagnitude < 1f;
            }

            Logger.LogWarning($"[Movement] Invalid NavMesh target: {position}");
            return false;
        }

        #endregion
    }
}
