// <auto-generated>
//   This file is part of AI-Refactored, an open-source project focused on realistic AI behavior in Escape from Tarkov.
//   Licensed under the MIT License. See LICENSE in the repository root for more information.
//
//   THIS FILE IS SYSTEMATICALLY MANAGED.
//   All movement, combat lean, and strafe logic is bulletproof and layered over EFT BotMover.
//   No fallback logic. No invalid targets. Smooth, human-like movement only.
// </auto-generated>

namespace AIRefactored.AI.Movement
{
    using System;
    using AIRefactored.AI.Core;
    using AIRefactored.Core;
    using BepInEx.Logging;
    using EFT;
    using UnityEngine;

    /// <summary>
    /// Realistic overlay for BotMover navigation. Adds combat lean, strafe, and human-like directionality.
    /// Fully native to EFT movement system. All behaviors are multiplayer and headless safe.
    /// </summary>
    public sealed class BotMovementController
    {
        private static readonly ManualLogSource Logger = Plugin.LoggerInstance;

        private BotOwner _bot;
        private BotComponentCache _cache;

        private float _lastScanTime;
        private float _nextLeanTime;
        private float _strafeTimer;
        private bool _strafeRight;
        private bool _lootingMode;

        public void Initialize(BotComponentCache cache)
        {
            if (cache == null || cache.Bot == null)
                throw new InvalidOperationException("[BotMovementController] Invalid initialization.");

            _cache = cache;
            _bot = cache.Bot;

            _lastScanTime = Time.time;
            _nextLeanTime = Time.time;
            _strafeTimer = 0.5f;
            _lootingMode = false;
        }

        public void Tick(float deltaTime)
        {
            try
            {
                var mover = _bot?.Mover;
                if (mover == null || _bot.IsDead || _bot.GetPlayer == null || !_bot.GetPlayer.IsAI)
                    return;

                if (!_lootingMode)
                {
                    TryCombatStrafe(mover, deltaTime);
                    TryLean();
                }

                TrySmoothLook(mover, deltaTime);
                TryScan();
            }
            catch (Exception ex)
            {
                Logger.LogError("[BotMovementController] Tick error: " + ex);
            }
        }

        public void EnterLootingMode() => _lootingMode = true;
        public void ExitLootingMode() => _lootingMode = false;

        /// <summary>
        /// Smoothly rotates bot to look toward its current navigation target (next corner or destination).
        /// Uses only valid _pathController references; bulletproof against nulls.
        /// </summary>
        private void TrySmoothLook(BotMover mover, float deltaTime)
        {
            try
            {
                var pathController = mover._pathController;
                if (pathController == null)
                    return;

                // Defensive: LastTargetPoint may still throw if controller is not ready.
                Vector3 point;
                try
                {
                    point = pathController.LastTargetPoint(1.0f);
                }
                catch
                {
                    return;
                }

                if (point == Vector3.zero)
                    return;

                Vector3 dir = point - _bot.Position;
                dir.y = 0f;

                if (dir.sqrMagnitude < 0.01f)
                    return;

                Quaternion desired = Quaternion.LookRotation(dir);
                _bot.Transform.rotation = Quaternion.Lerp(_bot.Transform.rotation, desired, 6f * deltaTime);
            }
            catch (Exception ex)
            {
                Logger.LogError("[BotMovementController] TrySmoothLook error: " + ex);
            }
        }

        /// <summary>
        /// Adds realistic side-to-side strafing during combat using only native BotMover and CharacterController logic.
        /// </summary>
        private void TryCombatStrafe(BotMover mover, float deltaTime)
        {
            try
            {
                if (_bot.Memory?.GoalEnemy == null || !mover.IsMoving)
                    return;

                _strafeTimer -= deltaTime;
                if (_strafeTimer <= 0f)
                {
                    _strafeRight = UnityEngine.Random.value > 0.5f;
                    _strafeTimer = UnityEngine.Random.Range(0.5f, 1.0f);
                }

                Vector3 offset = _strafeRight ? _bot.Transform.right : -_bot.Transform.right;
                Vector3 randomJitter = UnityEngine.Random.insideUnitSphere * 0.05f;
                Vector3 strafeVector = (offset + randomJitter).normalized * 1.1f * deltaTime;

                Vector3 navDir = mover.NormDirCurPoint;
                Vector3 blend = Vector3.Lerp(navDir, strafeVector, 0.25f).normalized * 1.0f * deltaTime;

                _bot.GetPlayer?.CharacterController?.Move(blend, deltaTime);
            }
            catch (Exception ex)
            {
                Logger.LogError("[BotMovementController] TryCombatStrafe error: " + ex);
            }
        }

        /// <summary>
        /// Simulates human-like peeking or leaning around corners or obstacles, with cover/obstacle logic.
        /// </summary>
        private void TryLean()
        {
            try
            {
                if (_cache.Tilt == null || Time.time < _nextLeanTime || _bot.Memory?.GoalEnemy == null)
                    return;

                Vector3 head = _bot.Position + Vector3.up * 1.5f;
                bool wallLeft = Physics.Raycast(head, -_bot.Transform.right, 1.5f, AIRefactoredLayerMasks.VisionBlockers);
                bool wallRight = Physics.Raycast(head, _bot.Transform.right, 1.5f, AIRefactoredLayerMasks.VisionBlockers);

                if (wallLeft && !wallRight)
                {
                    _cache.Tilt.Set(BotTiltType.right);
                }
                else if (wallRight && !wallLeft)
                {
                    _cache.Tilt.Set(BotTiltType.left);
                }
                else
                {
                    Vector3 toEnemy = _bot.Memory.GoalEnemy.CurrPosition - _bot.Position;
                    float dot = Vector3.Dot(toEnemy.normalized, _bot.Transform.right);
                    _cache.Tilt.Set(dot > 0f ? BotTiltType.right : BotTiltType.left);
                }

                _nextLeanTime = Time.time + 1.5f;
            }
            catch (Exception ex)
            {
                Logger.LogError("[BotMovementController] TryLean error: " + ex);
            }
        }

        /// <summary>
        /// Randomized head/vision scan for realism (pauses and checks vision line).
        /// </summary>
        private void TryScan()
        {
            try
            {
                if (Time.time - _lastScanTime < 1.25f)
                    return;

                Vector3 head = _bot.Position + Vector3.up * 1.5f;
                Vector3 dir = _bot.Transform.forward;

                if (Physics.SphereCast(head, 0.25f, dir, out _, 2.5f, AIRefactoredLayerMasks.VisionBlockers))
                {
                    if (_bot.BotTalk != null && UnityEngine.Random.value < 0.25f)
                        _bot.BotTalk.TrySay(EPhraseTrigger.Look);
                }

                _lastScanTime = Time.time;
            }
            catch (Exception ex)
            {
                Logger.LogError("[BotMovementController] TryScan error: " + ex);
            }
        }
    }
}
