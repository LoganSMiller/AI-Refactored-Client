// <auto-generated>
//   This file is part of AI-Refactored, an open-source project focused on realistic AI behavior in Escape from Tarkov.
//   Licensed under the MIT License. See LICENSE in the repository root for more information.
//
//   THIS FILE IS SYSTEMATICALLY MANAGED.
//   All movement, combat lean, and strafe logic is bulletproof and layered over EFT BotMover.
//   No fallback logic. No invalid targets. Smooth, human-like movement only.
//   Realism Pass: Subtle randomness, human hesitation, personality-driven leaning, and micro-scanning.
// </auto-generated>

namespace AIRefactored.AI.Movement
{
    using System;
    using AIRefactored.AI.Core;
    using AIRefactored.AI.Navigation;
    using AIRefactored.Core;
    using BepInEx.Logging;
    using EFT;
    using UnityEngine;

    /// <summary>
    /// Realistic overlay for BotMover navigation. Adds combat lean, strafe, and human-like directionality.
    /// Fully native to EFT movement system. All behaviors are multiplayer and headless safe.
    /// </summary>
    public sealed class BotMovementController
    {
        private static readonly ManualLogSource Logger = Plugin.LoggerInstance;

        private BotOwner _bot;
        private BotComponentCache _cache;

        private float _lastScanTime;
        private float _nextLeanTime;
        private float _strafeTimer;
        private bool _strafeRight;
        private bool _lootingMode;

        private float _lastRandomPause;
        private float _nextRandomPause;
        private float _leanMissChance = 0.07f;

        public void Initialize(BotComponentCache cache)
        {
            if (cache == null || cache.Bot == null)
                throw new InvalidOperationException("[BotMovementController] Invalid initialization.");

            _cache = cache;
            _bot = cache.Bot;

            _lastScanTime = Time.time;
            _nextLeanTime = Time.time;
            _strafeTimer = 0.5f;
            _lootingMode = false;
            _lastRandomPause = Time.time;
            _nextRandomPause = Time.time + UnityEngine.Random.Range(1.5f, 3.8f);
        }

        public void Tick(float deltaTime)
        {
            try
            {
                if (_bot == null || _bot.IsDead || _bot.Mover == null)
                    return;

                var player = _bot.GetPlayer;
                if (player == null || !player.IsAI)
                    return;

                if (!_lootingMode)
                {
                    TryCombatStrafe(_bot.Mover, deltaTime);
                    TryLean();
                }

                TrySmoothLook(_bot.Mover, deltaTime);
                TryScan();
            }
            catch (Exception ex)
            {
                Logger.LogError("[BotMovementController] Tick error: " + ex);
            }
        }

        public void EnterLootingMode() => _lootingMode = true;
        public void ExitLootingMode() => _lootingMode = false;

        private void TrySmoothLook(BotMover mover, float deltaTime)
        {
            if (_bot?.Transform == null)
                return;

            if (!BotNavHelper.TryGetSafeTarget(_bot, out Vector3 point))
                return;

            Vector3 dir = point - _bot.Position;
            dir.y = 0f;
            if (dir.sqrMagnitude < 0.0125f)
                return;

            if (Time.time < _lastRandomPause + 0.13f && UnityEngine.Random.value < 0.09f)
                return;

            Quaternion desired = Quaternion.LookRotation(dir);
            _bot.Transform.rotation = Quaternion.Lerp(_bot.Transform.rotation, desired, 6f * deltaTime);

            if (Time.time > _nextRandomPause)
            {
                _lastRandomPause = Time.time;
                _nextRandomPause = Time.time + UnityEngine.Random.Range(1.2f, 3.7f);
            }
        }

        private void TryCombatStrafe(BotMover mover, float deltaTime)
        {
            if (_bot == null || mover == null || _bot.Memory?.GoalEnemy == null)
                return;

            if (!mover.HasPathAndNoComplete || !mover.IsMoving || _bot.Transform == null)
                return;

            _strafeTimer -= deltaTime;
            if (_strafeTimer <= 0f)
            {
                _strafeRight = UnityEngine.Random.value > 0.5f;
                _strafeTimer = UnityEngine.Random.Range(0.42f, 1.11f);
            }

            Vector3 offset = _strafeRight ? _bot.Transform.right : -_bot.Transform.right;
            Vector3 jitter = UnityEngine.Random.insideUnitSphere * 0.06f;
            Vector3 strafe = (offset + jitter).normalized * 1.05f * deltaTime;

            Vector3 navDir = mover.NormDirCurPoint;
            Vector3 blend = Vector3.Lerp(navDir, strafe, UnityEngine.Random.Range(0.2f, 0.28f)).normalized * deltaTime;

            var player = _bot.GetPlayer;
            player?.CharacterController?.Move(blend, deltaTime);
        }

        private void TryLean()
        {
            if (_cache?.Tilt == null || _bot == null || Time.time < _nextLeanTime)
                return;

            var memory = _bot.Memory;
            if (memory?.GoalEnemy == null || _bot.Transform == null)
                return;

            float missChance = (_cache.AIRefactoredBotOwner?.PersonalityProfile?.Caution ?? 0.5f) * _leanMissChance;
            if (UnityEngine.Random.value < missChance)
            {
                _nextLeanTime = Time.time + UnityEngine.Random.Range(0.65f, 1.35f);
                return;
            }

            Vector3 head = _bot.Position + Vector3.up * 1.5f;
            bool wallLeft = Physics.Raycast(head, -_bot.Transform.right, 1.35f, AIRefactoredLayerMasks.VisionBlockers);
            bool wallRight = Physics.Raycast(head, _bot.Transform.right, 1.35f, AIRefactoredLayerMasks.VisionBlockers);

            if (wallLeft && !wallRight)
            {
                _cache.Tilt.Set(BotTiltType.right);
            }
            else if (wallRight && !wallLeft)
            {
                _cache.Tilt.Set(BotTiltType.left);
            }
            else
            {
                Vector3 toEnemy = memory.GoalEnemy.CurrPosition - _bot.Position;
                float dot = Vector3.Dot(toEnemy.normalized, _bot.Transform.right);
                _cache.Tilt.Set(dot > 0f ? BotTiltType.right : BotTiltType.left);
            }

            _nextLeanTime = Time.time + UnityEngine.Random.Range(0.65f, 1.15f);
        }

        private void TryScan()
        {
            if (_bot?.Transform == null)
                return;

            if (Time.time - _lastScanTime < UnityEngine.Random.Range(1.12f, 1.45f))
                return;

            Vector3 head = _bot.Position + Vector3.up * 1.5f;
            Vector3 dir = _bot.Transform.forward;

            if (Physics.SphereCast(head, 0.24f, dir, out _, 2.4f, AIRefactoredLayerMasks.VisionBlockers))
            {
                if (_bot.BotTalk != null && UnityEngine.Random.value < 0.21f)
                    _bot.BotTalk.TrySay(EPhraseTrigger.Look);
            }

            _lastScanTime = Time.time;
        }
    }
}
