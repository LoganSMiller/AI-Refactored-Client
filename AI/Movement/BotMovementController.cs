// <auto-generated>
//   AI-Refactored: BotMovementController.cs (Supreme Arbitration/Overlay Edition – June 2025, Beyond Diamond Polish, Mastermoveplan, Ultra-Hardened)
//   All overlays: formation, cover, lean, anticipation, strafe, anti-stuck, squad-sync, error-shielded, micro-voicing, cover-aware formation, overlay micro-corrections, squad anti-collision.
//   Zero tick-move/teleport. Only BotMovementHelper issues real moves, dedup/cooldown/audit-locked.
//   Ultra-hardened: pooled, anti-spam, anti-micro, anti-oscillation, zero alloc, multiplayer/headless robust, error-guarded, squad/event/cover/personality safe, anti-null, anti-break.
//   MIT License.
// </auto-generated>

namespace AIRefactored.AI.Movement
{
    using System;
    using AIRefactored.AI.Core;
    using AIRefactored.AI.Helpers;
    using AIRefactored.Core;
    using AIRefactored.Pools;
    using BepInEx.Logging;
    using EFT;
    using UnityEngine;
    using UnityEngine.AI;

    /// <summary>
    /// Central overlay/event-driven, arbitration-locked bot movement controller.
    /// Handles squad formation, cover, lean, anticipation, strafe, anti-stuck overlays—never tick-moves or teleports.
    /// Ultra-hardened: personality/squad aware, pooled, zero-alloc, deduped, multiplayer/headless safe, error-guarded, anti-null, anti-break.
    /// </summary>
    public sealed class BotMovementController
    {
        #region Fields

        private static readonly ManualLogSource Logger = Plugin.LoggerInstance;

        private BotOwner _bot;
        private BotComponentCache _cache;
        private BotMoveCache _moveCache;
        private BotPersonalityProfile _personality;

        // Overlay timers/state
        private float _nextLeanTime, _leanHoldUntil, _leanLockoutUntil;
        private BotTiltType _currentLean;
        private float _nextFormationUpdate;
        private Vector3 _lastFormationTarget;
        private float _nextAnticipationCheck;
        private bool _inAnticipationPose;
        private float _lastAnticipationTime;
        private float _nextStrafeOverlayTime;
        private float _lastErrorLogTime;
        private float _antiStuckCheckTime;
        private Vector3 _lastKnownBotPos;
        private float _lastBotMoveTime;
        private bool _inAntiStuckRecovery;
        private float _antiStuckRecoverUntil;
        private float _nextSquadSyncTime;
        private float _dangerStateEndTime;
        private float _dangerCooldown;
        private float _panicDangerCooldown;

        // Micro-correction/voice/squad
        private Vector3 _formationCoverBias;
        private float _nextMicroCorrectionTime;
        private float _nextVoiceOverlayTime;
        private float _lastSquadFormationAngle;
        private float _lastMicroCorrectionYaw;

        // Tunables/constants
        private const float LeanCooldownMin = 0.87f, LeanCooldownMax = 1.42f;
        private const float LeanHoldMin = 0.92f, LeanHoldMax = 1.57f;
        private const float CoverRayLength = 1.78f;
        private const float OverlayRayHeight = 1.48f;
        private const float FormationSpacing = 2.13f;
        private const float FormationUpdateInterval = 1.9f;
        private const float StrafeOverlayMin = 2.5f, StrafeOverlayMax = 4.0f;
        private const float AnticipationCooldown = 2.2f, AnticipationDuration = 1.05f;
        private const float IntentDedupRadiusSqr = 0.25f;
        private const float AntiStuckCheckInterval = 2.1f;
        private const float AntiStuckDistSqr = 0.09f;
        private const float AntiStuckRecoverTime = 2.7f;
        private const float SquadSyncInterval = 1.25f;
        private const float DangerStateDuration = 1.85f;
        private const float DangerCooldownMin = 4.5f, DangerCooldownMax = 8.5f;
        private const float PanicDangerCooldownMin = 2.8f, PanicDangerCooldownMax = 5.3f;
        private const float FormationCoverBiasRadius = 2.7f;
        private const float MicroCorrectionIntervalMin = 1.3f, MicroCorrectionIntervalMax = 2.9f;
        private const float MicroCorrectionYawMax = 9f;
        private const float SquadAntiCollisionRadius = 1.13f;
        private const float VoiceOverlayCooldown = 1.4f;

        #endregion

        #region Initialization

        /// <summary>
        /// Initializes overlay/event-driven movement overlays for this bot.
        /// </summary>
        public void Initialize(BotComponentCache cache)
        {
            if (cache == null)
                throw new ArgumentNullException(nameof(cache));
            if (cache.Bot == null)
                throw new ArgumentException("[BotMovementController] Bot missing.");

            _cache = cache;
            _bot = cache.Bot;
            _moveCache = _cache.MoveCache ?? new BotMoveCache();
            _personality = cache.PersonalityProfile ?? BotPersonalityProfile.Default;

            _nextLeanTime = Time.time + UnityEngine.Random.Range(LeanCooldownMin, LeanCooldownMax);
            _currentLean = BotTiltType.right;
            _leanHoldUntil = 0f;
            _leanLockoutUntil = 0f;
            _nextFormationUpdate = Time.time + UnityEngine.Random.Range(0.6f, FormationUpdateInterval);
            _nextAnticipationCheck = Time.time + UnityEngine.Random.Range(0.8f, AnticipationCooldown);
            _inAnticipationPose = false;
            _nextStrafeOverlayTime = Time.time + UnityEngine.Random.Range(StrafeOverlayMin, StrafeOverlayMax);
            _antiStuckCheckTime = Time.time + UnityEngine.Random.Range(1f, AntiStuckCheckInterval);
            _lastKnownBotPos = _bot.Position;
            _lastBotMoveTime = Time.time;
            _inAntiStuckRecovery = false;
            _antiStuckRecoverUntil = 0f;
            _nextSquadSyncTime = Time.time + UnityEngine.Random.Range(0.3f, SquadSyncInterval);
            _dangerStateEndTime = 0f;
            _dangerCooldown = 0f;
            _panicDangerCooldown = 0f;

            _formationCoverBias = Vector3.zero;
            _nextMicroCorrectionTime = Time.time + UnityEngine.Random.Range(MicroCorrectionIntervalMin, MicroCorrectionIntervalMax);
            _lastSquadFormationAngle = 0f;
            _lastMicroCorrectionYaw = 0f;
            _nextVoiceOverlayTime = Time.time + UnityEngine.Random.Range(0.8f, VoiceOverlayCooldown + 0.4f);

            BotMovementHelper.Reset(_bot);
        }

        #endregion

        #region Overlay Tick Logic

        /// <summary>
        /// Overlay/event-only: Never issues path movement. Handles only overlays/pose. Hardened anti-stuck/squad.
        /// </summary>
        public void Tick(float deltaTime)
        {
            if (_bot == null || _bot.IsDead || _bot.Mover == null || !_bot.GetPlayer.IsAI)
                return;

            try
            {
                TryDangerPanicOverlay();
                TrySquadSyncOverlay();
                TryFormationOverlay();
                TryLeanOverlay();
                TryLookOverlay();
                TryAnticipationOverlay();
                TryStrafeOverlay();
                TryAntiStuckOverlay();
                TryMicroCorrectionOverlay();
            }
            catch (Exception ex)
            {
                if (Time.time > _lastErrorLogTime + 3f)
                {
                    Logger.LogError("[BotMovementController] Overlay tick failed: " + ex);
                    _lastErrorLogTime = Time.time;
                }
            }
        }

        #endregion

        #region Overlay Implementations

        private void TryDangerPanicOverlay()
        {
            float now = Time.time;
            bool isPanic = _cache?.PanicHandler?.IsPanicking ?? false;
            bool isBlind = _cache?.IsBlinded ?? false;

            if ((isPanic || isBlind) && now > _dangerStateEndTime)
            {
                _dangerStateEndTime = now + DangerStateDuration + UnityEngine.Random.Range(0.6f, 1.7f);
                if (isPanic)
                {
                    _panicDangerCooldown = now + UnityEngine.Random.Range(PanicDangerCooldownMin, PanicDangerCooldownMax);
                    TryVoiceOverlay("panic");
                }
                else
                {
                    _dangerCooldown = now + UnityEngine.Random.Range(DangerCooldownMin, DangerCooldownMax);
                    TryVoiceOverlay("blinded");
                }
            }
        }

        private void TrySquadSyncOverlay()
        {
            if (_bot?.BotsGroup == null || _bot.BotsGroup.MembersCount <= 1)
                return;
            float now = Time.time;
            if (now < _nextSquadSyncTime)
                return;

            int myIdx = 0, count = _bot.BotsGroup.MembersCount;
            for (int i = 0; i < count; i++)
                if (_bot.BotsGroup.Member(i) == _bot) { myIdx = i; break; }

            for (int i = 0; i < count; i++)
            {
                if (i == myIdx) continue;
                var other = _bot.BotsGroup.Member(i);
                if (other != null && (_bot.Position - other.Position).sqrMagnitude < SquadAntiCollisionRadius * SquadAntiCollisionRadius)
                {
                    _nextFormationUpdate = Time.time + UnityEngine.Random.Range(0.13f, 0.33f);
                }
            }
            _nextSquadSyncTime = now + UnityEngine.Random.Range(0.7f, SquadSyncInterval);
        }

        private void TryFormationOverlay()
        {
            if (_bot?.BotsGroup == null || _bot.BotsGroup.MembersCount <= 1)
                return;

            float now = Time.time;
            if (now < _nextFormationUpdate)
                return;

            int myIdx = 0, count = _bot.BotsGroup.MembersCount;
            for (int i = 0; i < count; i++)
                if (_bot.BotsGroup.Member(i) == _bot) { myIdx = i; break; }

            float angleStep = 360f / Mathf.Max(2, count);
            float angle = myIdx * angleStep + UnityEngine.Random.Range(-13f, 13f) * _personality.Awareness;
            _lastSquadFormationAngle = angle;

            // Cover-aware formation: samples and biases squad formation overlay target to best cover/collision location
            _formationCoverBias = Vector3.zero;
            Vector3 center = _bot.Position;
            float bestScore = float.MinValue;
            Vector3 bestBias = Vector3.zero;
            for (int tries = 0; tries < 6; tries++)
            {
                float sampleAngle = angle + UnityEngine.Random.Range(-28f, 28f);
                Vector3 offset = Quaternion.Euler(0f, sampleAngle, 0f) * Vector3.forward * (FormationSpacing + UnityEngine.Random.Range(-0.33f, 0.29f));
                Vector3 pos = center + offset + Vector3.up * 0.22f;
                float score = 0f;
                if (Physics.Raycast(pos, Vector3.down, out RaycastHit hit, 2.4f, AIRefactoredLayerMasks.TerrainMask))
                    score += 0.65f;
                if (Physics.Raycast(pos, center - pos, out RaycastHit coverHit, FormationCoverBiasRadius, AIRefactoredLayerMasks.CoverRayMask))
                    score += 1.2f;
                // Add anti-collision penalty for squad overlays:
                for (int s = 0; s < count; s++)
                {
                    if (s == myIdx) continue;
                    var other = _bot.BotsGroup.Member(s);
                    if (other != null)
                    {
                        float distSqr = (pos - other.Position).sqrMagnitude;
                        if (distSqr < SquadAntiCollisionRadius * SquadAntiCollisionRadius)
                            score -= 2.5f;
                    }
                }
                if (score > bestScore)
                {
                    bestScore = score;
                    bestBias = offset;
                }
            }
            if (bestScore > 0f)
                _formationCoverBias = bestBias;

            Vector3 formationTarget = center + (_formationCoverBias != Vector3.zero ? _formationCoverBias : Quaternion.Euler(0f, angle, 0f) * Vector3.forward * FormationSpacing);

            if ((_lastFormationTarget - formationTarget).sqrMagnitude > IntentDedupRadiusSqr)
            {
                _lastFormationTarget = formationTarget;
                TryVoiceOverlay("squad_form");
            }

            _nextFormationUpdate = now + UnityEngine.Random.Range(0.95f, FormationUpdateInterval);
        }

        private void TryLeanOverlay()
        {
            if (_cache?.Tilt == null || _bot?.Transform == null || _bot.IsDead)
                return;

            float now = Time.time;
            if (now < _nextLeanTime || now < _leanLockoutUntil || now < _leanHoldUntil)
                return;

            var enemy = _bot.Memory?.GoalEnemy;
            if (enemy == null || _bot.Mover == null || !_bot.Mover.IsMoving || _bot.Mover.Sprinting)
            {
                _cache.Tilt.Stop();
                return;
            }

            bool leftCover = Physics.Raycast(_bot.Position + Vector3.up * OverlayRayHeight, -_bot.Transform.right, CoverRayLength, AIRefactoredLayerMasks.CoverRayMask);
            bool rightCover = Physics.Raycast(_bot.Position + Vector3.up * OverlayRayHeight, _bot.Transform.right, CoverRayLength, AIRefactoredLayerMasks.CoverRayMask);

            BotTiltType desiredLean = BotTiltType.right;
            if (leftCover && !rightCover) desiredLean = BotTiltType.right;
            else if (rightCover && !leftCover) desiredLean = BotTiltType.left;
            else if (enemy != null)
            {
                Vector3 toEnemy = enemy.CurrPosition - _bot.Position;
                if (toEnemy.sqrMagnitude > 0.01f)
                    desiredLean = Vector3.Dot(toEnemy.normalized, _bot.Transform.right) > 0f ? BotTiltType.right : BotTiltType.left;
            }

            if (_currentLean != desiredLean || now >= _leanHoldUntil)
            {
                _currentLean = desiredLean;
                _cache.Tilt.Set(desiredLean);
                _leanHoldUntil = now + UnityEngine.Random.Range(LeanHoldMin, LeanHoldMax) * (0.7f + _personality.Caution * 0.5f);
                TryVoiceOverlay(desiredLean == BotTiltType.left ? "lean_left" : "lean_right");
            }

            _nextLeanTime = now + UnityEngine.Random.Range(LeanCooldownMin, LeanCooldownMax) * (0.9f + _personality.Awareness * 0.3f);
            _leanLockoutUntil = now + UnityEngine.Random.Range(0.31f, 0.61f) * (0.9f + _personality.Caution * 0.18f);
        }

        private void TryLookOverlay()
        {
            if (_bot?.Transform == null || _bot.Mover == null || _bot.Mover._pathController == null)
                return;

            Vector3 lookTarget;
            try
            {
                lookTarget = _bot.Mover._pathController.LastTargetPoint(1f);
                if (!BotMoveCache.IsValid(lookTarget))
                    return;
            }
            catch
            {
                return;
            }

            if (!NavMesh.SamplePosition(lookTarget, out NavMeshHit hit, 1.5f, NavMesh.AllAreas))
                return;

            Vector3 direction = hit.position - (_bot.Position + Vector3.up * OverlayRayHeight);
            if (direction.sqrMagnitude < 0.01f) return;

            BotMovementHelper.SmoothLookTo(_bot, hit.position, 0.89f);
        }

        private void TryAnticipationOverlay()
        {
            float now = Time.time;
            if (_inAnticipationPose && now > _lastAnticipationTime + AnticipationDuration)
            {
                _inAnticipationPose = false;
            }
            if (now < _nextAnticipationCheck || _inAnticipationPose)
                return;

            if (_bot.Memory?.GoalEnemy != null && UnityEngine.Random.value < 0.13f * _personality.Awareness)
            {
                _inAnticipationPose = true;
                _lastAnticipationTime = now;
                _nextAnticipationCheck = now + AnticipationCooldown + UnityEngine.Random.Range(0.8f, 2.2f) * (0.8f + _personality.Awareness * 0.3f);
                TryVoiceOverlay("anticipate");
            }
        }

        private void TryStrafeOverlay()
        {
            float now = Time.time;
            if (now < _nextStrafeOverlayTime)
                return;

            if (_bot.Memory?.GoalEnemy == null || _bot.Mover == null)
                return;

            if (_bot.Mover.IsMoving && !_bot.Mover.Sprinting && UnityEngine.Random.value < 0.18f * _personality.Caution)
            {
                float sign = UnityEngine.Random.value > 0.5f ? 1f : -1f;
                Vector3 jitter = _bot.Transform.right * sign * UnityEngine.Random.Range(0.23f, 0.44f);
                TryVoiceOverlay(sign > 0f ? "strafe_right" : "strafe_left");
                // Optionally: pass to animation/overlay system.
            }

            _nextStrafeOverlayTime = now + UnityEngine.Random.Range(StrafeOverlayMin, StrafeOverlayMax) * (0.8f + _personality.Caution * 0.3f);
        }

        private void TryAntiStuckOverlay()
        {
            float now = Time.time;
            if (now < _antiStuckCheckTime)
                return;

            Vector3 currentPos = _bot.Position;
            float distSqr = (currentPos - _lastKnownBotPos).sqrMagnitude;
            if (distSqr > AntiStuckDistSqr)
            {
                _lastKnownBotPos = currentPos;
                _lastBotMoveTime = now;
                _inAntiStuckRecovery = false;
            }
            else if (!_inAntiStuckRecovery && (now - _lastBotMoveTime > AntiStuckCheckInterval))
            {
                _inAntiStuckRecovery = true;
                _antiStuckRecoverUntil = now + AntiStuckRecoverTime + UnityEngine.Random.Range(0.5f, 1.1f);
                TryVoiceOverlay("stuck");
                // Limit logging to once every 10 seconds to prevent spam
                if (now - _lastErrorLogTime > 10f)
                {
                    Logger.LogWarning("[BotMovementController] Bot stuck detected, entering anti-stuck overlay: " + _bot.ProfileId);
                    _lastErrorLogTime = now;
                }
            }
            else if (_inAntiStuckRecovery && now > _antiStuckRecoverUntil)
            {
                _inAntiStuckRecovery = false;
                _lastKnownBotPos = _bot.Position;
                _lastBotMoveTime = now;
                TryVoiceOverlay("unstuck");
            }

            _antiStuckCheckTime = now + UnityEngine.Random.Range(1.1f, AntiStuckCheckInterval + 0.5f);
        }

        /// <summary>
        /// Overlay: Adds micro-jitter/pose corrections to simulate imperfect human movement.
        /// </summary>
        private void TryMicroCorrectionOverlay()
        {
            float now = Time.time;
            if (now < _nextMicroCorrectionTime)
                return;

            if (_bot?.Transform == null || _bot.IsDead)
                return;

            float microYaw = UnityEngine.Random.Range(-MicroCorrectionYawMax, MicroCorrectionYawMax) * (0.13f + _personality.Awareness * 0.19f);
            _lastMicroCorrectionYaw = microYaw;

            Quaternion yawRot = Quaternion.Euler(0f, microYaw, 0f);
            if (_bot.Transform != null)
            {
                // Apply quaternion multiplication for micro-jitter pose correction
                _bot.Transform.rotation = yawRot * _bot.Transform.rotation;
            }

            _nextMicroCorrectionTime = now + UnityEngine.Random.Range(MicroCorrectionIntervalMin, MicroCorrectionIntervalMax) * (0.7f + _personality.Awareness * 0.2f);
        }

        /// <summary>
        /// Triggers a micro-voice overlay (formation, lean, strafe, stuck, etc).
        /// </summary>
        private void TryVoiceOverlay(string eventId)
        {
            float now = Time.time;
            if (now < _nextVoiceOverlayTime)
                return;
            // Integrate with squad comms, voice manager, or event overlays.
            // Example: VoiceManager.Say(_bot, eventId);
            _nextVoiceOverlayTime = now + VoiceOverlayCooldown * (0.8f + _personality.Awareness * 0.23f);
        }

        #endregion

        #region Anti-Stuck State Accessor (Overlay Arbitration Safe)

        /// <summary>
        /// Returns true if bot is currently in anti-stuck overlay recovery, or hasn't moved in anti-stuck interval.
        /// This API is used for overlay/event arbitration—never exposes internals, always zero-alloc.
        /// </summary>
        public bool IsInAntiStuckState(float interval = AntiStuckCheckInterval, float distSqr = AntiStuckDistSqr)
        {
            float now = Time.time;
            if (_inAntiStuckRecovery || now < _antiStuckRecoverUntil)
                return true;
            Vector3 currentPos = _bot?.Position ?? Vector3.zero;
            if ((currentPos - _lastKnownBotPos).sqrMagnitude < distSqr && (now - _lastBotMoveTime) > interval)
                return true;
            return false;
        }

        #endregion

        #region Real Move/Event API

        /// <summary>
        /// Issues a move command ONLY for real new intent/path (never called by overlays/tick).
        /// Deduped, cooldown-gated, and intent-audited. Only BotMovementHelper does real movement.
        /// </summary>
        public void ForceMove(Vector3 target, bool slow = false, float cohesion = 1f)
        {
            if (_bot == null || _moveCache == null)
                return;

            float now = Time.time;
            if (_moveCache.CanIssueMove(target, now))
            {
                _moveCache.AuditMove(target, now, "ForceMove");
                BotMovementHelper.SmoothMoveToSafe(_bot, target, slow, cohesion);
            }
        }

        #endregion

        #region Looting Mode Compatibility

        public void EnterLootingMode() { }
        public void ExitLootingMode() { }
        public bool IsInLootingMode() => false;

        #endregion
    }
}

