// <auto-generated>
//   This file is part of AI-Refactored, an open-source project focused on realistic AI behavior in Escape from Tarkov.
//   Licensed under the MIT License. See LICENSE in the repository root for more information.
//
//   THIS FILE IS SYSTEMATICALLY MANAGED.
//   All movement, combat lean, and strafe logic is bulletproof and layered over EFT BotMover.
//   No fallback logic. No invalid targets. Smooth, human-like movement only.
// </auto-generated>

namespace AIRefactored.AI.Movement
{
    using System;
    using AIRefactored.AI.Core;
    using AIRefactored.AI.Helpers;
    using AIRefactored.Core;
    using BepInEx.Logging;
    using EFT;
    using UnityEngine;

    /// <summary>
    /// Realistic overlay for BotMover navigation. Adds combat lean, strafe, and human-like directionality.
    /// Fully native to EFT movement system. All behaviors are multiplayer and headless safe.
    /// </summary>
    public sealed class BotMovementController
    {
        private static readonly ManualLogSource Logger = Plugin.LoggerInstance;

        private BotOwner _bot;
        private BotComponentCache _cache;

        private float _lastScanTime;
        private float _nextLeanTime;
        private float _strafeTimer;
        private bool _strafeRight;
        private bool _lootingMode;

        public void Initialize(BotComponentCache cache)
        {
            if (cache == null || cache.Bot == null)
                throw new InvalidOperationException("[BotMovementController] Invalid initialization.");

            _cache = cache;
            _bot = cache.Bot;

            _lastScanTime = Time.time;
            _nextLeanTime = Time.time;
            _strafeTimer = 0.5f;
            _lootingMode = false;
        }

        public void Tick(float deltaTime)
        {
            try
            {
                if (_bot?.Mover == null || _bot.IsDead || _bot.GetPlayer == null || !_bot.GetPlayer.IsAI)
                    return;

                if (!_lootingMode)
                {
                    TryCombatStrafe(deltaTime);
                    TryLean();
                }

                TrySmoothLook(deltaTime);
                TryScan();
            }
            catch (Exception ex)
            {
                Logger.LogError("[BotMovementController] Tick error: " + ex);
            }
        }

        public void EnterLootingMode() => _lootingMode = true;
        public void ExitLootingMode() => _lootingMode = false;

        private void TrySmoothLook(float deltaTime)
        {
            try
            {
                Vector3? target = _bot.Mover.TargetPoint;
                if (!target.HasValue || target.Value == Vector3.zero)
                    return;

                Vector3 dir = target.Value - _bot.Position;
                dir.y = 0f;

                if (dir.sqrMagnitude < 0.01f)
                    return;

                Quaternion desired = Quaternion.LookRotation(dir);
                _bot.Transform.rotation = Quaternion.Lerp(_bot.Transform.rotation, desired, 6f * deltaTime);
            }
            catch (Exception ex)
            {
                Logger.LogError("[BotMovementController] TrySmoothLook error: " + ex);
            }
        }

        private void TryCombatStrafe(float deltaTime)
        {
            try
            {
                if (_bot.Memory?.GoalEnemy == null)
                    return;

                _strafeTimer -= deltaTime;
                if (_strafeTimer <= 0f)
                {
                    _strafeRight = UnityEngine.Random.value > 0.5f;
                    _strafeTimer = UnityEngine.Random.Range(0.4f, 0.75f);
                }

                Vector3 offset = _strafeRight ? _bot.Transform.right : -_bot.Transform.right;
                Vector3 nudge = offset + UnityEngine.Random.insideUnitSphere * 0.1f;
                _bot.GetPlayer?.CharacterController?.Move(nudge.normalized * 1.25f * deltaTime, deltaTime);
            }
            catch (Exception ex)
            {
                Logger.LogError("[BotMovementController] TryCombatStrafe error: " + ex);
            }
        }

        private void TryLean()
        {
            try
            {
                if (_cache.Tilt == null || Time.time < _nextLeanTime || _bot.Memory?.GoalEnemy == null)
                    return;

                Vector3 head = _bot.Position + Vector3.up * 1.5f;
                bool wallLeft = Physics.Raycast(head, -_bot.Transform.right, 1.5f, AIRefactoredLayerMasks.VisionBlockers);
                bool wallRight = Physics.Raycast(head, _bot.Transform.right, 1.5f, AIRefactoredLayerMasks.VisionBlockers);

                if (wallLeft && !wallRight)
                {
                    _cache.Tilt.Set(BotTiltType.right);
                }
                else if (wallRight && !wallLeft)
                {
                    _cache.Tilt.Set(BotTiltType.left);
                }
                else
                {
                    Vector3 toEnemy = _bot.Memory.GoalEnemy.CurrPosition - _bot.Position;
                    float dot = Vector3.Dot(toEnemy.normalized, _bot.Transform.right);
                    _cache.Tilt.Set(dot > 0f ? BotTiltType.right : BotTiltType.left);
                }

                _nextLeanTime = Time.time + 1.5f;
            }
            catch (Exception ex)
            {
                Logger.LogError("[BotMovementController] TryLean error: " + ex);
            }
        }

        private void TryScan()
        {
            try
            {
                if (Time.time - _lastScanTime < 1.25f)
                    return;

                Vector3 head = _bot.Position + Vector3.up * 1.5f;
                Vector3 dir = _bot.Transform.forward;

                if (Physics.SphereCast(head, 0.25f, dir, out _, 2.5f, AIRefactoredLayerMasks.VisionBlockers))
                {
                    if (_bot.BotTalk != null && UnityEngine.Random.value < 0.25f)
                        _bot.BotTalk.TrySay(EPhraseTrigger.Look);
                }

                _lastScanTime = Time.time;
            }
            catch (Exception ex)
            {
                Logger.LogError("[BotMovementController] TryScan error: " + ex);
            }
        }
    }
}
