// <auto-generated>
//   This file is part of AI-Refactored, an open-source project focused on realistic AI behavior in Escape from Tarkov.
//   Licensed under the MIT License. See LICENSE in the repository root for more information.
//
//   THIS FILE IS SYSTEMATICALLY MANAGED.
//   All movement, combat lean, and strafe logic is bulletproof and layered over EFT BotMover.
//   No fallback logic. No invalid targets. Smooth, human-like movement only.
//   Realism Pass: Adds subtle randomness, human hesitation, personality-driven leaning, and micro-scanning.
// </auto-generated>

namespace AIRefactored.AI.Movement
{
    using System;
    using AIRefactored.AI.Core;
    using AIRefactored.Core;
    using BepInEx.Logging;
    using EFT;
    using UnityEngine;

    /// <summary>
    /// Realistic overlay for BotMover navigation. Adds combat lean, strafe, and human-like directionality.
    /// Fully native to EFT movement system. All behaviors are multiplayer and headless safe.
    /// </summary>
    public sealed class BotMovementController
    {
        private static readonly ManualLogSource Logger = Plugin.LoggerInstance;

        private BotOwner _bot;
        private BotComponentCache _cache;

        private float _lastScanTime;
        private float _nextLeanTime;
        private float _strafeTimer;
        private bool _strafeRight;
        private bool _lootingMode;

        private float _lastRandomPause;
        private float _nextRandomPause;
        private float _leanMissChance = 0.07f;

        public void Initialize(BotComponentCache cache)
        {
            if (cache == null || cache.Bot == null)
                throw new InvalidOperationException("[BotMovementController] Invalid initialization.");

            _cache = cache;
            _bot = cache.Bot;

            _lastScanTime = Time.time;
            _nextLeanTime = Time.time;
            _strafeTimer = 0.5f;
            _lootingMode = false;
            _lastRandomPause = Time.time;
            _nextRandomPause = Time.time + UnityEngine.Random.Range(1.5f, 3.8f);
        }

        public void Tick(float deltaTime)
        {
            try
            {
                if (_bot == null)
                    return;

                var mover = _bot.Mover;
                if (mover == null || _bot.IsDead)
                    return;

                var player = _bot.GetPlayer;
                if (player == null || !player.IsAI)
                    return;

                if (!_lootingMode)
                {
                    TryCombatStrafe(mover, deltaTime);
                    TryLean();
                }

                TrySmoothLook(mover, deltaTime);
                TryScan();
            }
            catch (Exception ex)
            {
                Logger.LogError("[BotMovementController] Tick error: " + ex);
            }
        }

        public void EnterLootingMode() => _lootingMode = true;
        public void ExitLootingMode() => _lootingMode = false;

        /// <summary>
        /// Smoothly rotates bot to look toward its current navigation target (next corner or destination).
        /// </summary>
        private void TrySmoothLook(BotMover mover, float deltaTime)
        {
            try
            {
                if (mover == null || _bot == null || _bot.Transform == null)
                    return;

                var pathController = mover._pathController;
                if (pathController == null || !pathController.HavePath)
                    return;

                Vector3 point;
                try
                {
                    point = pathController.LastTargetPoint(1.0f);
                }
                catch
                {
                    return;
                }

                if (point == Vector3.zero || float.IsNaN(point.x) || float.IsInfinity(point.x))
                    return;

                Vector3 dir = point - _bot.Position;
                dir.y = 0f;

                if (dir.sqrMagnitude < 0.01f)
                    return;

                if (Time.time < _lastRandomPause + 0.13f && UnityEngine.Random.value < 0.09f)
                    return;

                Quaternion desired = Quaternion.LookRotation(dir);
                _bot.Transform.rotation = Quaternion.Lerp(_bot.Transform.rotation, desired, 6f * deltaTime);

                if (Time.time > _nextRandomPause)
                {
                    _lastRandomPause = Time.time;
                    _nextRandomPause = Time.time + UnityEngine.Random.Range(1.2f, 3.7f);
                }
            }
            catch (Exception ex)
            {
                Logger.LogError("[BotMovementController] TrySmoothLook error: " + ex);
            }
        }

        /// <summary>
        /// Adds realistic side-to-side strafing during combat using only native BotMover and CharacterController logic.
        /// </summary>
        private void TryCombatStrafe(BotMover mover, float deltaTime)
        {
            try
            {
                if (_bot == null || mover == null)
                    return;

                var memory = _bot.Memory;
                if (memory == null || memory.GoalEnemy == null)
                    return;

                if (!mover.HasPathAndNoComplete || !mover.IsMoving)
                    return;

                if (_bot.Transform == null)
                    return;

                _strafeTimer -= deltaTime;
                if (_strafeTimer <= 0f)
                {
                    _strafeRight = UnityEngine.Random.value > 0.5f;
                    _strafeTimer = UnityEngine.Random.Range(0.42f, 1.11f);
                }

                Vector3 offset = _strafeRight ? _bot.Transform.right : -_bot.Transform.right;
                Vector3 randomJitter = UnityEngine.Random.insideUnitSphere * 0.08f;
                Vector3 strafeVector = (offset + randomJitter).normalized * 1.08f * deltaTime;

                Vector3 navDir = mover.NormDirCurPoint;
                Vector3 blend = Vector3.Lerp(navDir, strafeVector, UnityEngine.Random.Range(0.21f, 0.32f)).normalized * 1.0f * deltaTime;

                var player = _bot.GetPlayer;
                if (player?.CharacterController != null)
                {
                    player.CharacterController.Move(blend, deltaTime);
                }
            }
            catch (Exception ex)
            {
                Logger.LogError("[BotMovementController] TryCombatStrafe error: " + ex);
            }
        }

        /// <summary>
        /// Simulates human-like peeking or leaning around corners or obstacles, with cover/obstacle logic.
        /// Personality: Cautious bots lean less; aggressive bots lean more. Adds rare "miss" for realism.
        /// </summary>
        private void TryLean()
        {
            try
            {
                if (_cache == null || _cache.Tilt == null || _bot == null)
                    return;

                if (Time.time < _nextLeanTime)
                    return;

                var memory = _bot.Memory;
                if (memory == null || memory.GoalEnemy == null)
                    return;

                if (_bot.Transform == null)
                    return;

                float leanMiss = (_cache.AIRefactoredBotOwner?.PersonalityProfile?.Caution ?? 0.5f) * _leanMissChance;
                if (UnityEngine.Random.value < leanMiss)
                {
                    _nextLeanTime = Time.time + UnityEngine.Random.Range(1.1f, 2.3f);
                    return;
                }

                Vector3 head = _bot.Position + Vector3.up * 1.5f;
                bool wallLeft = Physics.Raycast(head, -_bot.Transform.right, 1.5f, AIRefactoredLayerMasks.VisionBlockers);
                bool wallRight = Physics.Raycast(head, _bot.Transform.right, 1.5f, AIRefactoredLayerMasks.VisionBlockers);

                if (wallLeft && !wallRight)
                {
                    _cache.Tilt.Set(BotTiltType.right);
                }
                else if (wallRight && !wallLeft)
                {
                    _cache.Tilt.Set(BotTiltType.left);
                }
                else if (memory.GoalEnemy != null)
                {
                    Vector3 toEnemy = memory.GoalEnemy.CurrPosition - _bot.Position;
                    float dot = Vector3.Dot(toEnemy.normalized, _bot.Transform.right);
                    _cache.Tilt.Set(dot > 0f ? BotTiltType.right : BotTiltType.left);
                }

                _nextLeanTime = Time.time + UnityEngine.Random.Range(1.1f, 2.3f);
            }
            catch (Exception ex)
            {
                Logger.LogError("[BotMovementController] TryLean error: " + ex);
            }
        }

        /// <summary>
        /// Randomized head/vision scan for realism (pauses and checks vision line).
        /// </summary>
        private void TryScan()
        {
            try
            {
                if (_bot == null || _bot.Transform == null)
                    return;

                if (Time.time - _lastScanTime < UnityEngine.Random.Range(1.15f, 1.65f))
                    return;

                Vector3 head = _bot.Position + Vector3.up * 1.5f;
                Vector3 dir = _bot.Transform.forward;

                if (Physics.SphereCast(head, 0.25f, dir, out _, 2.5f, AIRefactoredLayerMasks.VisionBlockers))
                {
                    if (_bot.BotTalk != null && UnityEngine.Random.value < 0.25f)
                        _bot.BotTalk.TrySay(EPhraseTrigger.Look);
                }

                _lastScanTime = Time.time;
            }
            catch (Exception ex)
            {
                Logger.LogError("[BotMovementController] TryScan error: " + ex);
            }
        }
    }
}
