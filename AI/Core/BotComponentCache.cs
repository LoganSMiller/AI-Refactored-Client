// <auto-generated>
//   This file is part of AI-Refactored, an open-source project focused on realistic AI behavior in Escape from Tarkov.
//   Licensed under the MIT License. See LICENSE in the repository root for more information.
//
//   THIS FILE IS SYSTEMATICALLY MANAGED.
//   Please follow strict StyleCop, ReSharper, and AI-Refactored code standards for all modifications.
// </auto-generated>

#nullable enable

namespace AIRefactored.AI.Core
{
    using System;
    using AIRefactored.AI.Combat;
    using AIRefactored.AI.Components;
    using AIRefactored.AI.Groups;
    using AIRefactored.AI.Looting;
    using AIRefactored.AI.Medical;
    using AIRefactored.AI.Memory;
    using AIRefactored.AI.Movement;
    using AIRefactored.AI.Optimization;
    using AIRefactored.AI.Perception;
    using AIRefactored.AI.Reactions;
    using AIRefactored.Runtime;
    using BepInEx.Logging;
    using EFT;
    using UnityEngine;

    /// <summary>
    /// Runtime container for all bot-specific AIRefactored logic systems.
    /// Attached to each bot during initialization.
    /// </summary>
    public sealed class BotComponentCache
    {
        #region Logger

        private static readonly ManualLogSource Logger = AIRefactoredController.Logger;

        #endregion

        #region Core References

        public BotOwner? Bot { get; internal set; }

        public AIRefactoredBotOwner? AIRefactoredBotOwner { get; private set; }

        public BotMemoryClass? Memory => this.Bot?.Memory;

        public string Nickname => this.Bot?.Profile?.Info?.Nickname ?? "Unknown";

        public Vector3 Position => this.Bot?.Position ?? Vector3.zero;

        #endregion

        #region Runtime Flags

        public bool IsBlinded { get; set; }

        public float BlindUntilTime { get; set; }

        public float LastFlashTime { get; set; }

        public float LastHeardTime { get; private set; } = -999f;

        public Vector3? LastHeardDirection { get; private set; }

        #endregion

        #region AI Subsystems

        public CombatStateMachine? Combat { get; private set; }

        public BotMovementController? Movement { get; private set; }

        public BotPoseController? PoseController { get; set; }

        public BotTilt? Tilt { get; private set; }

        public BotTacticalDeviceController? Tactical { get; private set; }

        public BotGroupBehavior? GroupBehavior { get; private set; }

        public BotThreatSelector? ThreatSelector { get; private set; }

        public BotTacticalMemory? TacticalMemory { get; private set; }

        public BotLastShotTracker? LastShotTracker { get; private set; }

        public BotGroupComms? GroupComms { get; private set; }

        public BotSuppressionReactionComponent? Suppression { get; private set; }

        public BotPanicHandler? PanicHandler { get; private set; }

        public BotThreatEscalationMonitor? Escalation { get; private set; }

        public BotInjurySystem? InjurySystem { get; private set; }

        public BotDeadBodyScanner? DeadBodyScanner { get; private set; }

        public BotLootScanner? LootScanner { get; private set; }

        public BotOwnerPathfindingCache? Pathing { get; private set; }

        public SquadPathCoordinator? SquadPath { get; private set; }

        public BotDoorOpener? DoorOpener { get; private set; }

        public BotHealingBySomebody? HealReceiver { get; private set; }

        public BotHealAnotherTarget? SquadHealer { get; private set; }

        public FlashGrenadeComponent? FlashGrenade { get; private set; }

        public HearingDamageComponent? HearingDamage { get; private set; }

        public TrackedEnemyVisibility? VisibilityTracker { get; set; }

        public BotGroupSyncCoordinator? GroupSync => this.GroupBehavior?.GroupSync;

        public BotPanicHandler? Panic => this.PanicHandler;

        #endregion

        #region Properties

        /// <summary>
        /// Gets a value indicating whether the bot systems are ready.
        /// </summary>
        public bool IsReady =>
            this.Bot != null &&
            this.Movement != null &&
            this.Suppression != null &&
            this.PanicHandler != null &&
            this.Tactical != null &&
            this.FlashGrenade != null;

        #endregion

        #region Initialization

        /// <summary>
        /// Fully initializes the bot component cache and wires all AI subsystems.
        /// </summary>
        /// <param name="bot">The BotOwner instance.</param>
        public void Initialize(BotOwner bot)
        {
            if (bot == null)
            {
                throw new ArgumentNullException(nameof(bot));
            }

            this.Bot = bot;

            this.FlashGrenade = new FlashGrenadeComponent();
            this.FlashGrenade.Initialize(this);

            this.PanicHandler = new BotPanicHandler();
            this.PanicHandler.Initialize(this);

            this.Suppression = new BotSuppressionReactionComponent();
            this.Suppression.Initialize(this);

            this.Escalation = new BotThreatEscalationMonitor();
            this.Escalation.Initialize(bot);

            this.GroupBehavior = new BotGroupBehavior();
            this.GroupBehavior.Initialize(this);

            this.Movement = new BotMovementController();
            this.Movement.Initialize(this);

            this.Tactical = new BotTacticalDeviceController();
            this.Tactical.Initialize(this);

            this.HearingDamage = new HearingDamageComponent();

            this.Combat = new CombatStateMachine();
            this.Combat.Initialize(this);

            this.Tilt = new BotTilt(bot);

            this.Pathing = new BotOwnerPathfindingCache();

            this.SquadPath = new SquadPathCoordinator();
            this.SquadPath.Initialize(this);

            this.TacticalMemory = new BotTacticalMemory();
            this.TacticalMemory.Initialize(this);

            this.LootScanner = new BotLootScanner();
            this.LootScanner.Initialize(this);

            this.DeadBodyScanner = new BotDeadBodyScanner();
            this.DeadBodyScanner.Initialize(this);

            this.DoorOpener = new BotDoorOpener(bot);

            this.ThreatSelector = new BotThreatSelector(this);
            this.InjurySystem = new BotInjurySystem(this);
            this.LastShotTracker = new BotLastShotTracker();
            this.GroupComms = new BotGroupComms(this);

            this.SquadHealer = bot.HealAnotherTarget ?? new BotHealAnotherTarget(bot);
            this.HealReceiver = bot.HealingBySomebody ?? new BotHealingBySomebody(bot);

            Logger.LogDebug("[BotComponentCache] ✅ Initialized for bot: " + this.Nickname);
        }

        #endregion

        #region Runtime Helpers

        /// <summary>
        /// Clears transient runtime state like flash, audio, and tactical memory.
        /// </summary>
        public void Reset()
        {
            this.IsBlinded = false;
            this.BlindUntilTime = 0f;
            this.LastFlashTime = 0f;
            this.LastHeardTime = -999f;
            this.LastHeardDirection = null;
            this.VisibilityTracker = null;

            if (this.Pathing != null)
            {
                this.Pathing.Clear();
            }

            if (this.TacticalMemory != null)
            {
                this.TacticalMemory.ClearAll();
            }
        }

        /// <summary>
        /// Registers a directional sound heard by the bot.
        /// </summary>
        /// <param name="source">The sound origin.</param>
        public void RegisterHeardSound(Vector3 source)
        {
            if (this.Bot != null && this.Bot.GetPlayer?.IsAI == true)
            {
                this.LastHeardTime = Time.time;
                this.LastHeardDirection = source - this.Position;
            }
        }

        /// <summary>
        /// Sets the AIRefactored wrapper owner for this bot.
        /// </summary>
        /// <param name="owner">The associated wrapper.</param>
        public void SetOwner(AIRefactoredBotOwner owner)
        {
            if (owner != null)
            {
                this.AIRefactoredBotOwner = owner;
            }
        }

        /// <summary>
        /// Returns true if the bot’s assigned personality passes a given test.
        /// </summary>
        /// <param name="predicate">The trait evaluator.</param>
        public bool HasPersonalityTrait(Func<BotPersonalityProfile, bool> predicate)
        {
            return this.AIRefactoredBotOwner != null &&
                   this.AIRefactoredBotOwner.PersonalityProfile != null &&
                   predicate(this.AIRefactoredBotOwner.PersonalityProfile);
        }

        /// <summary>
        /// Logs debug info about current runtime flags and subsystems.
        /// </summary>
        public void DebugPrint()
        {
            Logger.LogInfo(
                "[BotComponentCache] " + this.Nickname +
                " | Ready=" + this.IsReady +
                " | Blinded=" + this.IsBlinded +
                " | Heard=" + this.LastHeardTime.ToString("F2") + "s ago");
        }

        #endregion
    }
}
