// <auto-generated>
//   This file is part of AI-Refactored, an open-source project focused on realistic AI behavior in Escape from Tarkov.
//   Licensed under the MIT License. See LICENSE in the repository root for more information.
//
//   THIS FILE IS SYSTEMATICALLY MANAGED.
//   Please follow strict StyleCop, ReSharper, and AI-Refactored code standards for all modifications.
// </auto-generated>

#nullable enable

namespace AIRefactored.AI.Core
{
    using System;
    using AIRefactored.AI.Combat;
    using AIRefactored.AI.Components;
    using AIRefactored.AI.Groups;
    using AIRefactored.AI.Looting;
    using AIRefactored.AI.Medical;
    using AIRefactored.AI.Memory;
    using AIRefactored.AI.Movement;
    using AIRefactored.AI.Optimization;
    using AIRefactored.AI.Perception;
    using AIRefactored.AI.Reactions;
    using AIRefactored.Runtime;
    using BepInEx.Logging;
    using EFT;
    using UnityEngine;

    /// <summary>
    /// Runtime container for all bot-specific AIRefactored logic systems.
    /// Attached to each bot during initialization.
    /// </summary>
    public sealed class BotComponentCache : MonoBehaviour
    {
        private static readonly ManualLogSource Logger = AIRefactoredController.Logger;

        #region Core References

        public BotOwner? Bot { get; internal set; }
        public AIRefactoredBotOwner? AIRefactoredBotOwner { get; private set; }
        public BotMemoryClass? Memory => this.Bot?.Memory;
        public string Nickname => this.Bot?.Profile?.Info?.Nickname ?? "Unknown";
        public Vector3 Position => this.Bot?.Position ?? Vector3.zero;

        #endregion

        #region Runtime Flags

        public bool IsBlinded { get; set; }
        public float BlindUntilTime { get; set; }
        public float LastFlashTime { get; set; }
        public float LastHeardTime { get; private set; } = -999f;
        public Vector3? LastHeardDirection { get; private set; }

        #endregion

        #region AI Subsystems

        public CombatStateMachine? Combat { get; private set; }
        public BotMovementController? Movement { get; private set; }
        public BotPoseController? PoseController { get; set; }
        public BotTilt? Tilt { get; private set; }
        public BotTacticalDeviceController? Tactical { get; private set; }
        public BotGroupBehavior? GroupBehavior { get; private set; }
        public BotThreatSelector? ThreatSelector { get; private set; }
        public BotTacticalMemory? TacticalMemory { get; private set; }
        public BotLastShotTracker? LastShotTracker { get; private set; }
        public BotGroupComms? GroupComms { get; private set; }
        public BotSuppressionReactionComponent? Suppression { get; private set; }
        public BotPanicHandler? PanicHandler { get; private set; }
        public BotThreatEscalationMonitor? Escalation { get; private set; }
        public BotInjurySystem? InjurySystem { get; private set; }
        public BotDeadBodyScanner? DeadBodyScanner { get; private set; }
        public BotLootScanner? LootScanner { get; private set; }
        public BotOwnerPathfindingCache? Pathing { get; private set; }
        public SquadPathCoordinator? SquadPath { get; private set; }
        public BotDoorOpener? DoorOpener { get; private set; }
        public BotHealingBySomebody? HealReceiver { get; private set; }
        public BotHealAnotherTarget? SquadHealer { get; private set; }
        public FlashGrenadeComponent? FlashGrenade { get; private set; }
        public HearingDamageComponent? HearingDamage { get; private set; }
        public TrackedEnemyVisibility? VisibilityTracker { get; set; }

        public BotGroupSyncCoordinator? GroupSync => this.GroupBehavior?.GroupSync;
        public BotPanicHandler? Panic => this.PanicHandler;

        #endregion

        #region Properties

        public bool IsReady =>
            this.Bot != null &&
            this.Movement != null &&
            this.Suppression != null &&
            this.PanicHandler != null &&
            this.Tactical != null &&
            this.FlashGrenade != null;

        #endregion

        #region Initialization
        public void Initialize(BotOwner bot)
        {
            if (bot == null)
            {
                throw new ArgumentNullException(nameof(bot));
            }

            // Prevent redundant initialization
            if (this.Bot != null)
            {
                Logger.LogWarning("[BotComponentCache] Already initialized for bot " + bot.Profile?.Id);
                return;
            }

            this.Bot = bot;

            try
            {
                // Initialize Pathing Cache and Tactical Memory
                this.Pathing = new BotOwnerPathfindingCache();
                this.TacticalMemory = new BotTacticalMemory();
                this.TacticalMemory.Initialize(this);

                // Safely initialize subsystems, ensuring no recursion or redundant calls.
                this.TryInitSubsystem(nameof(CombatStateMachine), () =>
                {
                    if (this.Combat == null)  // Check if CombatStateMachine is already initialized
                    {
                        this.Combat = new CombatStateMachine();
                        this.Combat.Initialize(this);
                    }
                }, this.TacticalMemory);

                this.TryInitSubsystem(nameof(FlashGrenadeComponent), () =>
                {
                    if (this.FlashGrenade == null)  // Check if FlashGrenadeComponent is already initialized
                    {
                        this.FlashGrenade = new FlashGrenadeComponent();
                        this.FlashGrenade.Initialize(this);
                    }
                });

                this.TryInitSubsystem(nameof(BotPanicHandler), () =>
                {
                    if (this.PanicHandler == null)  // Check if PanicHandler is already initialized
                    {
                        this.PanicHandler = new BotPanicHandler();
                        this.PanicHandler.Initialize(this);
                    }
                });

                this.TryInitSubsystem(nameof(BotSuppressionReactionComponent), () =>
                {
                    if (this.Suppression == null)  // Check if SuppressionComponent is already initialized
                    {
                        this.Suppression = new BotSuppressionReactionComponent();
                        this.Suppression.Initialize(this);
                    }
                });

                this.TryInitSubsystem(nameof(BotThreatEscalationMonitor), () =>
                {
                    if (this.Escalation == null)  // Check if Escalation is already initialized
                    {
                        this.Escalation = new BotThreatEscalationMonitor();
                        this.Escalation.Initialize(bot);
                    }
                });

                this.TryInitSubsystem(nameof(BotGroupBehavior), () =>
                {
                    if (this.GroupBehavior == null)  // Check if GroupBehavior is already initialized
                    {
                        this.GroupBehavior = new BotGroupBehavior();
                        this.GroupBehavior.Initialize(this);
                    }
                }, this.PanicHandler);

                // Ensure systems are always initialized, regardless of headless mode
                this.TryInitSubsystem(nameof(BotMovementController), () =>
                {
                    if (this.Movement == null)  // Check if MovementController is already initialized
                    {
                        this.Movement = new BotMovementController();
                        this.Movement.Initialize(this);
                    }
                });

                this.TryInitSubsystem(nameof(BotTacticalDeviceController), () =>
                {
                    if (this.Tactical == null)  // Check if Tactical is already initialized
                    {
                        this.Tactical = new BotTacticalDeviceController();
                        this.Tactical.Initialize(this);
                    }
                });

                // Fix for BotPoseController to pass BotOwner and BotComponentCache
                if (this.PoseController == null)  // Check if PoseController is already initialized
                {
                    this.PoseController = new BotPoseController(bot, this);  // Corrected constructor call
                }

                // Initialize non-Unity components regardless of headless mode
                if (this.HearingDamage == null)
                {
                    this.HearingDamage = new HearingDamageComponent();
                }

                if (this.Tilt == null)
                {
                    this.Tilt = new BotTilt(bot);
                }

                // Initialize SquadPath, LootScanner, DeadBodyScanner, DoorOpener, and other components
                this.SquadPath = new SquadPathCoordinator();
                this.SquadPath.Initialize(this);

                this.LootScanner = new BotLootScanner();
                this.LootScanner.Initialize(this);

                this.DeadBodyScanner = new BotDeadBodyScanner();
                this.DeadBodyScanner.Initialize(this);

                this.DoorOpener = new BotDoorOpener(bot);

                this.InjurySystem = new BotInjurySystem(this);
                this.LastShotTracker = new BotLastShotTracker();
                this.GroupComms = new BotGroupComms(this);

                this.SquadHealer = bot.HealAnotherTarget ?? new BotHealAnotherTarget(bot);
                this.HealReceiver = bot.HealingBySomebody ?? new BotHealingBySomebody(bot);

                Logger.LogDebug("[BotComponentCache] ✅ Initialized for bot: " + this.Nickname);
            }
            catch (Exception ex)
            {
                Logger.LogError("[BotComponentCache] ❌ Full initialization failed for bot " + bot.Profile?.Id + ": " + ex.Message + "\n" + ex.StackTrace);
                throw;
            }
        }

        private void TryInitSubsystem(string name, Action init, params object?[] required)
        {
            for (int i = 0; i < required.Length; i++)
            {
                if (required[i] == null)
                {
                    throw new InvalidOperationException("[BotComponentCache] " + name + " initialization failed — missing required dependency.");
                }
            }

            init.Invoke();
        }

        #endregion

        // SetOwner implementation
        public void SetOwner(AIRefactoredBotOwner owner)
        {
            if (owner == null)
            {
                return;
            }

            this.AIRefactoredBotOwner = owner;

            if (this.ThreatSelector == null)
            {
                this.ThreatSelector = new BotThreatSelector(this);
            }
        }

        // RegisterHeardSound implementation
        public void RegisterHeardSound(Vector3 source)
        {
            if (this.Bot != null && this.Bot.GetPlayer != null && this.Bot.GetPlayer.IsAI)
            {
                // Log the sound registration
                Logger.LogDebug($"[BotSoundRegistry] Sound registered from source: {source}");

                // Store the sound position and direction if needed
                this.LastHeardTime = Time.time;
                this.LastHeardDirection = source - this.Position;

                // Optionally, add more logic such as sound memory or AI responses
            }
            else
            {
                Logger.LogWarning("[BotSoundRegistry] Sound registration failed - Bot or Player not valid.");
            }
        }
    }
}
