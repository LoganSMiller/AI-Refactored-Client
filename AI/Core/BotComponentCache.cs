// <auto-generated>
//   AI-Refactored: BotComponentCache.cs (Supreme Arbitration Overlay/Event Edition – June 2025)
//   Hardened: strict single init, owner wiring guards, concurrency-safe, no overwrite, error-isolated subsystems, safe teardown, zero alloc, multiplayer/headless safe.
//   MIT License.
// </auto-generated>

namespace AIRefactored.AI.Core
{
    using System;
    using System.Collections.Generic;
    using AIRefactored.AI.Combat;
    using AIRefactored.AI.Combat.States;
    using AIRefactored.AI.Groups;
    using AIRefactored.AI.Helpers;
    using AIRefactored.AI.Looting;
    using AIRefactored.AI.Medical;
    using AIRefactored.AI.Memory;
    using AIRefactored.AI.Missions.Subsystems;
    using AIRefactored.AI.Movement;
    using AIRefactored.AI.Navigation;
    using AIRefactored.AI.Optimization;
    using AIRefactored.AI.Perception;
    using AIRefactored.AI.Reactions;
    using AIRefactored.Core;
    using AIRefactored.Pools;
    using AIRefactored.Runtime;
    using BepInEx.Logging;
    using EFT;
    using UnityEngine;

    public sealed class BotComponentCache : IDisposable
    {
        public static readonly BotComponentCache Empty = new BotComponentCache();

        private static readonly ManualLogSource Logger = Plugin.LoggerInstance;
        private static readonly object StaticLock = new object();
        private static readonly HashSet<string> InitializedBots = new HashSet<string>(StringComparer.OrdinalIgnoreCase);

        private AIRefactoredBotOwner _owner;
        private FallbackHandler _fallbackHandler;
        private BotMovementOverlayController _movementOverlayController;
        private bool _disposed;

        public BotOwner Bot { get; private set; }
        public AIRefactoredBotOwner AIRefactoredBotOwner => _owner;
        public BotPersonalityProfile PersonalityProfile { get; private set; } = new BotPersonalityProfile();
        public string Nickname => Bot?.Profile?.Info?.Nickname ?? "Unknown";
        public BotMemoryClass Memory => Bot?.Memory;
        public Vector3 Position => Bot != null ? Bot.Position : Vector3.zero;

        public bool IsBlinded { get; set; }
        public float BlindUntilTime { get; set; }
        public float LastFlashTime { get; set; }
        public float LastHeardTime { get; private set; } = -999f;
        public Vector3 LastHeardDirection { get; private set; }
        public bool HasHeardDirection { get; private set; }
        public BotMoveCache MoveCache { get; } = new BotMoveCache();

        public CombatStateMachine Combat { get; private set; }
        public BotMovementController Movement { get; private set; }
        public BotPoseController PoseController { get; private set; }
        public BotLookController Look { get; private set; }
        public BotTilt Tilt { get; private set; }
        public BotTacticalDeviceController Tactical { get; private set; }
        public BotGroupBehavior GroupBehavior { get; private set; }
        public BotThreatSelector ThreatSelector { get; private set; }
        public BotTacticalMemory TacticalMemory { get; private set; }
        public BotLastShotTracker LastShotTracker { get; private set; }
        public BotGroupComms GroupComms { get; private set; }
        public BotSuppressionReactionComponent Suppression { get; private set; }
        public BotPanicHandler PanicHandler { get; private set; }
        public BotThreatEscalationMonitor Escalation { get; private set; }
        public BotInjurySystem InjurySystem { get; private set; }
        public BotDeadBodyScanner DeadBodyScanner { get; private set; }
        public BotLootScanner LootScanner { get; private set; }
        public BotLootDecisionSystem LootDecisionSystem { get; private set; }
        public SquadPathCoordinator SquadPath { get; private set; }
        public BotDoorInteractionSystem DoorInteraction { get; private set; }
        public BotHealingBySomebody HealReceiver { get; private set; }
        public BotHealAnotherTarget SquadHealer { get; private set; }
        public FlashGrenadeComponent FlashGrenade { get; private set; }
        public HearingDamageComponent HearingDamage { get; private set; }
        public TrackedEnemyVisibility VisibilityTracker { get; set; }
        public BotPerceptionSystem Perception { get; private set; }
        public BotCoverRetreatPlanner CoverPlanner { get; private set; }
        public MissionEvaluator MissionEvaluator { get; private set; }

        public BotGroupSyncCoordinator GroupSync => GroupBehavior?.GroupSync;
        public FallbackHandler Fallback => _fallbackHandler;
        public BotPanicHandler Panic => PanicHandler;
        public BotMovementOverlayController MovementOverlayController => _movementOverlayController;

        public bool IsReady =>
            Bot != null && Movement != null && Suppression != null &&
            PanicHandler != null && Tactical != null && FlashGrenade != null &&
            ThreatSelector != null && _owner != null && LootScanner != null &&
            LootDecisionSystem != null && GroupComms != null &&
            GroupBehavior != null && Look != null && _movementOverlayController != null &&
            !_disposed;

        public void Initialize(BotOwner bot)
        {
            if (bot == null)
            {
                Logger.LogError("[BotComponentCache] Initialize called with null bot.");
                return;
            }

            string id = bot.Profile?.Id ?? "null";

            lock (StaticLock)
            {
                if (Bot != null)
                    return;

                if (InitializedBots.Contains(id))
                {
                    Logger.LogDebug($"[BotComponentCache] Bot {id} already initialized, skipping.");
                    return;
                }

                InitializedBots.Add(id);
            }

            Bot = bot;

            TryEnsureOwner(bot);
            TryEnsurePersonality(bot);

            TryInit(() => MissionEvaluator = new MissionEvaluator(bot, this), nameof(MissionEvaluator));
            TryInit(() => { TacticalMemory = new BotTacticalMemory(); TacticalMemory.Initialize(this); }, nameof(TacticalMemory));
            TryInit(() => _fallbackHandler = new FallbackHandler(this), nameof(FallbackHandler));
            TryInit(() => { Combat = new CombatStateMachine(); Combat.Initialize(this); }, nameof(Combat));
            TryInit(() => { FlashGrenade = new FlashGrenadeComponent(); FlashGrenade.Initialize(this); }, nameof(FlashGrenade));
            TryInit(() => { PanicHandler = new BotPanicHandler(); PanicHandler.Initialize(this); }, nameof(PanicHandler));
            TryInit(() => { Suppression = new BotSuppressionReactionComponent(); Suppression.Initialize(this); }, nameof(Suppression));
            TryInit(() => { Escalation = new BotThreatEscalationMonitor(); Escalation.Initialize(bot); }, nameof(Escalation));
            TryInit(() => { GroupBehavior = new BotGroupBehavior(); GroupBehavior.Initialize(this); }, nameof(GroupBehavior));
            TryInit(() => { Movement = new BotMovementController(); Movement.Initialize(this); }, nameof(Movement));
            TryInit(() => Look = new BotLookController(bot, this), nameof(Look));
            TryInit(() => { Tactical = new BotTacticalDeviceController(); Tactical.Initialize(this); }, nameof(Tactical));
            TryInit(() => PoseController = new BotPoseController(bot, this), nameof(PoseController));
            TryInit(() => Tilt = new BotTilt(bot), nameof(Tilt));
            TryInit(() => HearingDamage = new HearingDamageComponent(), nameof(HearingDamage));
            TryInit(() => { SquadPath = new SquadPathCoordinator(); SquadPath.Initialize(this); }, nameof(SquadPath));
            TryInit(() => { LootScanner = new BotLootScanner(); LootScanner.Initialize(this); }, nameof(LootScanner));
            TryInit(() => { LootDecisionSystem = new BotLootDecisionSystem(); LootDecisionSystem.Initialize(this); }, nameof(LootDecisionSystem));
            TryInit(() => { DeadBodyScanner = new BotDeadBodyScanner(); DeadBodyScanner.Initialize(this); }, nameof(DeadBodyScanner));
            TryInit(() => DoorInteraction = new BotDoorInteractionSystem(bot), nameof(DoorInteraction));
            TryInit(() => InjurySystem = new BotInjurySystem(this), nameof(InjurySystem));
            TryInit(() => LastShotTracker = new BotLastShotTracker(), nameof(LastShotTracker));
            TryInit(() => GroupComms = new BotGroupComms(this), nameof(GroupComms));
            TryInit(() => SquadHealer = bot.HealAnotherTarget ?? new BotHealAnotherTarget(bot), nameof(SquadHealer));
            TryInit(() => HealReceiver = bot.HealingBySomebody ?? new BotHealingBySomebody(bot), nameof(HealReceiver));
            TryInit(() => ThreatSelector = new BotThreatSelector(this), nameof(ThreatSelector));
            TryInit(() => { Perception = new BotPerceptionSystem(); Perception.Initialize(this); }, nameof(Perception));
            TryInit(() => CoverPlanner = new BotCoverRetreatPlanner(bot), nameof(CoverPlanner));
            TryInit(() => _movementOverlayController = new BotMovementOverlayController(this), nameof(MovementOverlayController));

            _disposed = false;
        }

        private void TryEnsureOwner(BotOwner bot)
        {
            if (_owner != null && _owner.IsInitialized)
                return;

            try
            {
                _owner = bot.GetComponent<AIRefactoredBotOwner>();
                if (_owner == null)
                {
                    _owner = new AIRefactoredBotOwner();
                    Logger.LogDebug($"[BotComponentCache] Created AIRefactoredBotOwner for bot {bot.Profile?.Id ?? "null"}");
                }
                SetOwner(_owner);

                if (!_owner.IsInitialized)
                    _owner.Initialize(bot);
            }
            catch (Exception ex)
            {
                Logger.LogError($"[BotComponentCache] Failed to ensure AIRefactoredBotOwner: {ex}");
            }
        }

        private void TryEnsurePersonality(BotOwner bot)
        {
            if (PersonalityProfile != null && !ReferenceEquals(PersonalityProfile, BotPersonalityProfile.Default))
                return;

            string id = bot.Profile?.Id ?? "null";
            WildSpawnType role = bot.Profile?.Info?.Settings?.Role ?? WildSpawnType.assault;

            try
            {
                PersonalityProfile = BotRegistry.GetOrGenerate(id, PersonalityType.Balanced, role);
            }
            catch (Exception ex)
            {
                Logger.LogError($"[BotComponentCache] Failed to ensure personality: {ex}");
                PersonalityProfile = BotPersonalityProfile.Default;
            }
        }

        private void TryInit(Action init, string label)
        {
            try
            {
                init();
            }
            catch (Exception ex)
            {
                Logger.LogError($"[BotComponentCache] Subsystem {label} failed: {ex}");
            }
        }

        public void SetOwner(AIRefactoredBotOwner owner)
        {
            if (owner == null)
            {
                Logger.LogError("[BotComponentCache] SetOwner() called with null.");
                return;
            }

            if (_owner != null && ReferenceEquals(_owner, owner))
                return;

            if (_owner != null && !ReferenceEquals(_owner, owner))
            {
                Logger.LogWarning("[BotComponentCache] SetOwner() attempted to overwrite existing owner.");
                return;
            }

            _owner = owner;
        }

        public void RegisterHeardSound(Vector3 source)
        {
            if (Bot == null) return;
            LastHeardTime = Time.time;
            LastHeardDirection = source - Position;
            HasHeardDirection = true;
        }

        public void Dispose()
        {
            if (_disposed)
                return;

            try
            {
                _fallbackHandler?.Dispose();
                BotOverlayManager.ForceClear(Bot);
            }
            catch (Exception ex)
            {
                Logger.LogWarning("[BotComponentCache] Dispose failed: " + ex);
            }

            _fallbackHandler = null;
            _disposed = true;
        }
    }
}
