// <auto-generated>
//   This file is part of AI-Refactored, an open-source project focused on realistic AI behavior in Escape from Tarkov.
//   Licensed under the MIT License. See LICENSE in the repository root for more information.
//
//   THIS FILE IS SYSTEMATICALLY MANAGED.
//   Please follow strict StyleCop, ReSharper, and AI-Refactored code standards for all modifications.
// </auto-generated>

#nullable enable

namespace AIRefactored.AI.Threads
{
    using System;
    using System.Reflection;
    using AIRefactored.AI.Core;
    using AIRefactored.Core;
    using AIRefactored.Runtime;
    using BepInEx.Logging;
    using HarmonyLib;
    using UnityEngine;

    /// <summary>
    /// Scans bot GameObjects for unauthorized logic and removes all non-AIRefactored MonoBehaviours.
    /// Prevents logic injection by external mods or Harmony patches.
    /// Only runs on the authoritative host (headless, local-host, or client-host).
    /// </summary>
    public static class BotBrainGuardian
    {
        #region Logger

        private static readonly ManualLogSource Logger = AIRefactoredController.Logger;

        #endregion

        #region Public API

        /// <summary>
        /// Enforces AIRefactored control by destroying any foreign brain logic on the given GameObject.
        /// </summary>
        /// <param name="botGameObject">The bot GameObject to sanitize.</param>
        public static void Enforce(GameObject botGameObject)
        {
            // Skip enforcement on non-authoritative clients
            if (!GameWorldHandler.IsInitialized || !GameWorldHandler.IsLocalHost())
            {
                return;
            }

            if (botGameObject == null)
            {
                return;
            }

            MonoBehaviour[] components = botGameObject.GetComponents<MonoBehaviour>();
            if (components == null || components.Length == 0)
            {
                return;
            }

            for (int i = 0; i < components.Length; i++)
            {
                MonoBehaviour comp = components[i];
                if (comp == null)
                {
                    continue;
                }

                Type? type = comp.GetType();
                if (type == null)
                {
                    continue;
                }

                string name = type.Name.ToLowerInvariant();
                string ns = type.Namespace != null ? type.Namespace.ToLowerInvariant() : string.Empty;

                // Whitelist known AIRefactored core components
                if (type == typeof(BotBrain) || type == typeof(BotComponentCache))
                {
                    continue;
                }

                // Allow Unity/EFT native components
                if (IsSafeComponent(ns))
                {
                    continue;
                }

                // Remove foreign or patched components
                if (IsConflictingBrain(name, ns) || IsHarmonyPatched(type) || HasSuspiciousMethods(type))
                {
                    UnityEngine.Object.Destroy(comp);
                    Logger.LogWarning(
                        "[BotBrainGuardian] ⚠ Removed unauthorized AI component: "
                        + type.FullName + " from GameObject: " + botGameObject.name);
                }
            }
        }

        #endregion

        #region Internal Checks

        private static bool IsSafeComponent(string ns)
        {
            return ns.StartsWith("unity", StringComparison.Ordinal)
                || ns.StartsWith("eft", StringComparison.Ordinal)
                || ns.Contains("comfort");
        }

        private static bool IsConflictingBrain(string name, string ns)
        {
            return name.Contains("brain")
                || name.StartsWith("pmc")
                || name.StartsWith("spt")
                || name.StartsWith("lua")
                || name.StartsWith("boss")
                || name.StartsWith("follower")
                || name.StartsWith("assault")
                || name.StartsWith("exusec")
                || ns.Contains("sain")
                || ns.Contains("mod")
                || ns.Contains("spt")
                || ns.Contains("lua")
                || !ns.Contains("tarkov"); // suspicious if not in EFT or Comfort or Tarkov space
        }

        private static bool IsHarmonyPatched(Type type)
        {
            MethodInfo? updateMethod = type.GetMethod(
                "Update",
                BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic);

            return updateMethod != null && Harmony.GetPatchInfo(updateMethod) != null;
        }

        private static bool HasSuspiciousMethods(Type type)
        {
            string[] suspicious = { "Update", "LateUpdate", "FixedUpdate", "Tick" };

            for (int i = 0; i < suspicious.Length; i++)
            {
                MethodInfo? m = type.GetMethod(
                    suspicious[i],
                    BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic);

                if (m != null && m.DeclaringType != typeof(MonoBehaviour))
                {
                    return true;
                }
            }

            return false;
        }

        #endregion
    }
}
