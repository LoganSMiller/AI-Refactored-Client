// <auto-generated>
//   This file is part of AI-Refactored, an open-source project focused on realistic AI behavior in Escape from Tarkov.
//   Licensed under the MIT License. See LICENSE in the repository root for more information.
//
//   THIS FILE IS SYSTEMATICALLY MANAGED.
//   Please follow strict StyleCop, ReSharper, and AI-Refactored code standards for all modifications.
// </auto-generated>

#nullable enable

namespace AIRefactored.AI.Threads
{
    using System;
    using System.Reflection;
    using AIRefactored.AI.Core;
    using AIRefactored.Core;
    using AIRefactored.Runtime;
    using BepInEx.Logging;
    using HarmonyLib;
    using UnityEngine;

    /// <summary>
    /// Scans bot GameObjects for unauthorized logic and removes all non-AIRefactored MonoBehaviours.
    /// Prevents logic injection by external mods or Harmony patches.
    /// Only runs on the authoritative host (headless, local-host, or client-host).
    /// </summary>
    public static class BotBrainGuardian
    {
        private static readonly ManualLogSource Logger = AIRefactoredController.Logger;

        /// <summary>
        /// Enforces AIRefactored control by destroying any foreign MonoBehaviours on the bot GameObject.
        /// </summary>
        /// <param name="botGameObject">The bot GameObject to sanitize.</param>
        public static void Enforce(GameObject botGameObject)
        {
            if (botGameObject == null || !GameWorldHandler.IsLocalHost())
            {
                return;
            }

            MonoBehaviour[] components = botGameObject.GetComponents<MonoBehaviour>();
            if (components == null || components.Length == 0)
            {
                return;
            }

            foreach (MonoBehaviour component in components)
            {
                if (component == null)
                {
                    continue;
                }

                Type type = component.GetType();
                if (type == typeof(BotBrain) || type == typeof(BotComponentCache))
                {
                    continue;
                }

                string typeName = type.Name.ToLowerInvariant();
                string ns = type.Namespace?.ToLowerInvariant() ?? string.Empty;

                if (IsUnityOrEftSafe(typeName, ns))
                {
                    continue;
                }

                if (IsConflictingBrain(typeName, ns) || IsHarmonyPatched(type) || HasSuspiciousMethods(type))
                {
                    UnityEngine.Object.Destroy(component);
                    Logger.LogWarning("[BotBrainGuardian] ⚠ Removed unauthorized AI logic: " + type.FullName + " from: " + botGameObject.name);
                }
            }
        }

        private static bool IsUnityOrEftSafe(string name, string ns)
        {
            return name == "fullbodybipedik"
                || name == "charactercontrollerspawner"
                || name == "coopbot"
                || name == "simplecharactercontroller"
                || name == "triggercollidersearcher"
                || name == "botpacketsender"
                || name == "botfirearmcontroller"
                || ns.StartsWith("unity", StringComparison.Ordinal)
                || ns.StartsWith("eft", StringComparison.Ordinal)
                || ns.Contains("comfort");
        }

        private static bool IsConflictingBrain(string name, string ns)
        {
            return name.Contains("brain")
                || name.StartsWith("pmc", StringComparison.Ordinal)
                || name.StartsWith("spt", StringComparison.Ordinal)
                || name.StartsWith("lua", StringComparison.Ordinal)
                || name.StartsWith("boss", StringComparison.Ordinal)
                || name.StartsWith("follower", StringComparison.Ordinal)
                || name.StartsWith("assault", StringComparison.Ordinal)
                || name.StartsWith("exusec", StringComparison.Ordinal)
                || ns.Contains("sain")
                || ns.Contains("mod")
                || ns.Contains("spt")
                || ns.Contains("lua")
                || (!ns.Contains("tarkov") && !ns.Contains("ai-refactored"));
        }

        private static bool IsHarmonyPatched(Type type)
        {
            try
            {
                MethodInfo? updateMethod = type.GetMethod("Update", BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic);
                return updateMethod != null && Harmony.GetPatchInfo(updateMethod) != null;
            }
            catch
            {
                return false;
            }
        }

        private static bool HasSuspiciousMethods(Type type)
        {
            string[] suspicious = { "Update", "LateUpdate", "FixedUpdate", "Tick" };

            foreach (var methodName in suspicious)
            {
                MethodInfo? method = type.GetMethod(
                    methodName,
                    BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic);

                if (method != null && method.DeclaringType != typeof(MonoBehaviour))
                {
                    return true;
                }
            }

            return false;
        }
    }
}
