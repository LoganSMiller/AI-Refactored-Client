// <auto-generated>
//   AI-Refactored: BotOverlayManager.cs (Human Arbitration Edition, June 2025)
//   Single-overlay arbitration, zero artificial cooldown. Only prevents simultaneous overlay collisions.
//   Bulletproof, pooled, multiplayer/headless/client safe. MIT License.
// </auto-generated>

namespace AIRefactored.AI.Core
{
    using System.Collections.Generic;
    using AIRefactored.Pools;
    using EFT;
    using UnityEngine;

    /// <summary>
    /// Central overlay arbitration for all overlay/event-driven bot moves.
    /// Ensures no simultaneous overlay/event intent can issue a move for a bot.
    /// No cooldown: only arbitration for realism. Fully pooled, bulletproof, multiplayer/headless safe.
    /// </summary>
    public static class BotOverlayManager
    {
        #region Static Pool and State

        // Per-bot overlay lock state: only one overlay/event can issue a move at a time
        private static readonly Dictionary<BotOwner, OverlayActiveState> _overlayStates =
            TempDictionaryPool.Rent<BotOwner, OverlayActiveState>();

        #endregion

        #region Public API

        /// <summary>
        /// Returns true if *any* overlay is currently holding the move slot for this bot.
        /// </summary>
        public static bool IsAnyOverlayActive(BotOwner bot)
        {
            if (bot == null) return false;
            OverlayActiveState state;
            return _overlayStates.TryGetValue(bot, out state) && state != null && state.IsActive;
        }

        /// <summary>
        /// Can this overlay type issue a move for this bot right now? (no other overlay/event is active)
        /// </summary>
        public static bool CanIssueMove(BotOwner bot, BotOverlayType overlayType)
        {
            if (bot == null) return false;
            OverlayActiveState state;
            if (!_overlayStates.TryGetValue(bot, out state))
                return true; // No active overlay, so allowed
            return !state.IsActive || state.HolderType == overlayType;
        }

        /// <summary>
        /// Registers an overlay type as the active intent for this bot. Call *after* a successful move.
        /// </summary>
        public static void RegisterMove(BotOwner bot, BotOverlayType overlayType)
        {
            if (bot == null) return;
            OverlayActiveState state;
            if (!_overlayStates.TryGetValue(bot, out state))
            {
                state = TempOverlayActiveStatePool.Rent();
                _overlayStates[bot] = state;
            }
            state.IsActive = true;
            state.HolderType = overlayType;
        }

        /// <summary>
        /// Releases the current overlay lock for this bot (should be called at end of overlay/event tick, or before next intent).
        /// </summary>
        public static void ReleaseMove(BotOwner bot, BotOverlayType overlayType)
        {
            if (bot == null) return;
            OverlayActiveState state;
            if (_overlayStates.TryGetValue(bot, out state))
            {
                if (state.HolderType == overlayType)
                {
                    state.IsActive = false;
                    state.HolderType = BotOverlayType.None;
                }
            }
        }

        /// <summary>
        /// Forcibly clears all overlay locks for a bot (for teardown/recovery).
        /// </summary>
        public static void ForceClear(BotOwner bot)
        {
            if (bot == null) return;
            OverlayActiveState state;
            if (_overlayStates.TryGetValue(bot, out state))
            {
                TempOverlayActiveStatePool.Return(state);
                _overlayStates.Remove(bot);
            }
        }

        /// <summary>
        /// Full world teardown. Releases all overlay lock states to pool.
        /// </summary>
        public static void ClearAll()
        {
            foreach (var kvp in _overlayStates)
                TempOverlayActiveStatePool.Return(kvp.Value);
            _overlayStates.Clear();
        }

        /// <summary>
        /// Returns true if the specified overlay type is active for this bot (arbitration/lock check).
        /// </summary>
        public static bool HasActiveOverlay(BotOwner bot, BotOverlayType overlayType)
        {
            if (bot == null) return false;
            OverlayActiveState state;
            if (_overlayStates.TryGetValue(bot, out state) && state != null && state.IsActive)
            {
                return state.HolderType == overlayType;
            }
            return false;
        }

        #endregion

        #region OverlayActiveState Pool

        private sealed class OverlayActiveState
        {
            public bool IsActive;
            public BotOverlayType HolderType;
            public void Reset()
            {
                IsActive = false;
                HolderType = BotOverlayType.None;
            }
        }

        private static class TempOverlayActiveStatePool
        {
            private static readonly Stack<OverlayActiveState> Pool = new Stack<OverlayActiveState>(32);
            public static OverlayActiveState Rent()
            {
                if (Pool.Count > 0) return Pool.Pop();
                return new OverlayActiveState();
            }
            public static void Return(OverlayActiveState s)
            {
                s.Reset();
                Pool.Push(s);
            }
        }

        #endregion
    }
}
