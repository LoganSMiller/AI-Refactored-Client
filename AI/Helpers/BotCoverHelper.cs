// <auto-generated>
//   This file is part of AI-Refactored, an open-source project focused on realistic AI behavior in Escape from Tarkov.
//   Licensed under the MIT License. See LICENSE in the repository root for more information.
//
//   THIS FILE IS SYSTEMATICALLY MANAGED.
//   Please follow strict StyleCop, ReSharper, and AI-Refactored code standards for all modifications.
// </auto-generated>

#nullable enable

namespace AIRefactored.AI.Helpers
{
    using System.Collections.Generic;
    using AIRefactored.AI.Core;
    using AIRefactored.AI.Movement;
    using AIRefactored.AI.Navigation;
    using EFT;
    using UnityEngine;

    /// <summary>
    /// Utility for scoring, checking, and tracking tactical cover positions.
    /// Supports memory cooldown, real cover posture analysis, and multiplayer-safe validation.
    /// </summary>
    public static class BotCoverHelper
    {
        #region Constants

        private const float MemoryDuration = 20f;
        private const float MaxValidDistanceSqr = 16f;

        #endregion

        #region Static Cache

        private static readonly Dictionary<string, float> CoverMemory = new Dictionary<string, float>(128);

        #endregion

        #region Cover Type Checks

        public static bool IsLowCover(CustomNavigationPoint? point) =>
            point != null && point.CoverLevel == CoverLevel.Sit;

        public static bool IsProneCover(CustomNavigationPoint? point) =>
            point != null && point.CoverLevel == CoverLevel.Lay;

        public static bool IsStandingCover(CustomNavigationPoint? point) =>
            point != null && point.CoverLevel == CoverLevel.Stay;

        public static bool IsLowCover(NavPointData point) =>
            point.IsCover && point.ElevationBand == "Mid";

        public static bool IsProneCover(NavPointData point) =>
            point.IsCover && point.ElevationBand == "Low";

        public static bool IsStandingCover(NavPointData point) =>
            point.IsCover && point.ElevationBand == "High";

        #endregion

        #region Cover Usage Tracking

        public static void MarkUsed(CustomNavigationPoint? point)
        {
            if (point != null)
            {
                CoverMemory[GetKey(point.Position)] = Time.time;
            }
        }

        public static void MarkUsed(NavPointData point)
        {
            CoverMemory[GetKey(point.Position)] = Time.time;
        }

        public static void MarkUsed(Vector3 position)
        {
            CoverMemory[GetKey(position)] = Time.time;
        }

        public static bool WasRecentlyUsed(CustomNavigationPoint? point)
        {
            return point != null &&
                   CoverMemory.TryGetValue(GetKey(point.Position), out float last) &&
                   Time.time - last < MemoryDuration;
        }

        public static bool WasRecentlyUsed(NavPointData point)
        {
            return CoverMemory.TryGetValue(GetKey(point.Position), out float last) &&
                   Time.time - last < MemoryDuration;
        }

        public static bool WasRecentlyUsed(Vector3 position)
        {
            return CoverMemory.TryGetValue(GetKey(position), out float last) &&
                   Time.time - last < MemoryDuration;
        }

        #endregion

        #region Pose Integration

        public static void TrySetStanceFromNearbyCover(BotComponentCache cache, Vector3 position)
        {
            if (cache == null || cache.PoseController == null)
            {
                return;
            }

            var nearbyPoints = NavPointRegistry.QueryNearby(
                position,
                4f,
                p => p.IsCover && p.DistanceSqr(position) <= MaxValidDistanceSqr);

            for (int i = 0; i < nearbyPoints.Count; i++)
            {
                NavPointData point = nearbyPoints[i];

                if (IsProneCover(point))
                {
                    cache.PoseController.SetProne(true);
                    return;
                }

                if (IsLowCover(point))
                {
                    cache.PoseController.SetCrouch(true);
                    return;
                }
            }
        }

        #endregion

        #region Cover Scoring

        public static float Score(CustomNavigationPoint point, Vector3 botPos, Vector3 threatPos)
        {
            float distToBot = Vector3.Distance(botPos, point.Position);
            float distToThreat = Vector3.Distance(threatPos, point.Position);
            float angle = Vector3.Angle(threatPos - point.Position, botPos - point.Position);

            float typeBonus = IsProneCover(point) ? 1.25f :
                              IsLowCover(point) ? 1.0f :
                              IsStandingCover(point) ? 0.85f : 0.5f;

            float threatFactor = Mathf.Clamp01(distToThreat / 20f);
            float angleFactor = Mathf.Clamp01(angle / 180f);
            float rawScore = typeBonus + threatFactor + angleFactor;

            return rawScore / (1f + distToBot * 0.15f);
        }

        public static float Score(NavPointData point, Vector3 botPos, Vector3 threatPos)
        {
            float distToBot = Vector3.Distance(botPos, point.Position);
            float distToThreat = Vector3.Distance(threatPos, point.Position);
            float angle = Vector3.Angle(threatPos - point.Position, botPos - point.Position);

            float typeBonus = IsProneCover(point) ? 1.25f :
                              IsLowCover(point) ? 1.0f :
                              IsStandingCover(point) ? 0.85f : 0.5f;

            float threatFactor = Mathf.Clamp01(distToThreat / 20f);
            float angleFactor = Mathf.Clamp01(angle / 180f);
            float rawScore = typeBonus + threatFactor + angleFactor;

            return rawScore / (1f + distToBot * 0.15f);
        }

        #endregion

        #region EFT-Aware Filtering

        public static bool IsValidCoverPoint(CustomNavigationPoint point, BotOwner bot, bool requireFree = true, bool preferIndoor = false)
        {
            if (requireFree && !point.IsFreeById(bot.Id))
            {
                return false;
            }

            if (point.IsSpotted)
            {
                return false;
            }

            if (preferIndoor && !point.IsGoodInsideBuilding)
            {
                return false;
            }

            return true;
        }

        #endregion

        #region Helpers

        private static string GetKey(Vector3 pos)
        {
            return Mathf.RoundToInt(pos.x) + "_" +
                   Mathf.RoundToInt(pos.y) + "_" +
                   Mathf.RoundToInt(pos.z);
        }

        #endregion
    }
}
