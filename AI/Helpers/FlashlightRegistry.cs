// <auto-generated>
//   AI-Refactored: FlashlightRegistry.cs (Supreme Arbitration Overlay/Event Edition, June 2025, Max Realism & Bulletproofed, Fully Expanded)
//   All bot/head positional queries must use only EFTPlayerUtil or approved AIRefactored helpers.
//   Bulletproof, pooled, overlay/event-only, never throws or disables. MIT License.
// </auto-generated>

namespace AIRefactored.AI.Helpers
{
    using System;
    using System.Collections.Generic;
    using AIRefactored.Core;
    using EFT;
    using UnityEngine;

    /// <summary>
    /// Tracks, scores, and exposes all active tactical flashlights in the scene.
    /// Used by AI for flashblindness, evasion, panic triggers, squad sync, tactical strobe detection, and suppression overlays.
    /// Bulletproof: errors are local, never break bot/system logic, overlay/event-only, multiplayer/headless safe.
    /// </summary>
    public static class FlashlightRegistry
    {
        #region Constants

        private const float AngleThreshold = 60f;
        private const float ExposureConeAngle = 35f;
        private const float EyeRayBias = 0.22f;
        private const float IntensityThreshold = 1.5f;
        private const float MaxExposureDistance = 28f;
        private const float PanicCloseExposureDistance = 5.8f;
        private const float PanicSquadExposureDistance = 8.0f;
        private const float BlindEventMemory = 2.7f;
        private const float MinStrobeFrequency = 8f;
        private const float MaxStrobeFrequency = 16f;
        private const float StrobeAmplitude = 1.5f;

        #endregion

        #region Static State

        private static readonly List<Light> ActiveLights = new List<Light>(32);
        private static readonly List<Vector3> LastKnownFlashPositions = new List<Vector3>(32);
        private static readonly Dictionary<string, float> LastBlindTime = new Dictionary<string, float>(64);

        // Strobe detection state (light instance id → time, intensity).
        private static readonly Dictionary<int, StrobeTracker> StrobeStates = new Dictionary<int, StrobeTracker>(32);

        #endregion

        #region Public API

        /// <summary>
        /// Enumerates all currently active tactical flashlights, updating last known positions.
        /// Overlay/event only. Must be called each overlay/event.
        /// </summary>
        public static IEnumerable<Light> GetActiveFlashlights()
        {
            ActiveLights.Clear();
            LastKnownFlashPositions.Clear();

            try
            {
                Light[] lights = UnityEngine.Object.FindObjectsOfType<Light>();
                for (int i = 0; i < lights.Length; i++)
                {
                    Light light = lights[i];
                    if (IsValidTacticalLight(light))
                    {
                        Transform t = light.transform;
                        if (t != null)
                        {
                            ActiveLights.Add(light);
                            LastKnownFlashPositions.Add(t.position);
                            TrackStrobeState(light);
                        }
                    }
                }
            }
            catch { }
            return ActiveLights;
        }

        /// <summary>
        /// Gets a read-only list of last known flashlight positions.
        /// </summary>
        public static IReadOnlyList<Vector3> GetLastKnownFlashlightPositions() => LastKnownFlashPositions;

        /// <summary>
        /// Returns true if any active flashlight is exposing (blinding) the given player, outputs the blinding light, and records exposure.
        /// </summary>
        public static bool IsExposingBot(Player player, out Light blindingLight, float customMaxDist = MaxExposureDistance)
        {
            blindingLight = null;
            if (!EFTPlayerUtil.IsValid(player))
                return false;

            try
            {
                Vector3 botPos = EFTPlayerUtil.GetPosition(player);
                Vector3 eyePos = botPos + (Vector3.up * EyeRayBias);

                for (int i = 0; i < ActiveLights.Count; i++)
                {
                    Light light = ActiveLights[i];
                    if (!IsValidTacticalLight(light))
                        continue;

                    Transform lightTf = light.transform;
                    if (lightTf == null)
                        continue;

                    Vector3 toBot = eyePos - lightTf.position;
                    float dist = toBot.magnitude;
                    if (dist > customMaxDist)
                        continue;

                    float angle = Vector3.Angle(lightTf.forward, toBot);
                    if (angle > ExposureConeAngle)
                        continue;

                    Vector3 origin = lightTf.position;
                    Vector3 dir = toBot.normalized;
                    try
                    {
                        int mask = LayerMaskClass.HighPolyWithTerrainMaskAI;
                        if (Physics.Raycast(origin, dir, out RaycastHit hit, dist + 0.1f, mask))
                        {
                            var pTransform = player.Transform?.Original;
                            if (pTransform != null &&
                                (hit.transform == pTransform || (hit.collider != null && hit.collider.gameObject == pTransform.gameObject)))
                            {
                                blindingLight = light;
                                RecordBlindExposure(player, Time.time);
                                return true;
                            }
                        }
                        else if (angle < (ExposureConeAngle * 0.5f) && dist < PanicCloseExposureDistance)
                        {
                            blindingLight = light;
                            RecordBlindExposure(player, Time.time);
                            return true;
                        }
                    }
                    catch { }
                }
            }
            catch { }

            return false;
        }

        /// <summary>
        /// Returns true if the player was recently blinded by any tactical flashlight.
        /// </summary>
        public static bool WasRecentlyBlinded(Player player, float window = BlindEventMemory)
        {
            if (!EFTPlayerUtil.IsValid(player))
                return false;
            string pid = player.ProfileId;
            if (string.IsNullOrEmpty(pid))
                return false;
            return LastBlindTime.TryGetValue(pid, out float last) && (Time.time - last < window);
        }

        /// <summary>
        /// Returns true if any squadmate is currently exposed to a tactical flashlight. 
        /// Used for panic/cover overlays, group evasion, squad-level decision-making.
        /// </summary>
        public static bool IsSquadExposedToFlashlight(BotsGroup group, float maxDistance = PanicSquadExposureDistance)
        {
            if (group == null || group.MembersCount < 2)
                return false;
            for (int i = 0; i < group.MembersCount; i++)
            {
                var mate = group.Member(i);
                if (mate?.GetPlayer == null || mate.IsDead)
                    continue;
                if (WasRecentlyBlinded(mate.GetPlayer, 1.7f))
                    return true;
            }
            return false;
        }

        /// <summary>
        /// Returns true if any strobe/flickering tactical flashlight is detected (expands with strobe logic).
        /// </summary>
        public static bool IsFlickeringFlashlightActive()
        {
            foreach (var kvp in StrobeStates)
            {
                if (kvp.Value.IsStrobing)
                    return true;
            }
            return false;
        }

        /// <summary>
        /// Scores the 'threat' level of a flashlight against a position, taking angle, distance, and strobe into account.
        /// </summary>
        public static float ScoreFlashlightThreat(Light light, Vector3 targetPos)
        {
            if (!IsValidTacticalLight(light))
                return 0f;

            Transform t = light.transform;
            Vector3 toTarget = targetPos - t.position;
            float dist = toTarget.magnitude;
            if (dist > MaxExposureDistance)
                return 0f;
            float angle = Vector3.Angle(t.forward, toTarget);
            if (angle > AngleThreshold)
                return 0f;

            float score = Mathf.Clamp01(1f - (dist / MaxExposureDistance));
            score *= Mathf.Clamp01(1f - (angle / AngleThreshold));
            score *= Mathf.Clamp(light.intensity / IntensityThreshold, 0.6f, 1.5f);
            if (StrobeStates.TryGetValue(light.GetInstanceID(), out var strobe) && strobe.IsStrobing)
                score *= 1.15f;
            return score;
        }

        /// <summary>
        /// Returns the highest flashlight threat score against a position (for bot avoidance, cover, panic).
        /// </summary>
        public static float GetMaxThreatScore(Vector3 targetPos)
        {
            float best = 0f;
            foreach (var light in ActiveLights)
                best = Mathf.Max(best, ScoreFlashlightThreat(light, targetPos));
            return best;
        }

        /// <summary>
        /// Clears all flashlight state/memory. Call on raid end.
        /// </summary>
        public static void Clear()
        {
            ActiveLights.Clear();
            LastKnownFlashPositions.Clear();
            LastBlindTime.Clear();
            StrobeStates.Clear();
        }

        #endregion

        #region Internal

        /// <summary>
        /// Validates a Unity Light as a tactical flashlight. Only real, live, spot, active, minimum intensity.
        /// </summary>
        private static bool IsValidTacticalLight(Light light)
        {
            try
            {
                return light != null &&
                       light.enabled &&
                       light.type == LightType.Spot &&
                       light.intensity >= IntensityThreshold &&
                       light.spotAngle <= AngleThreshold &&
                       light.gameObject.activeInHierarchy;
            }
            catch { return false; }
        }

        /// <summary>
        /// Records a blind exposure event for the given player (profileId).
        /// </summary>
        private static void RecordBlindExposure(Player player, float time)
        {
            if (player == null || string.IsNullOrEmpty(player.ProfileId))
                return;
            LastBlindTime[player.ProfileId] = time;
        }

        /// <summary>
        /// Tracks/updates strobe state for a tactical flashlight (frequency/amplitude, max realism, pooled).
        /// </summary>
        private static void TrackStrobeState(Light light)
        {
            int id = light.GetInstanceID();
            if (!StrobeStates.TryGetValue(id, out var state))
            {
                state = new StrobeTracker();
                StrobeStates[id] = state;
            }

            float now = Time.time;
            state.Update(light.intensity, now);

            // Remove old lights/states if inactive
            if (!light.enabled || !light.gameObject.activeInHierarchy)
                StrobeStates.Remove(id);
        }

        #endregion

        #region Inner Types

        /// <summary>
        /// Strobe pattern tracker for flickering/strobe tactical lights.
        /// </summary>
        private sealed class StrobeTracker
        {
            private const int MaxSamples = 8;
            private readonly float[] _samples = new float[MaxSamples];
            private int _sampleIdx = 0;
            private float _lastSampleTime = -1f;
            public bool IsStrobing { get; private set; }

            public void Update(float intensity, float now)
            {
                // Only sample at a reasonable frequency to avoid noise
                if (_lastSampleTime < 0f || now - _lastSampleTime > 0.04f)
                {
                    _samples[_sampleIdx] = intensity;
                    _sampleIdx = (_sampleIdx + 1) % MaxSamples;
                    _lastSampleTime = now;

                    Analyze();
                }
            }

            private void Analyze()
            {
                // Heuristic: rapid >MinStrobeFrequency Hz amplitude swings mean "strobing"
                float min = float.MaxValue, max = float.MinValue;
                for (int i = 0; i < MaxSamples; i++)
                {
                    float v = _samples[i];
                    if (v < min) min = v;
                    if (v > max) max = v;
                }
                float amp = max - min;
                IsStrobing = amp > StrobeAmplitude;
            }
        }

        #endregion
    }
}
