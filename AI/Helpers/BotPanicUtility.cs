// <auto-generated>
//   AI-Refactored: BotPanicUtility.cs (Supreme Arbitration, Beyond Diamond, Squad Contagion, Max Realism, June 2025)
//   Bulletproof, async, personality/squad/nearby panic propagation. Overlay/event-only. Error-isolated, pooled, multiplayer/headless safe.
//   MIT License.
// </auto-generated>

namespace AIRefactored.AI.Helpers
{
    using System;
    using System.Collections.Generic;
    using System.Threading.Tasks;
    using AIRefactored.AI.Combat;
    using AIRefactored.AI.Core;
    using AIRefactored.Pools;
    using EFT;
    using UnityEngine;

    /// <summary>
    /// Bulletproof panic propagation utility. Event/overlay-driven, async, personality/squad/contagion-aware.
    /// All logic multiplayer/headless/squad safe, zero-alloc in hot path, and error-shielded.
    /// </summary>
    public static class BotPanicUtility
    {
        #region Public API

        /// <summary>
        /// Triggers panic for a single bot (overlay/event, personality/squad safe).
        /// </summary>
        public static void Trigger(BotComponentCache cache, string source = null)
        {
            try
            {
                if (IsEligible(cache))
                    cache.PanicHandler.TriggerPanic(source ?? "panic");
            }
            catch { }
        }

        /// <summary>
        /// Triggers panic across a squad/group with MovementJitter/personality-based async jitter (overlay/event-only, bulletproof).
        /// </summary>
        public static void TriggerGroup(IReadOnlyList<BotComponentCache> group, string source = null)
        {
            if (group == null) return;
            int order = 0;
            for (int i = 0; i < group.Count; i++)
            {
                try
                {
                    var cache = group[i];
                    if (!IsEligible(cache))
                        continue;
                    float delay = 0.033f * order + GetPanicJitter(cache.Bot?.ProfileId, order, cache.PersonalityProfile);
                    TriggerDelayedPanic(cache, delay, source);
                    order++;
                }
                catch { }
            }
        }

        /// <summary>
        /// Triggers panic for all bots within a radius of origin (overlay/event only, pooled, async, personality/squad safe).
        /// </summary>
        public static void TriggerNearby(Vector3 origin, float radius, string source = null)
        {
            if (radius <= 0f || float.IsNaN(radius) || float.IsInfinity(radius))
                return;

            float radiusSqr = radius * radius;
            int order = 0;
            foreach (var cache in BotCacheUtility.AllActiveBots())
            {
                try
                {
                    if (!IsEligible(cache)) continue;
                    Vector3 pos = cache.Bot?.Position ?? Vector3.zero;
                    if (!IsVectorValid(pos) || (origin - pos).sqrMagnitude > radiusSqr)
                        continue;
                    float delay = 0.021f * order + GetPanicJitter(cache.Bot?.ProfileId, order, cache.PersonalityProfile);
                    TriggerDelayedPanic(cache, delay, source);
                    order++;
                }
                catch { }
            }
        }

        /// <summary>
        /// Triggers squad panic contagion from a single bot, propagating only to valid/nearby squadmates.
        /// </summary>
        public static void TriggerSquadContagion(BotComponentCache cache, float spreadRadius = 13.5f, string source = null)
        {
            if (!IsEligible(cache)) return;
            var bot = cache.Bot;
            var group = bot?.BotsGroup;
            if (group == null || group.MembersCount < 2) return;
            var origin = bot.Position;
            var squad = TempListPool.Rent<BotComponentCache>();
            for (int i = 0; i < group.MembersCount; i++)
            {
                BotOwner mate = group.Member(i);
                if (mate == null || mate.IsDead || mate == bot) continue;
                if (BotCacheUtility.TryGet(mate, out var mateCache) && IsEligible(mateCache))
                {
                    if ((mate.Position - origin).sqrMagnitude < spreadRadius * spreadRadius)
                        squad.Add(mateCache);
                }
            }
            if (squad.Count > 0)
                TriggerGroup(squad, source ?? "squad-contagion");
            TempListPool.Return(squad);
        }

        /// <summary>
        /// Tries to retrieve a valid panic handler for a bot cache.
        /// </summary>
        public static bool TryGet(BotComponentCache cache, out BotPanicHandler panic)
        {
            panic = cache?.PanicHandler;
            return panic != null;
        }

        #endregion

        #region Internal Helpers

        /// <summary>
        /// Returns true if bot is valid, alive, not panicking, and has a panic handler.
        /// </summary>
        private static bool IsEligible(BotComponentCache cache)
        {
            return cache != null
                && cache.Bot != null
                && !cache.Bot.IsDead
                && cache.PanicHandler != null
                && !cache.PanicHandler.IsPanicking;
        }

        /// <summary>
        /// Returns MovementJitter/personality-based panic propagation jitter (seconds, unique per bot/order).
        /// </summary>
        private static float GetPanicJitter(string profileId, int order, BotPersonalityProfile profile)
        {
            float bias = profile != null
                ? Mathf.Clamp01(1f + (profile.MovementJitter - 0.5f) * 0.4f)
                : 1f;
            int hash = (profileId?.GetHashCode() ?? 0) ^ (order * 41) ^ 0x5E1F1213;
            unchecked
            {
                hash = (hash ^ (hash >> 15)) * 0x6B1F29;
                float frac = (hash & 0xFFF) / 4096f;
                return frac * 0.14f * bias;
            }
        }

        /// <summary>
        /// Async, isolated delayed panic trigger (error-guarded). Only fires if eligible on wake.
        /// </summary>
        private static void TriggerDelayedPanic(BotComponentCache cache, float delay, string source = null)
        {
            if (cache == null) return;
            Task.Run(async () =>
            {
                try
                {
                    int ms = Mathf.Max(0, (int)(delay * 1000f));
                    if (ms > 0)
                        await Task.Delay(ms);

                    if (IsEligible(cache))
                        cache.PanicHandler.TriggerPanic(source ?? "panic-async");
                }
                catch { }
            });
        }

        /// <summary>
        /// True if Vector3 is finite and world-valid.
        /// </summary>
        private static bool IsVectorValid(Vector3 v)
        {
            return !float.IsNaN(v.x) && !float.IsNaN(v.y) && !float.IsNaN(v.z)
                && !float.IsInfinity(v.x) && !float.IsInfinity(v.y) && !float.IsInfinity(v.z)
                && Mathf.Abs(v.x) < 40000f && Mathf.Abs(v.y) < 40000f && Mathf.Abs(v.z) < 40000f;
        }

        #endregion
    }
}
