// <auto-generated>
//   AI-Refactored: BotPanicUtility.cs (Beyond Diamond, Ultra-Platinum++ Squad Contagion Edition, June 2025)
//   Bulletproof, emotion-driven panic propagation for squads/groups/nearby bots.
//   MovementJitter-based jitter, fallback immunity, async isolation. All logic multiplayer/headless safe. MIT License.
// </auto-generated>

namespace AIRefactored.AI.Helpers
{
    using System;
    using System.Collections.Generic;
    using System.Threading.Tasks;
    using AIRefactored.AI.Combat;
    using AIRefactored.AI.Core;
    using EFT;
    using UnityEngine;

    /// <summary>
    /// Handles ultra-realistic panic propagation for individuals, squads, and nearby bots.
    /// All delays, jitter, and eligibility checks are composure/personality-based and bulletproof.
    /// Fully async/isolated. Multiplayer, squad, and headless/client safe. Zero side-effects. MIT License.
    /// </summary>
    public static class BotPanicUtility
    {
        #region Public API

        /// <summary>
        /// Triggers panic for a single bot if eligible.
        /// </summary>
        public static void Trigger(BotComponentCache cache)
        {
            try
            {
                if (IsEligible(cache))
                    cache.PanicHandler.TriggerPanic();
            }
            catch { /* Panic triggers are always error-isolated. */ }
        }

        /// <summary>
        /// Triggers panic across a squad/group with MovementJitter-based async jitter (no cascade, no races).
        /// </summary>
        public static void TriggerGroup(List<BotComponentCache> group)
        {
            if (group == null) return;
            int order = 0;
            for (int i = 0; i < group.Count; i++)
            {
                try
                {
                    var cache = group[i];
                    if (!IsEligible(cache))
                        continue;
                    float delay = 0.03f * order + GetPanicJitter(cache.Bot?.ProfileId, order, cache.PersonalityProfile);
                    TriggerDelayedPanic(cache, delay);
                    order++;
                }
                catch { }
            }
        }

        /// <summary>
        /// Triggers panic for all bots within a radius of origin. Uses async, MovementJitter-based jitter, and order.
        /// </summary>
        public static void TriggerNearby(Vector3 origin, float radius)
        {
            if (radius <= 0f || float.IsNaN(radius) || float.IsInfinity(radius))
                return;

            float radiusSqr = radius * radius;
            int order = 0;
            foreach (var cache in BotCacheUtility.AllActiveBots())
            {
                try
                {
                    if (!IsEligible(cache)) continue;
                    Vector3 pos = cache.Bot?.Position ?? Vector3.zero;
                    if (!IsVectorValid(pos) || (origin - pos).sqrMagnitude > radiusSqr)
                        continue;
                    float delay = 0.02f * order + GetPanicJitter(cache.Bot?.ProfileId, order, cache.PersonalityProfile);
                    TriggerDelayedPanic(cache, delay);
                    order++;
                }
                catch { }
            }
        }

        /// <summary>
        /// Tries to retrieve a valid panic handler.
        /// </summary>
        public static bool TryGet(BotComponentCache cache, out BotPanicHandler panic)
            => TryGetPanicComponent(cache, out panic);

        public static bool TryGetPanicComponent(BotComponentCache cache, out BotPanicHandler panic)
        {
            panic = cache?.PanicHandler;
            return panic != null;
        }

        #endregion

        #region Internal Helpers

        /// <summary>
        /// Returns true if bot is valid, alive, not already panicking, and handler is present.
        /// </summary>
        private static bool IsEligible(BotComponentCache cache)
        {
            return cache != null
                && cache.Bot != null
                && !cache.Bot.IsDead
                && cache.PanicHandler != null
                && !cache.PanicHandler.IsPanicking;
        }

        /// <summary>
        /// Returns MovementJitter-based panic propagation jitter (seconds, unique per bot/order).
        /// </summary>
        private static float GetPanicJitter(string profileId, int order, BotPersonalityProfile profile)
        {
            // MovementJitter: low (calm bot) = less delay, high (nervous) = more delay
            float bias = profile != null
                ? Mathf.Clamp01(1f + (profile.MovementJitter - 0.5f) * 0.5f) // ~0.75-1.25
                : 1f;

            int hash = (profileId?.GetHashCode() ?? 0) ^ (order * 37) ^ 0x5E1F1213;
            unchecked
            {
                hash = (hash ^ (hash >> 15)) * 0x6B1F29;
                float frac = (hash & 0xFFF) / 4096f;
                return frac * 0.14f * bias; // ~0 to ~0.17s, jitter by movement jitter
            }
        }

        /// <summary>
        /// Async, pooled delayed panic trigger (error-guarded). Only fires if eligible on wake.
        /// </summary>
        private static void TriggerDelayedPanic(BotComponentCache cache, float delay)
        {
            if (cache == null) return;
            Task.Run(async () =>
            {
                try
                {
                    int ms = Mathf.Max(0, (int)(delay * 1000f));
                    if (ms > 0)
                        await Task.Delay(ms);

                    if (IsEligible(cache))
                        cache.PanicHandler.TriggerPanic();
                }
                catch { }
            });
        }

        /// <summary>
        /// True if Vector3 is finite and world-valid.
        /// </summary>
        private static bool IsVectorValid(Vector3 v)
        {
            return !float.IsNaN(v.x) && !float.IsNaN(v.y) && !float.IsNaN(v.z)
                && !float.IsInfinity(v.x) && !float.IsInfinity(v.y) && !float.IsInfinity(v.z)
                && Mathf.Abs(v.x) < 40000f && Mathf.Abs(v.y) < 40000f && Mathf.Abs(v.z) < 40000f;
        }

        #endregion
    }
}
