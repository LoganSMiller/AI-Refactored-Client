// <auto-generated>
//   AI-Refactored: BotPanicUtility.cs (Supreme Arbitration, Beyond Diamond, Squad Contagion Edition, June 2025)
//   Bulletproof, emotion-driven, squad/nearby panic propagation. Async/overlay, no tick/coroutine, no allocation hot-path.
//   All logic multiplayer/headless safe, overlay/event-only, error contained. MIT License.
// </auto-generated>

namespace AIRefactored.AI.Helpers
{
    using System;
    using System.Collections.Generic;
    using System.Threading.Tasks;
    using AIRefactored.AI.Combat;
    using AIRefactored.AI.Core;
    using AIRefactored.Pools;
    using EFT;
    using UnityEngine;

    /// <summary>
    /// Handles bulletproof, event-driven panic propagation for individuals, squads, and nearby bots.
    /// Propagation is async, non-blocking, and emotionally/personality driven. Multiplayer/headless safe, overlay/event only.
    /// </summary>
    public static class BotPanicUtility
    {
        #region Public API

        /// <summary>
        /// Triggers panic for a single bot if eligible (overlay/event only).
        /// </summary>
        public static void Trigger(BotComponentCache cache)
        {
            try
            {
                if (IsEligible(cache))
                    cache.PanicHandler.TriggerPanic();
            }
            catch { /* Error isolated. */ }
        }

        /// <summary>
        /// Triggers panic across a squad/group with MovementJitter-based async jitter (non-blocking, no race).
        /// All panic propagation is overlay/event only; no tick/coroutine.
        /// </summary>
        public static void TriggerGroup(IReadOnlyList<BotComponentCache> group)
        {
            if (group == null) return;
            int order = 0;
            for (int i = 0; i < group.Count; i++)
            {
                try
                {
                    var cache = group[i];
                    if (!IsEligible(cache))
                        continue;
                    float delay = 0.035f * order + GetPanicJitter(cache.Bot?.ProfileId, order, cache.PersonalityProfile);
                    TriggerDelayedPanic(cache, delay);
                    order++;
                }
                catch { }
            }
        }

        /// <summary>
        /// Triggers panic for all bots within radius of origin (event/overlay only, pooled, async, personality-driven).
        /// </summary>
        public static void TriggerNearby(Vector3 origin, float radius)
        {
            if (radius <= 0f || float.IsNaN(radius) || float.IsInfinity(radius))
                return;

            float radiusSqr = radius * radius;
            int order = 0;
            foreach (var cache in BotCacheUtility.AllActiveBots())
            {
                try
                {
                    if (!IsEligible(cache)) continue;
                    Vector3 pos = cache.Bot?.Position ?? Vector3.zero;
                    if (!IsVectorValid(pos) || (origin - pos).sqrMagnitude > radiusSqr)
                        continue;
                    float delay = 0.025f * order + GetPanicJitter(cache.Bot?.ProfileId, order, cache.PersonalityProfile);
                    TriggerDelayedPanic(cache, delay);
                    order++;
                }
                catch { }
            }
        }

        /// <summary>
        /// Tries to retrieve a valid panic handler for a bot cache.
        /// </summary>
        public static bool TryGet(BotComponentCache cache, out BotPanicHandler panic)
        {
            panic = cache?.PanicHandler;
            return panic != null;
        }

        #endregion

        #region Internal Helpers

        /// <summary>
        /// True if bot is valid, alive, not panicking, and has a panic handler.
        /// </summary>
        private static bool IsEligible(BotComponentCache cache)
        {
            return cache != null
                && cache.Bot != null
                && !cache.Bot.IsDead
                && cache.PanicHandler != null
                && !cache.PanicHandler.IsPanicking;
        }

        /// <summary>
        /// Returns MovementJitter/personality-based panic propagation jitter (seconds, unique per bot/order).
        /// </summary>
        private static float GetPanicJitter(string profileId, int order, BotPersonalityProfile profile)
        {
            float bias = profile != null
                ? Mathf.Clamp01(1f + (profile.MovementJitter - 0.5f) * 0.5f) // ~0.75-1.25
                : 1f;

            int hash = (profileId?.GetHashCode() ?? 0) ^ (order * 37) ^ 0x5E1F1213;
            unchecked
            {
                hash = (hash ^ (hash >> 15)) * 0x6B1F29;
                float frac = (hash & 0xFFF) / 4096f;
                return frac * 0.14f * bias;
            }
        }

        /// <summary>
        /// Async, isolated delayed panic trigger (error-guarded). Only fires if eligible on wake.
        /// </summary>
        private static void TriggerDelayedPanic(BotComponentCache cache, float delay)
        {
            if (cache == null) return;
            Task.Run(async () =>
            {
                try
                {
                    int ms = Mathf.Max(0, (int)(delay * 1000f));
                    if (ms > 0)
                        await Task.Delay(ms);

                    if (IsEligible(cache))
                        cache.PanicHandler.TriggerPanic();
                }
                catch { }
            });
        }

        /// <summary>
        /// True if Vector3 is finite and world-valid.
        /// </summary>
        private static bool IsVectorValid(Vector3 v)
        {
            return !float.IsNaN(v.x) && !float.IsNaN(v.y) && !float.IsNaN(v.z)
                && !float.IsInfinity(v.x) && !float.IsInfinity(v.y) && !float.IsInfinity(v.z)
                && Mathf.Abs(v.x) < 40000f && Mathf.Abs(v.y) < 40000f && Mathf.Abs(v.z) < 40000f;
        }

        #endregion
    }
}
