// <auto-generated>
//   AI-Refactored: BotMovementHelper.cs (Supreme Arbitration Overlay/Event Edition – June 2025, Triple-Guard, Zero-Alloc)
//   Canonical arbitration/event overlay entry for ALL bot moves. Overlay-triple-guarded, bulletproof NavMesh/Y, intent/event only.
//   No teleport, distance clamping, or direct position set. Only overlays/intents to EFT BotMover. Full SPT/FIKA/headless/client parity. Zero alloc. MIT License.
// </auto-generated>

namespace AIRefactored.AI.Helpers
{
    using System.Collections.Generic;
    using AIRefactored.AI.Core;
    using AIRefactored.Pools;
    using EFT;
    using UnityEngine;
    using UnityEngine.AI;

    /// <summary>
    /// Centralized, overlay-arbitrated, triple-guarded (arbitration, NavMesh/Y, dedup) movement/event intent system.
    /// All overlays, events, and fallback logic must use this. Zero direct position/transform assignment, zero per-tick/coroutine gating.
    /// Bulletproof, pooled, and SPT/FIKA/headless/client safe. No environment branches at runtime.
    /// </summary>
    public static class BotMovementHelper
    {
        #region Constants

        private const float MinMoveDistance = 0.25f;
        private const float MoveCooldown = 1.8f;
        private const float NavMeshSampleRadius = 1.5f;
        private const float NavMeshSampleRadiusRetreat = 2.2f;
        private const float YClampMax = 3.0f;
        private const float LookSmoothSpeed = 9.5f;
        private const float LookMaxDegPerSec = 160f;
        private const float StuckTimeout = 3.0f;
        private const float SquadRetreatDistance = 8.0f;
        private static readonly Vector3 Invalid = new Vector3(float.NaN, float.NaN, float.NaN);

        #endregion

        #region Main Movement (Overlay/Event/Intent Only)

        public static void SmoothMoveToSafe(
            BotOwner bot,
            Vector3 destination,
            bool slow = true,
            float cohesion = 1f,
            BotOverlayType overlayType = BotOverlayType.Patrol)
        {
            if (!IsAlive(bot)) return;
            var cache = bot.GetComponent<BotComponentCache>();
            if (cache == null || cache.MoveCache == null) return;

            if (!BotOverlayManager.CanIssueMove(bot, overlayType))
                return;
            if (cache.MoveCache.AnticipationActive || cache.MoveCache.EventLockoutActive)
                return;
            if (IsMovementPaused(bot) || IsInInteractionState(bot))
                return;

            if (!NavMesh.SamplePosition(destination, out var hit, NavMeshSampleRadius, NavMesh.AllAreas))
                return;

            Vector3 safe = hit.position;
            float baseY = GetPosition(bot).y;
            if (Mathf.Abs(safe.y - baseY) > YClampMax)
                safe.y = baseY;
            if (!IsValid(safe)) return;

            Vector3 drifted = ApplyMicroDrift(safe, bot.ProfileId, Time.frameCount, cache.PersonalityProfile);

            if (!ShouldMove(bot, drifted)) return;

            BotOverlayManager.RegisterMove(bot, overlayType);
            bot.Mover?.GoToPoint(drifted, slow, cohesion);
            cache.MoveCache.AuditMove(drifted, Time.time, overlayType.ToString());
        }

        public static bool ShouldMove(BotOwner bot, Vector3 destination)
        {
            var cache = bot?.GetComponent<BotComponentCache>()?.MoveCache;
            if (cache == null) return false;

            Vector3 current = GetPosition(bot);
            float sqrDist = (current - destination).sqrMagnitude;
            if (sqrDist < MinMoveDistance * MinMoveDistance)
                return false;
            if (Time.time - cache.LastMoveTime < MoveCooldown)
                return false;
            if (!cache.IsNewTarget(destination, MinMoveDistance * MinMoveDistance))
                return false;
            return true;
        }

        #endregion

        #region Overlay/Event Retreat (Squad-Safe)

        public static List<Vector3> GetSquadSafeRetreatPath(BotOwner bot, Vector3 threatDir, float squadSpacing)
        {
            var result = TempListPool.Rent<Vector3>();
            if (bot == null || bot.Transform == null) return result;

            var group = bot.BotsGroup;
            int groupCount = group != null ? group.MembersCount : 1;
            int index = 0;
            if (group != null && groupCount > 1)
            {
                for (int i = 0; i < groupCount; i++)
                {
                    var mate = group.Member(i);
                    if (mate != null && mate.ProfileId == bot.ProfileId)
                    {
                        index = i;
                        break;
                    }
                }
            }

            Vector3 origin = GetPosition(bot);
            float angleSpread = 70f;
            float angleBase = -angleSpread * 0.5f + (groupCount > 1 ? (index * (angleSpread / (groupCount - 1))) : 0f);
            Quaternion offsetRot = Quaternion.Euler(0f, angleBase, 0f);
            Vector3 retreatDir = offsetRot * -threatDir.normalized;
            Vector3 retreatTarget = origin + retreatDir * SquadRetreatDistance;

            if (!NavMesh.SamplePosition(retreatTarget, out var navHit, NavMeshSampleRadiusRetreat, NavMesh.AllAreas))
            {
                result.Add(origin);
                return result;
            }

            Vector3 safe = navHit.position;
            if (Mathf.Abs(safe.y - origin.y) > YClampMax)
                safe.y = origin.y;

            result.Add(origin);
            result.Add(safe);
            return result;
        }

        #endregion

        #region Look / Aim Overlay (Smooth, One-Shot, No Snap)

        public static void SmoothLookTo(BotOwner bot, Vector3 target, float speed = LookSmoothSpeed)
        {
            if (!IsAlive(bot) || bot.Transform == null) return;

            Vector3 dir = (target - bot.Transform.position);
            if (dir.sqrMagnitude < 0.0001f) return;

            dir.Normalize();
            Quaternion currentRot = bot.Transform.rotation;
            Quaternion targetRot = Quaternion.LookRotation(dir);

            float dt = Mathf.Clamp(Time.deltaTime, 0f, 1f / 30f);
            float maxStep = Mathf.Clamp(speed, 0.1f, 10f) * LookMaxDegPerSec * dt;
            float angle = Quaternion.Angle(currentRot, targetRot);
            float t = (angle < maxStep) ? 1f : maxStep / angle;
            bot.Transform.rotation = Quaternion.Slerp(currentRot, targetRot, t);
        }

        #endregion

        #region Utility & Safety

        public static Vector3 GetPosition(BotOwner bot)
        {
            if (bot == null) return Vector3.zero;
            var player = bot.GetPlayer;
            if (player != null && player.Transform != null)
                return player.Transform.position;
            if (bot.Transform != null)
                return bot.Transform.position;
            return Vector3.zero;
        }

        public static Vector3 ApplyMicroDrift(Vector3 pos, string profileId, int tick, BotPersonalityProfile profile)
        {
            float baseMag = 0.13f;
            float bias = profile != null
                ? Mathf.Clamp(1f + profile.MovementJitter * 0.22f, 0.87f, 1.18f)
                : 1f;

            int hash = (profileId?.GetHashCode() ?? 0) ^ (tick * 19) ^ 0x4A8BC13F;
            unchecked
            {
                hash = (hash ^ (hash >> 13)) * 0x6A5D39E9;
                float dx = ((hash & 0xFF) / 255f - 0.5f) * baseMag * bias;
                float dz = (((hash >> 8) & 0xFF) / 255f - 0.5f) * baseMag * bias;
                return pos + new Vector3(dx, 0f, dz);
            }
        }

        public static bool IsStuckAtTarget(BotOwner bot)
        {
            var cache = bot?.GetComponent<BotComponentCache>()?.MoveCache;
            if (cache == null) return false;

            Vector3 current = GetPosition(bot);
            float moved = (current - cache.LastIssuedTarget).sqrMagnitude;
            return moved < 0.015f && (Time.time - cache.LastMoveTime) > StuckTimeout;
        }

        public static void Reset(BotOwner bot)
        {
            var cache = bot?.GetComponent<BotComponentCache>()?.MoveCache;
            if (cache == null) return;
            cache.Reset();
        }

        private static bool IsValid(Vector3 pos)
        {
            return !float.IsNaN(pos.x) && !float.IsInfinity(pos.x) &&
                   !float.IsNaN(pos.y) && !float.IsInfinity(pos.y) &&
                   !float.IsNaN(pos.z) && !float.IsInfinity(pos.z) &&
                   Mathf.Abs(pos.x) < 40000f && Mathf.Abs(pos.y) < 40000f && Mathf.Abs(pos.z) < 40000f;
        }

        private static bool IsAlive(BotOwner bot)
        {
            return bot != null && bot.GetPlayer != null && bot.GetPlayer.HealthController?.IsAlive == true;
        }

        public static bool IsMovementPaused(BotOwner bot)
        {
            if (bot?.Mover == null) return false;
            if (bot.Mover.Pause) return true;
            if (bot.Mover.RemainPause > 0.01f) return true;
            return false;
        }

        public static bool IsInInteractionState(BotOwner bot)
        {
            var player = bot?.GetPlayer;
            if (player == null) return false;
            var state = player.CurrentStateName;
            return state == EPlayerState.Loot ||
                   state == EPlayerState.Pickup ||
                   state == EPlayerState.Open ||
                   state == EPlayerState.Close ||
                   state == EPlayerState.Unlock ||
                   state == EPlayerState.Plant ||
                   state == EPlayerState.Approach;
        }

        public static void SmoothMoveToSafeExit(BotOwner bot, Vector3 destination, bool slow = true, float cohesion = 1f)
        {
            SmoothMoveToSafe(bot, destination, slow, cohesion, BotOverlayType.Fallback);
        }

        #endregion
    }
}
