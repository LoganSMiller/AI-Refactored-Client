// <auto-generated>
//   AI-Refactored: BotMovementHelper.cs (Ultimate Overlay-Only, NavMesh-Validated Edition – June 2025)
//   All movement is intent/cooldown-based, never tick-driven or spammed. No per-frame logic.
//   Only overlays humanized micro-drift, checks for stuck, validates NavMesh. Zero teleport, zero snap.
//   MIT License.
// </auto-generated>

namespace AIRefactored.AI.Helpers
{
    using System.Collections.Generic;
    using AIRefactored.AI.Core;
    using AIRefactored.Pools;
    using EFT;
    using UnityEngine;
    using UnityEngine.AI;

    /// <summary>
    /// Pure utility for issuing human-like, NavMesh-safe, intent-driven movement to bots.
    /// Never called every frame. No Update/tick logic. One-shot, only via explicit intent.
    /// </summary>
    public static class BotMovementHelper
    {
        #region Constants

        private const float MinMoveDistance = 0.22f;      // Min distance to trigger move
        private const float MoveCooldown = 0.75f;         // Per-bot move spam guard (s)
        private const float NavMeshSampleRadius = 1.5f;   // NavMesh validation
        private const float LookSmoothSpeed = 12f;
        private const float StuckTimeout = 3.0f;          // Time to consider "stuck"
        private const float SquadRetreatDistance = 8.0f;  // Retreat fallback (can be tweaked)
        private static readonly Vector3 Invalid = new Vector3(float.NaN, float.NaN, float.NaN);

        #endregion

        #region Main Movement (Intent Only)

        /// <summary>
        /// Move bot to a validated NavMesh point, overlaying micro-drift. 
        /// Never issues movement more than once per cooldown.
        /// </summary>
        public static void SmoothMoveToSafe(BotOwner bot, Vector3 destination, bool slow = true, float cohesion = 1f)
        {
            if (!IsAlive(bot)) return;
            var cache = bot?.GetComponent<BotComponentCache>();
            if (cache == null || cache.MoveCache == null) return;

            Vector3 current = GetPosition(bot);

            // Only move if intent is valid and not paused
            if (!ShouldMove(bot, destination)) return;
            if (IsMovementPaused(bot)) return;

            if (!NavMesh.SamplePosition(destination, out var hit, NavMeshSampleRadius, NavMesh.AllAreas))
                return; // Invalid move

            Vector3 safe = hit.position;
            if (!IsValid(safe)) return;

            Vector3 drifted = ApplyMicroDrift(safe, bot.ProfileId, Time.frameCount, cache.PersonalityProfile);
            bot.Mover?.GoToPoint(drifted, slow, cohesion);

            cache.MoveCache.LastMoveTime = Time.time;
            cache.MoveCache.LastIssuedTarget = drifted;
        }

        /// <summary>
        /// Returns true if bot should move to this destination (distance + cooldown + dedupe check).
        /// </summary>
        public static bool ShouldMove(BotOwner bot, Vector3 destination)
        {
            var cache = bot?.GetComponent<BotComponentCache>();
            var moveCache = cache?.MoveCache;
            if (moveCache == null) return false;

            Vector3 current = GetPosition(bot);
            float sqrDist = (current - destination).sqrMagnitude;

            if (sqrDist < MinMoveDistance * MinMoveDistance)
                return false; // Already close enough

            if (Time.time - moveCache.LastMoveTime < MoveCooldown)
                return false; // Move spam guard

            if (!moveCache.IsNewTarget(destination, MinMoveDistance * MinMoveDistance))
                return false; // Target dedupe

            return true;
        }

        #endregion

        #region Overlay/Event Retreat (Squad-Safe Retreat)

        /// <summary>
        /// Returns a pooled, squad-aware retreat path for a bot, based on threatDir and squad spacing.
        /// Overlay/event only—never called per-frame or ticked.
        /// </summary>
        public static List<Vector3> GetSquadSafeRetreatPath(BotOwner bot, Vector3 threatDir, float squadSpacing)
        {
            var result = TempListPool.Rent<Vector3>();
            if (bot == null || bot.Transform == null)
                return result;

            // Get the bot's group formation index (for offset)
            var group = bot.BotsGroup;
            int groupCount = group != null ? group.MembersCount : 1;
            int index = 0;
            if (group != null && groupCount > 1)
            {
                for (int i = 0; i < groupCount; i++)
                {
                    var mate = group.Member(i);
                    if (mate != null && mate.ProfileId == bot.ProfileId)
                    {
                        index = i;
                        break;
                    }
                }
            }

            Vector3 origin = GetPosition(bot);

            // Offset retreat direction for squad formation
            float angleSpread = 70f;
            float angleBase = -angleSpread * 0.5f + (groupCount > 1 ? (index * (angleSpread / (groupCount - 1))) : 0f);
            Quaternion offsetRot = Quaternion.Euler(0f, angleBase, 0f);
            Vector3 retreatDir = offsetRot * -threatDir.normalized;
            Vector3 retreatTarget = origin + retreatDir * SquadRetreatDistance;

            // NavMesh validate retreat target
            if (!NavMesh.SamplePosition(retreatTarget, out var navHit, 2.2f, NavMesh.AllAreas))
            {
                result.Add(origin);
                return result;
            }

            result.Add(origin);
            result.Add(navHit.position);
            return result;
        }

        #endregion

        #region Look / Aim Overlay

        /// <summary>
        /// Overlay a smooth look/rotation (never snapped), for aim/pose blending.
        /// Call only from BotLookController or similar.
        /// </summary>
        public static void SmoothLookTo(BotOwner bot, Vector3 target, float speed = LookSmoothSpeed)
        {
            if (!IsAlive(bot)) return;
            if (bot.Transform == null) return;

            Vector3 dir = (target - bot.Transform.position);
            if (dir.sqrMagnitude < 0.0001f) return;

            dir.Normalize();
            Quaternion targetRot = Quaternion.LookRotation(dir);
            bot.Transform.rotation = Quaternion.Slerp(bot.Transform.rotation, targetRot, Mathf.Clamp01(speed * Time.deltaTime));
        }

        #endregion

        #region Utility & Safety

        /// <summary>
        /// Returns current world position of bot or its player, safe for all overlays and movement.
        /// </summary>
        public static Vector3 GetPosition(BotOwner bot)
        {
            if (bot == null) return Vector3.zero;
            var player = bot.GetPlayer;
            if (player != null && player.Transform != null)
                return player.Transform.position;
            if (bot.Transform != null)
                return bot.Transform.position;
            return Vector3.zero;
        }

        /// <summary>
        /// Applies subtle, personality-driven micro-drift to a target position for realism.
        /// </summary>
        public static Vector3 ApplyMicroDrift(Vector3 pos, string profileId, int tick, BotPersonalityProfile profile)
        {
            float baseMag = 0.13f;
            float bias = profile != null
                ? Mathf.Clamp(1f + profile.MovementJitter * 0.22f, 0.87f, 1.18f)
                : 1f;

            // Seed: profile, tick, constant, xor shuffle
            int hash = (profileId?.GetHashCode() ?? 0) ^ (tick * 19) ^ 0x4A8BC13F;
            unchecked
            {
                hash = (hash ^ (hash >> 13)) * 0x6A5D39E9;
                float dx = ((hash & 0xFF) / 255f - 0.5f) * baseMag * bias;
                float dz = (((hash >> 8) & 0xFF) / 255f - 0.5f) * baseMag * bias;
                return pos + new Vector3(dx, 0f, dz);
            }
        }

        /// <summary>
        /// Returns true if bot is considered stuck at last move target (for >3s, not moving).
        /// </summary>
        public static bool IsStuckAtTarget(BotOwner bot)
        {
            var cache = bot?.GetComponent<BotComponentCache>()?.MoveCache;
            if (cache == null) return false;

            Vector3 current = GetPosition(bot);
            float moved = (current - cache.LastIssuedTarget).sqrMagnitude;
            return moved < 0.015f && (Time.time - cache.LastMoveTime) > StuckTimeout;
        }

        /// <summary>
        /// Reset movement cooldown and last-move for recovery or test.
        /// </summary>
        public static void Reset(BotOwner bot)
        {
            var cache = bot?.GetComponent<BotComponentCache>()?.MoveCache;
            if (cache == null) return;

            cache.LastMoveTime = -1000f;
            cache.LastIssuedTarget = Invalid;
        }

        /// <summary>
        /// Returns true if a Vector3 is finite, valid, and usable for navigation.
        /// </summary>
        private static bool IsValid(Vector3 pos)
        {
            return !float.IsNaN(pos.x) && !float.IsInfinity(pos.x) &&
                   !float.IsNaN(pos.y) && !float.IsInfinity(pos.y) &&
                   !float.IsNaN(pos.z) && !float.IsInfinity(pos.z);
        }

        /// <summary>
        /// Returns true if the bot and its player are valid and alive.
        /// </summary>
        private static bool IsAlive(BotOwner bot)
        {
            return bot != null && bot.GetPlayer != null && bot.GetPlayer.HealthController?.IsAlive == true;
        }

        /// <summary>
        /// Returns true if bot is currently in a movement pause (SPT/FIKA/EFT safe).
        /// </summary>
        private static bool IsMovementPaused(BotOwner bot)
        {
            if (bot?.Mover == null)
                return false;
            if (bot.Mover.Pause)
                return true;
            if (bot.Mover.RemainPause > 0.01f)
                return true;
            return false;
        }

        /// <summary>
        /// Special move intent for extractions—exactly like SmoothMoveToSafe, but signals extract/escape context.
        /// All pathing, cooldown, NavMesh, and drift rules apply.
        /// </summary>
        public static void SmoothMoveToSafeExit(BotOwner bot, Vector3 destination, bool slow = true, float cohesion = 1f)
        {
            SmoothMoveToSafe(bot, destination, slow, cohesion);
        }

        #endregion
    }
}
