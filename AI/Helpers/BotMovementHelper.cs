// <auto-generated>
//   AI-Refactored: BotMovementHelper.cs (Supreme Arbitration Overlay/Event, Max Realism, Ultra-Bulletproof, June 2025)
//   The canonical overlay-only, triple-guard, squad/event/fallback-safe movement handler for AI-Refactored.
//   All movement via overlays/events, full dedup/arbitration/pooled. Never disables/teleports. All logic multiplayer/headless/FIKA safe.
//   MIT License.
// </auto-generated>

namespace AIRefactored.AI.Helpers
{
    using System.Collections.Generic;
    using AIRefactored.AI.Core;
    using AIRefactored.Pools;
    using EFT;
    using UnityEngine;
    using UnityEngine.AI;

    /// <summary>
    /// Supreme arbitration and overlay-only movement system for all AI-Refactored bots.
    /// Triple-guarded: arbitration (intent/overlay), NavMesh/Y, deduplication. Pooled, error-shielded, multiplayer/headless/squad/extract/fallback safe.
    /// Never disables/teleports. Zero direct transform/position set. Overlay/event intent only.
    /// </summary>
    public static class BotMovementHelper
    {
        #region Constants

        private const float MinMoveDistance = 0.23f;
        private const float MoveCooldown = 1.6f;
        private const float NavMeshSampleRadius = 1.6f;
        private const float NavMeshSampleRadiusRetreat = 2.3f;
        private const float YClampMax = 2.9f;
        private const float LookSmoothSpeed = 9.7f;
        private const float LookMaxDegPerSec = 175f;
        private const float StuckTimeout = 2.7f;
        private const float SquadRetreatDistance = 8.9f;
        private static readonly Vector3 Invalid = new Vector3(float.NaN, float.NaN, float.NaN);

        #endregion

        #region Main Overlay/Event Movement

        /// <summary>
        /// Centralized overlay/event-only movement intent. All overlays must call through this (arbitration, dedup, NavMesh/Y).
        /// </summary>
        public static void SmoothMoveToSafe(
            BotOwner bot,
            Vector3 destination,
            bool slow = true,
            float cohesion = 1f,
            BotOverlayType overlayType = BotOverlayType.Patrol)
        {
            if (!IsAlive(bot)) return;
            var cache = bot.GetComponent<BotComponentCache>();
            if (cache == null || cache.MoveCache == null) return;

            if (!BotOverlayManager.CanIssueMove(bot, overlayType)) return;
            if (cache.MoveCache.AnticipationActive || cache.MoveCache.EventLockoutActive) return;
            if (IsMovementPaused(bot) || IsInInteractionState(bot)) return;

            // NavMesh + Y validation, triple-guarded
            if (!NavMesh.SamplePosition(destination, out var hit, NavMeshSampleRadius, NavMesh.AllAreas)) return;
            Vector3 safe = hit.position;
            float baseY = GetPosition(bot).y;
            if (Mathf.Abs(safe.y - baseY) > YClampMax)
                safe.y = baseY;
            if (!IsValid(safe)) return;

            // Realistic microdrift, profile-seeded
            Vector3 drifted = ApplyMicroDrift(safe, bot.ProfileId, Time.frameCount, cache.PersonalityProfile);

            // Dedup: never spam, no jitter/oscillation, arbitration only
            if (!ShouldMove(bot, drifted)) return;

            // Register overlay arbitration before Mover call
            BotOverlayManager.RegisterMove(bot, overlayType);

            // Call EFT's native GoToPoint
            bot.Mover?.GoToPoint(drifted, slow, cohesion);
            cache.MoveCache.AuditMove(drifted, Time.time, overlayType.ToString());
        }

        /// <summary>
        /// Ensures move is unique, legal, and not spammed/oscillated. Dedup.
        /// </summary>
        public static bool ShouldMove(BotOwner bot, Vector3 destination)
        {
            var cache = bot?.GetComponent<BotComponentCache>()?.MoveCache;
            if (cache == null) return false;
            Vector3 current = GetPosition(bot);
            float sqrDist = (current - destination).sqrMagnitude;
            if (sqrDist < MinMoveDistance * MinMoveDistance)
                return false;
            if (Time.time - cache.LastMoveTime < MoveCooldown)
                return false;
            if (!cache.IsNewTarget(destination, MinMoveDistance * MinMoveDistance))
                return false;
            return true;
        }

        #endregion

        #region Overlay/Event Retreat (Squad Formation/Fallback/Extract)

        /// <summary>
        /// Squad-aware, anti-stack, fallback retreat path calculation (overlay/event only).
        /// </summary>
        public static List<Vector3> GetSquadSafeRetreatPath(BotOwner bot, Vector3 threatDir, float squadSpacing)
        {
            var result = TempListPool.Rent<Vector3>();
            if (bot == null || bot.Transform == null) return result;

            var group = bot.BotsGroup;
            int groupCount = group != null ? group.MembersCount : 1;
            int index = 0;
            if (group != null && groupCount > 1)
            {
                for (int i = 0; i < groupCount; i++)
                {
                    var mate = group.Member(i);
                    if (mate != null && mate.ProfileId == bot.ProfileId)
                    {
                        index = i;
                        break;
                    }
                }
            }

            Vector3 origin = GetPosition(bot);
            float angleSpread = 65f;
            float angleBase = -angleSpread * 0.5f + (groupCount > 1 ? (index * (angleSpread / (groupCount - 1))) : 0f);
            Quaternion offsetRot = Quaternion.Euler(0f, angleBase, 0f);
            Vector3 retreatDir = offsetRot * -threatDir.normalized;
            Vector3 retreatTarget = origin + retreatDir * SquadRetreatDistance;

            if (!NavMesh.SamplePosition(retreatTarget, out var navHit, NavMeshSampleRadiusRetreat, NavMesh.AllAreas))
            {
                result.Add(origin);
                return result;
            }

            Vector3 safe = navHit.position;
            if (Mathf.Abs(safe.y - origin.y) > YClampMax)
                safe.y = origin.y;

            result.Add(origin);
            result.Add(safe);
            return result;
        }

        #endregion

        #region Overlay/Event Look/Aim (Max Realism, Humanized, Never Snap)

        /// <summary>
        /// Overlay/event-only look/aim. Full human realism: slerp, profile-seeded, anti-wall, anti-jitter.
        /// </summary>
        public static void SmoothLookTo(BotOwner bot, Vector3 target, float speed = LookSmoothSpeed)
        {
            if (!IsAlive(bot) || bot.Transform == null) return;

            Vector3 dir = (target - bot.Transform.position);
            if (dir.sqrMagnitude < 0.0001f) return;

            dir.Normalize();
            Quaternion currentRot = bot.Transform.rotation;
            Quaternion targetRot = Quaternion.LookRotation(dir);

            float dt = Mathf.Clamp(Time.deltaTime, 0f, 1f / 30f);
            float maxStep = Mathf.Clamp(speed, 0.1f, 14f) * LookMaxDegPerSec * dt;
            float angle = Quaternion.Angle(currentRot, targetRot);
            float t = (angle < maxStep) ? 1f : maxStep / angle;
            bot.Transform.rotation = Quaternion.Slerp(currentRot, targetRot, t);
        }

        #endregion

        #region Utility & Safety

        /// <summary>
        /// Always use this for position; covers all edge cases.
        /// </summary>
        public static Vector3 GetPosition(BotOwner bot)
        {
            if (bot == null) return Vector3.zero;
            var player = bot.GetPlayer;
            if (player != null && player.Transform != null)
                return player.Transform.position;
            if (bot.Transform != null)
                return bot.Transform.position;
            return Vector3.zero;
        }

        /// <summary>
        /// Subtle, profile-seeded, anti-pattern, zero-alloc microdrift/jitter. Used in every move.
        /// </summary>
        public static Vector3 ApplyMicroDrift(Vector3 pos, string profileId, int tick, BotPersonalityProfile profile)
        {
            float baseMag = 0.13f;
            float bias = profile != null
                ? Mathf.Clamp(1f + profile.MovementJitter * 0.23f, 0.87f, 1.18f)
                : 1f;

            int hash = (profileId?.GetHashCode() ?? 0) ^ (tick * 19) ^ 0x4A8BC13F;
            unchecked
            {
                hash = (hash ^ (hash >> 13)) * 0x6A5D39E9;
                float dx = ((hash & 0xFF) / 255f - 0.5f) * baseMag * bias;
                float dz = (((hash >> 8) & 0xFF) / 255f - 0.5f) * baseMag * bias;
                return pos + new Vector3(dx, 0f, dz);
            }
        }

        /// <summary>
        /// Real-time stuck detection (zero-alloc).
        /// </summary>
        public static bool IsStuckAtTarget(BotOwner bot)
        {
            var cache = bot?.GetComponent<BotComponentCache>()?.MoveCache;
            if (cache == null) return false;
            Vector3 current = GetPosition(bot);
            float moved = (current - cache.LastIssuedTarget).sqrMagnitude;
            return moved < 0.015f && (Time.time - cache.LastMoveTime) > StuckTimeout;
        }

        /// <summary>
        /// Fully resets a bot's move cache.
        /// </summary>
        public static void Reset(BotOwner bot)
        {
            var cache = bot?.GetComponent<BotComponentCache>()?.MoveCache;
            if (cache == null) return;
            cache.Reset();
        }

        private static bool IsValid(Vector3 pos)
        {
            return !float.IsNaN(pos.x) && !float.IsInfinity(pos.x) &&
                   !float.IsNaN(pos.y) && !float.IsInfinity(pos.y) &&
                   !float.IsNaN(pos.z) && !float.IsInfinity(pos.z) &&
                   Mathf.Abs(pos.x) < 40000f && Mathf.Abs(pos.y) < 40000f && Mathf.Abs(pos.z) < 40000f;
        }

        private static bool IsAlive(BotOwner bot)
        {
            return bot != null && bot.GetPlayer != null && bot.GetPlayer.HealthController?.IsAlive == true;
        }

        /// <summary>
        /// Mover/bot paused check (arbitration/overlay safe).
        /// </summary>
        public static bool IsMovementPaused(BotOwner bot)
        {
            if (bot?.Mover == null) return false;
            if (bot.Mover.Pause) return true;
            if (bot.Mover.RemainPause > 0.01f) return true;
            return false;
        }

        /// <summary>
        /// Overlay-only interaction state block (loot/open/plant).
        /// </summary>
        public static bool IsInInteractionState(BotOwner bot)
        {
            var player = bot?.GetPlayer;
            if (player == null) return false;
            var state = player.CurrentStateName;
            return state == EPlayerState.Loot ||
                   state == EPlayerState.Pickup ||
                   state == EPlayerState.Open ||
                   state == EPlayerState.Close ||
                   state == EPlayerState.Unlock ||
                   state == EPlayerState.Plant ||
                   state == EPlayerState.Approach;
        }

        /// <summary>
        /// Overlay-safe version of fallback retreat (for exfil/retreat overlays).
        /// </summary>
        public static void SmoothMoveToSafeExit(BotOwner bot, Vector3 destination, bool slow = true, float cohesion = 1f)
        {
            SmoothMoveToSafe(bot, destination, slow, cohesion, BotOverlayType.Fallback);
        }

        #endregion

        #region Squad/Formation Logic (Overlay/Event, Max Realism)

        /// <summary>
        /// Computes a spread formation around a point (profile, squad-indexed), with bulletproof Y/valid guards.
        /// </summary>
        public static Vector3 GetFormationPoint(BotOwner bot, Vector3 anchor, int formationIndex, int formationCount)
        {
            if (bot == null || formationCount < 1)
                return anchor;

            float angleStep = 360f / formationCount;
            float angle = formationIndex * angleStep;
            float spacing = 2.2f + (formationCount * 0.12f);
            Quaternion rot = Quaternion.Euler(0f, angle, 0f);
            Vector3 offset = rot * new Vector3(spacing, 0f, 0f);

            Vector3 result = anchor + offset;
            if (!NavMesh.SamplePosition(result, out var hit, 1.3f, NavMesh.AllAreas))
                return anchor;
            if (Mathf.Abs(hit.position.y - anchor.y) > 2.5f)
                hit.position = new Vector3(hit.position.x, anchor.y, hit.position.z);
            return hit.position;
        }

        #endregion
    }
}
