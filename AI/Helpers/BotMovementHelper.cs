// <auto-generated>
//   AI-Refactored: BotMovementHelper.cs (Ultra-Platinum++ Final Edition Patched – June 2025)
//   Intent/event-only, anti-spam, bulletproof NavMesh, anticipation-safe, no teleport. Zero alloc. MIT License.
// </auto-generated>

namespace AIRefactored.AI.Helpers
{
    using System.Collections.Generic;
    using AIRefactored.AI.Core;
    using AIRefactored.Pools;
    using EFT;
    using UnityEngine;
    using UnityEngine.AI;

    /// <summary>
    /// Human-realistic, anticipation/event-only, NavMesh-validated, intent-driven movement for bots.
    /// All movement is deduped, safe, and error-guarded. Compatible with intent dispatch, anticipation delays, and all multiplayer/headless/server modes.
    /// </summary>
    public static class BotMovementHelper
    {
        #region Constants

        private const float MinMoveDistance = 0.25f;      // Min distance for intent move
        private const float MoveCooldown = 1.2f;          // Per-bot anti-spam cooldown (seconds)
        private const float NavMeshSampleRadius = 1.5f;
        private const float LookSmoothSpeed = 9.5f;
        private const float LookMaxDegPerSec = 160f;
        private const float StuckTimeout = 3.0f;
        private const float SquadRetreatDistance = 8.0f;
        private static readonly Vector3 Invalid = new Vector3(float.NaN, float.NaN, float.NaN);

        #endregion

        #region Main Movement (Intent/Event-Only)

        /// <summary>
        /// Moves the bot to a NavMesh-safe point with micro-drift. Called only from MovementIntentDispatcher or equivalent event logic.
        /// </summary>
        public static void SmoothMoveToSafe(BotOwner bot, Vector3 destination, bool slow = true, float cohesion = 1f)
        {
            if (!IsAlive(bot)) return;
            var cache = bot?.GetComponent<BotComponentCache>();
            if (cache == null || cache.MoveCache == null) return;
            if (!ShouldMove(bot, destination)) return;
            if (IsMovementPaused(bot) || IsInInteractionState(bot)) return;

            if (!NavMesh.SamplePosition(destination, out var hit, NavMeshSampleRadius, NavMesh.AllAreas))
                return;

            Vector3 safe = hit.position;
            if (!IsValid(safe)) return;

            Vector3 drifted = ApplyMicroDrift(safe, bot.ProfileId, Time.frameCount, cache.PersonalityProfile);

            bot.Mover?.GoToPoint(drifted, slow, cohesion);
            cache.MoveCache.LastMoveTime = Time.time;
            cache.MoveCache.LastIssuedTarget = drifted;
        }

        /// <summary>
        /// Returns true if the bot should move to this destination (distance, cooldown, dedup).
        /// </summary>
        public static bool ShouldMove(BotOwner bot, Vector3 destination)
        {
            var cache = bot?.GetComponent<BotComponentCache>();
            var moveCache = cache?.MoveCache;
            if (moveCache == null) return false;

            Vector3 current = GetPosition(bot);
            float sqrDist = (current - destination).sqrMagnitude;

            if (sqrDist < MinMoveDistance * MinMoveDistance)
                return false;
            if (Time.time - moveCache.LastMoveTime < MoveCooldown)
                return false;
            if (!moveCache.IsNewTarget(destination, MinMoveDistance * MinMoveDistance))
                return false;
            return true;
        }

        #endregion

        #region Overlay/Event Retreat

        /// <summary>
        /// Returns a pooled squad-safe retreat path for a bot, formation-aware. Never called per frame/tick.
        /// </summary>
        public static List<Vector3> GetSquadSafeRetreatPath(BotOwner bot, Vector3 threatDir, float squadSpacing)
        {
            var result = TempListPool.Rent<Vector3>();
            if (bot == null || bot.Transform == null) return result;

            var group = bot.BotsGroup;
            int groupCount = group != null ? group.MembersCount : 1;
            int index = 0;
            if (group != null && groupCount > 1)
            {
                for (int i = 0; i < groupCount; i++)
                {
                    var mate = group.Member(i);
                    if (mate != null && mate.ProfileId == bot.ProfileId)
                    {
                        index = i;
                        break;
                    }
                }
            }

            Vector3 origin = GetPosition(bot);

            float angleSpread = 70f;
            float angleBase = -angleSpread * 0.5f + (groupCount > 1 ? (index * (angleSpread / (groupCount - 1))) : 0f);
            Quaternion offsetRot = Quaternion.Euler(0f, angleBase, 0f);
            Vector3 retreatDir = offsetRot * -threatDir.normalized;
            Vector3 retreatTarget = origin + retreatDir * SquadRetreatDistance;

            if (!NavMesh.SamplePosition(retreatTarget, out var navHit, 2.2f, NavMesh.AllAreas))
            {
                result.Add(origin);
                return result;
            }
            result.Add(origin);
            result.Add(navHit.position);
            return result;
        }

        #endregion

        #region Look / Aim Overlay

        /// <summary>
        /// Smoothly rotates bot to look at target, with human-clamped speed.
        /// Never called from tick-move logic. Overlay/anticipation only.
        /// </summary>
        public static void SmoothLookTo(BotOwner bot, Vector3 target, float speed = LookSmoothSpeed)
        {
            if (!IsAlive(bot) || bot.Transform == null) return;

            Vector3 dir = (target - bot.Transform.position);
            if (dir.sqrMagnitude < 0.0001f) return;

            dir.Normalize();
            Quaternion currentRot = bot.Transform.rotation;
            Quaternion targetRot = Quaternion.LookRotation(dir);

            float maxStep = LookMaxDegPerSec * Mathf.Clamp01(Time.deltaTime);
            float angle = Quaternion.Angle(currentRot, targetRot);
            float t = (angle < maxStep) ? 1f : maxStep / angle;
            bot.Transform.rotation = Quaternion.Slerp(currentRot, targetRot, t);
        }

        #endregion

        #region Utility & Safety

        public static Vector3 GetPosition(BotOwner bot)
        {
            if (bot == null) return Vector3.zero;
            var player = bot.GetPlayer;
            if (player != null && player.Transform != null)
                return player.Transform.position;
            if (bot.Transform != null)
                return bot.Transform.position;
            return Vector3.zero;
        }

        public static Vector3 ApplyMicroDrift(Vector3 pos, string profileId, int tick, BotPersonalityProfile profile)
        {
            float baseMag = 0.13f;
            float bias = profile != null
                ? Mathf.Clamp(1f + profile.MovementJitter * 0.22f, 0.87f, 1.18f)
                : 1f;

            int hash = (profileId?.GetHashCode() ?? 0) ^ (tick * 19) ^ 0x4A8BC13F;
            unchecked
            {
                hash = (hash ^ (hash >> 13)) * 0x6A5D39E9;
                float dx = ((hash & 0xFF) / 255f - 0.5f) * baseMag * bias;
                float dz = (((hash >> 8) & 0xFF) / 255f - 0.5f) * baseMag * bias;
                return pos + new Vector3(dx, 0f, dz);
            }
        }

        public static bool IsStuckAtTarget(BotOwner bot)
        {
            var cache = bot?.GetComponent<BotComponentCache>()?.MoveCache;
            if (cache == null) return false;

            Vector3 current = GetPosition(bot);
            float moved = (current - cache.LastIssuedTarget).sqrMagnitude;
            return moved < 0.015f && (Time.time - cache.LastMoveTime) > StuckTimeout;
        }

        public static void Reset(BotOwner bot)
        {
            var cache = bot?.GetComponent<BotComponentCache>()?.MoveCache;
            if (cache == null) return;

            cache.LastMoveTime = -1000f;
            cache.LastIssuedTarget = Invalid;
        }

        private static bool IsValid(Vector3 pos)
        {
            return !float.IsNaN(pos.x) && !float.IsInfinity(pos.x) &&
                   !float.IsNaN(pos.y) && !float.IsInfinity(pos.y) &&
                   !float.IsNaN(pos.z) && !float.IsInfinity(pos.z);
        }

        private static bool IsAlive(BotOwner bot)
        {
            return bot != null && bot.GetPlayer != null && bot.GetPlayer.HealthController?.IsAlive == true;
        }

        /// <summary>
        /// Checks if bot is currently paused or blocked (animation, heal, loot, etc).
        /// </summary>
        public static bool IsMovementPaused(BotOwner bot)
        {
            if (bot?.Mover == null)
                return false;
            if (bot.Mover.Pause)
                return true;
            if (bot.Mover.RemainPause > 0.01f)
                return true;
            return false;
        }

        private static bool IsInInteractionState(BotOwner bot)
        {
            var player = bot?.GetPlayer;
            if (player == null) return false;
            var state = player.CurrentStateName;
            return state == EPlayerState.Loot ||
                   state == EPlayerState.Pickup ||
                   state == EPlayerState.Open ||
                   state == EPlayerState.Close ||
                   state == EPlayerState.Unlock ||
                   state == EPlayerState.Plant ||
                   state == EPlayerState.Approach;
        }

        public static void SmoothMoveToSafeExit(BotOwner bot, Vector3 destination, bool slow = true, float cohesion = 1f)
        {
            SmoothMoveToSafe(bot, destination, slow, cohesion);
        }

        #endregion
    }
}
