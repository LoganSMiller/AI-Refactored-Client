// <auto-generated>
//   This file is part of AI-Refactored, an open-source project focused on realistic AI behavior in Escape from Tarkov.
//   Licensed under the MIT License. See LICENSE in the repository root for more information.
//
//   THIS FILE IS SYSTEMATICALLY MANAGED.
//   Please follow strict StyleCop, ReSharper, and AI-Refactored code standards for all modifications.
// </auto-generated>

namespace AIRefactored.AI.Helpers
{
    using UnityEngine;

    /// <summary>
    /// Evaluates directional exposure to high-intensity light sources like flashlights and flares.
    /// Used by AI vision systems for flashblindness detection, light evasion, and behavioral reactions.
    /// </summary>
    public static class FlashLightUtils
    {
        /// <summary>
        /// Returns a visibility score between 0 and 1 based on angle and distance to flashlight.
        /// Combines frontal alignment and proximity to determine severity of exposure.
        /// </summary>
        public static float CalculateFlashScore(
            Transform lightTransform,
            Transform botHeadTransform,
            float maxDistance = 20f)
        {
            // Null check for safety
            if (lightTransform == null || botHeadTransform == null)
            {
                return 0f;
            }

            Vector3 toLight = lightTransform.position - botHeadTransform.position;
            float distance = toLight.magnitude;

            // Return 0 if the distance is too small or too far
            if (distance < 0.01f || distance > maxDistance)
            {
                return 0f;
            }

            // Calculate the angle between the bot's forward direction and the direction to the light
            Vector3 botForward = botHeadTransform.forward.normalized;
            Vector3 lightDir = toLight.normalized;
            float angleFactor = Mathf.Clamp01(Vector3.Dot(botForward, lightDir));

            // Calculate distance factor based on max distance
            float distanceFactor = 1f - Mathf.Clamp01(distance / maxDistance);

            // Return the combined score
            return angleFactor * distanceFactor;
        }

        /// <summary>
        /// Calculates the normalized frontal exposure to a flashlight.
        /// </summary>
        public static float GetFlashIntensityFactor(
            Transform lightTransform,
            Transform botHeadTransform)
        {
            // Null check for safety
            if (lightTransform == null || botHeadTransform == null)
            {
                return 0f;
            }

            // Calculate the vector pointing from bot to the light
            Vector3 toLight = (lightTransform.position - botHeadTransform.position).normalized;
            Vector3 forward = botHeadTransform.forward.normalized;

            // Calculate the angle between the bot's forward direction and the light direction
            return Mathf.Clamp01(Vector3.Dot(forward, toLight));
        }

        /// <summary>
        /// Determines whether the bot is facing a light source within a dangerous exposure cone.
        /// </summary>
        public static bool IsBlindingLight(
            Transform lightTransform,
            Transform botHeadTransform,
            float angleThreshold = 30f)
        {
            // Null check for safety
            if (lightTransform == null || botHeadTransform == null)
            {
                return false;
            }

            // Calculate the angle between the bot's forward direction and the light direction
            Vector3 toLight = lightTransform.position - botHeadTransform.position;
            float angle = Vector3.Angle(botHeadTransform.forward, toLight);

            // Return true if the angle is within the threshold
            return angle <= angleThreshold;
        }

        /// <summary>
        /// Determines if the flashlight is pointing toward the bot within the specified angle threshold.
        /// </summary>
        public static bool IsFacingTarget(
            Transform source,
            Transform target,
            float angleThreshold = 30f)
        {
            // Null check for safety
            if (source == null || target == null)
            {
                return false;
            }

            // Calculate the direction from the source to the target
            Vector3 toTarget = target.position - source.position;
            float angle = Vector3.Angle(source.forward, toTarget);

            // Return true if the angle is within the threshold
            return angle <= angleThreshold;
        }
    }
}
