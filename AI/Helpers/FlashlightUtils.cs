// <auto-generated>
//   AI-Refactored: FlashLightUtils.cs (Supreme Arbitration Overlay/Event Edition – Light Exposure Realism, June 2025)
//   All vision/light exposure logic bulletproof, deterministic, multiplayer/headless-safe, overlay/event only.
//   All transforms must be pre-validated. No allocations, no invalid Unity calls. MIT License.
// </auto-generated>

namespace AIRefactored.AI.Helpers
{
    using UnityEngine;

    /// <summary>
    /// Evaluates directional exposure to high-intensity light sources like flashlights and flares.
    /// Used by AI vision systems for flashblindness detection, evasion, and behavioral reactions.
    /// Bulletproof: all logic is overlay/event-safe, null-guarded, and deterministic.
    /// </summary>
    public static class FlashLightUtils
    {
        /// <summary>
        /// Returns a normalized [0,1] flash exposure score based on proximity and alignment.
        /// Overlay/event only. No allocations. All input transforms must be pre-validated.
        /// </summary>
        public static float CalculateFlashScore(Transform lightTransform, Transform botHeadTransform, float maxDistance = 20f)
        {
            if (!IsValid(lightTransform) || !IsValid(botHeadTransform))
                return 0f;

            Vector3 toBot = botHeadTransform.position - lightTransform.position;
            float distance = toBot.magnitude;

            if (distance < 0.01f || distance > maxDistance || float.IsNaN(distance))
                return 0f;

            // Alignment: is light pointed toward the bot's head
            float lightToBotDot = Vector3.Dot(lightTransform.forward, toBot.normalized);
            if (float.IsNaN(lightToBotDot))
                return 0f;

            // Alignment: is bot looking at light
            float botToLightDot = Vector3.Dot(botHeadTransform.forward, (lightTransform.position - botHeadTransform.position).normalized);
            if (float.IsNaN(botToLightDot))
                return 0f;

            float alignFactor = Mathf.Clamp01(botToLightDot);
            float facingFactor = Mathf.Clamp01(lightToBotDot);
            float distFactor = 1f - Mathf.Clamp01(distance / maxDistance);

            // Requires both to be facing each other, boosts exposure score
            float score = alignFactor * facingFactor * distFactor;

            // If both are well aligned and close, boost
            if (alignFactor > 0.93f && facingFactor > 0.85f && distance < maxDistance * 0.7f)
                return Mathf.Clamp01(score * 1.18f);

            return Mathf.Clamp01(score);
        }

        /// <summary>
        /// Returns a frontal dot product (0 = behind, 1 = directly in front) of light vs bot head.
        /// Overlay/event only. No allocations.
        /// </summary>
        public static float GetFlashIntensityFactor(Transform lightTransform, Transform botHeadTransform)
        {
            if (!IsValid(lightTransform) || !IsValid(botHeadTransform))
                return 0f;

            float dot = Vector3.Dot(botHeadTransform.forward, (lightTransform.position - botHeadTransform.position).normalized);
            return float.IsNaN(dot) ? 0f : Mathf.Clamp01(dot);
        }

        /// <summary>
        /// Returns true if bot is within light cone angle. Overlay/event only.
        /// </summary>
        public static bool IsBlindingLight(Transform lightTransform, Transform botHeadTransform, float angleThreshold = 30f)
        {
            if (!IsValid(lightTransform) || !IsValid(botHeadTransform))
                return false;

            float angle = Vector3.Angle(lightTransform.forward, botHeadTransform.position - lightTransform.position);
            return !float.IsNaN(angle) && angle <= angleThreshold;
        }

        /// <summary>
        /// Returns true if light is pointed directly at bot’s head (for flashblindness, overlay/event only).
        /// </summary>
        public static bool IsFacingTarget(Transform source, Transform target, float angleThreshold = 30f)
        {
            if (!IsValid(source) || !IsValid(target))
                return false;

            float angle = Vector3.Angle(source.forward, target.position - source.position);
            return !float.IsNaN(angle) && angle <= angleThreshold;
        }

        /// <summary>
        /// Null-safe validation for transform usage.
        /// </summary>
        private static bool IsValid(Transform tf)
        {
            return tf != null &&
                   !float.IsNaN(tf.position.x) && !float.IsInfinity(tf.position.x) &&
                   !float.IsNaN(tf.position.y) && !float.IsInfinity(tf.position.y) &&
                   !float.IsNaN(tf.position.z) && !float.IsInfinity(tf.position.z) &&
                   !float.IsNaN(tf.forward.x) && !float.IsInfinity(tf.forward.x) &&
                   !float.IsNaN(tf.forward.y) && !float.IsInfinity(tf.forward.y) &&
                   !float.IsNaN(tf.forward.z) && !float.IsInfinity(tf.forward.z);
        }
    }
}
