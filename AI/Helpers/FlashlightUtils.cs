// <auto-generated>
//   AI-Refactored: FlashLightUtils.cs (Supreme Arbitration Overlay/Event Edition – Light Exposure Realism, Max Features, June 2025)
//   All vision/light exposure logic bulletproof, deterministic, multiplayer/headless-safe, overlay/event only.
//   Supports cone, color, strobe, intensity, and per-eye scoring. No allocations, no invalid Unity calls. MIT License.
// </auto-generated>

namespace AIRefactored.AI.Helpers
{
    using UnityEngine;

    /// <summary>
    /// Evaluates directional exposure to high-intensity light sources (flashlights, flares, laser, strobe).
    /// Used by AI vision and perception systems for flashblindness, evasion, panic, suppression, and strobe-triggered reaction.
    /// Bulletproof: All logic is overlay/event-safe, null-guarded, deterministic, multiplayer/headless parity.
    /// </summary>
    public static class FlashLightUtils
    {
        #region Constants

        private const float DefaultMaxDistance = 24f;
        private const float DefaultConeAngle = 35f;
        private const float DefaultStrobeBoost = 1.14f;
        private const float MinEffectiveIntensity = 1.1f;
        private const float EyeOffset = 0.13f;

        #endregion

        #region Main API

        /// <summary>
        /// Returns a normalized [0,1] flash exposure score based on proximity, cone, alignment, intensity, strobe, and color.
        /// Overlay/event only. All transforms pre-validated. Never allocates.
        /// </summary>
        public static float CalculateFlashScore(
            Transform lightTransform,
            Transform botHeadTransform,
            float intensity = 1.0f,
            float maxDistance = DefaultMaxDistance,
            float coneAngle = DefaultConeAngle,
            bool isStrobing = false,
            Color? lightColor = null)
        {
            if (!IsValid(lightTransform) || !IsValid(botHeadTransform))
                return 0f;

            // Calculate vector from light to "eye"
            Vector3 eyePos = botHeadTransform.position + botHeadTransform.up * EyeOffset;
            Vector3 toBot = eyePos - lightTransform.position;
            float distance = toBot.magnitude;

            if (distance < 0.01f || distance > maxDistance || float.IsNaN(distance))
                return 0f;

            float coneAngleActual = coneAngle > 0.1f ? coneAngle : DefaultConeAngle;
            float angleToBot = Vector3.Angle(lightTransform.forward, toBot);
            if (float.IsNaN(angleToBot) || angleToBot > coneAngleActual)
                return 0f;

            // How well is bot head facing the light?
            float botFacing = Mathf.Clamp01(Vector3.Dot(botHeadTransform.forward, (lightTransform.position - eyePos).normalized));
            // How well is light facing bot?
            float lightFacing = Mathf.Clamp01(Vector3.Dot(lightTransform.forward, (eyePos - lightTransform.position).normalized));
            // How centered is bot in light cone?
            float coneFactor = 1f - Mathf.Clamp01(angleToBot / coneAngleActual);
            // Intensity factor, clamped to minimum.
            float intensityFactor = Mathf.Clamp01(intensity / MinEffectiveIntensity);

            // Color boost (white and blue are harshest, red/green/yellow much less)
            float colorFactor = 1f;
            if (lightColor.HasValue)
            {
                Color c = lightColor.Value;
                if (c.b > 0.7f && c.r < 0.5f) colorFactor += 0.07f; // harsh blue
                if (c.g > 0.75f && c.b < 0.3f) colorFactor -= 0.10f; // soft green
                if (c.r > 0.9f && c.g > 0.7f) colorFactor -= 0.18f; // warm yellow
                if (c.r > 0.92f && c.g < 0.5f) colorFactor -= 0.23f; // red
            }

            float distFactor = 1f - Mathf.Clamp01(distance / maxDistance);

            // Main score: everything multiplied for realism
            float score = botFacing * lightFacing * coneFactor * distFactor * intensityFactor * colorFactor;
            if (isStrobing)
                score *= DefaultStrobeBoost;

            // Ultra-close boost if fully aligned and strobing
            if (score > 0.88f && distance < (maxDistance * 0.4f) && isStrobing)
                score = Mathf.Clamp01(score * 1.18f);

            return Mathf.Clamp01(score);
        }

        /// <summary>
        /// Returns the "flash intensity" factor from bot POV (1 = directly in eyes, 0 = side/back).
        /// Overlay/event only. No allocations.
        /// </summary>
        public static float GetFlashIntensityFactor(Transform lightTransform, Transform botHeadTransform)
        {
            if (!IsValid(lightTransform) || !IsValid(botHeadTransform))
                return 0f;
            float dot = Vector3.Dot(botHeadTransform.forward, (lightTransform.position - botHeadTransform.position).normalized);
            return float.IsNaN(dot) ? 0f : Mathf.Clamp01(dot);
        }

        /// <summary>
        /// True if bot is within the light cone angle (used for flashblindness checks).
        /// </summary>
        public static bool IsBlindingLight(Transform lightTransform, Transform botHeadTransform, float angleThreshold = DefaultConeAngle)
        {
            if (!IsValid(lightTransform) || !IsValid(botHeadTransform))
                return false;
            float angle = Vector3.Angle(lightTransform.forward, botHeadTransform.position - lightTransform.position);
            return !float.IsNaN(angle) && angle <= angleThreshold;
        }

        /// <summary>
        /// True if light is pointed directly at bot's head (for quick exposure detection, overlay/event only).
        /// </summary>
        public static bool IsFacingTarget(Transform source, Transform target, float angleThreshold = DefaultConeAngle)
        {
            if (!IsValid(source) || !IsValid(target))
                return false;
            float angle = Vector3.Angle(source.forward, target.position - source.position);
            return !float.IsNaN(angle) && angle <= angleThreshold;
        }

        /// <summary>
        /// Returns the "panic/contagion risk" multiplier if bot is exposed to strobe or ultra-bright light.
        /// </summary>
        public static float GetPanicStrobeMultiplier(bool isStrobing, float flashScore)
        {
            if (!isStrobing || flashScore < 0.66f)
                return 1f;
            // High strobe+alignment raises panic risk by 15-28%
            return 1.15f + Mathf.Clamp01(flashScore - 0.7f) * 0.13f;
        }

        /// <summary>
        /// Returns a [0,1] flash risk value using all parameters, for use in panic overlays or squad sync.
        /// Overlay/event only. No allocations.
        /// </summary>
        public static float GetFlashRiskScore(
            Transform lightTransform,
            Transform botHeadTransform,
            float intensity = 1.0f,
            bool isStrobing = false,
            Color? color = null)
        {
            float raw = CalculateFlashScore(lightTransform, botHeadTransform, intensity, DefaultMaxDistance, DefaultConeAngle, isStrobing, color);
            if (isStrobing && raw > 0.73f)
                raw = Mathf.Clamp01(raw * 1.15f);
            return raw;
        }

        /// <summary>
        /// Null-safe transform validation for all overlay/event calls.
        /// </summary>
        private static bool IsValid(Transform tf)
        {
            return tf != null &&
                   !float.IsNaN(tf.position.x) && !float.IsInfinity(tf.position.x) &&
                   !float.IsNaN(tf.position.y) && !float.IsInfinity(tf.position.y) &&
                   !float.IsNaN(tf.position.z) && !float.IsInfinity(tf.position.z) &&
                   !float.IsNaN(tf.forward.x) && !float.IsInfinity(tf.forward.x) &&
                   !float.IsNaN(tf.forward.y) && !float.IsInfinity(tf.forward.y) &&
                   !float.IsNaN(tf.forward.z) && !float.IsInfinity(tf.forward.z);
        }

        #endregion
    }
}
