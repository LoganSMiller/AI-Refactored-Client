// <auto-generated>
//   AI-Refactored: BotSuppressionHelper.cs (Supreme Arbitration Overlay/Event, Max Realism, June 2025 – Ultimate Feature Expansion)
//   100% overlay/event-driven suppression, panic, fallback, and squad contagion. Bulletproof, pooled, and multiplayer/headless safe.
//   Real-world LOS/cover, squad echo, danger memory, personality, damage, wounds, angle/context, and voice escalation.
//   No speculative API, zero hot-path allocation, error-contained. MIT License.
// </auto-generated>

namespace AIRefactored.AI.Helpers
{
    using System;
    using System.Collections.Generic;
    using AIRefactored.AI.Core;
    using AIRefactored.AI.Memory;
    using AIRefactored.Pools;
    using AIRefactored.Core;
    using BepInEx.Logging;
    using EFT;
    using UnityEngine;

    /// <summary>
    /// Maximum-realism suppression, panic, fallback, and squad contagion logic.
    /// Real-world angle/LOS, cover checks, personality, squad echo, damage/wound factoring, and tactical memory.
    /// All overlay/event only, pooled, error-isolated, and multiplayer/headless safe.
    /// </summary>
    public static class BotSuppressionHelper
    {
        #region Constants

        private const float SuppressionBaseDuration = 2.5f;
        private const float SuppressionDurationVariance = 1.6f;
        private const float SuppressionChainRadius = 13.5f;
        private const float SuppressionChainRadiusSqr = SuppressionChainRadius * SuppressionChainRadius;
        private const float MinSuppressionThreshold = 0.17f;
        private const float SquadPropagationChance = 0.6f;
        private const float DangerZoneRadius = 7.5f;
        private const float SuppressionMinDamage = 0.04f;
        private const float MaxSuppressionAngle = 125f; // Field of fire for suppression
        private const float SquadEchoCooldown = 2.8f;
        private const float LOSCheckStep = 0.68f; // Step size for cover/LOS raycast

        #endregion

        #region State

        private static readonly ManualLogSource Logger = Plugin.LoggerInstance;

        // Memory to prevent squad echo spam
        private static readonly Dictionary<string, float> LastSquadSuppressed = new Dictionary<string, float>(64);

        // Track which bots are recently suppressed for voice logic
        private static readonly Dictionary<string, float> RecentSuppressedBots = new Dictionary<string, float>(128);

        #endregion

        #region Main API

        /// <summary>
        /// Should suppression be triggered based on line of sight, angle, threat proximity, and context?
        /// </summary>
        public static bool ShouldTriggerSuppression(Player player, Vector3? threat = null, float visibleDistThreshold = 13f, float ambientThreshold = 0.22f)
        {
            try
            {
                if (!EFTPlayerUtil.IsValid(player) || !player.IsAI)
                    return false;

                BotOwner owner = player.AIData?.BotOwner;
                if (owner == null) return false;

                float visibleDist = owner.LookSensor != null ? owner.LookSensor.ClearVisibleDist : 0f;
                float ambientLight = 0.5f;
                try { ambientLight = RenderSettings.ambientLight.grayscale; } catch { }

                bool lowVis = visibleDist < visibleDistThreshold;
                bool lowLight = ambientLight < ambientThreshold;

                if (!threat.HasValue)
                    return (lowVis || lowLight);

                Vector3 playerPos = EFTPlayerUtil.GetPosition(player);
                Vector3 threatVec = (threat.Value - playerPos);
                float distSqr = threatVec.sqrMagnitude;

                // Must be within realistic threat distance
                if (distSqr > SuppressionChainRadiusSqr * 1.22f)
                    return false;

                // Angle: must be within field of fire
                Vector3 fwd = player.LookDirection.normalized;
                float angle = Vector3.Angle(fwd, threatVec.normalized);
                if (angle > MaxSuppressionAngle)
                    return false;

                // Cover/LOS check (raycast)—suppression less likely if full cover exists
                if (HasCoverBetween(playerPos, threat.Value))
                    return false;

                // Already panicking?
                var cache = BotCacheUtility.GetCache(owner);
                if (cache?.PanicHandler != null && cache.PanicHandler.IsPanicking)
                    return false;

                return (lowVis || lowLight || distSqr < SuppressionChainRadiusSqr);
            }
            catch (Exception ex)
            {
                Logger.LogError($"[BotSuppressionHelper] ShouldTriggerSuppression failed: {ex}");
                return false;
            }
        }

        /// <summary>
        /// Triggers suppression/panic, danger memory, and full squad echo/contagion, voice escalation, context and cover aware.
        /// Overlay/event only, multiplayer/headless safe, pooled and error contained.
        /// </summary>
        public static void TrySuppressBot(Player player, Vector3 threatPos, IPlayer source = null, float rawDamage = 0f, bool forceEcho = false)
        {
            try
            {
                if (!EFTPlayerUtil.IsValid(player) || !player.IsAI) return;
                BotOwner owner = player.AIData?.BotOwner;
                if (owner == null || owner.IsDead) return;

                BotComponentCache cache = BotCacheUtility.GetCache(owner);
                if (cache == null || cache.PanicHandler == null || cache.PanicHandler.IsPanicking) return;

                float suppressionScore = CalculateSuppressionScore(cache, player, threatPos, rawDamage);

                if (suppressionScore < MinSuppressionThreshold && !forceEcho)
                    return;

                // Don't double suppress if already in memory (avoids echo spam)
                float now = Time.time;
                string id = owner.ProfileId;
                if (RecentSuppressedBots.TryGetValue(id, out float last) && now - last < 0.95f && !forceEcho)
                    return;

                cache.PanicHandler.TriggerPanic("suppression");
                RecentSuppressedBots[id] = now;
                MarkDangerZone(owner, threatPos);

                bool saidSuppressed = false;
                // Voice: Squad echo logic (rate-limited, only 1 voice within cooldown)
                string groupId = owner.GetPlayer?.Profile?.Info?.GroupId;
                if (!string.IsNullOrEmpty(groupId))
                {
                    if (!LastSquadSuppressed.TryGetValue(groupId, out float lastSquad) || now - lastSquad > SquadEchoCooldown || forceEcho)
                    {
                        if (!FikaHeadlessDetector.IsHeadless && owner.BotTalk != null)
                        {
                            try { owner.BotTalk.TrySay(EPhraseTrigger.Suppress); saidSuppressed = true; } catch { }
                        }
                        LastSquadSuppressed[groupId] = now;
                    }
                }
                else if (!FikaHeadlessDetector.IsHeadless && owner.BotTalk != null && !saidSuppressed)
                {
                    try { owner.BotTalk.TrySay(EPhraseTrigger.Suppress); } catch { }
                }

                // Squad Contagion—fully personality and context aware
                PropagateSuppressionToSquad(owner, cache, threatPos, suppressionScore);

                // Tactical memory
                try { owner.Memory?.SetUnderFire(source); } catch { }
            }
            catch (Exception ex)
            {
                Logger.LogError($"[BotSuppressionHelper] TrySuppressBot failed: {ex}");
            }
        }

        #endregion

        #region Calculation/Helper Logic

        /// <summary>
        /// Calculates suppression score with context, wounds, personality, damage, distance, and angle.
        /// </summary>
        private static float CalculateSuppressionScore(BotComponentCache cache, Player player, Vector3 threatPos, float rawDamage)
        {
            float caution = cache?.PersonalityProfile?.Caution ?? 0.6f;
            float wounds = 0.0f;
            var health = player?.HealthController;
            if (health != null)
            {
                float max = 0f, current = 0f;
                foreach (EBodyPart part in Enum.GetValues(typeof(EBodyPart)))
                {
                    var v = health.GetBodyPartHealth(part);
                    max += v.Maximum;
                    current += v.Current;
                }
                wounds = max > 0f ? (max - current) / max : 0f;
            }

            Vector3 playerPos = EFTPlayerUtil.GetPosition(player);
            float threatDist = (playerPos - threatPos).sqrMagnitude;
            float distFactor = Mathf.Clamp01(1f - (threatDist / (SuppressionChainRadiusSqr * 1.3f)));
            float rawFactor = Mathf.Clamp01(rawDamage / 60f);

            // Angle bias: bots facing away are less likely to be fully suppressed
            Vector3 toThreat = (threatPos - playerPos).normalized;
            Vector3 fwd = player.LookDirection.normalized;
            float angle = Vector3.Angle(fwd, toThreat);
            float anglePenalty = Mathf.Clamp01(angle / 180f);

            float suppression =
                0.21f +
                (caution * 0.28f) +
                (wounds * 0.18f) +
                (rawFactor * 0.23f) +
                (distFactor * 0.14f) -
                (anglePenalty * 0.15f);

            return Mathf.Clamp01(suppression);
        }

        /// <summary>
        /// Squad suppression contagion, personality/context aware, with randomized spread/jitter and cover checks.
        /// </summary>
        private static void PropagateSuppressionToSquad(BotOwner bot, BotComponentCache cache, Vector3 threat, float parentSuppression)
        {
            try
            {
                if (bot.BotsGroup == null || bot.BotsGroup.MembersCount < 2)
                    return;

                Vector3 myPos = bot.Position;
                int count = bot.BotsGroup.MembersCount;
                float now = Time.time;
                for (int i = 0; i < count; i++)
                {
                    BotOwner mate = bot.BotsGroup.Member(i);
                    if (mate == null || mate.IsDead || mate == bot) continue;

                    Vector3 matePos = mate.Position;
                    float distSqr = (matePos - myPos).sqrMagnitude;
                    if (distSqr > SuppressionChainRadiusSqr)
                        continue;

                    if (HasCoverBetween(matePos, threat))
                        continue;

                    float squadChance = SquadPropagationChance;
                    if (BotRegistry.TryGet(mate.ProfileId, out var mateProfile))
                    {
                        // Boost for fearful, penalty for frenzied, bias for low composure/caution
                        if (mateProfile.IsFearful) squadChance += 0.13f;
                        if (mateProfile.IsFrenzied) squadChance -= 0.11f;
                        squadChance += Mathf.Clamp01(1f - mateProfile.Cohesion) * 0.07f;
                        squadChance += Mathf.Clamp01(1f - mateProfile.Awareness) * 0.05f;
                    }

                    if (UnityEngine.Random.value > squadChance)
                        continue;

                    BotComponentCache mateCache = BotCacheUtility.GetCache(mate);
                    if (mateCache?.PanicHandler != null && !mateCache.PanicHandler.IsPanicking)
                    {
                        mateCache.PanicHandler.TriggerPanic("squad-suppression");
                        // Voice: Only escalate if squad echo is not on cooldown
                        string groupId = mate.GetPlayer?.Profile?.Info?.GroupId;
                        if (!string.IsNullOrEmpty(groupId) && (!LastSquadSuppressed.TryGetValue(groupId, out float lastSquad) || now - lastSquad > SquadEchoCooldown))
                        {
                            if (!FikaHeadlessDetector.IsHeadless && mate.BotTalk != null)
                            {
                                try { mate.BotTalk.TrySay(EPhraseTrigger.Suppress); } catch { }
                            }
                            LastSquadSuppressed[groupId] = now;
                        }
                    }
                }
            }
            catch (Exception ex)
            {
                Logger.LogError($"[BotSuppressionHelper] PropagateSuppressionToSquad failed: {ex}");
            }
        }

        /// <summary>
        /// Checks for hard cover/obstacle between two points using Physics.Raycast (pooled, step-wise for partial cover).
        /// Returns true if cover detected.
        /// </summary>
        private static bool HasCoverBetween(Vector3 from, Vector3 to)
        {
            Vector3 dir = (to - from);
            float dist = dir.magnitude;
            if (dist < 0.1f) return false;
            dir.Normalize();

            int steps = Mathf.CeilToInt(dist / LOSCheckStep);
            Vector3 step = dir * LOSCheckStep;
            Vector3 pos = from;

            for (int i = 0; i < steps; i++)
            {
                pos += step;
                if (Physics.Raycast(pos, dir, out RaycastHit hit, LOSCheckStep, AIRefactoredLayerMasks.CoverRayMask))
                {
                    // Consider any hit as hard cover for suppression
                    return true;
                }
            }
            return false;
        }

        /// <summary>
        /// Marks a tactical danger zone for fallback/awareness (overlay/event only).
        /// </summary>
        private static void MarkDangerZone(BotOwner bot, Vector3 position)
        {
            try
            {
                string mapId = GameWorldHandler.TryGetValidMapName() ?? bot.Profile?.Info?.EntryPoint ?? "unknown";
                BotMemoryStore.AddDangerZone(mapId, position, DangerTriggerType.Suppression, DangerZoneRadius);
            }
            catch (Exception ex)
            {
                Logger.LogError($"[BotSuppressionHelper] MarkDangerZone failed: {ex}");
            }
        }

        #endregion

        #region Diagnostics

        /// <summary>
        /// Returns true if the player is currently suppressed/panicking (event/overlay only).
        /// </summary>
        public static bool IsSuppressed(Player player)
        {
            try
            {
                BotOwner owner = player.AIData?.BotOwner;
                BotComponentCache cache = BotCacheUtility.GetCache(owner);
                return cache?.PanicHandler != null && cache.PanicHandler.IsPanicking;
            }
            catch { return false; }
        }

        /// <summary>
        /// Call on raid end to clear all suppression/voice tracking memory.
        /// </summary>
        public static void ClearSuppressionMemory()
        {
            LastSquadSuppressed.Clear();
            RecentSuppressedBots.Clear();
        }

        #endregion
    }
}
