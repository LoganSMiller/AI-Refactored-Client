// <auto-generated>
//   This file is part of AI-Refactored, an open-source project focused on realistic AI behavior in Escape from Tarkov.
//   Licensed under the MIT License. See LICENSE in the repository root for more information.
//
//   THIS FILE IS SYSTEMATICALLY MANAGED.
//   Please follow strict StyleCop, ReSharper, and AI-Refactored code standards for all modifications.
// </auto-generated>

#nullable enable

namespace AIRefactored.AI.Helpers
{
    using AIRefactored.AI.Core;
    using EFT;
    using UnityEngine;

    /// <summary>
    /// Triggers suppression and panic behavior in AIRefactored bots.
    /// Simulates enemy fire pressure and flash-based fear effects.
    /// </summary>
    public static class BotSuppressionHelper
    {
        private const float FlashBlindDuration = 4.5f;

        /// <summary>
        /// Gets the BotOwner instance from a Player, if AI-controlled.
        /// </summary>
        /// <param name="player">The player to check.</param>
        /// <returns>The BotOwner instance, or null if not AI.</returns>
        public static BotOwner? GetBotOwner(Player? player)
        {
            if (player?.IsAI == true && player.AIData is BotOwner owner)
            {
                return owner;
            }

            return null;
        }

        /// <summary>
        /// Gets the BotComponentCache from a Player, if AI-controlled.
        /// </summary>
        /// <param name="player">The player to check.</param>
        /// <returns>The bot's BotComponentCache, or null if not AI.</returns>
        public static BotComponentCache? GetCache(Player? player)
        {
            if (player?.IsAI == true)
            {
                return BotCacheUtility.GetCache(player);
            }

            return null;
        }

        /// <summary>
        /// Evaluates whether suppression should occur based on bot visibility and ambient lighting.
        /// </summary>
        /// <param name="player">The player to evaluate.</param>
        /// <param name="visibleDistThreshold">The visibility distance threshold.</param>
        /// <param name="ambientThreshold">The ambient light threshold.</param>
        /// <returns>True if suppression should be triggered; otherwise, false.</returns>
        public static bool ShouldTriggerSuppression(
            Player? player,
            float visibleDistThreshold = 12f,
            float ambientThreshold = 0.25f)
        {
            BotOwner? owner = GetBotOwner(player);
            if (owner?.LookSensor == null)
            {
                return false;
            }

            float visibleDist = owner.LookSensor.ClearVisibleDist;
            float ambientLight = 0.5f;

            try
            {
                ambientLight = RenderSettings.ambientLight.grayscale;
            }
            catch
            {
                // fallback to default
            }

            return visibleDist < visibleDistThreshold || ambientLight < ambientThreshold;
        }

        /// <summary>
        /// Triggers suppression effects for a bot from a threat source.
        /// Applies panic or flash-based blindness depending on bot state.
        /// </summary>
        /// <param name="player">The player to suppress.</param>
        /// <param name="threatPosition">The world-space threat position.</param>
        /// <param name="source">The enemy player causing the suppression, if known.</param>
        public static void TrySuppressBot(Player? player, Vector3 threatPosition, IPlayer? source = null)
        {
            if (player == null || !player.IsAI)
            {
                return;
            }

            BotOwner? owner = GetBotOwner(player);
            BotComponentCache? cache = GetCache(player);

            if (owner == null || cache == null || owner.IsDead)
            {
                return;
            }

            if (owner.Memory != null)
            {
                owner.Memory.SetUnderFire(source);
            }

            if (cache.PanicHandler != null && !cache.PanicHandler.IsPanicking)
            {
                cache.PanicHandler.TriggerPanic();
            }
            else if (cache.FlashGrenade != null)
            {
                cache.FlashGrenade.ForceBlind();
            }
        }
    }
}
