// <auto-generated>
//   AI-Refactored: BotSuppressionHelper.cs (Supreme Arbitration Overlay/Event, Max Realism, June 2025 – Ultimate Feature Expansion)
//   100% overlay/event-driven suppression, panic, fallback, and squad contagion. Bulletproof, pooled, arbitration-locked, multiplayer/headless safe.
//   Real-world LOS/cover, squad echo, danger memory, personality, wounds, context, voice escalation, pooling, error isolation.
//   No speculative API, zero hot-path allocation, zero direct move, no cooldown gating, dedupe locked. MIT License.
// </auto-generated>

namespace AIRefactored.AI.Helpers
{
    using AIRefactored.AI.Core;
    using AIRefactored.AI.Memory;
    using AIRefactored.Core;
    using AIRefactored.Pools;
    using BepInEx.Logging;
    using EFT;
    using System;
    using System.Collections.Generic;
    using UnityEngine;
    using static AIRefactored.AI.Memory.BotMemoryStore;

    /// <summary>
    /// Max-realism suppression, panic, fallback, squad contagion and arbitration-locked squad echo.
    /// Field of fire/LOS/cover, wounds/personality/context/damage, danger memory, pooled and multiplayer/headless safe.
    /// Zero hot-path alloc, bulletproof and fully deduped.
    /// </summary>
    public static class BotSuppressionHelper
    {
        #region Constants

        private const float SuppressionChainRadius = 13.5f;
        private const float SuppressionChainRadiusSqr = SuppressionChainRadius * SuppressionChainRadius;
        private const float MinSuppressionThreshold = 0.17f;
        private const float SquadPropagationChance = 0.6f;
        private const float DangerZoneRadius = 7.5f;
        private const float MaxSuppressionAngle = 125f;
        private const float SquadEchoCooldown = 2.8f;
        private const float LOSCheckStep = 0.68f;

        #endregion

        #region State

        private static readonly ManualLogSource Logger = Plugin.LoggerInstance;

        // Prevents squad echo spam and double suppression
        private static readonly Dictionary<string, float> LastSquadSuppressed = new Dictionary<string, float>(64);
        private static readonly Dictionary<string, float> RecentSuppressedBots = new Dictionary<string, float>(128);

        #endregion

        #region Main API

        /// <summary>
        /// Should suppression trigger (event only)? True if real LOS, field, and context are valid.
        /// </summary>
        public static bool ShouldTriggerSuppression(Player player, Vector3? threat = null, float visibleDistThreshold = 13f, float ambientThreshold = 0.22f)
        {
            try
            {
                if (!EFTPlayerUtil.IsValid(player) || !player.IsAI) return false;
                BotOwner owner = player.AIData?.BotOwner;
                if (owner == null) return false;

                float visibleDist = owner.LookSensor?.ClearVisibleDist ?? 0f;
                float ambientLight = 0.5f;
                try { ambientLight = RenderSettings.ambientLight.grayscale; } catch { }

                bool lowVis = visibleDist < visibleDistThreshold;
                bool lowLight = ambientLight < ambientThreshold;
                if (!threat.HasValue)
                    return (lowVis || lowLight);

                Vector3 playerPos = EFTPlayerUtil.GetPosition(player);
                Vector3 threatVec = (threat.Value - playerPos);
                float distSqr = threatVec.sqrMagnitude;

                if (distSqr > SuppressionChainRadiusSqr * 1.22f)
                    return false;

                Vector3 fwd = player.LookDirection.normalized;
                float angle = Vector3.Angle(fwd, threatVec.normalized);
                if (angle > MaxSuppressionAngle)
                    return false;

                if (HasCoverBetween(playerPos, threat.Value))
                    return false;

                var cache = BotCacheUtility.GetCache(owner);
                if (cache?.PanicHandler != null && cache.PanicHandler.IsPanicking)
                    return false;

                return (lowVis || lowLight || distSqr < SuppressionChainRadiusSqr);
            }
            catch (Exception ex)
            {
                Logger.LogError($"[BotSuppressionHelper] ShouldTriggerSuppression failed: {ex}");
                return false;
            }
        }

        /// <summary>
        /// Overlay/event-only: triggers suppression/panic, danger memory, squad echo (arbitration-locked), voice escalation, and squad contagion.
        /// No spam, no double issue, pooled and error contained.
        /// </summary>
        public static void TrySuppressBot(Player player, Vector3 threatPos, IPlayer source = null, float rawDamage = 0f, bool forceEcho = false)
        {
            try
            {
                if (!EFTPlayerUtil.IsValid(player) || !player.IsAI) return;
                BotOwner owner = player.AIData?.BotOwner;
                if (owner == null || owner.IsDead) return;

                BotComponentCache cache = BotCacheUtility.GetCache(owner);
                if (cache == null || cache.PanicHandler == null || cache.PanicHandler.IsPanicking) return;

                float suppressionScore = CalculateSuppressionScore(cache, player, threatPos, rawDamage);
                if (suppressionScore < MinSuppressionThreshold && !forceEcho) return;

                float now = Time.time;
                string id = owner.ProfileId;
                if (RecentSuppressedBots.TryGetValue(id, out float last) && now - last < 0.95f && !forceEcho)
                    return;

                cache.PanicHandler.TriggerPanic("suppression");
                RecentSuppressedBots[id] = now;
                MarkDangerZone(owner, threatPos);

                // Squad echo: Only arbitration allows a squad Suppress phrase every SquadEchoCooldown
                string groupId = owner.GetPlayer?.Profile?.Info?.GroupId;
                bool saidSuppressed = false;
                if (!string.IsNullOrEmpty(groupId))
                {
                    if (!LastSquadSuppressed.TryGetValue(groupId, out float lastSquad) || now - lastSquad > SquadEchoCooldown || forceEcho)
                    {
                        if (!FikaHeadlessDetector.IsHeadless && owner.BotTalk != null)
                        {
                            try { owner.BotTalk.TrySay(EPhraseTrigger.Suppress); saidSuppressed = true; } catch { }
                        }
                        LastSquadSuppressed[groupId] = now;
                    }
                }
                else if (!FikaHeadlessDetector.IsHeadless && owner.BotTalk != null && !saidSuppressed)
                {
                    try { owner.BotTalk.TrySay(EPhraseTrigger.Suppress); } catch { }
                }

                // Squad suppression contagion: context and personality aware, arbitration-locked, deduped
                PropagateSuppressionToSquad(owner, cache, threatPos, suppressionScore);

                // Tactical memory
                try { owner.Memory?.SetUnderFire(source); } catch { }
            }
            catch (Exception ex)
            {
                Logger.LogError($"[BotSuppressionHelper] TrySuppressBot failed: {ex}");
            }
        }

        #endregion

        #region Helper/Logic

        /// <summary>
        /// Calculates suppression context, wounds, caution, damage, angle, and distance.
        /// </summary>
        private static float CalculateSuppressionScore(BotComponentCache cache, Player player, Vector3 threatPos, float rawDamage)
        {
            float caution = cache?.PersonalityProfile?.Caution ?? 0.6f;
            float wounds = 0.0f;
            var health = player?.HealthController;
            if (health != null)
            {
                float max = 0f, current = 0f;
                foreach (EBodyPart part in Enum.GetValues(typeof(EBodyPart)))
                {
                    var v = health.GetBodyPartHealth(part);
                    max += v.Maximum;
                    current += v.Current;
                }
                wounds = max > 0f ? (max - current) / max : 0f;
            }

            Vector3 playerPos = EFTPlayerUtil.GetPosition(player);
            float threatDist = (playerPos - threatPos).sqrMagnitude;
            float distFactor = Mathf.Clamp01(1f - (threatDist / (SuppressionChainRadiusSqr * 1.3f)));
            float rawFactor = Mathf.Clamp01(rawDamage / 60f);

            Vector3 toThreat = (threatPos - playerPos).normalized;
            Vector3 fwd = player.LookDirection.normalized;
            float angle = Vector3.Angle(fwd, toThreat);
            float anglePenalty = Mathf.Clamp01(angle / 180f);

            float suppression =
                0.21f +
                (caution * 0.28f) +
                (wounds * 0.18f) +
                (rawFactor * 0.23f) +
                (distFactor * 0.14f) -
                (anglePenalty * 0.15f);

            return Mathf.Clamp01(suppression);
        }

        /// <summary>
        /// Squad suppression contagion—arbitration-locked, context and personality aware, deduped, no spam.
        /// </summary>
        private static void PropagateSuppressionToSquad(BotOwner bot, BotComponentCache cache, Vector3 threat, float parentSuppression)
        {
            try
            {
                if (bot.BotsGroup == null || bot.BotsGroup.MembersCount < 2)
                    return;

                Vector3 myPos = bot.Position;
                int count = bot.BotsGroup.MembersCount;
                float now = Time.time;
                for (int i = 0; i < count; i++)
                {
                    BotOwner mate = bot.BotsGroup.Member(i);
                    if (mate == null || mate.IsDead || mate == bot) continue;

                    Vector3 matePos = mate.Position;
                    float distSqr = (matePos - myPos).sqrMagnitude;
                    if (distSqr > SuppressionChainRadiusSqr)
                        continue;
                    if (HasCoverBetween(matePos, threat))
                        continue;

                    float squadChance = SquadPropagationChance;
                    if (BotRegistry.TryGet(mate.ProfileId, out var mateProfile))
                    {
                        if (mateProfile.IsFearful) squadChance += 0.13f;
                        if (mateProfile.IsFrenzied) squadChance -= 0.11f;
                        squadChance += Mathf.Clamp01(1f - mateProfile.Cohesion) * 0.07f;
                        squadChance += Mathf.Clamp01(1f - mateProfile.Awareness) * 0.05f;
                    }

                    if (UnityEngine.Random.value > squadChance)
                        continue;

                    BotComponentCache mateCache = BotCacheUtility.GetCache(mate);
                    if (mateCache?.PanicHandler != null && !mateCache.PanicHandler.IsPanicking)
                    {
                        mateCache.PanicHandler.TriggerPanic("squad-suppression");
                        string groupId = mate.GetPlayer?.Profile?.Info?.GroupId;
                        if (!string.IsNullOrEmpty(groupId) &&
                            (!LastSquadSuppressed.TryGetValue(groupId, out float lastSquad) || now - lastSquad > SquadEchoCooldown))
                        {
                            if (!FikaHeadlessDetector.IsHeadless && mate.BotTalk != null)
                            {
                                try { mate.BotTalk.TrySay(EPhraseTrigger.Suppress); } catch { }
                            }
                            LastSquadSuppressed[groupId] = now;
                        }
                    }
                }
            }
            catch (Exception ex)
            {
                Logger.LogError($"[BotSuppressionHelper] PropagateSuppressionToSquad failed: {ex}");
            }
        }

        /// <summary>
        /// Returns true if cover/obstacle is present between points (stepwise ray, pooled, zero alloc).
        /// </summary>
        private static bool HasCoverBetween(Vector3 from, Vector3 to)
        {
            Vector3 dir = (to - from);
            float dist = dir.magnitude;
            if (dist < 0.1f) return false;
            dir.Normalize();

            int steps = Mathf.CeilToInt(dist / LOSCheckStep);
            Vector3 step = dir * LOSCheckStep;
            Vector3 pos = from;

            for (int i = 0; i < steps; i++)
            {
                pos += step;
                if (Physics.Raycast(pos, dir, out RaycastHit hit, LOSCheckStep, AIRefactoredLayerMasks.CoverRayMask))
                    return true;
            }
            return false;
        }

        /// <summary>
        /// Marks tactical danger zone for fallback/awareness overlays (event-only, pooled).
        /// </summary>
        private static void MarkDangerZone(BotOwner bot, Vector3 position)
        {
            try
            {
                string mapId = GameWorldHandler.TryGetValidMapName() ?? bot.Profile?.Info?.EntryPoint ?? "unknown";
                BotMemoryStore.AddDangerZone(mapId, position, DangerTriggerType.Suppression, DangerZoneRadius);
            }
            catch (Exception ex)
            {
                Logger.LogError($"[BotSuppressionHelper] MarkDangerZone failed: {ex}");
            }
        }

        #endregion

        #region Diagnostics

        /// <summary>
        /// True if bot is currently suppressed/panicking (event/overlay).
        /// </summary>
        public static bool IsSuppressed(Player player)
        {
            try
            {
                BotOwner owner = player.AIData?.BotOwner;
                BotComponentCache cache = BotCacheUtility.GetCache(owner);
                return cache?.PanicHandler != null && cache.PanicHandler.IsPanicking;
            }
            catch { return false; }
        }

        /// <summary>
        /// Call on raid end to clear all suppression/voice arbitration memory.
        /// </summary>
        public static void ClearSuppressionMemory()
        {
            LastSquadSuppressed.Clear();
            RecentSuppressedBots.Clear();
        }

        #endregion
    }
}
