// <auto-generated>
//   AI-Refactored: BotTacticalDeviceController.cs (Ultra-Platinum++ Overlay/Event-Only Edition, June 2025)
//   SYSTEMATICALLY MANAGED. Humanized tactical device toggling—chaos-bait, ambient/fog-aware, personality-integrated.
//   Bulletproof: pooling, null-guarded, error-isolated, multiplayer/headless safe, overlay/event-only (never tick-based).
//   MIT License.
// </auto-generated>

namespace AIRefactored.AI.Perception
{
    using System;
    using System.Collections.Generic;
    using AIRefactored.AI.Core;
    using AIRefactored.Core;
    using AIRefactored.Pools;
    using EFT;
    using EFT.InventoryLogic;
    using UnityEngine;

    /// <summary>
    /// Manages bot flashlight, laser, NVG, and thermal device logic.
    /// Overlay/event-only: never per-frame. Called only from BotBrain overlay tick.
    /// Realism: chaos-bait, ambient/fog detection, personality, squad/anti-echo.
    /// Bulletproof: pooling, null-guarded, error-isolated, multiplayer/headless safe.
    /// </summary>
    public sealed class BotTacticalDeviceController
    {
        #region Fields

        private BotOwner _bot;
        private BotComponentCache _cache;
        private float _nextDecisionTime;
        private bool _failed;

        // Anti-echo: Last squad device toggle
        private static readonly Dictionary<string, float> LastSquadToggle = new Dictionary<string, float>(24);

        #endregion

        #region Initialization

        /// <summary>
        /// Initializes the device controller for a bot (overlay/event-only).
        /// </summary>
        public void Initialize(BotComponentCache cache)
        {
            _failed = false;
            _nextDecisionTime = 0f;

            try
            {
                if (cache == null || cache.Bot == null)
                {
                    _failed = true;
                    return;
                }

                _bot = cache.Bot;
                _cache = cache;
            }
            catch (Exception ex)
            {
                _failed = true;
                Plugin.LoggerInstance.LogError($"[BotTacticalDeviceController] Initialize exception: {ex}");
            }
        }

        #endregion

        #region Overlay/Event Tick

        /// <summary>
        /// Overlay/event-only: Called ONLY from BotBrain overlay tick. Never per-frame.
        /// </summary>
        public void Tick()
        {
            if (_failed || !CanThink())
                return;

            try
            {
                _nextDecisionTime = Time.time + TacticalConfig.CheckInterval;

                Weapon weapon = _bot.WeaponManager?.CurrentWeapon;
                if (weapon == null)
                    return;

                var devices = TempListPool.Rent<LightComponent>();
                try
                {
                    ScanModsForTacticalDevices(weapon, devices);

                    bool isLowVisibility = IsLowVisibility();
                    float chaosChance = GetChaosBaitChance();
                    bool baitTrigger = UnityEngine.Random.value < chaosChance;
                    bool shouldEnable = isLowVisibility || baitTrigger;

                    // Squad/anti-echo: Only one squad member should flip device state at a time
                    string squadId = _bot.Profile?.Info?.GroupId ?? _bot.ProfileId;
                    float now = Time.time;
                    bool isLeader = IsSquadLeader(_bot);

                    if (shouldEnable && !IsSquadRecentlyToggled(squadId, now))
                    {
                        for (int i = 0, count = devices.Count; i < count; i++)
                        {
                            LightComponent device = devices[i];
                            if (device != null && !device.IsActive)
                                device.IsActive = true;
                        }
                        SetSquadToggle(squadId, now);
                    }
                    else if (!shouldEnable)
                    {
                        for (int i = 0, count = devices.Count; i < count; i++)
                        {
                            LightComponent device = devices[i];
                            if (device != null && device.IsActive)
                                device.IsActive = false;
                        }
                        SetSquadToggle(squadId, now);
                    }

                    // Chaos-bait: Occasionally toggle device state briefly for fakeout
                    if (baitTrigger && isLeader)
                    {
                        _nextDecisionTime = now + 1.6f + UnityEngine.Random.Range(-0.4f, 0.4f);
                        for (int i = 0, count = devices.Count; i < count; i++)
                        {
                            LightComponent device = devices[i];
                            if (device != null)
                                device.IsActive = false;
                        }
                        // Simulate brief off, then on again next tick.
                    }
                }
                finally
                {
                    TempListPool.Return(devices);
                }
            }
            catch (Exception ex)
            {
                _failed = true;
                Plugin.LoggerInstance.LogError($"[BotTacticalDeviceController] Tick exception: {ex}");
            }
        }

        #endregion

        #region Logic

        /// <summary>
        /// Returns true if bot is alive, valid, and ready for device logic.
        /// </summary>
        private bool CanThink()
        {
            return !_failed &&
                   _bot != null &&
                   _cache != null &&
                   !_bot.IsDead &&
                   Time.time >= _nextDecisionTime &&
                   EFTPlayerUtil.IsValid(_bot.GetPlayer) &&
                   _bot.GetPlayer.IsAI;
        }

        /// <summary>
        /// Returns chaos-bait trigger chance (personality-driven, awareness-inverse, role-dependent).
        /// </summary>
        private float GetChaosBaitChance()
        {
            try
            {
                var owner = _cache?.AIRefactoredBotOwner;
                if (owner == null || owner.PersonalityProfile == null)
                    return 0.01f;

                float baseChaos = owner.PersonalityProfile.ChaosFactor * 0.24f;
                float awarenessMod = 1f - Mathf.Clamp01(owner.PersonalityProfile.Awareness);
                float squadMod = IsSquadLeader(_bot) ? 1.15f : 0.84f;
                float roleMod = GetRoleChaosModifier();
                float fogBonus = IsLowVisibility() ? 0.14f : 0f;
                return Mathf.Clamp01((baseChaos * (0.7f + 0.6f * awarenessMod) * squadMod * roleMod) + fogBonus);
            }
            catch (Exception ex)
            {
                _failed = true;
                Plugin.LoggerInstance.LogError($"[BotTacticalDeviceController] GetChaosBaitChance exception: {ex}");
                return 0.008f;
            }
        }

        /// <summary>
        /// True if low-light or fog warrants device enable.
        /// </summary>
        private static bool IsLowVisibility()
        {
            try
            {
                float ambient = RenderSettings.ambientLight.grayscale;
                float fogDensity = RenderSettings.fog ? RenderSettings.fogDensity : 0f;
                // No custom weather proxy (headless safe). 
                // Consider it "dark" if ambient is low, or fog is heavy.
                return (ambient < TacticalConfig.LightThreshold) || (fogDensity > TacticalConfig.FogThreshold);
            }
            catch
            {
                return false;
            }
        }

        /// <summary>
        /// Finds all attached tactical devices (light/laser/nvg/thermal) on the weapon, pooled/zero-alloc.
        /// </summary>
        private static void ScanModsForTacticalDevices(Weapon weapon, List<LightComponent> result)
        {
            if (weapon == null || result == null)
                return;

            var slots = weapon.AllSlots;
            if (slots == null)
                return;

            foreach (Slot slot in slots)
            {
                if (slot == null)
                    continue;

                Item mod = slot.ContainedItem;
                if (mod == null || mod.Template == null)
                    continue;

                string name = mod.Template.Name?.ToLowerInvariant();
                if (string.IsNullOrEmpty(name) || !IsTacticalName(name))
                    continue;

                if (mod is FlashlightItemClass flash && flash.Light != null)
                    result.Add(flash.Light);
                else if (mod is TacticalComboItemClass combo && combo.Light != null)
                    result.Add(combo.Light);
                else if (mod is LightLaserItemClass laser && laser.Light != null)
                    result.Add(laser.Light);
                // Add NVG/Thermal support if class exposed
            }
        }

        /// <summary>
        /// True if name contains a tactical device keyword.
        /// </summary>
        private static bool IsTacticalName(string name)
        {
            var keywords = TacticalConfig.Keywords;
            for (int i = 0; i < keywords.Length; i++)
                if (name.Contains(keywords[i]))
                    return true;
            return false;
        }

        /// <summary>
        /// Returns true if this bot is the logical leader in its squad/group.
        /// </summary>
        private static bool IsSquadLeader(BotOwner bot)
        {
            try
            {
                var group = bot?.BotsGroup;
                if (group == null || group.MembersCount < 1)
                    return true;
                // Use the lowest profileId as deterministic leader
                string myId = bot.ProfileId;
                string minId = myId;
                for (int i = 0; i < group.MembersCount; i++)
                {
                    var mate = group.Member(i);
                    if (mate == null) continue;
                    if (string.Compare(mate.ProfileId, minId, StringComparison.Ordinal) < 0)
                        minId = mate.ProfileId;
                }
                return myId == minId;
            }
            catch { return true; }
        }

        /// <summary>
        /// Returns additional chaos modifier based on squad role (aggressive roles more likely to bait).
        /// </summary>
        private float GetRoleChaosModifier()
        {
            try
            {
                var role = _bot?.Profile?.Info?.Settings?.Role ?? WildSpawnType.assault;
                switch (role)
                {
                    case WildSpawnType.assault:
                    case WildSpawnType.followerBully:
                    case WildSpawnType.bossBully:
                    case WildSpawnType.marksman:
                        return 1.18f;
                    case WildSpawnType.cursedAssault:
                    case WildSpawnType.bossKilla:
                    case WildSpawnType.bossTagilla:
                    case WildSpawnType.bossKnight:
                    case WildSpawnType.bossSanitar:
                    case WildSpawnType.bossGluhar:
                        return 1.34f;
                    case WildSpawnType.pmcBot:
                    case WildSpawnType.exUsec:
                    case WildSpawnType.sectantWarrior:
                        return 1.07f;
                    case WildSpawnType.sectantPriest:
                    case WildSpawnType.gifter:
                    case WildSpawnType.test:
                        return 0.84f;
                    default:
                        return 1.0f;
                }
            }
            catch { return 1.0f; }
        }

        /// <summary>
        /// Returns true if squad toggled tactical devices recently (prevents echo/flicker).
        /// </summary>
        private static bool IsSquadRecentlyToggled(string squadId, float now)
        {
            if (string.IsNullOrEmpty(squadId)) return false;
            if (LastSquadToggle.TryGetValue(squadId, out float last))
                return now - last < 1.85f;
            return false;
        }

        private static void SetSquadToggle(string squadId, float now)
        {
            if (string.IsNullOrEmpty(squadId)) return;
            LastSquadToggle[squadId] = now;
        }

        #endregion

        #region TacticalConfig

        private static class TacticalConfig
        {
            public const float CheckInterval = 2.0f;
            public const float FogThreshold = 0.5f;
            public const float LightThreshold = 0.3f;
            public static readonly string[] Keywords = { "light", "laser", "nvg", "thermal", "flash" };
        }

        #endregion
    }
}
