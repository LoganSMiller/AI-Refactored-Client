// <auto-generated>
//   This file is part of AI-Refactored, an open-source project focused on realistic AI behavior in Escape from Tarkov.
//   Licensed under the MIT License. See LICENSE in the repository root for more information.
//
//   THIS FILE IS SYSTEMATICALLY MANAGED.
//   Please follow strict StyleCop, ReSharper, and AI-Refactored code standards for all modifications.
// </auto-generated>

namespace AIRefactored.AI.Perception
{
    using AIRefactored.AI.Core;
    using AIRefactored.AI.Groups;
    using AIRefactored.AI.Helpers;
    using AIRefactored.Core;
    using EFT;
    using UnityEngine;

    /// <summary>
    /// Controls visual impairment from flashbangs, flares, and suppression.
    /// Adjusts vision range, triggers panic and speech, and propagates enemy awareness.
    /// </summary>
    public sealed class BotPerceptionSystem : IFlashReactiveBot
    {
        #region Constants

        private const float BlindSpeechThreshold = 0.4f;
        private const float FlareRecoverySpeed = 0.2f;
        private const float FlashRecoverySpeed = 0.5f;
        private const float MaxSightDistance = 70f;
        private const float MinSightDistance = 15f;
        private const float PanicTriggerThreshold = 0.6f;
        private const float SuppressionRecoverySpeed = 0.3f;

        #endregion

        #region State

        private float _blindStartTime = -1f;
        private float _flashBlindness;
        private float _flareIntensity;
        private float _suppressionFactor;

        private BotOwner _bot;
        private BotComponentCache _cache;
        private BotVisionProfile _profile;

        #endregion

        #region Initialization

        /// <summary>
        /// Initializes the bot visual perception system using validated bot cache.
        /// </summary>
        /// <param name="cache">Runtime bot AI cache.</param>
        public void Initialize(BotComponentCache cache)
        {
            if (cache == null)
            {
                return;
            }

            BotOwner owner = cache.Bot;
            if (owner == null || owner.IsDead)
            {
                return;
            }

            Player player = owner.GetPlayer;
            if (player == null || !player.IsAI)
            {
                return;
            }

            BotVisionProfile vision = BotVisionProfiles.Get(player);
            if (vision == null)
            {
                return;
            }

            _bot = owner;
            _cache = cache;
            _profile = vision;
        }

        #endregion

        #region Tick Loop

        /// <summary>
        /// Updates vision clarity, panic triggers, and sensory impairment over time.
        /// </summary>
        /// <param name="deltaTime">Frame delta time.</param>
        public void Tick(float deltaTime)
        {
            if (!IsActive())
            {
                return;
            }

            UpdateFlashlightExposure();

            float penalty = Mathf.Max(_flashBlindness, _flareIntensity, _suppressionFactor);
            float adjustedSight = Mathf.Lerp(MinSightDistance, MaxSightDistance, 1f - penalty);

            if (_bot.LookSensor != null)
            {
                _bot.LookSensor.ClearVisibleDist = adjustedSight * _profile.AdaptationSpeed;
            }

            float blindDuration = Mathf.Clamp01(_flashBlindness) * 3f;
            _cache.IsBlinded = _flashBlindness > BlindSpeechThreshold;
            _cache.BlindUntilTime = Time.time + blindDuration;

            TryTriggerPanic();
            RecoverClarity(deltaTime);
            SyncEnemyIfVisible();
        }

        #endregion

        #region Exposure Effects

        /// <summary>
        /// Applies flare-induced visibility impairment.
        /// </summary>
        /// <param name="strength">Intensity of flare.</param>
        public void ApplyFlareExposure(float strength)
        {
            _flareIntensity = Mathf.Clamp(strength * 0.6f, 0f, 0.8f);
        }

        /// <summary>
        /// Applies flashbang-induced blindness.
        /// </summary>
        /// <param name="intensity">Blindness strength.</param>
        public void ApplyFlashBlindness(float intensity)
        {
            if (!IsActive())
            {
                return;
            }

            float added = intensity * _profile.MaxBlindness;
            _flashBlindness = Mathf.Clamp01(_flashBlindness + added);
            _blindStartTime = Time.time;

            if (_flashBlindness > BlindSpeechThreshold)
            {
                _bot.BotTalk?.TrySay(EPhraseTrigger.OnBeingHurt);
            }
        }

        /// <summary>
        /// Applies suppression penalty from incoming fire.
        /// </summary>
        /// <param name="severity">Suppression strength.</param>
        public void ApplySuppression(float severity)
        {
            if (!IsActive())
            {
                return;
            }

            _suppressionFactor = Mathf.Clamp01(severity * _profile.AggressionResponse);
        }

        /// <summary>
        /// Called when direct flash exposure is detected from flashlight or grenade.
        /// </summary>
        /// <param name="lightOrigin">Flash source position.</param>
        public void OnFlashExposure(Vector3 lightOrigin)
        {
            if (IsActive())
            {
                ApplyFlashBlindness(0.4f);
            }
        }

        #endregion

        #region Internal Logic

        private bool IsActive()
        {
            return _bot != null &&
                   !_bot.IsDead &&
                   _bot.GetPlayer != null &&
                   _bot.GetPlayer.IsAI &&
                   _cache != null &&
                   _profile != null;
        }

        private void UpdateFlashlightExposure()
        {
            Transform head = BotCacheUtility.Head(_cache);
            if (head == null)
            {
                return;
            }

            Light source;
            if (FlashlightRegistry.IsExposingBot(head, out source) && source != null)
            {
                float score = FlashLightUtils.CalculateFlashScore(source.transform, head, 20f);
                if (score > 0.25f)
                {
                    ApplyFlashBlindness(score);
                }
            }
        }

        private void RecoverClarity(float deltaTime)
        {
            float recovery = _profile.ClarityRecoverySpeed;

            _flashBlindness = Mathf.MoveTowards(_flashBlindness, 0f, FlashRecoverySpeed * recovery * deltaTime);
            _flareIntensity = Mathf.MoveTowards(_flareIntensity, 0f, FlareRecoverySpeed * recovery * deltaTime);
            _suppressionFactor = Mathf.MoveTowards(_suppressionFactor, 0f, SuppressionRecoverySpeed * recovery * deltaTime);
        }

        private void TryTriggerPanic()
        {
            if (_cache.PanicHandler == null)
            {
                return;
            }

            if (_flashBlindness >= PanicTriggerThreshold &&
                (Time.time - _blindStartTime) < 2.5f)
            {
                _cache.PanicHandler.TriggerPanic();
            }
        }

        private void SyncEnemyIfVisible()
        {
            if (_cache.IsBlinded)
            {
                return;
            }

            IPlayer visible = _bot.Memory?.GoalEnemy?.Person;
            if (visible != null)
            {
                BotTeamLogic.AddEnemy(_bot, visible);
            }
        }

        #endregion
    }
}
