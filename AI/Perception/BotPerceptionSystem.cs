// <auto-generated>
//   This file is part of AI-Refactored, an open-source project focused on realistic AI behavior in Escape from Tarkov.
//   Licensed under the MIT License. See LICENSE in the repository root for more information.
//
//   THIS FILE IS SYSTEMATICALLY MANAGED.
//   Please follow strict StyleCop, ReSharper, and AI-Refactored code standards for all modifications.
// </auto-generated>

#nullable enable

namespace AIRefactored.AI.Perception
{
    using AIRefactored.AI.Core;
    using AIRefactored.AI.Groups;
    using AIRefactored.AI.Helpers;
    using EFT;
    using UnityEngine;

    /// <summary>
    /// Controls visual impairment from flashbangs, flares, and suppression.
    /// Adjusts sight distance, triggers panic and vocalizations, and syncs team awareness.
    /// </summary>
    public sealed class BotPerceptionSystem : IFlashReactiveBot
    {
        #region Constants

        private const float BlindSpeechThreshold = 0.4f;
        private const float FlareRecoverySpeed = 0.2f;
        private const float FlashRecoverySpeed = 0.5f;
        private const float MaxSightDistance = 70f;
        private const float MinSightDistance = 15f;
        private const float PanicTriggerThreshold = 0.6f;
        private const float SuppressionRecoverySpeed = 0.3f;

        #endregion

        #region Fields

        private float _blindStartTime = -1f;
        private float _flareIntensity;
        private float _flashBlindness;
        private float _suppressionFactor;

        private BotOwner? _bot;
        private BotComponentCache? _cache;
        private BotVisionProfile? _profile;

        #endregion

        #region Public Methods

        public void Initialize(BotComponentCache cache)
        {
            this._cache = cache;
            this._bot = cache.Bot;

            if (this._bot != null)
            {
                Player? player = this._bot.GetPlayer;
                if (player != null && player.IsAI)
                {
                    this._profile = BotVisionProfiles.Get(player);
                }
            }
        }

        public void Tick(float deltaTime)
        {
            if (!this.IsValid())
            {
                return;
            }

            this.HandleFlashlightExposure();

            // Adjust sight based on flash blindness, flare intensity, and suppression factors
            float penalty = Mathf.Max(this._flashBlindness, this._flareIntensity, this._suppressionFactor);
            float adjustedSight = Mathf.Lerp(MinSightDistance, MaxSightDistance, 1f - penalty);

            if (this._bot?.LookSensor != null && this._profile != null)
            {
                this._bot.LookSensor.ClearVisibleDist = adjustedSight * this._profile.AdaptationSpeed;
            }

            bool blinded = this._flashBlindness > BlindSpeechThreshold;
            float blindDuration = Mathf.Clamp01(this._flashBlindness) * 3f;

            if (this._cache != null)
            {
                this._cache.IsBlinded = blinded;
                this._cache.BlindUntilTime = Time.time + blindDuration;
            }

            this.TryTriggerPanic();
            this.RecoverVisualClarity(deltaTime);
            this.SyncEnemyIfVisible();
        }

        public void ApplyFlareExposure(float strength)
        {
            // Apply the flare intensity based on strength and adjust the exposure.
            this._flareIntensity = Mathf.Clamp(strength * 0.6f, 0f, 0.8f);
        }

        public void ApplyFlashBlindness(float intensity)
        {
            if (!this.IsValid() || this._profile == null)
            {
                return;
            }

            // Calculate and apply the flash blindness level
            float addedBlindness = intensity * this._profile.MaxBlindness;
            this._flashBlindness = Mathf.Clamp01(this._flashBlindness + addedBlindness);
            this._blindStartTime = Time.time;

            // Trigger bot speech for blindness
            if (this._flashBlindness > BlindSpeechThreshold)
            {
                this._bot?.BotTalk?.TrySay(EPhraseTrigger.OnBeingHurt);
            }
        }

        public void ApplySuppression(float severity)
        {
            if (!this.IsValid() || this._profile == null)
            {
                return;
            }

            // Adjust suppression factor based on the severity
            this._suppressionFactor = Mathf.Clamp01(severity * this._profile.AggressionResponse);
        }

        public void OnFlashExposure(Vector3 lightOrigin)
        {
            if (this.IsValid())
            {
                this.ApplyFlashBlindness(0.4f);
            }
        }

        #endregion

        #region Private Methods

        private void HandleFlashlightExposure()
        {
            if (this._cache == null)
            {
                return;
            }

            Transform? head = BotCacheUtility.Head(this._cache);
            if (head == null)
            {
                return;
            }

            Light? source;
            if (FlashlightRegistry.IsExposingBot(head, out source) && source != null)
            {
                float score = FlashLightUtils.CalculateFlashScore(source.transform, head, 20f);
                if (score > 0.25f)
                {
                    this.ApplyFlashBlindness(score);
                }
            }
        }

        private void RecoverVisualClarity(float deltaTime)
        {
            // Adjust recovery speed based on personality traits and environmental factors
            float recoveryFactor = this._profile?.ClarityRecoverySpeed ?? 1f;

            this._flashBlindness = Mathf.MoveTowards(this._flashBlindness, 0f, FlashRecoverySpeed * recoveryFactor * deltaTime);
            this._flareIntensity = Mathf.MoveTowards(this._flareIntensity, 0f, FlareRecoverySpeed * recoveryFactor * deltaTime);
            this._suppressionFactor = Mathf.MoveTowards(this._suppressionFactor, 0f, SuppressionRecoverySpeed * recoveryFactor * deltaTime);
        }

        private void SyncEnemyIfVisible()
        {
            if (this._bot == null || this._cache == null || this._cache.IsBlinded)
            {
                return;
            }

            IPlayer? seen = this._bot.Memory?.GoalEnemy?.Person;
            if (seen != null)
            {
                BotTeamLogic.AddEnemy(this._bot, seen);
            }
        }

        private void TryTriggerPanic()
        {
            if (this._cache?.PanicHandler == null || this._bot == null)
            {
                return;
            }

            // Trigger panic if the bot is blinded by flashbang and certain conditions are met
            if (this._flashBlindness >= PanicTriggerThreshold &&
                Time.time - this._blindStartTime < 2.5f)
            {
                this._cache.PanicHandler.TriggerPanic();
            }
        }

        private bool IsValid()
        {
            if (this._bot == null || this._bot.IsDead || this._cache == null || this._profile == null)
            {
                return false;
            }

            Player? player = this._bot.GetPlayer;
            return player != null && player.IsAI;
        }

        #endregion
    }
}
