// <auto-generated>
//   AI-Refactored: BotDeadBodyScanner.cs (Ultra-Platinum++ Overlay-Only, Anti-Alloc, Squad/Headless Safe – June 2025)
//   SYSTEMATICALLY MANAGED. Overlay/event-driven corpse looting only. All memory pooled, zero alloc, never disables, squad/multiplayer/headless compliant.
//   MIT License.
// </auto-generated>

namespace AIRefactored.AI.Looting
{
    using System;
    using System.Collections.Generic;
    using AIRefactored.AI.Core;
    using AIRefactored.AI.Helpers;
    using AIRefactored.AI.Navigation;
    using AIRefactored.Core;
    using AIRefactored.Pools;
    using EFT;
    using EFT.Interactive;
    using EFT.InventoryLogic;
    using UnityEngine;

    /// <summary>
    /// Handles overlay/event-driven bot corpse looting. Zero-alloc, pooled, bulletproof, multiplayer/headless compliant.
    /// </summary>
    public sealed class BotDeadBodyScanner
    {
        #region Constants

        private const float LootCooldown = 10f;
        private const float LootMemoryDuration = 15f;
        private const float MaxLootAngle = 120f;
        private const float RaycastPadding = 0.3f;
        private const float ScanRadius = 12f;
        private const float MaxContainerDistance = 0.75f;
        private const float CooldownVariance = 1.5f;
        private const float MinPersonalCooldown = 0.33f;
        private const float MoveToCorpseRadius = 1.4f;
        private const float MoveToCorpseCohesion = 0.73f;
        private const int MaxSquadLooters = 1; // Only 1 squadmate loots a corpse at a time.

        #endregion

        #region Static Memory

        private static readonly Dictionary<string, float> LootTimestamps = new Dictionary<string, float>(32);
        private static readonly HashSet<string> RecentlyLooted = new HashSet<string>();
        private static readonly Dictionary<string, string> SquadCorpseLocks = new Dictionary<string, string>(8); // groupId→profileId

        #endregion

        #region Fields

        private BotOwner _bot;
        private BotComponentCache _cache;
        private float _nextScanTime;
        private float _personalScanVariance;

        #endregion

        #region Initialization

        /// <summary>
        /// Static: Scans all lootable corpses and associates dead player profile IDs with containers (once per world).
        /// </summary>
        public static void ScanAll()
        {
            try
            {
                if (!GameWorldHandler.IsSafeToInitialize)
                    return;

                List<LootableContainer> containers = LootRegistry.GetAllContainers();
                GameWorld world = GameWorldHandler.Get();
                if (world == null || world.RegisteredPlayers == null)
                    return;

                List<IPlayer> rawPlayers = world.RegisteredPlayers;
                List<Player> deadPlayers = TempListPool.Rent<Player>();

                for (int i = 0, n = rawPlayers.Count; i < n; i++)
                {
                    Player p = EFTPlayerUtil.AsEFTPlayer(rawPlayers[i]);
                    if (p != null && p.HealthController != null && !p.HealthController.IsAlive)
                        deadPlayers.Add(p);
                }

                for (int i = 0, n = containers.Count; i < n; i++)
                {
                    LootableContainer container = containers[i];
                    if (container == null)
                        continue;

                    Vector3 containerPos = container.transform.position;
                    for (int j = 0, m = deadPlayers.Count; j < m; j++)
                    {
                        Player player = deadPlayers[j];
                        if (player == null || string.IsNullOrEmpty(player.ProfileId) || DeadBodyContainerCache.Contains(player.ProfileId))
                            continue;

                        float dist = Vector3.Distance(player.Transform.position, containerPos);
                        if (dist <= MaxContainerDistance)
                        {
                            DeadBodyContainerCache.Register(player, container);
                            break;
                        }
                    }
                }

                TempListPool.Return(deadPlayers);
            }
            catch (Exception ex)
            {
                Plugin.LoggerInstance.LogError($"[BotDeadBodyScanner] Exception in ScanAll: {ex}");
            }
        }

        /// <summary>
        /// Static: Clear global loot/cooldown state.
        /// </summary>
        public static void ClearStaticState()
        {
            LootTimestamps.Clear();
            RecentlyLooted.Clear();
            SquadCorpseLocks.Clear();
        }

        /// <summary>
        /// Initialize this scanner with the bot's cache.
        /// </summary>
        public void Initialize(BotComponentCache cache)
        {
            if (cache == null || cache.Bot == null)
            {
                _bot = null;
                _cache = null;
                _personalScanVariance = 0f;
                return;
            }

            _bot = cache.Bot;
            _cache = cache;
            _personalScanVariance = UnityEngine.Random.Range(-CooldownVariance * 0.5f, CooldownVariance * 0.5f);
            _nextScanTime = Mathf.Max(Time.time, Time.time + MinPersonalCooldown + _personalScanVariance);
        }

        #endregion

        #region Overlay-Only Entry

        /// <summary>
        /// Overlay/event-only. Call from BotBrain tick or explicit loot intent event.
        /// </summary>
        public void TryLootNearby()
        {
            try
            {
                if (!IsReady() || Time.time < _nextScanTime)
                    return;

                if (IsAnticipationActive() || IsInteractionLocked())
                    return;

                _nextScanTime = Time.time + LootCooldown + _personalScanVariance;
                TryLootOnce();
            }
            catch (Exception ex)
            {
                Plugin.LoggerInstance.LogError($"[BotDeadBodyScanner] Exception in TryLootNearby: {ex}");
                _bot = null;
                _cache = null;
            }
        }

        #endregion

        #region Core Logic

        /// <summary>
        /// Ready for overlay looting—bot is alive, not panicking, valid, can act, and not blocked by squad logic.
        /// </summary>
        private bool IsReady()
        {
            if (_bot == null || _bot.IsDead || !EFTPlayerUtil.IsValid(_bot.GetPlayer) || _cache == null)
                return false;
            if (_cache.PanicHandler != null && _cache.PanicHandler.IsPanicking)
                return false;
            // Squad lock: only one squadmate loots a corpse at a time
            if (_bot.BotsGroup != null && _bot.BotsGroup.MembersCount > 1)
            {
                string groupId = _bot.Profile?.Info?.GroupId ?? string.Empty;
                if (!string.IsNullOrEmpty(groupId) && SquadCorpseLocks.TryGetValue(groupId, out string locked))
                {
                    if (!string.IsNullOrEmpty(locked) && locked != _bot.ProfileId)
                        return false;
                }
            }
            return true;
        }

        /// <summary>
        /// Overlay: anticipation/interaction block check.
        /// </summary>
        private bool IsAnticipationActive()
        {
            // Optionally integrate squad/voice/anticipation overlays here if your project uses them.
            return false;
        }
        private bool IsInteractionLocked()
        {
            return BotMovementHelper.IsMovementPaused(_bot)
                || BotMovementHelper.IsInInteractionState(_bot);
        }

        /// <summary>
        /// Finds and moves to nearest lootable corpse, then attempts loot (never spams move/cooldown).
        /// </summary>
        private void TryLootOnce()
        {
            Player corpse = null;
            try
            {
                corpse = FindLootableCorpse();
                if (!EFTPlayerUtil.IsValid(corpse))
                    return;

                string profileId = corpse.ProfileId;
                if (string.IsNullOrEmpty(profileId))
                    return;

                // Squad lock
                if (_bot.BotsGroup != null && _bot.BotsGroup.MembersCount > 1)
                {
                    string groupId = _bot.Profile?.Info?.GroupId ?? string.Empty;
                    if (!string.IsNullOrEmpty(groupId))
                        SquadCorpseLocks[groupId] = profileId;
                }

                // Only move if not already close enough (strict anti-spam, anti-teleport).
                Vector3 corpsePos = corpse.Transform.position;
                float dist = Vector3.Distance(_bot.Position, corpsePos);
                if (dist > MoveToCorpseRadius)
                {
                    if (_cache.MoveCache != null && _cache.MoveCache.CanIssueMove(corpsePos, Time.time))
                    {
                        // Movement is strictly via canonical NavMesh helper, no cache/cooldown update unless successful.
                        BotMovementHelper.SmoothMoveToSafe(_bot, corpsePos, slow: true, MoveToCorpseCohesion);
                        // No cache update here; only the helper may update LastIssuedTarget/LastMoveTime if move is valid.
                    }
                    return;
                }

                // Now in range—loot attempt
                LootCorpse(corpse);
                RememberLooted(profileId);

                // Release squad lock
                if (_bot.BotsGroup != null && _bot.BotsGroup.MembersCount > 1)
                {
                    string groupId = _bot.Profile?.Info?.GroupId ?? string.Empty;
                    if (!string.IsNullOrEmpty(groupId) && SquadCorpseLocks.TryGetValue(groupId, out string locked) && locked == profileId)
                        SquadCorpseLocks[groupId] = null;
                }
            }
            catch (Exception ex)
            {
                Plugin.LoggerInstance.LogError($"[BotDeadBodyScanner] Exception in TryLootOnce (corpse={corpse?.ProfileId ?? "null"}): {ex}");
            }
        }

        /// <summary>
        /// Finds the best valid lootable corpse within range/angle/LOS (pooled, error-guarded, squad-safe).
        /// </summary>
        private Player FindLootableCorpse()
        {
            if (_bot == null || _bot.Transform == null)
                return null;

            Vector3 origin = _bot.Transform.position;
            Vector3 forward = (_bot.WeaponRoot != null) ? _bot.WeaponRoot.forward : _bot.Transform.forward;

            List<Player> allCorpses = TempListPool.Rent<Player>();
            List<Player> possible = GameWorldHandler.GetAllAlivePlayers();
            try
            {
                for (int i = 0; i < possible.Count; i++)
                {
                    Player p = possible[i];
                    if (p != null && !p.HealthController.IsAlive)
                        allCorpses.Add(p);
                }

                Player best = null;
                float bestDist = ScanRadius + 1f;

                for (int i = 0, n = allCorpses.Count; i < n; i++)
                {
                    Player candidate = allCorpses[i];
                    if (!IsValidCorpse(candidate))
                        continue;

                    Vector3 toCorpse = candidate.Transform.position - origin;
                    float distance = toCorpse.magnitude;
                    float angle = Vector3.Angle(forward, toCorpse.normalized);
                    if (distance > ScanRadius || angle > MaxLootAngle)
                        continue;

                    if (!HasLineOfSight(origin, toCorpse, distance, candidate))
                        continue;

                    // Squad lock: if another squadmate is already looting this, skip
                    if (_bot.BotsGroup != null && _bot.BotsGroup.MembersCount > 1)
                    {
                        string groupId = _bot.Profile?.Info?.GroupId ?? string.Empty;
                        if (!string.IsNullOrEmpty(groupId) && SquadCorpseLocks.TryGetValue(groupId, out string locked) && locked != _bot.ProfileId)
                            continue;
                    }

                    if (distance < bestDist)
                    {
                        best = candidate;
                        bestDist = distance;
                    }
                }

                return best;
            }
            finally
            {
                TempListPool.Return(allCorpses);
                TempListPool.Return(possible);
            }
        }

        /// <summary>
        /// All corpse validation: not self, dead, valid, not looted recently, and not locked to other squadmate.
        /// </summary>
        private bool IsValidCorpse(Player player)
        {
            if (!EFTPlayerUtil.IsValid(player)
                || player.HealthController == null
                || player.HealthController.IsAlive
                || player == _bot.GetPlayer
                || string.IsNullOrEmpty(player.ProfileId)
                || WasLootedRecently(player.ProfileId))
                return false;

            // Only one squadmate can loot a corpse at a time.
            if (_bot.BotsGroup != null && _bot.BotsGroup.MembersCount > 1)
            {
                string groupId = _bot.Profile?.Info?.GroupId ?? string.Empty;
                if (!string.IsNullOrEmpty(groupId) && SquadCorpseLocks.TryGetValue(groupId, out string locked))
                {
                    if (!string.IsNullOrEmpty(locked) && locked != _bot.ProfileId && player.ProfileId == locked)
                        return false;
                }
            }

            return true;
        }

        /// <summary>
        /// Simple LOS: only loot if clear sight.
        /// </summary>
        private bool HasLineOfSight(Vector3 origin, Vector3 direction, float distance, Player corpse)
        {
            try
            {
                if (corpse?.Transform?.Original == null)
                    return false;

                Ray ray = new Ray(origin, direction.normalized);
                if (!Physics.Raycast(ray, out RaycastHit hit, distance + RaycastPadding, AIRefactoredLayerMasks.TerrainHighLow))
                    return false;

                return hit.collider.transform.root == corpse.Transform.Original.root;
            }
            catch
            {
                return false;
            }
        }

        /// <summary>
        /// Attempt loot via dead body container or direct inventory steal, error-guarded.
        /// </summary>
        private void LootCorpse(Player corpse)
        {
            try
            {
                InventoryController source = corpse.InventoryController;
                InventoryController target = _bot.GetPlayer.InventoryController;
                if (source == null || target == null)
                    return;

                LootableContainer container = DeadBodyContainerCache.Get(corpse.ProfileId);
                if (container != null && container.enabled)
                {
                    container.Interact(new InteractionResult(EInteractionType.Open));
                    return;
                }

                StealBestItemOnce(source, target);
            }
            catch (Exception ex)
            {
                Plugin.LoggerInstance.LogError($"[BotDeadBodyScanner] Exception in LootCorpse: {ex}");
            }
        }

        /// <summary>
        /// Attempts to steal the "best" item from corpse inventory in priority order (anti-alloc, pooled, error-guarded).
        /// </summary>
        private void StealBestItemOnce(InventoryController source, InventoryController target)
        {
            EquipmentSlot[] prioritySlots =
            {
                EquipmentSlot.FirstPrimaryWeapon,
                EquipmentSlot.SecondPrimaryWeapon,
                EquipmentSlot.Holster,
                EquipmentSlot.TacticalVest,
                EquipmentSlot.Backpack,
                EquipmentSlot.Pockets
            };

            for (int i = 0; i < prioritySlots.Length; i++)
            {
                try
                {
                    var slot = source.Inventory.Equipment.GetSlot(prioritySlots[i]);
                    if (slot == null)
                        continue;

                    Item item = slot.ContainedItem;
                    if (item == null)
                        continue;

                    ItemAddress destination = target.FindSlotToPickUp(item);
                    if (destination == null)
                        continue;

                    if (InteractionsHandlerClass.Move(item, destination, target, true).Succeeded)
                        break;
                }
                catch (Exception ex)
                {
                    Plugin.LoggerInstance.LogError($"[BotDeadBodyScanner] Exception in StealBestItemOnce slot {prioritySlots[i]}: {ex}");
                }
            }
        }

        /// <summary>
        /// Records loot timestamp and profile for memory/future avoidance.
        /// </summary>
        private void RememberLooted(string profileId)
        {
            RecentlyLooted.Add(profileId);
            LootTimestamps[profileId] = Time.time;
        }

        /// <summary>
        /// Checks if a corpse has been looted recently (memory expiry randomized).
        /// </summary>
        private bool WasLootedRecently(string profileId)
        {
            return LootTimestamps.TryGetValue(profileId, out float lastTime)
                && (Time.time - lastTime < LootMemoryDuration + UnityEngine.Random.Range(-2f, 2f));
        }

        #endregion
    }
}
