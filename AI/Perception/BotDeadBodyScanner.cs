// <auto-generated>
//   This file is part of AI-Refactored, an open-source project focused on realistic AI behavior in Escape from Tarkov.
//   Licensed under the MIT License. See LICENSE in the repository root for more information.
//
//   THIS FILE IS SYSTEMATICALLY MANAGED.
//   Please follow strict StyleCop, ReSharper, and AI-Refactored code standards for all modifications.
// </auto-generated>

#nullable enable

namespace AIRefactored.AI.Looting
{
    using System.Collections.Generic;
    using AIRefactored.AI.Core;
    using AIRefactored.Core;
    using EFT;
    using EFT.Interactive;
    using EFT.InventoryLogic;
    using UnityEngine;

    /// <summary>
    /// Scans for nearby dead players and loots if safe and opportunistic.
    /// Tracks previously looted corpses to avoid redundancy.
    /// </summary>
    public sealed class BotDeadBodyScanner
    {
        private const float LootCooldown = 10f;
        private const float LootMemoryDuration = 15f;
        private const float MaxLootAngle = 120f;
        private const float RaycastPadding = 0.3f;
        private const float ScanRadius = 12f;

        private static readonly Dictionary<string, float> _lootTimestamps = new Dictionary<string, float>(32);
        private static readonly HashSet<string> _recentlyLooted = new HashSet<string>();


        private BotOwner? _bot;
        private BotComponentCache? _cache;
        private float _nextScanTime;

        public static void ScanAll()
        {
            int registered = 0;

            List<LootableContainer> containers = LootRegistry.GetAllContainers();
            List<Player> players = GameWorldHandler.GetAllAlivePlayers();

            for (int i = 0; i < containers.Count; i++)
            {
                LootableContainer container = containers[i];

                for (int j = 0; j < players.Count; j++)
                {
                    Player player = players[j];

                    if (player == null || player.HealthController?.IsAlive != false || string.IsNullOrEmpty(player.ProfileId))
                    {
                        continue;
                    }

                    float dist = Vector3.Distance(player.Transform.position, container.transform.position);
                    if (dist < 0.75f)
                    {
                        DeadBodyContainerCache.Register(player, container);
                        registered++;
                        break;
                    }
                }
            }
        }

        public void Initialize(BotComponentCache cache)
        {
            this._cache = cache;
            this._bot = cache.Bot;
        }

        public void Tick(float time)
        {
            if (!this.CanEvaluate(time))
            {
                return;
            }

            this._nextScanTime = time + LootCooldown;
            this.TryLootOnce();
        }

        public void TryLootNearby()
        {
            this.TryLootOnce();
        }

        private bool CanEvaluate(float time)
        {
            return this._bot != null
                && !this._bot.IsDead
                && this._bot.GetPlayer?.IsYourPlayer != true
                && this._cache?.PanicHandler?.IsPanicking != true
                && time >= this._nextScanTime;
        }

        private Player? FindLootableCorpse()
        {
            if (this._bot == null)
            {
                return null;
            }

            Vector3 origin = this._bot.Transform.position;
            Vector3 forward = this._bot.WeaponRoot.forward;
            List<Player> players = GameWorldHandler.GetAllAlivePlayers();

            for (int i = 0; i < players.Count; i++)
            {
                Player player = players[i];
                if (!this.IsValidCorpse(player))
                {
                    continue;
                }

                Vector3 toCorpse = player.Transform.position - origin;
                float distance = toCorpse.magnitude;

                if (distance > ScanRadius)
                {
                    continue;
                }

                if (Vector3.Angle(forward, toCorpse.normalized) > MaxLootAngle)
                {
                    continue;
                }

                if (!this.HasLineOfSight(origin, toCorpse, distance, player))
                {
                    continue;
                }

                return player;
            }

            return null;
        }

        private bool HasLineOfSight(Vector3 origin, Vector3 direction, float dist, Player corpse)
        {
            if (Physics.Raycast(origin, direction.normalized, out RaycastHit hit, dist + RaycastPadding, AIRefactoredLayerMasks.HighPolyWithTerrainMaskAI))
            {
                Transform? hitRoot = hit.collider?.transform.root;
                Transform? corpseRoot = corpse.Transform?.Original?.root;

                return hitRoot != null && corpseRoot != null && hitRoot == corpseRoot;
            }

            return false;
        }

        private bool IsValidCorpse(Player player)
        {
            return player != null
                && player.HealthController?.IsAlive == false
                && player != this._bot?.GetPlayer
                && !string.IsNullOrEmpty(player.ProfileId)
                && !this.WasLootedRecently(player.ProfileId);
        }

        private void TryLootOnce()
        {
            Player? corpse = this.FindLootableCorpse();
            if (corpse == null)
            {
                return;
            }

            this.LootCorpse(corpse);
            this.RememberLooted(corpse.ProfileId);
        }

        private void LootCorpse(Player corpse)
        {
            InventoryController? source = corpse.InventoryController;
            InventoryController? target = this._bot?.GetPlayer?.InventoryController;

            if (source == null || target == null)
            {
                return;
            }

            LootableContainer? container = DeadBodyContainerCache.Get(corpse.ProfileId);
            if (container != null && container.enabled)
            {
                container.Interact(new InteractionResult(EInteractionType.Open));
                return;
            }

            this.TryStealBestItem(source, target);
        }

        private void TryStealBestItem(InventoryController source, InventoryController target)
        {
            EquipmentSlot[] slots =
            {
                EquipmentSlot.FirstPrimaryWeapon,
                EquipmentSlot.SecondPrimaryWeapon,
                EquipmentSlot.Holster,
                EquipmentSlot.TacticalVest,
                EquipmentSlot.Backpack,
                EquipmentSlot.Pockets
            };

            for (int i = 0; i < slots.Length; i++)
            {
                EquipmentSlot slot = slots[i];
                Item? item = source.Inventory.Equipment.GetSlot(slot).ContainedItem;

                if (item == null)
                {
                    continue;
                }

                ItemAddress? destination = target.FindSlotToPickUp(item);
                if (destination == null)
                {
                    continue;
                }

                var result = InteractionsHandlerClass.Move(item, destination, target, true);
                if (result.Succeeded)
                {
                    target.TryRunNetworkTransaction(result);
                    return;
                }
            }
        }

        private void RememberLooted(string profileId)
        {
            _recentlyLooted.Add(profileId);
            _lootTimestamps[profileId] = Time.time;
        }

        private bool WasLootedRecently(string profileId)
        {
            float lastTime;
            return _lootTimestamps.TryGetValue(profileId, out lastTime) && Time.time - lastTime < LootMemoryDuration;
        }
    }
}
