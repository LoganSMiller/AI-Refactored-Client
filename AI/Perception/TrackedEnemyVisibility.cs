// <auto-generated>
//   This file is part of AI-Refactored, an open-source project focused on realistic AI behavior in Escape from Tarkov.
//   Licensed under the MIT License. See LICENSE in the repository root for more information.
//
//   THIS FILE IS SYSTEMATICALLY MANAGED.
//   Please follow strict StyleCop, ReSharper, and AI-Refactored code standards for all modifications.
// </auto-generated>

namespace AIRefactored.AI.Perception
{
    using System.Collections.Generic;
    using AIRefactored.Pools;
    using UnityEngine;

    /// <summary>
    /// Tracks enemy bone visibility from the bot's perspective.
    /// Simulates partial body exposure, confidence decay, ambient occlusion, and motion weighting.
    /// </summary>
    public sealed class TrackedEnemyVisibility
    {
        #region Constants

        private const float BoneVisibilityDuration = 0.5f;
        private const float LinecastSlack = 0.15f;

        #endregion

        #region Static Pool

        private static readonly Queue<string> ExpiredKeys = new Queue<string>(8);

        #endregion

        #region State

        private readonly Transform _botOrigin;
        private readonly Dictionary<string, BoneInfo> _visibleBones = new Dictionary<string, BoneInfo>(8);

        #endregion

        #region Constructor

        /// <summary>
        /// Creates a new visibility tracker bound to the bot origin.
        /// </summary>
        /// <param name="botOrigin">Origin transform of the observing bot.</param>
        public TrackedEnemyVisibility(Transform botOrigin)
        {
            _botOrigin = botOrigin;
        }

        #endregion

        #region Public API

        public bool HasEnoughData
        {
            get { return _visibleBones.Count >= 2; }
        }

        public bool CanSeeAny()
        {
            CleanExpired(Time.time);
            return _visibleBones.Count > 0;
        }

        public bool CanShootTo(string boneName)
        {
            BoneInfo info;
            if (!_visibleBones.TryGetValue(boneName, out info))
            {
                return false;
            }

            float now = Time.time;
            if (now - info.Timestamp > BoneVisibilityDuration)
            {
                return false;
            }

            Vector3 eye = _botOrigin.position + new Vector3(0f, 1.4f, 0f);
            float dist = Vector3.Distance(eye, info.Position);

            RaycastHit hit;
            return !Physics.Linecast(eye, info.Position, out hit) || hit.distance >= dist - LinecastSlack;
        }

        public void Clear()
        {
            _visibleBones.Clear();
        }

        public void DecayConfidence(float decayAmount)
        {
            float now = Time.time;
            List<string> keys = TempListPool.Rent<string>();

            foreach (var kvp in _visibleBones)
            {
                keys.Add(kvp.Key);
            }

            for (int i = 0; i < keys.Count; i++)
            {
                string key = keys[i];
                BoneInfo info = _visibleBones[key];
                float ts = Mathf.Max(0f, info.Timestamp - decayAmount);
                _visibleBones[key] = new BoneInfo(info.Position, ts);
            }

            TempListPool.Return(keys);
            CleanExpired(now);
        }

        public int ExposedBoneCount()
        {
            CleanExpired(Time.time);
            return _visibleBones.Count;
        }

        public float GetOverallConfidence()
        {
            CleanExpired(Time.time);
            return Mathf.Clamp01(_visibleBones.Count / 8f);
        }

        public void UpdateBoneVisibility(string boneName, Vector3 worldPosition)
        {
            _visibleBones[boneName] = new BoneInfo(worldPosition, Time.time);
        }

        public void UpdateBoneVisibility(string boneName, Vector3 worldPosition, float motionBonus, float ambientOcclusionFactor)
        {
            float now = Time.time;
            float extra = Mathf.Clamp(motionBonus, 0f, 0.4f);
            float penalty = Mathf.Lerp(0f, 0.2f, 1f - ambientOcclusionFactor);
            float timestamp = now + extra - penalty;

            _visibleBones[boneName] = new BoneInfo(worldPosition, timestamp);
        }

        #endregion

        #region Internal

        private void CleanExpired(float now)
        {
            ExpiredKeys.Clear();

            foreach (var kvp in _visibleBones)
            {
                if (now - kvp.Value.Timestamp > BoneVisibilityDuration)
                {
                    ExpiredKeys.Enqueue(kvp.Key);
                }
            }

            while (ExpiredKeys.Count > 0)
            {
                _visibleBones.Remove(ExpiredKeys.Dequeue());
            }
        }

        #endregion

        #region Structs

        private struct BoneInfo
        {
            public readonly Vector3 Position;
            public readonly float Timestamp;

            public BoneInfo(Vector3 pos, float ts)
            {
                Position = pos;
                Timestamp = ts;
            }
        }

        #endregion
    }
}
