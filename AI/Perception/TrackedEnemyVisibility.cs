// <auto-generated>
//   This file is part of AI-Refactored, an open-source project focused on realistic AI behavior in Escape from Tarkov.
//   Licensed under the MIT License. See LICENSE in the repository root for more information.
//
//   THIS FILE IS SYSTEMATICALLY MANAGED.
//   Please follow strict StyleCop, ReSharper, and AI-Refactored code standards for all modifications.
// </auto-generated>

#nullable enable

namespace AIRefactored.AI.Perception
{
    using System.Collections.Generic;
    using UnityEngine;

    /// <summary>
    /// Tracks enemy bone visibility from the bot's perspective.
    /// Simulates partial body exposure, confidence decay, ambient occlusion, and motion weighting.
    /// </summary>
    public sealed class TrackedEnemyVisibility
    {
        #region Constants

        private const float BoneVisibilityDuration = 0.5f;
        private const float LinecastSlack = 0.15f;

        #endregion

        #region Static

        private static readonly Queue<string> ExpiredKeys = new Queue<string>(8);

        #endregion

        #region Fields

        private readonly Transform _botOrigin;
        private readonly Dictionary<string, BoneInfo> _visibleBones = new Dictionary<string, BoneInfo>(8);

        #endregion

        #region Constructor

        /// <summary>
        /// Initializes a new instance of the <see cref="TrackedEnemyVisibility"/> class.
        /// </summary>
        /// <param name="botOrigin">The transform from which visibility is evaluated.</param>
        public TrackedEnemyVisibility(Transform botOrigin)
        {
            this._botOrigin = botOrigin;
        }

        #endregion

        #region Public API

        /// <summary>
        /// Gets a value indicating whether enough body parts are visible to make a confident decision.
        /// </summary>
        public bool HasEnoughData
        {
            get { return this._visibleBones.Count >= 2; }
        }

        /// <summary>
        /// Gets a value indicating whether any bones are currently visible.
        /// </summary>
        public bool CanSeeAny()
        {
            this.CleanExpired(Time.time);
            return this._visibleBones.Count > 0;
        }

        /// <summary>
        /// Determines whether a previously seen bone is still shootable (unobstructed).
        /// </summary>
        /// <param name="boneName">The name of the bone to test.</param>
        /// <returns>True if the bone is still visible and shootable; otherwise, false.</returns>
        public bool CanShootTo(string boneName)
        {
            BoneInfo info;
            if (!this._visibleBones.TryGetValue(boneName, out info))
            {
                return false;
            }

            float now = Time.time;
            if (now - info.Timestamp > BoneVisibilityDuration)
            {
                return false;
            }

            Vector3 eye = this._botOrigin.position + new Vector3(0f, 1.4f, 0f);
            float dist = Vector3.Distance(eye, info.Position);

            RaycastHit hit;
            return !Physics.Linecast(eye, info.Position, out hit) || hit.distance >= dist - LinecastSlack;
        }

        /// <summary>
        /// Clears all tracked visibility data.
        /// </summary>
        public void Clear()
        {
            this._visibleBones.Clear();
        }

        /// <summary>
        /// Applies aging to confidence by reducing timestamps.
        /// </summary>
        /// <param name="decayAmount">Time to subtract from each visible bone's timestamp.</param>
        public void DecayConfidence(float decayAmount)
        {
            float now = Time.time;

            List<string> keys = new List<string>(this._visibleBones.Keys);
            for (int i = 0; i < keys.Count; i++)
            {
                string key = keys[i];
                BoneInfo info = this._visibleBones[key];
                float newTimestamp = Mathf.Max(0f, info.Timestamp - decayAmount);
                this._visibleBones[key] = new BoneInfo(info.Position, newTimestamp);
            }

            this.CleanExpired(now);
        }

        /// <summary>
        /// Gets number of bones currently visible.
        /// </summary>
        public int ExposedBoneCount()
        {
            this.CleanExpired(Time.time);
            return this._visibleBones.Count;
        }

        /// <summary>
        /// Returns total bone confidence scaled to [0,1].
        /// </summary>
        public float GetOverallConfidence()
        {
            this.CleanExpired(Time.time);
            return Mathf.Clamp01(this._visibleBones.Count / 8f);
        }

        /// <summary>
        /// Updates the visibility record for a bone with default visibility weight.
        /// </summary>
        public void UpdateBoneVisibility(string boneName, Vector3 worldPosition)
        {
            this._visibleBones[boneName] = new BoneInfo(worldPosition, Time.time);
        }

        /// <summary>
        /// Updates the visibility record with optional motion and occlusion bonuses.
        /// </summary>
        /// <param name="boneName">Bone name (e.g. "Head", "Spine").</param>
        /// <param name="worldPosition">Bone world-space location.</param>
        /// <param name="motionBonus">Optional motion confidence boost [0..1].</param>
        /// <param name="ambientOcclusionFactor">Optional decay penalty from ambient occlusion [0..1].</param>
        public void UpdateBoneVisibility(string boneName, Vector3 worldPosition, float motionBonus, float ambientOcclusionFactor)
        {
            float now = Time.time;
            float timestamp = now + Mathf.Clamp(motionBonus, 0f, 0.4f);
            float decay = Mathf.Lerp(0f, 0.2f, 1f - ambientOcclusionFactor);
            this._visibleBones[boneName] = new BoneInfo(worldPosition, timestamp - decay);
        }

        #endregion

        #region Private Methods

        private void CleanExpired(float now)
        {
            ExpiredKeys.Clear();

            foreach (KeyValuePair<string, BoneInfo> kvp in this._visibleBones)
            {
                if (now - kvp.Value.Timestamp > BoneVisibilityDuration)
                {
                    ExpiredKeys.Enqueue(kvp.Key);
                }
            }

            while (ExpiredKeys.Count > 0)
            {
                this._visibleBones.Remove(ExpiredKeys.Dequeue());
            }
        }

        #endregion

        #region Private Structs

        private struct BoneInfo
        {
            public BoneInfo(Vector3 position, float timestamp)
            {
                this.Position = position;
                this.Timestamp = timestamp;
            }

            public readonly Vector3 Position;
            public readonly float Timestamp;
        }

        #endregion
    }
}
