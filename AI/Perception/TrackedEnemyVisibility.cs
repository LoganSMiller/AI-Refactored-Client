// <auto-generated>
//   AI-Refactored: TrackedEnemyVisibility.cs (Ultra-Platinum++, Beyond Diamond, Arbitration/Event Overlay, June 2025)
//   SYSTEMATICALLY MANAGED. Bone visibility tracking is pooled, bulletproof, squad-safe, null-guarded.
//   Overlay/event-only—never pose/move/teleport. SPT/FIKA/headless parity. MIT License.
// </auto-generated>

namespace AIRefactored.AI.Perception
{
    using System;
    using System.Collections.Generic;
    using AIRefactored.Core;
    using AIRefactored.Pools;
    using UnityEngine;

    /// <summary>
    /// Overlay/event-only: tracks enemy bone visibility per-bot.
    /// Simulates partial exposure, line-of-sight occlusion, motion/ambient bias, and confidence decay.
    /// Bulletproof: pooled, error-isolated, squad/multiplayer/headless-safe, no pose/move/teleport.
    /// </summary>
    public sealed class TrackedEnemyVisibility
    {
        #region Constants

        private const float BoneVisibilityDuration = 0.5f;
        private const float LinecastSlack = 0.15f;
        private static readonly Vector3 EyeOffset = new Vector3(0f, 1.4f, 0f);
        private const int MaxBones = 8; // Used for normalized confidence

        #endregion

        #region Fields

        private readonly Transform _botOrigin;
        private readonly Dictionary<string, BoneInfo> _visibleBones = new Dictionary<string, BoneInfo>(MaxBones);

        #endregion

        #region Constructor

        /// <summary>
        /// Constructs a new bone visibility tracker for the given bot origin transform.
        /// </summary>
        public TrackedEnemyVisibility(Transform botOrigin)
        {
            _botOrigin = botOrigin;
        }

        #endregion

        #region Properties

        /// <summary>
        /// Gets whether the bot has enough visual data to estimate a threat confidently.
        /// </summary>
        public bool HasEnoughData
        {
            get
            {
                try { CleanExpired(Time.time); }
                catch { }
                return _visibleBones.Count >= 2;
            }
        }

        #endregion

        #region Public Methods

        /// <summary>
        /// Returns true if any bone is currently visible (confidence > 0).
        /// </summary>
        public bool CanSeeAny()
        {
            try
            {
                CleanExpired(Time.time);
                return _visibleBones.Count > 0;
            }
            catch { return false; }
        }

        /// <summary>
        /// Returns true if the given bone is visible and unobstructed by line of sight.
        /// </summary>
        public bool CanShootTo(string boneName)
        {
            try
            {
                if (_botOrigin == null || string.IsNullOrEmpty(boneName))
                    return false;
                if (!_visibleBones.TryGetValue(boneName, out BoneInfo info))
                    return false;

                float now = Time.time;
                if (now - info.Timestamp > BoneVisibilityDuration)
                    return false;

                Vector3 eye = _botOrigin.position + EyeOffset;
                float dist = Vector3.Distance(eye, info.Position);

                return !Physics.Linecast(eye, info.Position, out RaycastHit hit, AIRefactoredLayerMasks.LineOfSightMask)
                    || hit.distance >= dist - LinecastSlack;
            }
            catch { return false; }
        }

        /// <summary>
        /// Updates tracked visibility for a given bone. Timestamp is always Time.time.
        /// </summary>
        public void UpdateBoneVisibility(string boneName, Vector3 worldPosition)
        {
            try
            {
                if (_botOrigin == null || string.IsNullOrEmpty(boneName))
                    return;
                _visibleBones[boneName] = new BoneInfo(worldPosition, Time.time);
            }
            catch { }
        }

        /// <summary>
        /// Updates tracked visibility for a bone, including motion/ambient factors (adds realism/jitter).
        /// </summary>
        public void UpdateBoneVisibility(string boneName, Vector3 worldPosition, float motionBonus, float ambientOcclusionFactor)
        {
            try
            {
                if (_botOrigin == null || string.IsNullOrEmpty(boneName))
                    return;

                float now = Time.time;
                float bonus = Mathf.Clamp(motionBonus, 0f, 0.42f); // Slightly boosted for movement
                float penalty = Mathf.Lerp(0f, 0.22f, 1f - Mathf.Clamp01(ambientOcclusionFactor));
                float timestamp = now + bonus - penalty;

                _visibleBones[boneName] = new BoneInfo(worldPosition, timestamp);
            }
            catch { }
        }

        /// <summary>
        /// Decays all visible bone confidence values by the specified amount.
        /// </summary>
        public void DecayConfidence(float decayAmount)
        {
            float now = Time.time;
            List<string> keys = TempListPool.Rent<string>();
            try
            {
                foreach (var kv in _visibleBones)
                    keys.Add(kv.Key);

                for (int i = 0; i < keys.Count; i++)
                {
                    string key = keys[i];
                    BoneInfo info = _visibleBones[key];
                    float decayedTime = Mathf.Max(0f, info.Timestamp - decayAmount);
                    _visibleBones[key] = new BoneInfo(info.Position, decayedTime);
                }
                CleanExpired(now);
            }
            catch { }
            finally
            {
                TempListPool.Return(keys);
            }
        }

        /// <summary>
        /// Gets the overall confidence in visibility (normalized [0,1], pooled).
        /// </summary>
        public float GetOverallConfidence()
        {
            try
            {
                CleanExpired(Time.time);
                return Mathf.Clamp01(_visibleBones.Count / (float)MaxBones);
            }
            catch { return 0f; }
        }

        /// <summary>
        /// Returns the number of bones currently exposed.
        /// </summary>
        public int ExposedBoneCount()
        {
            try
            {
                CleanExpired(Time.time);
                return _visibleBones.Count;
            }
            catch { return 0; }
        }

        /// <summary>
        /// Clears all tracked visibility info.
        /// </summary>
        public void Clear()
        {
            try { _visibleBones.Clear(); }
            catch { }
        }

        #endregion

        #region Internal/Private Methods

        /// <summary>
        /// Removes all expired (invisible) bones from the set.
        /// </summary>
        private void CleanExpired(float now)
        {
            List<string> expired = TempListPool.Rent<string>();
            try
            {
                foreach (var kv in _visibleBones)
                {
                    if (now - kv.Value.Timestamp > BoneVisibilityDuration)
                        expired.Add(kv.Key);
                }

                for (int i = 0; i < expired.Count; i++)
                    _visibleBones.Remove(expired[i]);
            }
            catch { }
            finally
            {
                TempListPool.Return(expired);
            }
        }

        #endregion

        #region Structs

        /// <summary>
        /// Stores info for a visible bone: position and timestamp.
        /// </summary>
        private struct BoneInfo
        {
            public readonly Vector3 Position;
            public readonly float Timestamp;

            public BoneInfo(Vector3 pos, float ts)
            {
                Position = pos;
                Timestamp = ts;
            }
        }

        #endregion
    }
}
