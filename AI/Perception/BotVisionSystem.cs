// <auto-generated>
//   This file is part of AI-Refactored, an open-source project focused on realistic AI behavior in Escape from Tarkov.
//   Licensed under the MIT License. See LICENSE in the repository root for more information.
//
//   THIS FILE IS SYSTEMATICALLY MANAGED.
//   Please follow strict StyleCop, ReSharper, and AI-Refactored code standards for all modifications.
// </auto-generated>

namespace AIRefactored.AI.Perception
{
    using System.Collections.Generic;
    using AIRefactored.AI.Core;
    using AIRefactored.AI.Helpers;
    using AIRefactored.AI.Memory;
    using AIRefactored.Core;
    using AIRefactored.Pools;
    using EFT;
    using EFT.Animations;
    using UnityEngine;

    /// <summary>
    /// Simulates realistic bot visual perception using view cone, fog/light occlusion,
    /// bone confidence, motion detection, suppression, and squad memory sharing.
    /// </summary>
    public sealed class BotVisionSystem
    {
        private const float AutoDetectRadius = 4f;
        private const float BaseViewConeAngle = 120f;
        private const float BoneConfidenceDecay = 0.1f;
        private const float BoneConfidenceThreshold = 0.45f;
        private const float MaxDetectionDistance = 120f;
        private const float SuppressionMissChance = 0.2f;
        private const float MotionBoost = 0.2f;

        private static readonly Vector3 EyeOffset = new Vector3(0f, 1.4f, 0f);

        private static readonly PlayerBoneType[] BonesToCheck =
        {
            PlayerBoneType.Head, PlayerBoneType.Spine, PlayerBoneType.Ribcage,
            PlayerBoneType.LeftShoulder, PlayerBoneType.RightShoulder,
            PlayerBoneType.Pelvis, PlayerBoneType.LeftThigh1, PlayerBoneType.RightThigh1
        };

        private BotOwner _bot;
        private BotComponentCache _cache;
        private BotTacticalMemory _memory;
        private BotPersonalityProfile _profile;
        private float _lastCommitTime = -999f;

        public void Initialize(BotComponentCache cache)
        {
            _bot = cache.Bot;
            _cache = cache;
            _profile = cache.AIRefactoredBotOwner.PersonalityProfile;
            _memory = cache.TacticalMemory;
        }

        public void Tick(float time)
        {
            if (!IsValid())
            {
                return;
            }

            Vector3 eye = _bot.Position + EyeOffset;
            Vector3 forward = _bot.LookDirection;

            float fogFactor = RenderSettings.fog ? Mathf.Clamp01(RenderSettings.fogDensity * 4f) : 0f;
            float ambient = RenderSettings.ambientLight.grayscale;
            float viewCone = Mathf.Lerp(BaseViewConeAngle, 60f, 1f - ambient);

            Transform head = BotCacheUtility.Head(_cache);
            if (head != null && FlashlightRegistry.IsExposingBot(head, out _))
            {
                viewCone *= 0.6f;
            }

            List<Player> players = GameWorldHandler.GetAllAlivePlayers();
            Player bestTarget = null;
            float bestDistance = float.MaxValue;

            for (int i = 0; i < players.Count; i++)
            {
                Player target = players[i];
                if (!IsValidTarget(target))
                {
                    continue;
                }

                Vector3 pos = EFTPlayerUtil.GetPosition(target);
                float dist = Vector3.Distance(eye, pos);
                float maxVisible = MaxDetectionDistance * (1f - fogFactor);

                if (dist > maxVisible)
                {
                    continue;
                }

                bool inCone = IsInViewCone(forward, eye, pos, viewCone);
                bool close = dist <= AutoDetectRadius;
                bool canSee = HasLineOfSight(eye, target);

                if ((inCone && canSee) || (close && canSee))
                {
                    if (dist < bestDistance)
                    {
                        bestDistance = dist;
                        bestTarget = target;
                    }
                }
                else if ((inCone || close) && !canSee && !FikaHeadlessDetector.IsHeadless)
                {
                    _bot.BotTalk?.TrySay(EPhraseTrigger.OnBeingHurt);
                }
            }

            if (bestTarget != null)
            {
                Vector3 position = EFTPlayerUtil.GetPosition(bestTarget);
                _memory.RecordEnemyPosition(position, "Visual", bestTarget.ProfileId);

                if (_cache.GroupSync != null)
                {
                    List<BotComponentCache> teammates = TempListPool.Rent<BotComponentCache>();
                    try
                    {
                        IReadOnlyList<BotOwner> squad = _cache.GroupSync.GetTeammates();
                        for (int i = 0; i < squad.Count; i++)
                        {
                            BotOwner teammate = squad[i];
                            if (BotRegistry.TryGetCache(teammate.ProfileId, out BotComponentCache component))
                            {
                                teammates.Add(component);
                            }
                        }

                        _memory.ShareMemoryWith(teammates);
                    }
                    finally
                    {
                        TempListPool.Return(teammates);
                    }
                }

                TrackVisibleBones(eye, bestTarget, fogFactor);
                EvaluateTargetConfidence(bestTarget, time);
            }
        }


        private void TrackVisibleBones(Vector3 eye, Player target, float fog)
        {
            if (_cache.VisibilityTracker == null)
            {
                _cache.VisibilityTracker = new TrackedEnemyVisibility(_bot.Transform.Original);
            }

            TrackedEnemyVisibility tracker = _cache.VisibilityTracker;

            if (target.TryGetComponent<PlayerSpiritBones>(out PlayerSpiritBones bones))
            {
                for (int i = 0; i < BonesToCheck.Length; i++)
                {
                    Transform bone = bones.GetBone(BonesToCheck[i]).Original;
                    if (bone != null && !Physics.Linecast(eye, bone.position, out _, AIRefactoredLayerMasks.LineOfSightMask))
                    {
                        float boost = IsMovingFast(target) ? MotionBoost : 0f;
                        tracker.UpdateBoneVisibility(BonesToCheck[i].ToString(), bone.position, boost, fog);
                    }
                }
            }
            else
            {
                Transform tf = EFTPlayerUtil.GetTransform(target);
                if (tf != null && !Physics.Linecast(eye, tf.position, out _, AIRefactoredLayerMasks.LineOfSightMask))
                {
                    tracker.UpdateBoneVisibility("Body", tf.position);
                }
            }

            tracker.DecayConfidence(BoneConfidenceDecay * Time.deltaTime);
        }

        private void EvaluateTargetConfidence(Player target, float time)
        {
            TrackedEnemyVisibility tracker = _cache.VisibilityTracker;
            if (!tracker.HasEnoughData)
            {
                return;
            }

            float confidence = tracker.GetOverallConfidence();

            if (_bot.Memory.IsUnderFire && Random.value < SuppressionMissChance)
            {
                return;
            }

            if (confidence < BoneConfidenceThreshold)
            {
                return;
            }

            CommitEnemyIfAllowed(target, time);
        }

        private void CommitEnemyIfAllowed(Player target, float time)
        {
            if (!EFTPlayerUtil.IsEnemyOf(_bot, target))
            {
                return;
            }

            float delay = Mathf.Lerp(0.1f, 0.6f, 1f - _profile.ReactionTime);
            if (time - _lastCommitTime < delay)
            {
                return;
            }

            IPlayer enemy = EFTPlayerUtil.AsSafeIPlayer(target);
            if (enemy == null || _bot.BotsGroup == null)
            {
                return;
            }

            _bot.BotsGroup.AddEnemy(enemy, EBotEnemyCause.addPlayer);
            _lastCommitTime = time;

            if (!FikaHeadlessDetector.IsHeadless)
            {
                _bot.BotTalk?.TrySay(EPhraseTrigger.OnEnemyConversation);
            }
        }

        private static bool HasLineOfSight(Vector3 from, Player target)
        {
            Transform t = EFTPlayerUtil.GetTransform(target);
            if (t == null)
            {
                return false;
            }

            Vector3 to = t.position + EyeOffset;
            return !Physics.Linecast(from, to, out RaycastHit hit, AIRefactoredLayerMasks.LineOfSightMask)
                   || hit.collider.transform.root == t.root;
        }

        private static bool IsInViewCone(Vector3 forward, Vector3 origin, Vector3 target, float angle)
        {
            return Vector3.Angle(forward, target - origin) <= angle * 0.5f;
        }

        private static bool IsMovingFast(Player p)
        {
            return p.Velocity.sqrMagnitude > 2.25f;
        }

        private bool IsValid()
        {
            return _bot != null &&
                   _cache != null &&
                   _profile != null &&
                   _memory != null &&
                   _bot.GetPlayer != null &&
                   _bot.GetPlayer.IsAI &&
                   !_bot.GetPlayer.IsYourPlayer &&
                   !_bot.IsDead &&
                   GameWorldHandler.IsSafeToInitialize;
        }

        private bool IsValidTarget(Player t)
        {
            return t != null &&
                   t.ProfileId != _bot.ProfileId &&
                   EFTPlayerUtil.IsEnemyOf(_bot, t) &&
                   EFTPlayerUtil.IsValid(t);
        }
    }
}
