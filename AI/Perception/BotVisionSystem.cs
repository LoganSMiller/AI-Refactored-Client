// <auto-generated>
//   This file is part of AI-Refactored, an open-source project focused on realistic AI behavior in Escape from Tarkov.
//   Licensed under the MIT License. See LICENSE in the repository root for more information.
//
//   THIS FILE IS SYSTEMATICALLY MANAGED.
//   Please follow strict StyleCop, ReSharper, and AI-Refactored code standards for all modifications.
// </auto-generated>

#nullable enable

namespace AIRefactored.AI.Perception
{
    using System.Collections.Generic;
    using AIRefactored.AI.Core;
    using AIRefactored.AI.Groups;
    using AIRefactored.AI.Memory;
    using AIRefactored.Core;
    using EFT;
    using EFT.Animations;
    using UnityEngine;

    /// <summary>
    /// Simulates realistic bot visual perception using view cone, distance, fog/light occlusion,
    /// bone confidence, suppression stress, and tactical memory.
    /// </summary>
    public sealed class BotVisionSystem
    {
        #region Constants

        private const float AutoDetectRadius = 4f;
        private const float BaseViewConeAngle = 120f;
        private const float BoneConfidenceDecay = 0.1f;
        private const float BoneConfidenceThreshold = 0.45f;
        private const float MaxDetectionDistance = 120f;
        private const float SuppressionMissChance = 0.2f;

        private static readonly Vector3 EyeOffset = new Vector3(0f, 1.4f, 0f);

        #endregion

        #region Static

        private static readonly PlayerBoneType[] BonesToCheck =
        {
            PlayerBoneType.Head,
            PlayerBoneType.Spine,
            PlayerBoneType.Ribcage,
            PlayerBoneType.LeftShoulder,
            PlayerBoneType.RightShoulder,
            PlayerBoneType.Pelvis,
            PlayerBoneType.LeftThigh1,
            PlayerBoneType.RightThigh1
        };

        #endregion

        #region Fields

        private BotOwner? _bot;
        private BotComponentCache? _cache;
        private BotTacticalMemory? _memory;
        private BotPersonalityProfile? _profile;
        private float _lastCommitTime = -999f;

        #endregion

        #region Public API

        /// <summary>
        /// Initializes the bot vision system with the given component cache.
        /// </summary>
        public void Initialize(BotComponentCache cache)
        {
            this._cache = cache;
            this._bot = cache.Bot;
            this._profile = cache.AIRefactoredBotOwner?.PersonalityProfile;
            this._memory = cache.TacticalMemory;
        }

        /// <summary>
        /// Performs a single visual detection tick.
        /// </summary>
        public void Tick(float time)
        {
            if (!this.IsValidContext() || this._bot == null)
            {
                return;
            }

            Vector3 eye = this._bot.Position + EyeOffset;
            Vector3 forward = this._bot.LookDirection;

            float fogPenalty = RenderSettings.fog ? Mathf.Clamp01(RenderSettings.fogDensity * 4f) : 0f;
            float ambientLight = RenderSettings.ambientLight.grayscale;
            float adjustedViewCone = Mathf.Lerp(BaseViewConeAngle, 60f, 1f - ambientLight);

            Player? bestTarget = null;
            float bestScore = float.MaxValue;

            List<Player> players = GameWorldHandler.GetAllAlivePlayers();
            for (int i = 0; i < players.Count; i++)
            {
                Player? target = players[i];
                if (!this.IsValidTarget(target))
                {
                    continue;
                }

                Vector3 targetPos = EFTPlayerUtil.GetPosition(target);
                float dist = Vector3.Distance(eye, targetPos);
                if (dist > MaxDetectionDistance * (1f - fogPenalty))
                {
                    continue;
                }

                bool inViewCone = IsInViewCone(forward, eye, targetPos, adjustedViewCone);
                bool withinAutoRange = dist <= AutoDetectRadius;
                bool canSee = HasLineOfSight(eye, target);

                if ((withinAutoRange && canSee) || (inViewCone && canSee))
                {
                    if (dist < bestScore)
                    {
                        bestScore = dist;
                        bestTarget = target;
                    }
                }
            }

            if (bestTarget != null && this._memory != null)
            {
                Vector3 botEye = this._bot.Position + EyeOffset;
                Vector3 enemyPos = EFTPlayerUtil.GetPosition(bestTarget);

                this._memory.RecordEnemyPosition(enemyPos);
                this.TrackVisibleBones(botEye, bestTarget);
                this.EvaluateTargetConfidence(bestTarget, time);
            }
        }

        #endregion

        #region Private Helpers

        private static bool HasLineOfSight(Vector3 from, Player target)
        {
            Transform? toTransform = EFTPlayerUtil.GetTransform(target);
            if (toTransform == null)
            {
                return false;
            }

            Vector3 to = toTransform.position + EyeOffset;
            return !Physics.Linecast(from, to, out RaycastHit hit) ||
                   hit.collider != null && hit.collider.transform.root == toTransform.root;
        }

        private static bool IsInViewCone(Vector3 forward, Vector3 origin, Vector3 target, float viewCone)
        {
            float angle = Vector3.Angle(forward, target - origin);
            return angle <= viewCone * 0.5f;
        }

        /// <summary>
        ///     Registers the target as an enemy if enough confidence has been built.
        ///     Avoids Dissonance ambiguity via safe casting.
        /// </summary>
        private void CommitEnemyIfAllowed(Player? target, float time)
        {
            if (target == null || this._bot == null || this._profile == null || this._bot.BotTalk == null)
            {
                return;
            }

            BotsGroup? group = this._bot.BotsGroup;
            if (group == null)
            {
                return;
            }

            object raw = target;
            EFT.IPlayer iTarget = (EFT.IPlayer)raw;

            if (group.IsEnemy(iTarget))
            {
                return;
            }

            float delay = Mathf.Lerp(0.1f, 0.6f, 1f - this._profile.ReactionTime);
            if (time - this._lastCommitTime < delay)
            {
                return;
            }

            group.AddEnemy(iTarget, EBotEnemyCause.addPlayer);

            if (!FikaHeadlessDetector.IsHeadless)
            {
                this._bot.BotTalk.TrySay(EPhraseTrigger.OnEnemyConversation);
            }

            this._lastCommitTime = time;
        }

        private void EvaluateTargetConfidence(Player target, float time)
        {
            TrackedEnemyVisibility? tracker = this._cache?.VisibilityTracker;
            if (tracker == null || !tracker.HasEnoughData)
            {
                return;
            }

            if (tracker.GetOverallConfidence() < BoneConfidenceThreshold)
            {
                return;
            }

            if (this._bot != null && this._bot.Memory.IsUnderFire)
            {
                if (Random.value < SuppressionMissChance)
                {
                    return;
                }
            }

            this.CommitEnemyIfAllowed(target, time);
        }

        private bool IsValidContext()
        {
            if (this._bot == null || this._cache == null || this._profile == null || this._memory == null)
            {
                return false;
            }

            Player? player = this._bot.GetPlayer as Player;
            return player != null && player.IsAI && !player.IsYourPlayer && !this._bot.IsDead;
        }

        /// <summary>
        ///     Validates that the target is a live enemy distinct from the bot.
        /// </summary>
        private bool IsValidTarget(Player target)
        {
            if (!EFTPlayerUtil.IsValid(target) || this._bot == null)
            {
                return false;
            }

            if (target.ProfileId == this._bot.ProfileId)
            {
                return false;
            }

            return EFTPlayerUtil.IsEnemyOf(this._bot, target);
        }

        private void TrackVisibleBones(Vector3 eye, Player target)
        {
            if (this._cache == null || this._bot == null)
            {
                return;
            }

            if (this._cache.VisibilityTracker == null)
            {
                this._cache.VisibilityTracker = new TrackedEnemyVisibility(this._bot.Transform.Original);
            }

            TrackedEnemyVisibility tracker = this._cache.VisibilityTracker;

            if (target.TryGetComponent<PlayerSpiritBones>(out PlayerSpiritBones bones) && bones != null)
            {
                for (int i = 0; i < BonesToCheck.Length; i++)
                {
                    Transform? bone = bones.GetBone(BonesToCheck[i])?.Original;
                    if (bone == null)
                    {
                        continue;
                    }

                    if (!Physics.Linecast(eye, bone.position, out RaycastHit hit)
                        || (hit.collider != null && hit.collider.gameObject == target.gameObject))
                    {
                        tracker.UpdateBoneVisibility(BonesToCheck[i].ToString(), bone.position);
                    }
                }
            }
            else
            {
                Transform? targetTransform = EFTPlayerUtil.GetTransform(target);
                if (targetTransform != null &&
                    Physics.Linecast(eye, targetTransform.position, out RaycastHit fallbackHit) &&
                    fallbackHit.collider != null &&
                    fallbackHit.collider.transform.root == targetTransform.root)
                {
                    tracker.UpdateBoneVisibility("Body", targetTransform.position);
                }
            }

            tracker.DecayConfidence(BoneConfidenceDecay * Time.deltaTime);
        }

        #endregion
    }
}
