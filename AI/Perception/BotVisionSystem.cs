// <auto-generated>
//   This file is part of AI-Refactored, an open-source project focused on realistic AI behavior in Escape from Tarkov.
//   Licensed under the MIT License. See LICENSE in the repository root for more information.
//
//   THIS FILE IS SYSTEMATICALLY MANAGED.
//   Please follow strict StyleCop, ReSharper, and AI-Refactored code standards for all modifications.
// </auto-generated>

#nullable enable

namespace AIRefactored.AI.Perception
{
    using System.Collections.Generic;
    using AIRefactored.AI.Core;
    using AIRefactored.AI.Helpers;
    using AIRefactored.AI.Memory;
    using AIRefactored.Core;
    using EFT;
    using EFT.Animations;
    using UnityEngine;

    /// <summary>
    /// Simulates realistic bot visual perception using view cone, fog/light occlusion,
    /// bone confidence, motion detection, suppression, and squad memory sharing.
    /// </summary>
    public sealed class BotVisionSystem
    {
        #region Constants

        private const float AutoDetectRadius = 4f;
        private const float BaseViewConeAngle = 120f;
        private const float BoneConfidenceDecay = 0.1f;
        private const float BoneConfidenceThreshold = 0.45f;
        private const float MaxDetectionDistance = 120f;
        private const float SuppressionMissChance = 0.2f;
        private const float MotionBoost = 0.2f;

        private static readonly Vector3 EyeOffset = new Vector3(0f, 1.4f, 0f);

        #endregion

        #region Static Data

        private static readonly PlayerBoneType[] BonesToCheck = new PlayerBoneType[]
        {
            PlayerBoneType.Head,
            PlayerBoneType.Spine,
            PlayerBoneType.Ribcage,
            PlayerBoneType.LeftShoulder,
            PlayerBoneType.RightShoulder,
            PlayerBoneType.Pelvis,
            PlayerBoneType.LeftThigh1,
            PlayerBoneType.RightThigh1
        };

        #endregion

        #region Fields

        private BotOwner? _bot;
        private BotComponentCache? _cache;
        private BotTacticalMemory? _memory;
        private BotPersonalityProfile? _profile;
        private float _lastCommitTime = -999f;

        #endregion

        #region Public Methods

        public void Initialize(BotComponentCache cache)
        {
            this._cache = cache;
            this._bot = cache.Bot;
            this._profile = cache.AIRefactoredBotOwner?.PersonalityProfile;
            this._memory = cache.TacticalMemory;
        }

        public void Tick(float time)
        {
            if (!this.IsValidContext())
            {
                return;
            }

            if (this._cache == null || this._bot == null || this._memory == null)
            {
                return;
            }

            if (this._cache.IsBlinded || time < this._cache.BlindUntilTime)
            {
                return;
            }

            Vector3 eye = this._bot.Position + EyeOffset;
            Vector3 forward = this._bot.LookDirection;

            // Fog and ambient light impact view cone angle and sight distance
            float fogFactor = RenderSettings.fog ? Mathf.Clamp01(RenderSettings.fogDensity * 4f) : 0f;
            float ambient = RenderSettings.ambientLight.grayscale;
            float adjustedViewCone = Mathf.Lerp(BaseViewConeAngle, 60f, 1f - ambient);

            Transform? head = BotCacheUtility.Head(this._cache);
            if (head != null && FlashlightRegistry.IsExposingBot(head, out _))
            {
                adjustedViewCone *= 0.6f;  // Reduce the view cone when exposed to light
            }

            List<Player> players = GameWorldHandler.GetAllAlivePlayers();
            Player? bestTarget = null;
            float closestDist = float.MaxValue;

            for (int i = 0; i < players.Count; i++)
            {
                Player target = players[i];
                if (!this.IsValidTarget(target))
                {
                    continue;
                }

                Vector3 targetPos = EFTPlayerUtil.GetPosition(target);
                float distance = Vector3.Distance(eye, targetPos);
                if (distance > MaxDetectionDistance * (1f - fogFactor))
                {
                    continue;
                }

                bool inCone = IsInViewCone(forward, eye, targetPos, adjustedViewCone);
                bool close = distance <= AutoDetectRadius;
                bool canSee = this.HasLineOfSight(eye, target);

                if ((inCone && canSee) || (close && canSee))
                {
                    if (distance < closestDist)
                    {
                        closestDist = distance;
                        bestTarget = target;
                    }
                }
                else if ((inCone || close) && !canSee && !FikaHeadlessDetector.IsHeadless)
                {
                    this._bot.BotTalk?.TrySay(EPhraseTrigger.OnBeingHurt);
                }
            }

            if (bestTarget != null)
            {
                string id = bestTarget.ProfileId ?? "unknown";
                Vector3 position = EFTPlayerUtil.GetPosition(bestTarget);

                this._memory.RecordEnemyPosition(position, "Visual", id);

                if (this._cache.GroupSync != null)
                {
                    List<BotComponentCache> teammates = new List<BotComponentCache>(8);
                    foreach (BotOwner teammate in this._cache.GroupSync.GetTeammates())
                    {
                        BotComponentCache? mateCache = BotRegistry.TryGetCache(teammate.ProfileId);
                        if (mateCache != null)
                        {
                            teammates.Add(mateCache);
                        }
                    }

                    this._memory.ShareMemoryWith(teammates);
                }

                this.TrackVisibleBones(eye, bestTarget, fogFactor);
                this.EvaluateTargetConfidence(bestTarget, time);
            }
        }

        #endregion

        #region Private Methods

        private bool HasLineOfSight(Vector3 from, Player target)
        {
            Transform? t = EFTPlayerUtil.GetTransform(target);
            if (t == null)
            {
                return false;
            }

            Vector3 to = t.position + EyeOffset;
            if (Physics.Linecast(from, to, out RaycastHit hit, AIRefactoredLayerMasks.LineOfSightMask))
            {
                return hit.collider != null && hit.collider.transform.root == t.root;
            }

            return true;
        }

        private static bool IsInViewCone(Vector3 forward, Vector3 origin, Vector3 target, float coneAngle)
        {
            float angle = Vector3.Angle(forward, target - origin);
            return angle <= coneAngle * 0.5f;
        }

        private void CommitEnemyIfAllowed(Player target, float time)
        {
            if (this._bot == null || this._profile == null)
            {
                return;
            }

            if (!EFTPlayerUtil.IsEnemyOf(this._bot, target))
            {
                return;
            }

            float delay = Mathf.Lerp(0.1f, 0.6f, 1f - this._profile.ReactionTime);
            if (time - this._lastCommitTime < delay)
            {
                return;
            }

            IPlayer? enemy = EFTPlayerUtil.AsSafeIPlayer(target);
            if (enemy == null || this._bot.BotsGroup == null)
            {
                return;
            }

            this._bot.BotsGroup.AddEnemy(enemy, EBotEnemyCause.addPlayer);
            this._lastCommitTime = time;

            if (!FikaHeadlessDetector.IsHeadless)
            {
                this._bot.BotTalk?.TrySay(EPhraseTrigger.OnEnemyConversation);
            }
        }

        private void EvaluateTargetConfidence(Player target, float time)
        {
            if (this._cache == null || this._bot == null)
            {
                return;
            }

            TrackedEnemyVisibility? tracker = this._cache.VisibilityTracker;
            if (tracker == null || !tracker.HasEnoughData)
            {
                return;
            }

            float confidence = tracker.GetOverallConfidence();

            if (this._bot.Memory.IsUnderFire && Random.value < SuppressionMissChance)
            {
                return;
            }

            if (confidence < BoneConfidenceThreshold)
            {
                return;
            }

            this.CommitEnemyIfAllowed(target, time);
        }

        private void TrackVisibleBones(Vector3 eye, Player target, float ambientOcclusionFactor)
        {
            if (this._cache == null || this._bot == null)
            {
                return;
            }

            if (this._cache.VisibilityTracker == null)
            {
                this._cache.VisibilityTracker = new TrackedEnemyVisibility(this._bot.Transform.Original);
            }

            TrackedEnemyVisibility tracker = this._cache.VisibilityTracker;

            if (target.TryGetComponent<PlayerSpiritBones>(out PlayerSpiritBones bones) && bones != null)
            {
                for (int i = 0; i < BonesToCheck.Length; i++)
                {
                    Transform? bone = bones.GetBone(BonesToCheck[i])?.Original;
                    if (bone == null)
                    {
                        continue;
                    }

                    if (!Physics.Linecast(eye, bone.position, out RaycastHit hit, AIRefactoredLayerMasks.LineOfSightMask))
                    {
                        float bonus = this.IsMovingFast(target) ? MotionBoost : 0f;
                        tracker.UpdateBoneVisibility(BonesToCheck[i].ToString(), bone.position, bonus, ambientOcclusionFactor);
                    }
                }
            }
            else
            {
                Transform? tf = EFTPlayerUtil.GetTransform(target);
                if (tf != null && !Physics.Linecast(eye, tf.position, out RaycastHit hit, AIRefactoredLayerMasks.LineOfSightMask))
                {
                    tracker.UpdateBoneVisibility("Body", tf.position);
                }
            }

            tracker.DecayConfidence(BoneConfidenceDecay * Time.deltaTime);
        }

        private bool IsMovingFast(Player player)
        {
            return player.Velocity.magnitude > 1.5f;
        }

        private bool IsValidContext()
        {
            return this._bot != null &&
                   this._cache != null &&
                   this._profile != null &&
                   this._memory != null &&
                   this._bot.GetPlayer != null &&
                   this._bot.GetPlayer.IsAI &&
                   !this._bot.GetPlayer.IsYourPlayer &&
                   !this._bot.IsDead;
        }

        private bool IsValidTarget(Player target)
        {
            if (this._bot == null || !EFTPlayerUtil.IsValid(target))
            {
                return false;
            }

            return target.ProfileId != this._bot.ProfileId &&
                   EFTPlayerUtil.IsEnemyOf(this._bot, target);
        }

        #endregion
    }
}
