// <auto-generated>
//   This file is part of AI-Refactored, an open-source project focused on realistic AI behavior in Escape from Tarkov.
//   Licensed under the MIT License. See LICENSE in the repository root for more information.
//
//   THIS FILE IS SYSTEMATICALLY MANAGED.
//   Please follow strict StyleCop, ReSharper, and AI-Refactored code standards for all modifications.
// </auto-generated>

#nullable enable

namespace AIRefactored.AI.Optimization
{
    using System.Collections.Generic;
    using AIRefactored.AI.Memory;
    using AIRefactored.AI.Navigation;
    using AIRefactored.Core;
    using AIRefactored.Runtime;
    using BepInEx.Logging;
    using EFT;
    using UnityEngine;
    using UnityEngine.AI;

    /// <summary>
    /// Caches NavMesh paths and fallback scoring for individual bots.
    /// Optimizes retreat and navigation behaviors with smart path reuse and avoidance heuristics.
    /// </summary>
    public class BotOwnerPathfindingCache
    {
        private const float BlockCheckHeight = 1.2f;
        private const float BlockCheckMargin = 0.5f;

        private static readonly ManualLogSource Logger = AIRefactoredController.Logger;

        private readonly Dictionary<string, float> _coverWeights = new Dictionary<string, float>(64);
        private readonly Dictionary<string, List<Vector3>> _fallbackCache = new Dictionary<string, List<Vector3>>(64);
        private readonly Dictionary<string, List<Vector3>> _pathCache = new Dictionary<string, List<Vector3>>(64);

        private BotTacticalMemory? _tacticalMemory;

        public void BroadcastRetreat(BotOwner botOwner, Vector3 point)
        {
            if (!IsAIBot(botOwner) || botOwner.BotsGroup == null || string.IsNullOrEmpty(botOwner.ProfileId))
            {
                return;
            }

            string map = GameWorldHandler.GetCurrentMapName();
            BotMemoryStore.AddDangerZone(map, point, DangerTriggerType.Panic, 5f);
        }

        public void Clear()
        {
            _pathCache.Clear();
            _fallbackCache.Clear();
        }

        public float GetCoverWeight(string mapId, Vector3 pos)
        {
            string key = mapId + "_" + RoundVector3ToKey(pos);
            return _coverWeights.TryGetValue(key, out float weight) ? weight : 1f;
        }

        public List<Vector3> GetFallbackPath(BotOwner bot, Vector3 direction)
        {
            string? id = bot.Profile?.Id;
            if (string.IsNullOrEmpty(id))
            {
                return new List<Vector3>();
            }

            Vector3 origin = bot.Position;
            Vector3 fallbackTarget = origin - direction.normalized * 8f;
            string key = id + "_fb_" + HashVecDir(origin, direction);

            if (_fallbackCache.TryGetValue(key, out List<Vector3>? cached)
                && cached.Count > 1
                && !IsPathBlocked(cached))
            {
                return cached;
            }

            List<Vector3> navFallbacks = NavPointRegistry.QueryNearby(
                origin,
                25f,
                pos => NavPointRegistry.GetTag(pos) == "fallback");

            for (int i = 0; i < navFallbacks.Count; i++)
            {
                Vector3 candidate = navFallbacks[i];

                if (IsPathInClearedZone(new List<Vector3> { candidate }))
                {
                    continue;
                }

                List<Vector3> navPath = BuildNavPath(origin, candidate);
                if (navPath.Count > 1 && !IsPathBlocked(navPath))
                {
                    _fallbackCache[key] = navPath;
                    return navPath;
                }
            }

            List<Vector3> raw = BuildNavPath(origin, fallbackTarget);
            if (raw.Count > 1 && !IsPathBlocked(raw) && !IsPathInClearedZone(raw))
            {
                _fallbackCache[key] = raw;
                return raw;
            }

            return new List<Vector3>();
        }

        public List<Vector3> GetOptimizedPath(BotOwner botOwner, Vector3 destination)
        {
            if (!IsAIBot(botOwner))
            {
                return new List<Vector3> { destination };
            }

            string? botId = botOwner.Profile?.Id;
            if (string.IsNullOrEmpty(botId))
            {
                return new List<Vector3> { destination };
            }

            string key = botId + "_" + destination.ToString("F2");

            if (_pathCache.TryGetValue(key, out List<Vector3>? cached) && !IsPathBlocked(cached))
            {
                return cached;
            }

            List<Vector3> path = BuildNavPath(botOwner.Position, destination);
            _pathCache[key] = path;
            return path;
        }

        public void RegisterCoverNode(string mapId, Vector3 pos, float score)
        {
            string key = mapId + "_" + RoundVector3ToKey(pos);
            if (!_coverWeights.ContainsKey(key))
            {
                _coverWeights[key] = Mathf.Clamp(score, 0.1f, 10f);
            }
        }

        public void SetTacticalMemory(BotTacticalMemory memory)
        {
            _tacticalMemory = memory;
        }

        public bool TryGetValidPath(BotOwner botOwner, Vector3 destination, out List<Vector3> path)
        {
            path = GetOptimizedPath(botOwner, destination);
            return path.Count >= 2 && !IsPathBlocked(path);
        }

        private static bool IsAIBot(BotOwner? bot)
        {
            Player? player = bot?.GetPlayer;
            return player != null && player.IsAI && !player.IsYourPlayer;
        }

        private static string HashVecDir(Vector3 pos, Vector3 dir)
        {
            Vector3 hashVec = pos + dir.normalized * 2f;
            return hashVec.x.ToString("F1") + "_" + hashVec.y.ToString("F1") + "_" + hashVec.z.ToString("F1");
        }

        private static string RoundVector3ToKey(Vector3 v)
        {
            return v.x.ToString("F1") + "_" + v.y.ToString("F1") + "_" + v.z.ToString("F1");
        }

        private List<Vector3> BuildNavPath(Vector3 origin, Vector3 target)
        {
            NavMeshPath navPath = new NavMeshPath();
            bool valid = NavMesh.CalculatePath(origin, target, NavMesh.AllAreas, navPath);

            if (valid && navPath.status == NavMeshPathStatus.PathComplete)
            {
                return new List<Vector3>(navPath.corners);
            }

            return new List<Vector3> { origin, target };
        }

        private bool IsPathBlocked(List<Vector3> path)
        {
            if (path.Count < 2)
            {
                return false;
            }

            Vector3 origin = path[0] + Vector3.up * BlockCheckHeight;
            Vector3 next = path[1];
            Vector3 dir = (next - path[0]).normalized;
            float dist = Vector3.Distance(path[0], next);

            return Physics.Raycast(origin, dir, dist + BlockCheckMargin, LayerMaskClass.DoorLayer);
        }

        private bool IsPathInClearedZone(List<Vector3> path)
        {
            if (_tacticalMemory == null || path.Count == 0)
            {
                return false;
            }

            for (int i = 0; i < path.Count; i++)
            {
                if (_tacticalMemory.WasRecentlyCleared(path[i]))
                {
                    return true;
                }
            }

            return false;
        }
    }
}
