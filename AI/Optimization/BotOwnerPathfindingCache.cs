// <auto-generated>
//   This file is part of AI-Refactored, an open-source project focused on realistic AI behavior in Escape from Tarkov.
//   Licensed under the MIT License. See LICENSE in the repository root for more information.
//
//   THIS FILE IS SYSTEMATICALLY MANAGED.
//   Please follow strict StyleCop, ReSharper, and AI-Refactored code standards for all modifications.
// </auto-generated>

#nullable enable

namespace AIRefactored.AI.Optimization
{
    using System.Collections.Generic;
    using AIRefactored.AI.Memory;
    using AIRefactored.AI.Navigation;
    using AIRefactored.Core;
    using AIRefactored.Runtime;
    using BepInEx.Logging;
    using EFT;
    using UnityEngine;
    using UnityEngine.AI;

    /// <summary>
    /// Caches NavMesh paths and fallback scoring for individual bots.
    /// Optimizes retreat and navigation behaviors with smart path reuse and avoidance heuristics.
    /// </summary>
    public sealed class BotOwnerPathfindingCache
    {
        private const float BlockCheckHeight = 1.2f;
        private const float BlockCheckMargin = 0.5f;

        private static readonly ManualLogSource Logger = AIRefactoredController.Logger;

        private readonly Dictionary<string, float> _coverWeights = new Dictionary<string, float>(64);
        private readonly Dictionary<string, List<Vector3>> _fallbackCache = new Dictionary<string, List<Vector3>>(64);
        private readonly Dictionary<string, List<Vector3>> _pathCache = new Dictionary<string, List<Vector3>>(64);

        private BotTacticalMemory? _tacticalMemory;

        /// <summary>
        /// Registers a fallback retreat trigger point in shared memory.
        /// </summary>
        public void BroadcastRetreat(BotOwner botOwner, Vector3 point)
        {
            if (!IsAIBot(botOwner) || botOwner.BotsGroup == null || string.IsNullOrEmpty(botOwner.ProfileId))
            {
                return;
            }

            string map = GameWorldHandler.GetCurrentMapName();
            BotMemoryStore.AddDangerZone(map, point, DangerTriggerType.Panic, 5f);
        }

        /// <summary>
        /// Clears cached paths and fallback data.
        /// </summary>
        public void Clear()
        {
            this._pathCache.Clear();
            this._fallbackCache.Clear();
        }

        /// <summary>
        /// Returns a weighted multiplier for cover position scoring, based on map data.
        /// </summary>
        public float GetCoverWeight(string mapId, Vector3 pos)
        {
            string key = mapId + "_" + RoundVector3ToKey(pos);
            return this._coverWeights.TryGetValue(key, out float weight) ? weight : 1f;
        }

        /// <summary>
        /// Returns the best fallback retreat path, based on tactical history and zone scoring.
        /// </summary>
        public List<Vector3> GetFallbackPath(BotOwner bot, Vector3 direction)
        {
            string? id = bot.Profile?.Id;
            if (string.IsNullOrEmpty(id))
            {
                return new List<Vector3>();
            }

            Vector3 origin = bot.Position;
            Vector3 fallbackTarget = origin - direction.normalized * 8f;
            string key = id + "_fb_" + HashVecDir(origin, direction);

            if (this._fallbackCache.TryGetValue(key, out List<Vector3>? cached)
                && cached.Count > 1
                && !this.IsPathBlocked(cached))
            {
                return cached;
            }

            List<Vector3> navFallbacks = NavPointRegistry.QueryNearby(
                origin,
                25f,
                pos => NavPointRegistry.GetTag(pos) == "fallback");

            for (int i = 0; i < navFallbacks.Count; i++)
            {
                Vector3 candidate = navFallbacks[i];
                if (this.IsPathInClearedZone(new List<Vector3> { candidate }))
                {
                    continue;
                }

                List<Vector3> navPath = this.BuildNavPath(origin, candidate);
                if (navPath.Count > 1 && !this.IsPathBlocked(navPath))
                {
                    this._fallbackCache[key] = navPath;
                    return navPath;
                }
            }

            List<Vector3> raw = this.BuildNavPath(origin, fallbackTarget);
            if (raw.Count > 1 && !this.IsPathBlocked(raw) && !this.IsPathInClearedZone(raw))
            {
                this._fallbackCache[key] = raw;
                return raw;
            }

            return new List<Vector3>();
        }

        /// <summary>
        /// Returns a safe and optimized cached path to the destination, or recalculates if invalid.
        /// </summary>
        public List<Vector3> GetOptimizedPath(BotOwner botOwner, Vector3 destination)
        {
            if (!IsAIBot(botOwner))
            {
                return new List<Vector3> { destination };
            }

            string? botId = botOwner.Profile?.Id;
            if (string.IsNullOrEmpty(botId))
            {
                return new List<Vector3> { destination };
            }

            string key = botId + "_" + destination.ToString("F2");

            if (this._pathCache.TryGetValue(key, out List<Vector3>? cached) && !this.IsPathBlocked(cached))
            {
                return cached;
            }

            List<Vector3> path = this.BuildNavPath(botOwner.Position, destination);
            this._pathCache[key] = path;
            return path;
        }

        /// <summary>
        /// Registers the score of a cover point for map-aware decision making.
        /// </summary>
        public void RegisterCoverNode(string mapId, Vector3 pos, float score)
        {
            string key = mapId + "_" + RoundVector3ToKey(pos);
            if (!this._coverWeights.ContainsKey(key))
            {
                this._coverWeights[key] = Mathf.Clamp(score, 0.1f, 10f);
            }
        }

        /// <summary>
        /// Assigns a tactical memory module for zone safety scoring.
        /// </summary>
        public void SetTacticalMemory(BotTacticalMemory memory)
        {
            this._tacticalMemory = memory;
        }

        /// <summary>
        /// Attempts to get a valid path that is neither blocked nor cleared.
        /// </summary>
        public bool TryGetValidPath(BotOwner botOwner, Vector3 destination, out List<Vector3> path)
        {
            path = this.GetOptimizedPath(botOwner, destination);
            return path.Count >= 2 && !this.IsPathBlocked(path);
        }

        private static bool IsAIBot(BotOwner? bot)
        {
            Player? player = bot?.GetPlayer;
            return player != null && player.IsAI && !player.IsYourPlayer;
        }

        private static string HashVecDir(Vector3 pos, Vector3 dir)
        {
            Vector3 hashVec = pos + dir.normalized * 2f;
            return hashVec.x.ToString("F1") + "_" + hashVec.y.ToString("F1") + "_" + hashVec.z.ToString("F1");
        }

        private static string RoundVector3ToKey(Vector3 v)
        {
            return v.x.ToString("F1") + "_" + v.y.ToString("F1") + "_" + v.z.ToString("F1");
        }

        private List<Vector3> BuildNavPath(Vector3 origin, Vector3 target)
        {
            NavMeshPath navPath = new NavMeshPath();
            bool valid = NavMesh.CalculatePath(origin, target, NavMesh.AllAreas, navPath);

            if (valid && navPath.status == NavMeshPathStatus.PathComplete)
            {
                return new List<Vector3>(navPath.corners);
            }

            return new List<Vector3> { origin, target };
        }

        private bool IsPathBlocked(List<Vector3> path)
        {
            if (path.Count < 2)
            {
                return false;
            }

            Vector3 origin = path[0] + Vector3.up * BlockCheckHeight;
            Vector3 next = path[1];
            Vector3 direction = (next - path[0]).normalized;
            float distance = Vector3.Distance(path[0], next) + BlockCheckMargin;

            if (Physics.Raycast(origin, direction, out RaycastHit hit, distance, AIRefactoredLayerMasks.DoorColliderMask))
            {
                int hitLayer = hit.collider.gameObject.layer;
                if (AIRefactoredLayerMasks.IsDoorLayer(hitLayer))
                {
                    NavMeshPath navPath = new NavMeshPath();
                    if (!NavMesh.CalculatePath(origin, next, NavMesh.AllAreas, navPath) ||
                        navPath.status != NavMeshPathStatus.PathComplete)
                    {
                        return true;
                    }
                }
            }

            return false;
        }

        private bool IsPathInClearedZone(List<Vector3> path)
        {
            if (this._tacticalMemory == null || path.Count == 0)
            {
                return false;
            }

            for (int i = 0; i < path.Count; i++)
            {
                if (this._tacticalMemory.WasRecentlyCleared(path[i]))
                {
                    return true;
                }
            }

            return false;
        }
    }
}
