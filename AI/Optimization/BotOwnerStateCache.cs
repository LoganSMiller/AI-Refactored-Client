// <auto-generated>
//   This file is part of AI-Refactored, an open-source project focused on realistic AI behavior in Escape from Tarkov.
//   Licensed under the MIT License. See LICENSE in the repository root for more information.
//
//   THIS FILE IS SYSTEMATICALLY MANAGED.
//   Please follow strict StyleCop, ReSharper, and AI-Refactored code standards for all modifications.
// </auto-generated>

#nullable enable

namespace AIRefactored.AI.Optimization
{
    using System.Collections.Generic;
    using AIRefactored.AI.Core;
    using AIRefactored.AI.Helpers;
    using EFT;
    using UnityEngine;

    /// <summary>
    /// Tracks tactical state deltas (aggression, caution, sneaky) and triggers behavior shifts.
    /// Used to detect and respond to mid-mission personality changes.
    /// </summary>
    public sealed class BotOwnerStateCache
    {
        private readonly Dictionary<string, BotStateSnapshot> _cache = new Dictionary<string, BotStateSnapshot>(64);

        /// <summary>
        /// Captures the bot's personality state into the cache at mission start.
        /// </summary>
        public void CacheBotOwnerState(BotOwner botOwner)
        {
            if (!IsAIBot(botOwner) || botOwner.Profile == null)
            {
                return;
            }

            string id = botOwner.Profile.Id;
            if (string.IsNullOrEmpty(id) || this._cache.ContainsKey(id))
            {
                return;
            }

            this._cache[id] = this.CaptureSnapshot(botOwner);
        }

        /// <summary>
        /// Checks for personality state changes and applies behavior adjustments if needed.
        /// </summary>
        public void UpdateBotOwnerStateIfNeeded(BotOwner botOwner)
        {
            if (!IsAIBot(botOwner) || botOwner.Profile == null)
            {
                return;
            }

            string id = botOwner.Profile.Id;
            if (string.IsNullOrEmpty(id))
            {
                return;
            }

            BotStateSnapshot current = this.CaptureSnapshot(botOwner);

            if (this._cache.TryGetValue(id, out BotStateSnapshot previous))
            {
                if (!previous.Equals(current))
                {
                    this._cache[id] = current;
                    this.ApplyStateChange(botOwner, current);
                }
            }
            else
            {
                this._cache[id] = current;
            }
        }

        private static bool IsAIBot(BotOwner? bot)
        {
            Player? player = bot?.GetPlayer;
            return player != null && player.IsAI && !player.IsYourPlayer;
        }

        private BotStateSnapshot CaptureSnapshot(BotOwner botOwner)
        {
            BotPersonalityProfile? profile = BotRegistry.Get(botOwner.ProfileId);
            BotComponentCache? cache = BotCacheUtility.GetCache(botOwner);
            float composure = cache?.PanicHandler?.GetComposureLevel() ?? 1f;

            if (profile == null)
            {
                return new BotStateSnapshot(0.5f, 0.5f, composure, false);
            }

            return new BotStateSnapshot(
                profile.AggressionLevel,
                profile.Caution,
                composure,
                profile.IsSilentHunter);
        }

        private void ApplyStateChange(BotOwner botOwner, BotStateSnapshot snapshot)
        {
            bool isAggressive = snapshot.Aggression > 0.7f && snapshot.Composure > 0.8f;
            bool isCautious = snapshot.Caution > 0.6f || snapshot.Composure < 0.35f;

            if (isAggressive)
            {
                this.TriggerZoneShift(botOwner, advance: true);
            }
            else if (isCautious)
            {
                this.TriggerZoneShift(botOwner, advance: false);
            }
            else
            {
                this.TriggerZoneShift(botOwner, advance: null);
            }
        }

        private void TriggerZoneShift(BotOwner botOwner, bool? advance)
        {
            if (botOwner.Transform == null)
            {
                return;
            }

            Vector3 shift = Vector3.zero;
            if (advance == true)
            {
                shift = botOwner.Transform.forward * 8f;
            }
            else if (advance == false)
            {
                shift = -botOwner.Transform.forward * 6f;
            }

            if (shift.sqrMagnitude > 0.01f)
            {
                Vector3 target = botOwner.Position + shift;
                BotMovementHelper.SmoothMoveTo(botOwner, target);
            }
        }

        private struct BotStateSnapshot
        {
            public float Aggression { get; }
            public float Caution { get; }
            public float Composure { get; }
            public bool IsSneaky { get; }

            public BotStateSnapshot(float aggression, float caution, float composure, bool isSneaky)
            {
                Aggression = aggression;
                Caution = caution;
                Composure = composure;
                IsSneaky = isSneaky;
            }

            public override bool Equals(object? obj)
            {
                if (obj is BotStateSnapshot other)
                {
                    return Mathf.Abs(Aggression - other.Aggression) < 0.05f &&
                           Mathf.Abs(Caution - other.Caution) < 0.05f &&
                           Mathf.Abs(Composure - other.Composure) < 0.05f &&
                           IsSneaky == other.IsSneaky;
                }

                return false;
            }

            public override int GetHashCode()
            {
                unchecked
                {
                    int hash = 17;
                    hash = (hash * 23) + Aggression.GetHashCode();
                    hash = (hash * 23) + Caution.GetHashCode();
                    hash = (hash * 23) + Composure.GetHashCode();
                    hash = (hash * 23) + IsSneaky.GetHashCode();
                    return hash;
                }
            }
        }
    }
}
