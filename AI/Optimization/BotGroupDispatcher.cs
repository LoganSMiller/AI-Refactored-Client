// <auto-generated>
//   This file is part of AI-Refactored, an open-source project focused on realistic AI behavior in Escape from Tarkov.
//   Licensed under the MIT License. See LICENSE in the repository root for more information.
//
//   THIS FILE IS SYSTEMATICALLY MANAGED.
//   Please follow strict StyleCop, ReSharper, and AI-Refactored code standards for all modifications.
// </auto-generated>

namespace AIRefactored.AI.Optimization
{
    using System;
    using System.Collections.Generic;
    using System.Threading;
    using System.Threading.Tasks;
    using AIRefactored.Core;
    using AIRefactored.Runtime;
    using BepInEx.Logging;
    using EFT;
    using UnityEngine;

    /// <summary>
    /// Schedules and dispatches thread-safe bot workloads during headless or client-hosted execution.
    /// </summary>
    public static class BotWorkGroupDispatcher
    {
        #region Constants

        private const int MaxWorkPerTick = 256;
        private const int MaxThreads = 16;

        #endregion

        #region Static Fields

        private static readonly List<IBotWorkload> WorkQueue = new List<IBotWorkload>(MaxWorkPerTick);
        private static readonly object Sync = new object();
        private static readonly ManualLogSource Log = Plugin.LoggerInstance;
        private static readonly int ThreadCount = Mathf.Clamp(Environment.ProcessorCount, 1, MaxThreads);

        #endregion

        #region Public API

        /// <summary>
        /// Queues a bot workload for background execution.
        /// </summary>
        /// <param name="workload">The workload to queue.</param>
        public static void Schedule(IBotWorkload workload)
        {
            if (workload == null)
            {
                return;
            }

            lock (Sync)
            {
                if (WorkQueue.Count >= MaxWorkPerTick)
                {
                    Log.LogWarning("[BotWorkGroupDispatcher] Max queue capacity reached. Dropping workload.");
                    return;
                }

                WorkQueue.Add(workload);
            }
        }

        /// <summary>
        /// Executes queued workloads in thread batches. Call from Update().
        /// </summary>
        public static void Tick()
        {
            if (!GameWorldHandler.IsLocalHost())
            {
                return;
            }

            List<IBotWorkload> batch;

            lock (Sync)
            {
                if (WorkQueue.Count == 0)
                {
                    return;
                }

                int slice = Mathf.Min(WorkQueue.Count, MaxWorkPerTick);
                batch = new List<IBotWorkload>(slice);
                for (int i = 0; i < slice; i++)
                {
                    batch.Add(WorkQueue[i]);
                }

                WorkQueue.RemoveRange(0, slice);
            }

            Dispatch(batch);
        }

        #endregion

        #region Dispatch

        private static void Dispatch(List<IBotWorkload> batch)
        {
            int total = batch.Count;
            if (total == 0)
            {
                return;
            }

            int threads = Mathf.Clamp(ThreadCount, 1, total);
            int blockSize = Mathf.CeilToInt(total / (float)threads);

            for (int i = 0; i < total; i += blockSize)
            {
                int start = i;
                int end = Mathf.Min(i + blockSize, total);

                Task.Run(() =>
                {
                    for (int j = start; j < end; j++)
                    {
                        try
                        {
                            batch[j].RunBackgroundWork();
                        }
                        catch (Exception ex)
                        {
                            Log.LogWarning("[BotWorkGroupDispatcher] Background workload exception: " + ex.Message + "\n" + ex.StackTrace);
                        }
                    }
                });
            }
        }

        #endregion
    }

    /// <summary>
    /// Background-safe interface for threaded bot logic. Must not use Unity APIs.
    /// </summary>
    public interface IBotWorkload
    {
        /// <summary>
        /// Executes the workload from a thread pool context.
        /// </summary>
        void RunBackgroundWork();
    }
}
