// <auto-generated>
//   AI-Refactored: AIOptimizationManager.cs (Beyond Diamond – Event-Driven Overlay, Ultimate Realism Edition, June 2025)
//   Bulletproof, event-only optimization & escalation for bots. No per-tick/interval logic. Null-guarded, multiplayer/headless/client safe.
//   All adjustments are pooled, randomized, personality-driven, and isolated to the target bot. No system disables, no exception cascade.
//   MIT License.
// </auto-generated>

namespace AIRefactored.AI.Optimization
{
    using System;
    using System.Collections.Generic;
    using AIRefactored.AI.Core;
    using AIRefactored.Core;
    using AIRefactored.Runtime;
    using BepInEx.Logging;
    using EFT;
    using UnityEngine;

    /// <summary>
    /// Centralized overlay/event-based optimization and escalation controller for all bots.
    /// - No tick/interval logic: all methods are single-event, called by BotBrain or overlay systems on demand.
    /// - All failures are isolated, never break the bot, never break tick order.
    /// - Bulletproof: fully multiplayer, headless, and client-host parity.
    /// </summary>
    public static class AIOptimizationManager
    {
        #region Constants

        private const float EscalationCooldownTime = 10f;
        private const float EscalationRandomVariance = 0.09f;

        #endregion

        #region Fields

        // Stateless event-only optimizer shared for all bots.
        private static readonly BotAIOptimization Optimizer = new BotAIOptimization();

        // Pooled optimization state per bot (instance id).
        private static readonly Dictionary<int, bool> BotOptimizationState = new Dictionary<int, bool>(128);

        // Last escalation time per bot (instance id).
        private static readonly Dictionary<int, float> LastEscalationTimes = new Dictionary<int, float>(128);

        private static readonly ManualLogSource Logger = Plugin.LoggerInstance;

        #endregion

        #region Public API

        /// <summary>
        /// Event-only: Applies optimization to a bot if not already optimized.
        /// Bulletproof, error-isolated, never disables other bots or cascades failure.
        /// </summary>
        /// <param name="bot">BotOwner to optimize.</param>
        public static void Apply(BotOwner bot)
        {
            try
            {
                if (!GameWorldHandler.IsLocalHost() || !IsValid(bot))
                    return;

                int id = bot.GetInstanceID();
                bool optimized;
                if (BotOptimizationState.TryGetValue(id, out optimized) && optimized)
                    return;

                try
                {
                    Optimizer.Optimize(bot);
                    BotOptimizationState[id] = true;
                }
                catch (Exception ex)
                {
                    BotOptimizationState[id] = false;
                    Logger.LogError("[AIOptimizationManager] Optimization failed for bot " + GetName(bot) + ": " + ex);
                }
            }
            catch (Exception outer)
            {
                Logger.LogError("[AIOptimizationManager] Apply() fatal error: " + outer);
            }
        }

        /// <summary>
        /// Event-only: Resets optimizations on the given bot if previously optimized.
        /// All failures are error-isolated.
        /// </summary>
        /// <param name="bot">BotOwner to reset.</param>
        public static void Reset(BotOwner bot)
        {
            try
            {
                if (!GameWorldHandler.IsLocalHost() || !IsValid(bot))
                    return;

                int id = bot.GetInstanceID();
                bool wasOptimized;
                if (!BotOptimizationState.TryGetValue(id, out wasOptimized) || !wasOptimized)
                    return;

                try
                {
                    Optimizer.ResetOptimization(bot);
                    BotOptimizationState[id] = false;
                }
                catch (Exception ex)
                {
                    Logger.LogError("[AIOptimizationManager] Reset failed for bot " + GetName(bot) + ": " + ex);
                    BotOptimizationState[id] = false;
                }
            }
            catch (Exception outer)
            {
                Logger.LogError("[AIOptimizationManager] Reset() fatal error: " + outer);
            }
        }

        /// <summary>
        /// Event-only: Escalates bot threat perception and responsiveness.
        /// Micro-randomized, personality/persona-driven, error-guarded, and locally pooled.
        /// </summary>
        /// <param name="bot">BotOwner to escalate.</param>
        public static void TriggerEscalation(BotOwner bot)
        {
            try
            {
                if (!GameWorldHandler.IsLocalHost() || !IsValid(bot))
                    return;

                int id = bot.GetInstanceID();
                float now = Time.time;
                float lastTime;
                if (LastEscalationTimes.TryGetValue(id, out lastTime) && (now - lastTime) < EscalationCooldownTime)
                    return;

                BotGlobalsMindSettings mind = null;
                try
                {
                    mind = GetMindSettings(bot);
                }
                catch (Exception ex)
                {
                    Logger.LogError("[AIOptimizationManager] Escalation aborted (mind settings fetch failed) for bot " + GetName(bot) + ": " + ex);
                    return;
                }

                if (mind == null)
                {
                    Logger.LogWarning("[AIOptimizationManager] Escalation aborted: missing mind settings for bot: " + GetName(bot));
                    return;
                }

                try
                {
                    float aggression = 0.5f;
                    float caution = 0.5f;
                    BotComponentCache cache = null;

                    string profileId = bot?.Profile?.Id;
                    if (!string.IsNullOrEmpty(profileId))
                        BotComponentCacheRegistry.TryGet(profileId, out cache);

                    var profile = cache?.AIRefactoredBotOwner?.PersonalityProfile
                        ?? (!string.IsNullOrEmpty(profileId) ? BotRegistry.Get(profileId) : null);

                    if (profile != null)
                    {
                        aggression = Mathf.Clamp01(profile.AggressionLevel);
                        caution = Mathf.Clamp01(profile.Caution);
                    }

                    float variance = 1f + UnityEngine.Random.Range(-EscalationRandomVariance, EscalationRandomVariance);

                    // Micro-randomized, personality-driven escalation. Clamp to safe, plausible values.
                    mind.DIST_TO_FOUND_SQRT = Mathf.Clamp(mind.DIST_TO_FOUND_SQRT * (1.25f + aggression * 0.1f) * variance, 180f, 800f);
                    mind.ENEMY_LOOK_AT_ME_ANG = Mathf.Clamp(mind.ENEMY_LOOK_AT_ME_ANG * (0.7f - caution * 0.07f) * variance, 5f, 60f);
                    mind.CHANCE_TO_RUN_CAUSE_DAMAGE_0_100 = Mathf.Clamp(
                        mind.CHANCE_TO_RUN_CAUSE_DAMAGE_0_100 + 20f + aggression * 10f - caution * 5f,
                        0f, 100f);

                    LastEscalationTimes[id] = now;
                }
                catch (Exception ex)
                {
                    Logger.LogError("[AIOptimizationManager] Escalation adjustment failed for bot " + GetName(bot) + ": " + ex);
                }
            }
            catch (Exception outer)
            {
                Logger.LogError("[AIOptimizationManager] TriggerEscalation() fatal error: " + outer);
            }
        }

        #endregion

        #region Internal Helpers

        /// <summary>
        /// Validates that a BotOwner is AI, alive, and not null.
        /// </summary>
        private static bool IsValid(BotOwner bot)
        {
            return bot != null
                && bot.GetPlayer != null
                && bot.GetPlayer.IsAI
                && !bot.IsDead;
        }

        /// <summary>
        /// Returns the bot's nickname or "Unknown".
        /// </summary>
        private static string GetName(BotOwner bot)
        {
            try
            {
                return bot?.Profile?.Info?.Nickname ?? "Unknown";
            }
            catch
            {
                return "Unknown";
            }
        }

        /// <summary>
        /// Returns the BotGlobalsMindSettings for this bot, if present.
        /// </summary>
        private static BotGlobalsMindSettings GetMindSettings(BotOwner bot)
        {
            if (bot == null || bot.Settings == null || bot.Settings.FileSettings == null)
                return null;
            return bot.Settings.FileSettings.Mind;
        }

        #endregion
    }
}
