// <auto-generated>
//   AI-Refactored: AIOptimizationManager.cs (Supreme Overlay Arbitration/Event-Only, Ultimate Realism Edition, June 2025)
//   Bulletproof, event-only optimization & escalation for bots. No per-tick/interval logic.
//   Full null-guarding, multiplayer/headless/client safe, no disables, zero exception cascade.
//   All logic is pooled, personality/randomized, and 100% overlay/event-driven. 
//   MIT License.
// </auto-generated>

namespace AIRefactored.AI.Optimization
{
    using System;
    using System.Collections.Generic;
    using AIRefactored.AI.Core;
    using AIRefactored.Core;
    using AIRefactored.Runtime;
    using BepInEx.Logging;
    using EFT;
    using UnityEngine;

    /// <summary>
    /// Centralized overlay/event-based optimization and escalation controller for all bots.
    /// - No tick/interval logic: all methods are event-driven, called by BotBrain or overlay systems on demand.
    /// - Bulletproof: never breaks bot or tick, all failures are error-isolated, never disables any system.
    /// - 100% pooled, SPT/FIKA/headless/client safe, full feature expansion.
    /// </summary>
    public static class AIOptimizationManager
    {
        #region Constants

        private const float EscalationCooldownTime = 10.0f;
        private const float EscalationRandomVariance = 0.11f;
        private const float MaxGlobalMindDist = 800f;
        private const float MinGlobalMindDist = 180f;
        private const float MaxLookAtMeAngle = 80f;
        private const float MinLookAtMeAngle = 5f;
        private const float MaxRunChance = 100f;
        private const float MinRunChance = 0f;
        private const float PersonalityAggressionBias = 0.15f;
        private const float PersonalityCautionBias = 0.14f;
        private const float OverlayRandomCooldown = 3.5f;
        private const float OverlayRandomCooldownJitter = 1.1f;

        #endregion

        #region Fields

        private static readonly BotAIOptimization Optimizer = new BotAIOptimization();
        // Event-only: cache/cooldown fields
        private static readonly Dictionary<int, bool> BotOptimizationState = new Dictionary<int, bool>(128);
        private static readonly Dictionary<int, float> LastEscalationTimes = new Dictionary<int, float>(128);
        private static readonly Dictionary<int, float> LastOverlayTune = new Dictionary<int, float>(128);
        private static readonly ManualLogSource Logger = Plugin.LoggerInstance;

        #endregion

        #region Public API

        /// <summary>
        /// Overlay/event-only: Applies pooled optimization overlays to a bot, once per life.
        /// </summary>
        public static void Apply(BotOwner bot)
        {
            try
            {
                if (!GameWorldHandler.IsLocalHost() || !IsValid(bot))
                    return;

                int id = bot.GetInstanceID();
                if (BotOptimizationState.TryGetValue(id, out var opt) && opt)
                    return;

                Optimizer.Optimize(bot);
                BotOptimizationState[id] = true;
            }
            catch (Exception ex)
            {
                Logger.LogError("[AIOptimizationManager] Optimization failed for bot " + GetName(bot) + ": " + ex);
            }
        }

        /// <summary>
        /// Overlay/event-only: Resets optimization overlays on a bot (e.g. on death/teardown).
        /// </summary>
        public static void Reset(BotOwner bot)
        {
            try
            {
                if (!GameWorldHandler.IsLocalHost() || !IsValid(bot))
                    return;

                int id = bot.GetInstanceID();
                if (!BotOptimizationState.TryGetValue(id, out var opt) || !opt)
                    return;

                Optimizer.ResetOptimization(bot);
                BotOptimizationState[id] = false;
            }
            catch (Exception ex)
            {
                Logger.LogError("[AIOptimizationManager] Reset failed for bot " + GetName(bot) + ": " + ex);
            }
        }

        /// <summary>
        /// Overlay/event-only: Escalates bot threat perception, urgency, and responsiveness.
        /// Micro-randomized, personality-driven, locally pooled. No tick/per-frame logic.
        /// </summary>
        public static void TriggerEscalation(BotOwner bot)
        {
            try
            {
                if (!GameWorldHandler.IsLocalHost() || !IsValid(bot))
                    return;

                int id = bot.GetInstanceID();
                float now = Time.time;

                if (LastEscalationTimes.TryGetValue(id, out float lastTime) && (now - lastTime) < EscalationCooldownTime)
                    return;

                var mind = GetMindSettings(bot);
                if (mind == null)
                {
                    Logger.LogWarning("[AIOptimizationManager] Escalation aborted: missing mind settings for bot: " + GetName(bot));
                    return;
                }

                var cache = GetCache(bot);
                var profile = cache?.AIRefactoredBotOwner?.PersonalityProfile
                              ?? (!string.IsNullOrEmpty(bot?.ProfileId) ? BotRegistry.Get(bot.ProfileId) : null);

                float aggression = profile?.AggressionLevel ?? 0.5f;
                float caution = profile?.Caution ?? 0.5f;
                float variance = 1f + UnityEngine.Random.Range(-EscalationRandomVariance, EscalationRandomVariance);

                // Escalate core mind settings for increased responsiveness and aggression
                mind.DIST_TO_FOUND_SQRT = Mathf.Clamp(
                    mind.DIST_TO_FOUND_SQRT * (1.23f + aggression * PersonalityAggressionBias) * variance,
                    MinGlobalMindDist, MaxGlobalMindDist);
                mind.ENEMY_LOOK_AT_ME_ANG = Mathf.Clamp(
                    mind.ENEMY_LOOK_AT_ME_ANG * (0.7f - caution * PersonalityCautionBias) * variance,
                    MinLookAtMeAngle, MaxLookAtMeAngle);
                mind.CHANCE_TO_RUN_CAUSE_DAMAGE_0_100 = Mathf.Clamp(
                    mind.CHANCE_TO_RUN_CAUSE_DAMAGE_0_100 + 19f + aggression * 7.5f - caution * 4.5f,
                    MinRunChance, MaxRunChance);

                LastEscalationTimes[id] = now;
                LastOverlayTune[id] = now + OverlayRandomCooldown + UnityEngine.Random.Range(0f, OverlayRandomCooldownJitter);

                // Humanized, squad-safe overlay comms (no move)
                if (cache?.GroupComms != null && UnityEngine.Random.value < 0.16f)
                    cache.GroupComms.Say(EPhraseTrigger.Regroup);
            }
            catch (Exception ex)
            {
                Logger.LogError("[AIOptimizationManager] Escalation error for bot " + GetName(bot) + ": " + ex);
            }
        }

        /// <summary>
        /// Overlay/event-only: Triggers randomized overlay tuning for bot (aggression, voice, caution overlays).
        /// Never disables, only overlays. No tick, no frame logic.
        /// </summary>
        public static void TriggerOverlayRandomization(BotOwner bot)
        {
            try
            {
                if (!IsValid(bot)) return;
                int id = bot.GetInstanceID();
                float now = Time.time;
                if (LastOverlayTune.TryGetValue(id, out float last) && now < last)
                    return;

                var cache = GetCache(bot);
                if (cache == null) return;

                // Voice overlays: rare, randomized, event-only
                if (cache.GroupComms != null && UnityEngine.Random.value < 0.07f)
                    cache.GroupComms.Say(UnityEngine.Random.value < 0.5f ? EPhraseTrigger.Cooperation : EPhraseTrigger.HoldPosition);

                // Overlay voice/fakeout for combat or escalation events
                if (cache.ThreatSelector != null && cache.ThreatSelector.CurrentTarget != null)
                {
                    if (UnityEngine.Random.value < 0.07f && cache.GroupComms != null)
                        cache.GroupComms.Say(EPhraseTrigger.OnEnemyGrenade);
                }

                // Overlay randomization event (debug only)
                Logger.LogDebug($"[AIOptimizationManager] Overlay randomization event triggered for bot: {GetName(bot)}");
                LastOverlayTune[id] = now + OverlayRandomCooldown + UnityEngine.Random.Range(0f, OverlayRandomCooldownJitter);
            }
            catch (Exception ex)
            {
                Logger.LogError("[AIOptimizationManager] OverlayRandomization error for bot " + GetName(bot) + ": " + ex);
            }
        }

        #endregion

        #region Internal Helpers

        /// <summary>
        /// Validates BotOwner: must be AI, alive, non-null.
        /// </summary>
        private static bool IsValid(BotOwner bot)
        {
            try
            {
                // Per real EFT logic: only if bot, alive, and player is AI
                return bot != null && !bot.IsDead && bot.GetPlayer is Player player && player.IsAI;
            }
            catch { return false; }
        }

        /// <summary>
        /// Returns canonical name or fallback.
        /// </summary>
        private static string GetName(BotOwner bot)
        {
            try { return bot?.Profile?.Info?.Nickname ?? bot?.ProfileId ?? "Unknown"; }
            catch { return "Unknown"; }
        }

        /// <summary>
        /// Gets BotGlobalsMindSettings (internal mind struct).
        /// </summary>
        private static BotGlobalsMindSettings GetMindSettings(BotOwner bot)
        {
            try
            {
                // Per EFT: Settings > FileSettings > Mind
                return bot?.Settings?.FileSettings?.Mind;
            }
            catch
            {
                return null;
            }
        }

        /// <summary>
        /// Gets the canonical BotComponentCache for the bot (pooled, SPT/FIKA safe).
        /// </summary>
        private static BotComponentCache GetCache(BotOwner bot)
        {
            if (bot == null) return null;
            if (!string.IsNullOrEmpty(bot.ProfileId))
            {
                BotComponentCacheRegistry.TryGet(bot.ProfileId, out var cache);
                return cache;
            }
            return null;
        }

        #endregion
    }
}
