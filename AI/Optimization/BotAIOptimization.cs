// <auto-generated>
//   AI-Refactored: BotAIOptimization.cs (Supreme Overlay Arbitration/Event-Only, Beyond Diamond Diagnostic & Introspection Edition, June 2025)
//   Bulletproof, overlay-only, pooled, SPT/FIKA/headless/client safe. Logs diagnostics on-demand; zero tick/coroutine.
//   Full introspection of look, mind, role, personality, suppression, panic, attach, and enemy memory. Max realism/features.
//   MIT License.
// </auto-generated>

namespace AIRefactored.AI.Optimization
{
    using System;
    using System.Collections.Generic;
    using AIRefactored.AI;
    using AIRefactored.AI.Core;
    using AIRefactored.Core;
    using AIRefactored.Runtime;
    using BepInEx.Logging;
    using EFT;
    using UnityEngine;

    /// <summary>
    /// Overlay/event-driven diagnostics & optimization logger for bot AI.
    /// - Logs cognition, mind, role, personality, suppression, panic, attach, and enemy memory.
    /// - Bulletproof error isolation; zero tick/coroutine; no state side effects.
    /// - Pooled, SPT/FIKA/headless/client safe, max feature expansion.
    /// </summary>
    public sealed class BotAIOptimization
    {
        #region Constants

        private const float OptimizationLogCooldown = 4.2f;
        private const int MaxLogMemoryBots = 256;

        #endregion

        #region Fields

        // Tracks which profiles were logged this session (profileId, not instance id).
        private readonly Dictionary<string, bool> _optimizationApplied =
            new Dictionary<string, bool>(MaxLogMemoryBots, StringComparer.OrdinalIgnoreCase);

        // Throttle event logs per instance.
        private static readonly Dictionary<int, float> LastOptimizationLogs = new Dictionary<int, float>(MaxLogMemoryBots);

        private static readonly ManualLogSource Logger = Plugin.LoggerInstance;

        #endregion

        #region Public API

        /// <summary>
        /// Overlay/event: Logs diagnostics for the given bot.
        /// Logs all AI config, profile/personality, suppression/panic, attach info, and live enemy memory state.
        /// Never disables; bulletproof error isolation.
        /// </summary>
        public void Optimize(BotOwner botOwner)
        {
            try
            {
                if (!GameWorldHandler.IsLocalHost() || !IsValid(botOwner))
                    return;

                string profileId = botOwner?.Profile?.Id ?? botOwner?.ProfileId ?? "Unknown";
                bool alreadyApplied;
                if (_optimizationApplied.TryGetValue(profileId, out alreadyApplied) && alreadyApplied)
                {
                    if (!ShouldLogOptimization(botOwner))
                        return;
                    Logger.LogDebug("[BotAIOptimization] Already logged for bot: " + profileId);
                    return;
                }

                // Full diagnostics, all error-guarded.
                SafeLog(LogCognition, botOwner, "[BotAIOptimization] LogCognition failed");
                SafeLog(LogMind, botOwner, "[BotAIOptimization] LogMind failed");
                SafeLog(LogRole, botOwner, "[BotAIOptimization] LogRole failed");
                SafeLog(LogPersonality, botOwner, "[BotAIOptimization] LogPersonality failed");
                SafeLog(LogSuppression, botOwner, "[BotAIOptimization] LogSuppression failed");
                SafeLog(LogPanic, botOwner, "[BotAIOptimization] LogPanic failed");
                SafeLog(LogAttachState, botOwner, "[BotAIOptimization] LogAttachState failed");
                SafeLog(LogEnemyMemory, botOwner, "[BotAIOptimization] LogEnemyMemory failed");

                _optimizationApplied[profileId] = true;
                Logger.LogDebug("[BotAIOptimization] Diagnostics logged for bot: " + profileId);
            }
            catch (Exception ex)
            {
                Logger.LogError("[BotAIOptimization] Optimize() fatal error: " + ex);
            }
        }

        /// <summary>
        /// Overlay/event: Clears optimization-applied state for this bot (per overlay reset/death/teardown).
        /// Never disables anything; bulletproof.
        /// </summary>
        public void ResetOptimization(BotOwner botOwner)
        {
            try
            {
                if (!GameWorldHandler.IsLocalHost() || !IsValid(botOwner))
                    return;

                string profileId = botOwner?.Profile?.Id ?? botOwner?.ProfileId ?? "Unknown";
                _optimizationApplied[profileId] = false;
                Logger.LogDebug("[BotAIOptimization] Reset optimization for bot: " + profileId);
            }
            catch (Exception ex)
            {
                Logger.LogError("[BotAIOptimization] ResetOptimization() fatal error: " + ex);
            }
        }

        #endregion

        #region Private Helpers

        /// <summary>
        /// True if bot is AI, alive, and initialized.
        /// </summary>
        private static bool IsValid(BotOwner bot)
        {
            try
            {
                return bot != null &&
                       bot.GetPlayer != null &&
                       bot.GetPlayer.IsAI &&
                       !bot.IsDead &&
                       bot.Profile != null &&
                       bot.Settings != null &&
                       bot.Settings.FileSettings != null;
            }
            catch { return false; }
        }

        /// <summary>
        /// True if it's safe to log (throttled per instance).
        /// </summary>
        private static bool ShouldLogOptimization(BotOwner bot)
        {
            try
            {
                int id = bot != null ? bot.GetInstanceID() : 0;
                float now = Time.time;
                if (LastOptimizationLogs.TryGetValue(id, out float last) && now - last < OptimizationLogCooldown)
                    return false;
                LastOptimizationLogs[id] = now;
                return true;
            }
            catch { return true; }
        }

        /// <summary>
        /// Error-guarded diagnostic logging.
        /// </summary>
        private static void SafeLog(Action<BotOwner> logFn, BotOwner bot, string errorContext)
        {
            try { logFn(bot); }
            catch (Exception ex) { Logger.LogError($"{errorContext}: {ex}"); }
        }

        /// <summary>
        /// Logs visual/cognition config.
        /// </summary>
        private static void LogCognition(BotOwner bot)
        {
            string name = bot?.Profile?.Info?.Nickname ?? bot?.ProfileId ?? "Unknown";
            var look = bot?.Settings?.FileSettings?.Look;
            if (look == null)
            {
                Logger.LogWarning("[BotDiagnostics][Cognition] " + name + " → No Look config.");
                return;
            }
            Logger.LogDebug("[BotDiagnostics][Cognition] " + name +
                $" | MAX_VISION_GRASS={look.MAX_VISION_GRASS_METERS:F1}, ENEMY_LIGHT_ADD={look.ENEMY_LIGHT_ADD:F1}, LightOnVisionDistance={look.LightOnVisionDistance:F1}, FAR_DISTANCE={look.FAR_DISTANCE:F1}, MIDDLE_DIST={look.MIDDLE_DIST:F1}");
        }

        /// <summary>
        /// Logs mind/memory config.
        /// </summary>
        private static void LogMind(BotOwner bot)
        {
            string name = bot?.Profile?.Info?.Nickname ?? bot?.ProfileId ?? "Unknown";
            var mind = bot?.Settings?.FileSettings?.Mind;
            if (mind == null)
            {
                Logger.LogWarning("[BotDiagnostics][Mind] " + name + " → No Mind config.");
                return;
            }
            Logger.LogDebug("[BotDiagnostics][Mind] " + name +
                $" | MIN_DAMAGE_SCARE={mind.MIN_DAMAGE_SCARE:F2}, CHANCE_TO_RUN={mind.CHANCE_TO_RUN_CAUSE_DAMAGE_0_100:F0}%, DIST_FOUND={mind.DIST_TO_FOUND_SQRT:F1}, ENEMY_LOOK_AT_ME={mind.ENEMY_LOOK_AT_ME_ANG:F1}");
        }

        /// <summary>
        /// Logs bot role/type from profile.
        /// </summary>
        private static void LogRole(BotOwner bot)
        {
            string name = bot?.Profile?.Info?.Nickname ?? bot?.ProfileId ?? "Unknown";
            WildSpawnType role = WildSpawnType.assault;
            try { role = bot?.Profile?.Info?.Settings?.Role ?? WildSpawnType.assault; }
            catch { }
            Logger.LogDebug("[BotDiagnostics][Role] " + name + $" | ProfileRole={role}");
        }

        /// <summary>
        /// Logs bot personality, aggression, caution, composure, awareness, hearing, stance.
        /// </summary>
        private static void LogPersonality(BotOwner bot)
        {
            string name = bot?.Profile?.Info?.Nickname ?? bot?.ProfileId ?? "Unknown";
            var cache = BotComponentCacheRegistry.TryGetExisting(bot);
            var profile = cache?.AIRefactoredBotOwner?.PersonalityProfile
                ?? (!string.IsNullOrEmpty(bot?.ProfileId) ? BotRegistry.Get(bot.ProfileId) : null)
                ?? BotPersonalityProfile.Default;

            Logger.LogDebug("[BotDiagnostics][Personality] " + name +
                $" | Aggression={profile.AggressionLevel:F2}, Caution={profile.Caution:F2}, Awareness={profile.Awareness:F2}, Hearing={profile.HearingBias:F2}, StanceBias={profile.StanceBias:F2}, Personality={profile.Personality}, Cohesion={profile.Cohesion:F2}, Retreat={profile.RetreatThreshold:F2}, Flinch={profile.FlinchThreshold:F2}, Reposition={profile.RepositionPriority:F2}, SuppressionSens={profile.SuppressionSensitivity:F2}, SuppressiveFireBias={profile.SuppressiveFireBias:F2}, MovementJitter={profile.MovementJitter:F2}, Communication={profile.CommunicationLevel:F2}");
        }

        /// <summary>
        /// Logs suppression system state (if available).
        /// </summary>
        private static void LogSuppression(BotOwner bot)
        {
            string name = bot?.Profile?.Info?.Nickname ?? bot?.ProfileId ?? "Unknown";
            var cache = BotComponentCacheRegistry.TryGetExisting(bot);

            if (cache?.Suppression == null)
            {
                Logger.LogDebug("[BotDiagnostics][Suppression] " + name + " → No suppression handler.");
                return;
            }
            Logger.LogDebug("[BotDiagnostics][Suppression] " + name +
                $" | IsSuppressed={cache.Suppression.IsSuppressed()}, AnticipationLock={cache.Suppression.AnticipationLockActive}, InSuppressionMemory={cache.Suppression.IsInSuppressionMemory()}, LastSource=({cache.Suppression.LastSuppressionSource})");
        }

        /// <summary>
        /// Logs panic/anticipation state (if available).
        /// </summary>
        private static void LogPanic(BotOwner bot)
        {
            string name = bot?.Profile?.Info?.Nickname ?? bot?.ProfileId ?? "Unknown";
            var cache = BotComponentCacheRegistry.TryGetExisting(bot);

            if (cache?.PanicHandler == null)
            {
                Logger.LogDebug("[BotDiagnostics][Panic] " + name + " → No panic handler.");
                return;
            }
            Logger.LogDebug("[BotDiagnostics][Panic] " + name +
                $" | IsPanicking={cache.PanicHandler.IsPanicking}, IsAnticipationLocked={cache.PanicHandler.IsAnticipationLocked}, Composure={cache.PanicHandler.GetComposureLevel():F2}");
        }

        /// <summary>
        /// Logs AIRefactoredBotOwner attach state.
        /// </summary>
        private static void LogAttachState(BotOwner bot)
        {
            string name = bot?.Profile?.Info?.Nickname ?? bot?.ProfileId ?? "Unknown";
            var cache = BotComponentCacheRegistry.TryGetExisting(bot);
            bool attached = cache != null && cache.AIRefactoredBotOwner != null;
            Logger.LogDebug("[BotDiagnostics][Attach] " + name + $" | AIRefactoredBotOwnerAttached={attached}");
        }

        /// <summary>
        /// Logs live enemy memory, including number of tracked enemies, and current threat.
        /// </summary>
        private static void LogEnemyMemory(BotOwner bot)
        {
            string name = bot?.Profile?.Info?.Nickname ?? bot?.ProfileId ?? "Unknown";
            var memory = bot?.Memory;
            var enemies = bot?.EnemiesController?.EnemyInfos;
            int count = enemies?.Count ?? 0;
            string goalName = memory?.GoalEnemy?.Person?.Profile?.Nickname ?? "None";
            string allEnemies = "";

            if (count > 0)
            {
                int i = 0;
                foreach (var kv in enemies)
                {
                    var info = kv.Value;
                    if (info == null) continue;
                    string ename = info.Person?.Profile?.Nickname ?? "Unknown";
                    string dist = info.Distance.ToString("F1");
                    allEnemies += $"[{ename}:{dist}m]";
                    if (++i > 8) { allEnemies += "..."; break; }
                }
            }

            Logger.LogDebug("[BotDiagnostics][Memory] " + name + $" | Enemies={count} | Goal={goalName} | All={allEnemies}");
        }

        #endregion
    }
}
