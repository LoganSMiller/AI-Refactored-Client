// <auto-generated>
//   AI-Refactored: BotAIOptimization.cs (Beyond Diamond – Overlay/Event-Driven Diagnostic, June 2025)
//   Bulletproof, pooling-optimized, side-effect-free. No tick/coroutine. Only event/intent diagnostic logging allowed.
//   MIT License.
// </auto-generated>

namespace AIRefactored.AI.Optimization
{
    using System;
    using System.Collections.Generic;
    using AIRefactored.Core;
    using AIRefactored.Runtime;
    using BepInEx.Logging;
    using EFT;
    using UnityEngine;

    /// <summary>
    /// Overlay/event-driven bot diagnostics & optimization logger.
    /// - Logs bot AI config (mind, look, role) safely, only when triggered via overlay/event (never ticked).
    /// - All failures are bulletproof and cannot propagate.
    /// - Safe for SPT, FIKA, headless, and client modes.
    /// </summary>
    public sealed class BotAIOptimization
    {
        #region Constants

        private const float OptimizationLogCooldown = 5f;

        #endregion

        #region Fields

        // Tracks whether this bot's diagnostics have already been logged this session (profileId, not instance id).
        private readonly Dictionary<string, bool> _optimizationApplied =
            new Dictionary<string, bool>(64, StringComparer.OrdinalIgnoreCase);

        // Tracks last log timestamp per bot instance.
        private static readonly Dictionary<int, float> LastOptimizationLogs = new Dictionary<int, float>(64);

        private static readonly ManualLogSource Logger = Plugin.LoggerInstance;

        #endregion

        #region Public API

        /// <summary>
        /// Overlay/event: Logs current optimization-relevant AI config for the given bot.
        /// Bulletproof; all errors locally isolated, no stateful side effects.
        /// </summary>
        /// <param name="botOwner">The bot owner instance to optimize/log.</param>
        public void Optimize(BotOwner botOwner)
        {
            try
            {
                if (!GameWorldHandler.IsLocalHost() || !IsValid(botOwner))
                    return;

                string profileId = botOwner?.Profile?.Id ?? "Unknown";
                bool alreadyApplied;
                if (_optimizationApplied.TryGetValue(profileId, out alreadyApplied) && alreadyApplied)
                {
                    if (!ShouldLogOptimization(botOwner))
                        return;
                    Logger.LogDebug("[BotAIOptimization] Optimization already applied for bot: " + profileId);
                    return;
                }

                // Log all diagnostics in error-isolated fashion
                SafeLog(LogCognition, botOwner, "[BotAIOptimization] LogCognition failed");
                SafeLog(LogMind, botOwner, "[BotAIOptimization] LogMind failed");
                SafeLog(LogRole, botOwner, "[BotAIOptimization] LogRole failed");

                _optimizationApplied[profileId] = true;
                Logger.LogDebug("[BotAIOptimization] Applied optimization for bot: " + profileId);
            }
            catch (Exception ex)
            {
                Logger.LogError("[BotAIOptimization] Optimize() fatal error: " + ex);
            }
        }

        /// <summary>
        /// Overlay/event: Clears optimization-applied state for this bot. Errors isolated; never disables anything.
        /// </summary>
        /// <param name="botOwner">BotOwner to reset logging flag for.</param>
        public void ResetOptimization(BotOwner botOwner)
        {
            try
            {
                if (!GameWorldHandler.IsLocalHost() || !IsValid(botOwner))
                    return;

                string profileId = botOwner?.Profile?.Id ?? "Unknown";
                _optimizationApplied[profileId] = false;
                Logger.LogDebug("[BotAIOptimization] Reset optimization for bot: " + profileId);
            }
            catch (Exception ex)
            {
                Logger.LogError("[BotAIOptimization] ResetOptimization() fatal error: " + ex);
            }
        }

        #endregion

        #region Private Helpers

        /// <summary>
        /// True if bot is AI, alive, and initialized.
        /// </summary>
        private static bool IsValid(BotOwner bot)
        {
            try
            {
                return bot != null &&
                       bot.GetPlayer != null &&
                       bot.GetPlayer.IsAI &&
                       !bot.IsDead &&
                       bot.Profile != null &&
                       bot.Settings != null &&
                       bot.Settings.FileSettings != null;
            }
            catch
            {
                return false;
            }
        }

        /// <summary>
        /// True if it's safe to log optimization diagnostics (throttled per instance).
        /// </summary>
        private static bool ShouldLogOptimization(BotOwner bot)
        {
            try
            {
                int id = bot != null ? bot.GetInstanceID() : 0;
                float now = Time.time;

                if (LastOptimizationLogs.TryGetValue(id, out float last) && now - last < OptimizationLogCooldown)
                    return false;

                LastOptimizationLogs[id] = now;
                return true;
            }
            catch
            {
                return true;
            }
        }

        /// <summary>
        /// Error-guarded log action for diagnostics.
        /// </summary>
        private static void SafeLog(Action<BotOwner> logFn, BotOwner bot, string errorContext)
        {
            try
            {
                logFn(bot);
            }
            catch (Exception ex)
            {
                Logger.LogError($"{errorContext}: {ex}");
            }
        }

        /// <summary>
        /// Logs bot visual/cognition config if available.
        /// </summary>
        private static void LogCognition(BotOwner bot)
        {
            string name = bot?.Profile?.Info?.Nickname ?? "Unknown";
            BotGlobalLookData look = bot?.Settings?.FileSettings?.Look;

            if (look == null)
            {
                Logger.LogWarning("[BotDiagnostics][Cognition] " + name + " → No Look config found.");
                return;
            }

            Logger.LogDebug("[BotDiagnostics][Cognition] " + name +
                            $" → MAX_VISION_GRASS_METERS={look.MAX_VISION_GRASS_METERS:F1}" +
                            $", ENEMY_LIGHT_ADD={look.ENEMY_LIGHT_ADD:F1}");
        }

        /// <summary>
        /// Logs bot mind/memory config if available.
        /// </summary>
        private static void LogMind(BotOwner bot)
        {
            string name = bot?.Profile?.Info?.Nickname ?? "Unknown";
            BotGlobalsMindSettings mind = bot?.Settings?.FileSettings?.Mind;

            if (mind == null)
            {
                Logger.LogWarning("[BotDiagnostics][Mind] " + name + " → No Mind config found.");
                return;
            }

            Logger.LogDebug("[BotDiagnostics][Mind] " + name +
                            $" → MIN_DAMAGE_SCARE={mind.MIN_DAMAGE_SCARE:F1}" +
                            $", CHANCE_TO_RUN_CAUSE_DAMAGE_0_100={mind.CHANCE_TO_RUN_CAUSE_DAMAGE_0_100:F0}%");
        }

        /// <summary>
        /// Logs bot role/type based on profile.
        /// </summary>
        private static void LogRole(BotOwner bot)
        {
            string name = bot?.Profile?.Info?.Nickname ?? "Unknown";
            WildSpawnType role = WildSpawnType.assault;
            try
            {
                role = bot?.Profile?.Info?.Settings?.Role ?? WildSpawnType.assault;
            }
            catch
            {
                // ignore, default stays
            }
            Logger.LogDebug("[BotDiagnostics][Role] " + name + $" → ProfileRole={role}");
        }

        #endregion
    }
}
