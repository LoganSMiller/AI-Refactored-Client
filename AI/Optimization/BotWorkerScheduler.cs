// <auto-generated>
//   This file is part of AI-Refactored, an open-source project focused on realistic AI behavior in Escape from Tarkov.
//   Licensed under the MIT License. See LICENSE in the repository root for more information.
//
//   THIS FILE IS SYSTEMATICALLY MANAGED.
//   Please follow strict StyleCop, ReSharper, and AI-Refactored code standards for all modifications.
// </auto-generated>

#nullable enable

namespace AIRefactored.AI.Optimization
{
    using System;
    using System.Collections.Concurrent;
    using System.Collections.Generic;
    using System.Threading;
    using AIRefactored.Core;
    using AIRefactored.Runtime;
    using BepInEx.Logging;
    using UnityEngine;

    /// <summary>
    /// Central dispatcher for safely queuing Unity API calls from background threads.
    /// Schedules Unity-related tasks and defers smoothed spawns to prevent frame spikes.
    /// Only active on the authoritative host (headless or client-host). Flushes must be invoked from main thread once per frame.
    /// </summary>
    public static class BotWorkScheduler
    {
        #region Fields

        private const int MaxSpawnsPerSecond = 5;
        private const int MaxSpawnQueueSize = 256;

        private static readonly ConcurrentQueue<Action> _mainThreadQueue = new();
        private static readonly Queue<Action> _spawnQueue = new(MaxSpawnQueueSize);
        private static readonly object _spawnLock = new();
        private static readonly ManualLogSource Logger = AIRefactoredController.Logger;

        private static int _queuedCount;
        private static int _executedCount;
        private static int _errorCount;

        // Prevents multiple injections of the FlushRunner
        private static bool _flushHostInjected;

        #endregion

        #region Public API

        /// <summary>
        /// Injects an invisible MonoBehaviour to run Flush() automatically each frame.
        /// Only on client-host (not on remote clients)—headless still doesn’t need a runner.
        /// </summary>
        public static void AutoInjectFlushHost()
        {
            // Only inject once, and only on the authoritative host
            if (_flushHostInjected || !GameWorldHandler.IsLocalHost())
            {
                return;
            }

            _flushHostInjected = true;

            // If someone else already put a GameObject by this name, respect it
            if (GameObject.Find("AIRefactored.FlushHost") != null)
            {
                Logger.LogDebug("[BotWorkScheduler] Found existing FlushHost—skipping injection.");
                return;
            }

            GameObject? go = null;
            try
            {
                go = new GameObject("AIRefactored.FlushHost");
                go.AddComponent<FlushRunner>();
                GameObject.DontDestroyOnLoad(go);
                Logger.LogInfo("[BotWorkScheduler] Flush host injected into scene.");
            }
            catch (Exception ex)
            {
                Logger.LogError($"[BotWorkScheduler] Failed to inject FlushRunner: {ex}");
                // Clean up partial GameObject if creation failed
                if (go != null)
                {
                    UnityEngine.Object.Destroy(go);
                }
            }
        }

        /// <summary>
        /// Schedules a Unity-safe action from a background thread to be executed on main thread.
        /// </summary>
        public static void EnqueueToMainThread(Action? action)
        {
            if (action == null || !GameWorldHandler.IsLocalHost())
            {
                return;
            }

            _mainThreadQueue.Enqueue(action);
            Interlocked.Increment(ref _queuedCount);
            Logger?.LogDebug("[BotWorkScheduler] Main thread action queued. Total queued: " + _queuedCount);
        }

        /// <summary>
        /// Enqueues GameObject.Instantiate or similar load-heavy logic for deferred spawn throttling.
        /// </summary>
        public static void EnqueueSpawnSmoothed(Action? spawnAction)
        {
            if (spawnAction == null || !GameWorldHandler.IsLocalHost())
            {
                return;
            }

            lock (_spawnLock)
            {
                if (_spawnQueue.Count < MaxSpawnQueueSize)
                {
                    _spawnQueue.Enqueue(spawnAction);
                    Logger?.LogDebug("[BotWorkScheduler] Spawn action queued. Queue size: " + _spawnQueue.Count);
                }
                else
                {
                    Logger.LogWarning("[BotWorkScheduler] Spawn queue full. Task dropped.");
                }
            }
        }

        /// <summary>
        /// Executes pending Unity-safe calls and batched spawns.
        /// Must be called from Unity's main thread once per frame.
        /// </summary>
        public static void Flush()
        {
            if (!GameWorldHandler.IsLocalHost())
            {
                return;
            }

            // -- Main-thread queue --
            while (_mainThreadQueue.TryDequeue(out var action))
            {
                try
                {
                    action();
                    Interlocked.Increment(ref _executedCount);
                }
                catch (Exception ex)
                {
                    Interlocked.Increment(ref _errorCount);
                    Logger.LogWarning($"[BotWorkScheduler] Main-thread task failed: {ex.Message}\n{ex.StackTrace}");
                }
            }

            // -- Smooth spawns --
            int allowedThisFrame = Mathf.Max(1, Mathf.FloorToInt(MaxSpawnsPerSecond * Time.unscaledDeltaTime));
            int executed = 0;
            lock (_spawnLock)
            {
                while (executed < allowedThisFrame && _spawnQueue.Count > 0)
                {
                    var next = _spawnQueue.Dequeue();
                    try
                    {
                        next();
                        executed++;
                    }
                    catch (Exception ex)
                    {
                        Logger.LogWarning($"[BotWorkScheduler] Spawn task failed: {ex.Message}\n{ex.StackTrace}");
                    }
                }
            }
        }

        /// <summary>
        /// Returns current diagnostic snapshot of workload and execution metrics.
        /// </summary>
        public static string GetStats()
            => $"[BotWorkScheduler] Queued: {_queuedCount}, Executed: {_executedCount}, Errors: {_errorCount}, SpawnQueue: {_spawnQueue.Count}";

        #endregion

        #region Internal Types

        /// <summary>
        /// Invisible runner that invokes Flush() each Unity Update.
        /// </summary>
        private sealed class FlushRunner : MonoBehaviour
        {
            private void Update() => Flush();
        }

        #endregion
    }
}
