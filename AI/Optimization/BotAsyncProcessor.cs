// <auto-generated>
//   AI-Refactored: BotAsyncProcessor.cs (Supreme Overlay Arbitration/Event-Only, Absolute Max-Realism Async Edition, June 2025, Event Queue, Squad Danger, and Async Intent)
//   Async/event-only: overlays, intent, squad, panic contagion, mind sync, personality recovery, pooled diagnostics, zero disables, no tick/coroutine, bulletproof expansion.
//   SPT/FIKA/headless/client parity, humanized, squad/tactical/context aware, all actions event/intent only. MIT License.
// </auto-generated>

namespace AIRefactored.AI.Optimization
{
    using System;
    using System.Collections.Generic;
    using System.Threading.Tasks;
    using AIRefactored.AI.Core;
    using AIRefactored.AI.Groups;
    using AIRefactored.Core;
    using AIRefactored.Runtime;
    using BepInEx.Logging;
    using EFT;
    using UnityEngine;

    /// <summary>
    /// Supreme overlay/event-only async bot optimizer and squad intent/tactical processor.
    /// - Async overlay event queue, intent-only, deduped, thread-safe, pooled.
    /// - Squad overlays: async comms, panic/fakeout contagion, regroup/fallback intent, squad role/voice overlays.
    /// - Mind/personality sync and recovery, humanization overlays, diagnostics, pooled danger overlays, squad sync.
    /// - Bulletproof, error-contained, pooled, SPT/FIKA/headless/client safe, maximum expansion.
    /// </summary>
    public sealed class BotAsyncProcessor
    {
        #region Constants

        private const float InitDelaySeconds = 0.52f;
        private const float ThinkCooldownHeadless = 1.49f;
        private const float ThinkCooldownNormal = 3.45f;
        private const float MinMumbleChance = 0.006f;
        private const float AsyncPersonalitySafetyTimeout = 1.77f;
        private const float MinSquadOverlayChance = 0.010f;
        private const float MinPersonalitySyncChance = 0.006f;
        private const float MinDebugOverlayChance = 0.007f;
        private const float SquadPanicContagionChance = 0.19f;
        private const float SquadRegroupChance = 0.13f;
        private const float FatigueVoiceChance = 0.08f;
        private const int MaxEventQueueSize = 10;
        private const int MaxSquadSync = 6;

        #endregion

        #region Fields

        private static readonly ManualLogSource Logger = Plugin.LoggerInstance;
        private readonly BotOwnerGroupOptimization _groupOptimizer = new BotOwnerGroupOptimization();

        private BotOwner _bot;
        private BotComponentCache _cache;
        private BotOwnerStateCache _stateCache;
        private bool _hasInitialized;
        private float _lastThinkTime;
        private bool _pendingInit;

        // Overlay event queue (thread-safe, pooled)
        private readonly Queue<OverlayEvent> _eventQueue = new Queue<OverlayEvent>(MaxEventQueueSize);
        private readonly object _eventQueueLock = new object();

        #endregion

        #region Overlay Event Definition

        private struct OverlayEvent
        {
            public Action<BotOwner, BotComponentCache> Callback;
            public float ScheduledTime;
        }

        #endregion

        #region Public API

        /// <summary>
        /// Overlay/event: Initializes the async processor for the specified bot. Errors affect only this bot.
        /// </summary>
        public void Initialize(BotOwner botOwner, BotComponentCache cache)
        {
            try
            {
                if (!GameWorldHandler.IsLocalHost() || botOwner == null || cache == null)
                    return;

                _bot = botOwner;
                _cache = cache;
                _stateCache = new BotOwnerStateCache();
                _hasInitialized = false;
                _lastThinkTime = 0f;
                _pendingInit = true;

                Task.Run(async () =>
                {
                    try
                    {
                        await Task.Delay(TimeSpan.FromSeconds(InitDelaySeconds)).ConfigureAwait(false);

                        var safety = Task.Delay(TimeSpan.FromSeconds(AsyncPersonalitySafetyTimeout));
                        var init = ApplyInitialPersonalityAsync(botOwner);

                        if (await Task.WhenAny(init, safety).ConfigureAwait(false) == init && !_hasInitialized)
                            _hasInitialized = true;
                    }
                    catch (Exception ex)
                    {
                        Logger.LogWarning("[BotAsyncProcessor] Async init failed: " + ex.Message);
                    }
                    finally { _pendingInit = false; }
                });
            }
            catch (Exception ex)
            {
                Logger.LogError("[BotAsyncProcessor] Initialize() fatal error: " + ex);
            }
        }

        /// <summary>
        /// Overlay/event: Triggers async group/personality logic, cooldown-guarded. Processes delayed overlay events.
        /// </summary>
        public void OverlayTick(float now)
        {
            try
            {
                if (!GameWorldHandler.IsLocalHost() || !_hasInitialized || _pendingInit || _bot == null || _bot.IsDead)
                    return;

                ProcessQueuedEvents(now);

                // Always update state cache for overlays/diagnostics
                SafeCall(() => _stateCache.UpdateBotOwnerStateIfNeeded(_bot), "[BotAsyncProcessor] StateCache update failed");
                SafeCall(TryOptimizeGroup, "[BotAsyncProcessor] TryOptimizeGroup failed");

                float cooldown = FikaHeadlessDetector.IsHeadless ? ThinkCooldownHeadless : ThinkCooldownNormal;
                if (now - _lastThinkTime < cooldown)
                    return;

                _lastThinkTime = now;

                if (FikaHeadlessDetector.IsHeadless)
                {
                    System.Threading.ThreadPool.QueueUserWorkItem(_ =>
                    {
                        SafeCall(Think, "[BotAsyncProcessor] Async headless think failed");
                    });
                }
                else
                {
                    SafeCall(Think, "[BotAsyncProcessor] Think execution failed");
                }
            }
            catch (Exception ex)
            {
                Logger.LogError("[BotAsyncProcessor] OverlayTick() fatal error: " + ex);
            }
        }

        /// <summary>
        /// Queues a delayed overlay/event intent (e.g., voice, regroup, memory update). Thread-safe, zero-alloc, pooled.
        /// </summary>
        public void QueueDelayedEvent(Action<BotOwner, BotComponentCache> callback, float delaySeconds)
        {
            if (_bot == null || _cache == null || callback == null)
                return;

            float scheduledTime = Time.time + Mathf.Max(0.01f, delaySeconds);

            lock (_eventQueueLock)
            {
                if (_eventQueue.Count >= MaxEventQueueSize)
                    _eventQueue.Dequeue(); // Discard oldest event if full

                _eventQueue.Enqueue(new OverlayEvent { Callback = callback, ScheduledTime = scheduledTime });
            }
        }

        #endregion

        #region Overlay Event Processor

        /// <summary>
        /// Processes and dispatches any queued overlay events whose scheduled time has arrived.
        /// </summary>
        private void ProcessQueuedEvents(float now)
        {
            if (_eventQueue.Count == 0) return;

            lock (_eventQueueLock)
            {
                int processed = 0;
                int total = _eventQueue.Count;
                while (processed < total)
                {
                    if (_eventQueue.Count == 0) break;
                    var evt = _eventQueue.Peek();
                    if (evt.ScheduledTime > now) break;
                    _eventQueue.Dequeue();
                    try { evt.Callback?.Invoke(_bot, _cache); }
                    catch (Exception ex) { Logger.LogWarning("[BotAsyncProcessor] Event dispatch failed: " + ex); }
                    processed++;
                }
            }
        }

        #endregion

        #region Internal Logic

        private async Task ApplyInitialPersonalityAsync(BotOwner bot)
        {
            try
            {
                if (_hasInitialized || bot == null || bot.Profile == null || bot.Settings == null || bot.Settings.FileSettings == null)
                    return;

                await Task.Yield();

                string profileId = bot.Profile?.Id ?? bot.ProfileId ?? "Unknown";
                if (string.IsNullOrEmpty(profileId))
                    return;

                BotGlobalsMindSettings mind = null;
                try { mind = bot.Settings.FileSettings.Mind; } catch { }
                if (mind == null)
                    return;

                BotPersonalityProfile personality = null;
                try { personality = BotRegistry.Get(profileId); } catch { }
                if (personality == null)
                    return;

                // Sync internal mind fields to personality traits (EFT logic)
                try { mind.PANIC_RUN_WEIGHT = Mathf.Lerp(0.48f, 2.12f, Mathf.Clamp01(personality.RiskTolerance)); } catch { }
                try { mind.PANIC_SIT_WEIGHT = Mathf.Lerp(9.8f, 81.0f, 1f - Mathf.Clamp01(personality.RiskTolerance)); } catch { }
                try { mind.DIST_TO_FOUND_SQRT = Mathf.Lerp(170f, 660f, 1f - Mathf.Clamp01(personality.Cohesion)); } catch { }
                try { mind.FRIEND_AGR_KILL = Mathf.Lerp(0f, 0.41f, Mathf.Clamp01(personality.AggressionLevel)); } catch { }
                try { mind.CHANCE_TO_RUN_CAUSE_DAMAGE_0_100 = Mathf.Clamp(mind.CHANCE_TO_RUN_CAUSE_DAMAGE_0_100 + personality.AggressionLevel * 7.3f - personality.Caution * 3.7f, 0f, 100f); } catch { }
                try { mind.MIN_DAMAGE_SCARE = Mathf.Lerp(0.01f, 0.43f, Mathf.Clamp01(personality.Caution)); } catch { }

                Logger.LogDebug("[BotAsyncProcessor] ✅ Personality mind values set for: " + (bot.Profile?.Info?.Nickname ?? "Unknown"));
                _hasInitialized = true;
            }
            catch (Exception ex)
            {
                Logger.LogWarning("[BotAsyncProcessor] ApplyInitialPersonalityAsync failed: " + ex.Message);
            }
        }

        private void Think()
        {
            try
            {
                if (_bot == null || _bot.IsDead)
                    return;

                // Async human mumble/voice overlays
                if (UnityEngine.Random.value < MinMumbleChance)
                {
                    BotWorkScheduler.EnqueueToMainThread(() =>
                    {
                        try
                        {
                            EFT.Player p = _bot.GetPlayer;
                            if (p != null)
                                p.Say(EPhraseTrigger.MumblePhrase);
                        }
                        catch (Exception ex)
                        {
                            Logger.LogWarning("[BotAsyncProcessor] Mumble dispatch failed: " + ex.Message);
                        }
                    });
                }

                // Async squad overlays and panic/fatigue contagion
                if (_bot.BotsGroup != null && _bot.BotsGroup.MembersCount > 1 && UnityEngine.Random.value < MinSquadOverlayChance)
                {
                    int squadCount = Math.Min(_bot.BotsGroup.MembersCount, MaxSquadSync);
                    for (int i = 0; i < squadCount; i++)
                    {
                        BotOwner mate = _bot.BotsGroup.Member(i);
                        if (mate != null && mate != _bot && !mate.IsDead)
                        {
                            var mateCache = mate.GetComponent<BotComponentCache>();
                            // Squad regroup overlay (rare)
                            if (mateCache != null && mateCache.GroupComms != null && UnityEngine.Random.value < SquadRegroupChance)
                                mateCache.GroupComms.Say(EPhraseTrigger.Regroup);

                            // Panic/fakeout contagion overlay (rare, based on composure)
                            var panic = mateCache?.PanicHandler;
                            if (panic != null && _cache?.PanicHandler != null &&
                                _cache.PanicHandler.GetComposureLevel() < 0.19f &&
                                UnityEngine.Random.value < SquadPanicContagionChance)
                            {
                                // If squad member is calm, trigger mild panic/fakeout overlay
                                if (panic.GetComposureLevel() > 0.5f)
                                    mateCache.GroupComms.Say(EPhraseTrigger.HoldPosition);
                            }
                        }
                    }
                }

                // Fatigue/stress overlays (simulate stress/fatigue voice)
                if (_cache != null && _cache.PanicHandler != null && _cache.PanicHandler.GetComposureLevel() < 0.21f
                    && _cache.GroupComms != null && UnityEngine.Random.value < FatigueVoiceChance)
                {
                    _cache.GroupComms.Say(EPhraseTrigger.NeedHelp);
                }

                // Async personality/mind sync overlay (rare)
                if (_cache != null && UnityEngine.Random.value < MinPersonalitySyncChance)
                {
                    SafeCall(() =>
                    {
                        var profile = _cache.AIRefactoredBotOwner?.PersonalityProfile;
                        var mind = _bot.Settings?.FileSettings?.Mind;
                        if (profile != null && mind != null)
                        {
                            mind.PANIC_RUN_WEIGHT = Mathf.Lerp(0.48f, 2.12f, Mathf.Clamp01(profile.RiskTolerance));
                            mind.PANIC_SIT_WEIGHT = Mathf.Lerp(9.8f, 81.0f, 1f - Mathf.Clamp01(profile.RiskTolerance));
                        }
                    }, "[BotAsyncProcessor] Overlay personality/mind sync failed");
                }

                // Async diagnostics overlay (very rare, pooled)
                if (_cache != null && UnityEngine.Random.value < MinDebugOverlayChance)
                {
                    SafeCall(() =>
                    {
                        var profile = _cache.AIRefactoredBotOwner?.PersonalityProfile;
                        Logger.LogDebug($"[BotAsyncProcessor] Overlay Diagnostics for: {_bot.Profile?.Info?.Nickname ?? "Unknown"} " +
                            $"Agg={profile?.AggressionLevel:F2} Cau={profile?.Caution:F2} Aw={profile?.Awareness:F2} Type={profile?.Personality}");
                    }, "[BotAsyncProcessor] Overlay diagnostics failed");
                }
            }
            catch (Exception ex)
            {
                Logger.LogWarning("[BotAsyncProcessor] Think() exception: " + ex.Message);
            }
        }

        private void TryOptimizeGroup()
        {
            try
            {
                if (_bot == null || _bot.Profile == null || _bot.Profile.Info == null)
                    return;

                string groupId = _bot.Profile.Info.GroupId;
                if (string.IsNullOrEmpty(groupId))
                    return;

                List<BotOwner> squad = null;
                try { squad = BotTeamTracker.GetGroup(groupId); } catch { }
                if (squad != null && squad.Count > 0)
                {
                    try { _groupOptimizer.OptimizeGroupAI(squad); } catch (Exception ex) { Logger.LogWarning("[BotAsyncProcessor] Group optimization failed: " + ex.Message); }
                }
            }
            catch (Exception ex)
            {
                Logger.LogWarning("[BotAsyncProcessor] TryOptimizeGroup() exception: " + ex.Message);
            }
        }

        private static void SafeCall(Action fn, string warnMsg)
        {
            try { fn(); } catch (Exception ex) { Logger.LogWarning($"{warnMsg}: {ex}"); }
        }

        #endregion
    }
}
