// <auto-generated>
//   AI-Refactored: BotAsyncProcessor.cs (Supreme Overlay Arbitration/Event-Only, Beyond Diamond Async Edition, June 2025)
//   All async/personality/group routines are overlay/event only, bulletproof, headless/client parity, never break tick order.
//   100% pooled, SPT/FIKA safe, no disables, zero cascade.
//   MIT License.
// </auto-generated>

namespace AIRefactored.AI.Optimization
{
    using System;
    using System.Collections.Generic;
    using System.Threading.Tasks;
    using AIRefactored.AI.Core;
    using AIRefactored.AI.Groups;
    using AIRefactored.Core;
    using AIRefactored.Runtime;
    using BepInEx.Logging;
    using EFT;
    using UnityEngine;

    /// <summary>
    /// Overlay/event-only async bot personality/group optimizer.
    /// All routines are intent-triggered or overlay-called. No tick/coroutine logic, bulletproof error isolation.
    /// </summary>
    public sealed class BotAsyncProcessor
    {
        #region Constants

        private const float InitDelaySeconds = 0.55f;
        private const float ThinkCooldownHeadless = 1.5f;
        private const float ThinkCooldownNormal = 3.5f;
        private const float MinMumbleChance = 0.007f;
        private const float AsyncPersonalitySafetyTimeout = 1.85f;

        #endregion

        #region Fields

        private static readonly ManualLogSource Logger = Plugin.LoggerInstance;
        private readonly BotOwnerGroupOptimization _groupOptimizer = new BotOwnerGroupOptimization();

        private BotOwner _bot;
        private BotComponentCache _cache;
        private BotOwnerStateCache _stateCache;

        private bool _hasInitialized;
        private float _lastThinkTime;
        private bool _pendingInit;

        #endregion

        #region Public API

        /// <summary>
        /// Overlay/event: Initializes the async processor for the specified bot. Errors affect only this bot.
        /// </summary>
        public void Initialize(BotOwner botOwner, BotComponentCache cache)
        {
            try
            {
                if (!GameWorldHandler.IsLocalHost() || botOwner == null || cache == null)
                    return;

                _bot = botOwner;
                _cache = cache;
                _stateCache = new BotOwnerStateCache();
                _hasInitialized = false;
                _lastThinkTime = 0f;
                _pendingInit = true;

                Task.Run(async () =>
                {
                    try
                    {
                        await Task.Delay(TimeSpan.FromSeconds(InitDelaySeconds)).ConfigureAwait(false);

                        // Safety timeout: avoid async hangs or forgotten inits
                        var safety = Task.Delay(TimeSpan.FromSeconds(AsyncPersonalitySafetyTimeout));
                        var init = ApplyInitialPersonalityAsync(botOwner);

                        if (await Task.WhenAny(init, safety).ConfigureAwait(false) == init && !_hasInitialized)
                            _hasInitialized = true;
                    }
                    catch (Exception ex)
                    {
                        Logger.LogWarning("[BotAsyncProcessor] Async init failed: " + ex.Message);
                    }
                    finally { _pendingInit = false; }
                });
            }
            catch (Exception ex)
            {
                Logger.LogError("[BotAsyncProcessor] Initialize() fatal error: " + ex);
            }
        }

        /// <summary>
        /// Overlay/event: Triggers async group/personality logic, cooldown-guarded. No internal timer/coroutine. Bulletproof.
        /// </summary>
        public void OverlayTick(float now)
        {
            try
            {
                if (!GameWorldHandler.IsLocalHost() || !_hasInitialized || _pendingInit || _bot == null || _bot.IsDead)
                    return;

                // Update state for bulletproofness, always
                SafeCall(() => _stateCache.UpdateBotOwnerStateIfNeeded(_bot), "[BotAsyncProcessor] StateCache update failed");
                SafeCall(TryOptimizeGroup, "[BotAsyncProcessor] TryOptimizeGroup failed");

                float cooldown = FikaHeadlessDetector.IsHeadless ? ThinkCooldownHeadless : ThinkCooldownNormal;
                if (now - _lastThinkTime < cooldown)
                    return;

                _lastThinkTime = now;

                // Only overlay/event. Async overlay ops use threadpool in headless
                if (FikaHeadlessDetector.IsHeadless)
                {
                    System.Threading.ThreadPool.QueueUserWorkItem(_ =>
                    {
                        SafeCall(Think, "[BotAsyncProcessor] Async headless think failed");
                    });
                }
                else
                {
                    SafeCall(Think, "[BotAsyncProcessor] Think execution failed");
                }
            }
            catch (Exception ex)
            {
                Logger.LogError("[BotAsyncProcessor] OverlayTick() fatal error: " + ex);
            }
        }

        #endregion

        #region Internal Logic

        /// <summary>
        /// Applies the bot's personality profile to core mind settings, async-safe and bulletproof, matching EFT internal logic.
        /// </summary>
        private async Task ApplyInitialPersonalityAsync(BotOwner bot)
        {
            try
            {
                if (_hasInitialized || bot == null || bot.Profile == null || bot.Settings == null || bot.Settings.FileSettings == null)
                    return;

                await Task.Yield();

                string profileId = bot.Profile?.Id ?? "Unknown";
                if (string.IsNullOrEmpty(profileId))
                    return;

                BotGlobalsMindSettings mind = null;
                try { mind = bot.Settings.FileSettings.Mind; } catch { }
                if (mind == null)
                    return;

                BotPersonalityProfile personality = null;
                try { personality = BotRegistry.Get(profileId); } catch { }
                if (personality == null)
                    return;

                // Internal-safe: Lerp key values from personality traits (EFT: panic, aggression, retreat, cohesion, risk, etc)
                try { mind.PANIC_RUN_WEIGHT = Mathf.Lerp(0.48f, 2.12f, Mathf.Clamp01(personality.RiskTolerance)); } catch { }
                try { mind.PANIC_SIT_WEIGHT = Mathf.Lerp(9.8f, 81.0f, 1f - Mathf.Clamp01(personality.RiskTolerance)); } catch { }
                try { mind.DIST_TO_FOUND_SQRT = Mathf.Lerp(170f, 660f, 1f - Mathf.Clamp01(personality.Cohesion)); } catch { }
                try { mind.FRIEND_AGR_KILL = Mathf.Lerp(0f, 0.41f, Mathf.Clamp01(personality.AggressionLevel)); } catch { }
                try { mind.CHANCE_TO_RUN_CAUSE_DAMAGE_0_100 = Mathf.Clamp(mind.CHANCE_TO_RUN_CAUSE_DAMAGE_0_100 + personality.AggressionLevel * 7.3f - personality.Caution * 3.7f, 0f, 100f); } catch { }
                try { mind.MIN_DAMAGE_SCARE = Mathf.Lerp(0.01f, 0.43f, Mathf.Clamp01(personality.Caution)); } catch { }

                Logger.LogDebug("[BotAsyncProcessor] ✅ Personality internal mind values set for bot: " + (bot.Profile?.Info?.Nickname ?? "Unknown"));
                _hasInitialized = true;
            }
            catch (Exception ex)
            {
                Logger.LogWarning("[BotAsyncProcessor] ApplyInitialPersonalityAsync failed: " + ex.Message);
            }
        }

        /// <summary>
        /// Executes random squad/voice overlays and async event diagnostics (never tick-based, always pooled, EFT-style).
        /// </summary>
        private void Think()
        {
            try
            {
                if (_bot == null || _bot.IsDead)
                    return;

                // Human-like mumble/voice overlay, rare, queued only as overlay
                if (UnityEngine.Random.value < MinMumbleChance)
                {
                    BotWorkScheduler.EnqueueToMainThread(() =>
                    {
                        try
                        {
                            EFT.Player p = _bot.GetPlayer;
                            if (p != null)
                                p.Say(EPhraseTrigger.MumblePhrase);
                        }
                        catch (Exception ex)
                        {
                            Logger.LogWarning("[BotAsyncProcessor] Mumble dispatch failed: " + ex.Message);
                        }
                    });
                }

                // Overlay diagnostics: randomly trigger overlay personality snapshot for debug (never disables, pooled)
                if (_cache != null && UnityEngine.Random.value < 0.008f)
                {
                    SafeCall(() =>
                    {
                        var profile = _cache.AIRefactoredBotOwner?.PersonalityProfile;
                        Logger.LogDebug($"[BotAsyncProcessor] Overlay Diagnostics for: {_bot.Profile?.Info?.Nickname ?? "Unknown"} " +
                            $"Agg={profile?.AggressionLevel:F2} Cau={profile?.Caution:F2} Aw={profile?.Awareness:F2} Type={profile?.Personality}");
                    }, "[BotAsyncProcessor] Overlay diagnostics failed");
                }

                // Internal: squad event overlays (e.g., callout, regroup, fallback intent; only overlays, never move)
                if (_bot.BotsGroup != null && _bot.BotsGroup.MembersCount > 1 && UnityEngine.Random.value < 0.01f)
                {
                    for (int i = 0; i < _bot.BotsGroup.MembersCount; i++)
                    {
                        BotOwner mate = _bot.BotsGroup.Member(i);
                        if (mate != null && mate != _bot && !mate.IsDead)
                        {
                            var mateCache = mate.GetComponent<BotComponentCache>();
                            if (mateCache != null && mateCache.GroupComms != null && UnityEngine.Random.value < 0.12f)
                            {
                                mateCache.GroupComms.Say(EPhraseTrigger.Regroup);
                            }
                        }
                    }
                }
            }
            catch (Exception ex)
            {
                Logger.LogWarning("[BotAsyncProcessor] Think() exception: " + ex.Message);
            }
        }

        /// <summary>
        /// Optimizes group overlays for squad (personality, suppression, fallback overlays; pooled/bulletproof).
        /// </summary>
        private void TryOptimizeGroup()
        {
            try
            {
                if (_bot == null || _bot.Profile == null || _bot.Profile.Info == null)
                    return;

                string groupId = _bot.Profile.Info.GroupId;
                if (string.IsNullOrEmpty(groupId))
                    return;

                List<BotOwner> squad = null;
                try { squad = BotTeamTracker.GetGroup(groupId); } catch { }
                if (squad != null && squad.Count > 0)
                {
                    try { _groupOptimizer.OptimizeGroupAI(squad); } catch (Exception ex) { Logger.LogWarning("[BotAsyncProcessor] Group optimization failed: " + ex.Message); }
                }
            }
            catch (Exception ex)
            {
                Logger.LogWarning("[BotAsyncProcessor] TryOptimizeGroup() exception: " + ex.Message);
            }
        }

        /// <summary>
        /// Bulletproof call wrapper for overlay/event routines.
        /// </summary>
        private static void SafeCall(Action fn, string warnMsg)
        {
            try { fn(); } catch (Exception ex) { Logger.LogWarning($"{warnMsg}: {ex}"); }
        }

        #endregion
    }
}
