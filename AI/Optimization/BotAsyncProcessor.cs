// <auto-generated>
//   AI-Refactored: BotAsyncProcessor.cs (Beyond Diamond – Async Overlay/Event Edition, June 2025)
//   All async/personality/group routines are overlay/event only, bulletproof, headless/client parity, and never break tick order.
//   MIT License.
// </auto-generated>

namespace AIRefactored.AI.Optimization
{
    using System;
    using System.Collections.Generic;
    using System.Threading.Tasks;
    using AIRefactored.AI.Core;
    using AIRefactored.AI.Groups;
    using AIRefactored.Core;
    using AIRefactored.Runtime;
    using BepInEx.Logging;
    using EFT;
    using UnityEngine;

    /// <summary>
    /// Overlay/event-only async bot personality/group optimizer.
    /// All routines are intent-triggered or overlay-called. No tick/coroutine logic, bulletproof error isolation.
    /// </summary>
    public sealed class BotAsyncProcessor
    {
        #region Constants

        private const float InitDelaySeconds = 0.5f;
        private const float ThinkCooldownHeadless = 1.5f;
        private const float ThinkCooldownNormal = 3.5f;

        #endregion

        #region Fields

        private static readonly ManualLogSource Logger = Plugin.LoggerInstance;
        private readonly BotOwnerGroupOptimization _groupOptimizer = new BotOwnerGroupOptimization();

        private BotOwner _bot;
        private BotComponentCache _cache;
        private BotOwnerStateCache _stateCache;

        private bool _hasInitialized;
        private float _lastThinkTime;

        #endregion

        #region Public API

        /// <summary>
        /// Overlay/event: Initializes the async processor for the specified bot. Errors affect only this bot.
        /// </summary>
        public void Initialize(BotOwner botOwner, BotComponentCache cache)
        {
            try
            {
                if (!GameWorldHandler.IsLocalHost() || botOwner == null || cache == null)
                    return;

                _bot = botOwner;
                _cache = cache;
                _stateCache = new BotOwnerStateCache();
                _hasInitialized = false;
                _lastThinkTime = 0f;

                // Event-only async logic, never polled/ticked.
                Task.Run(async () =>
                {
                    try
                    {
                        await Task.Delay(TimeSpan.FromSeconds(InitDelaySeconds)).ConfigureAwait(false);
                        if (!_hasInitialized)
                            await ApplyInitialPersonalityAsync(botOwner).ConfigureAwait(false);
                    }
                    catch (Exception ex)
                    {
                        Logger.LogWarning("[BotAsyncProcessor] Async init failed: " + ex.Message);
                    }
                });
            }
            catch (Exception ex)
            {
                Logger.LogError("[BotAsyncProcessor] Initialize() fatal error: " + ex);
            }
        }

        /// <summary>
        /// Overlay/event: Triggers async group/personality logic, cooldown-guarded. No internal timer/coroutine. Bulletproof.
        /// </summary>
        public void OverlayTick(float now)
        {
            try
            {
                if (!GameWorldHandler.IsLocalHost() || !_hasInitialized || _bot == null || _bot.IsDead)
                    return;

                // Always update state cache for bulletproofness.
                SafeCall(() => _stateCache.UpdateBotOwnerStateIfNeeded(_bot), "[BotAsyncProcessor] StateCache update failed");
                SafeCall(TryOptimizeGroup, "[BotAsyncProcessor] TryOptimizeGroup failed");

                float cooldown = FikaHeadlessDetector.IsHeadless ? ThinkCooldownHeadless : ThinkCooldownNormal;
                if (now - _lastThinkTime < cooldown)
                    return;

                _lastThinkTime = now;

                // Overlay/event: Only main-thread or queued, never tick.
                if (FikaHeadlessDetector.IsHeadless)
                {
                    System.Threading.ThreadPool.QueueUserWorkItem(_ =>
                    {
                        SafeCall(Think, "[BotAsyncProcessor] Async headless think failed");
                    });
                }
                else
                {
                    SafeCall(Think, "[BotAsyncProcessor] Think execution failed");
                }
            }
            catch (Exception ex)
            {
                Logger.LogError("[BotAsyncProcessor] OverlayTick() fatal error: " + ex);
            }
        }

        #endregion

        #region Internal Logic

        /// <summary>
        /// Applies the bot's personality profile to core mind settings, async-safe and bulletproof.
        /// </summary>
        private async Task ApplyInitialPersonalityAsync(BotOwner bot)
        {
            try
            {
                if (_hasInitialized || bot == null || bot.Profile == null || bot.Settings == null || bot.Settings.FileSettings == null)
                    return;

                await Task.Yield();

                string profileId = bot.Profile?.Id ?? "Unknown";
                if (string.IsNullOrEmpty(profileId))
                    return;

                BotGlobalsMindSettings mind = null;
                try { mind = bot.Settings.FileSettings.Mind; } catch { }
                if (mind == null)
                    return;

                BotPersonalityProfile personality = null;
                try { personality = BotRegistry.Get(profileId); } catch { }
                if (personality == null)
                    return;

                // Safely lerp mind config using personality traits.
                try { mind.PANIC_RUN_WEIGHT = Mathf.Lerp(0.5f, 2.0f, personality.RiskTolerance); } catch { }
                try { mind.PANIC_SIT_WEIGHT = Mathf.Lerp(10.0f, 80.0f, 1f - personality.RiskTolerance); } catch { }
                try { mind.DIST_TO_FOUND_SQRT = Mathf.Lerp(200f, 600f, 1f - personality.Cohesion); } catch { }
                try { mind.FRIEND_AGR_KILL = Mathf.Lerp(0f, 0.4f, personality.AggressionLevel); } catch { }

                Logger.LogDebug("[BotAsyncProcessor] ✅ Personality initialized for bot: " + (bot.Profile?.Info?.Nickname ?? "Unknown"));
                _hasInitialized = true;
            }
            catch (Exception ex)
            {
                Logger.LogWarning("[BotAsyncProcessor] ApplyInitialPersonalityAsync failed: " + ex.Message);
            }
        }

        /// <summary>
        /// Executes random "mumble" voice logic and other periodic async overlays, bulletproof.
        /// </summary>
        private void Think()
        {
            try
            {
                if (_bot == null || _bot.IsDead)
                    return;

                // Simulate human-like random mumble phrases rarely, always queued on main thread for safety.
                if (UnityEngine.Random.value < 0.008f)
                {
                    BotWorkScheduler.EnqueueToMainThread(() =>
                    {
                        try
                        {
                            EFT.Player p = _bot.GetPlayer;
                            if (p != null)
                                p.Say(EPhraseTrigger.MumblePhrase);
                        }
                        catch (Exception ex)
                        {
                            Logger.LogWarning("[BotAsyncProcessor] Mumble dispatch failed: " + ex.Message);
                        }
                    });
                }
            }
            catch (Exception ex)
            {
                Logger.LogWarning("[BotAsyncProcessor] Think() exception: " + ex.Message);
            }
        }

        /// <summary>
        /// Attempts to optimize group AI overlays for the bot's squad, bulletproof and pooled.
        /// </summary>
        private void TryOptimizeGroup()
        {
            try
            {
                if (_bot == null || _bot.Profile == null || _bot.Profile.Info == null)
                    return;

                string groupId = _bot.Profile.Info.GroupId;
                if (string.IsNullOrEmpty(groupId))
                    return;

                List<BotOwner> squad = null;
                try { squad = BotTeamTracker.GetGroup(groupId); } catch { }
                if (squad != null && squad.Count > 0)
                {
                    try { _groupOptimizer.OptimizeGroupAI(squad); } catch (Exception ex) { Logger.LogWarning("[BotAsyncProcessor] Group optimization failed: " + ex.Message); }
                }
            }
            catch (Exception ex)
            {
                Logger.LogWarning("[BotAsyncProcessor] TryOptimizeGroup() exception: " + ex.Message);
            }
        }

        /// <summary>
        /// Bulletproof call wrapper for overlay/event routines.
        /// </summary>
        private static void SafeCall(Action fn, string warnMsg)
        {
            try { fn(); } catch (Exception ex) { Logger.LogWarning($"{warnMsg}: {ex}"); }
        }

        #endregion
    }
}
