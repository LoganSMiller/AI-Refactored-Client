// <auto-generated>
//   AI-Refactored: BotCoverRetreatPlanner.cs (Ultimate Human-Like Retreat, Cover, and Squad Flow – June 2025 Beyond Diamond Edition)
//   Ultra-realistic cover/retreat, squad/chaos/personality-driven, pooled, headless/client safe, arbitration overlay/event-only.
//   No direct pathfinding, no direct move. Outputs overlays/intents only. Bulletproof error isolation, zero disables.
//   MIT License.
// </auto-generated>

namespace AIRefactored.AI.Optimization
{
    using System;
    using System.Collections.Generic;
    using AIRefactored.AI.Core;
    using AIRefactored.AI.Helpers;
    using AIRefactored.AI.Navigation;
    using AIRefactored.Core;
    using AIRefactored.Pools;
    using EFT;
    using UnityEngine;
    using UnityEngine.AI;

    /// <summary>
    /// Ultra-realistic, squad-aware cover/fallback/retreat planner for AIRefactored bots.
    /// Caches squad/group retreat overlays, applies chaos/personality/suppression modifiers, zero allocation in hot path.
    /// Arbitration/event-only, SPT/FIKA/headless/client parity. Never disables, never teleports or issues direct path/move.
    /// </summary>
    public sealed class BotCoverRetreatPlanner
    {
        #region Constants

        private const float SquadSpacingThreshold = 4.25f;
        private const float MemoryClearInterval = 61f;
        private const float ChaosOffsetRadius = 2.5f;
        private const float CoverProbeRadius = 4.2f;
        private const int CoverProbeRays = 12;
        private const float CoverCheckInterval = 0.23f;
        private const float CoverPersistTime = 0.67f;
        private const float NavSampleRadius = 1.5f;
        private const float MinRetreatDist = 7.5f;
        private const float MinCoverDot = 0.55f;

        #endregion

        #region Static Pool and Cache

        private static readonly Dictionary<string, Dictionary<string, List<Vector3>>> _squadRetreatCache =
            new Dictionary<string, Dictionary<string, List<Vector3>>>();
        private static float _lastClearTime = -999f;

        #endregion

        #region Fields

        private readonly BotOwner _bot;
        private float _lastCoverCheckTime;
        private bool _isInCover;
        private Vector3 _coverNormal;
        private float _coverLastFoundTime;
        private int _coverMisses;

        #endregion

        #region Construction

        public BotCoverRetreatPlanner(BotOwner bot)
        {
            _bot = bot ?? throw new ArgumentNullException(nameof(bot));
            _lastCoverCheckTime = -999f;
            _coverNormal = Vector3.zero;
            _coverLastFoundTime = -999f;
            _coverMisses = 0;
            _isInCover = false;
        }

        #endregion

        #region Properties

        public bool IsInCover
        {
            get
            {
                float now = Time.time;
                return _isInCover && now - _coverLastFoundTime < CoverPersistTime;
            }
        }

        public Vector3 CoverNormal => _coverNormal;

        #endregion

        #region Static Init

        public static void InitializeStatic()
        {
            try
            {
                _squadRetreatCache.Clear();
                _lastClearTime = Time.time;
            }
            catch (Exception ex)
            {
                Plugin.LoggerInstance.LogError("[BotCoverRetreatPlanner] Initialize failed: " + ex);
            }
        }

        #endregion

        #region Main Public API

        /// <summary>
        /// Overlay/event-only: Returns a pooled, NavMesh-safe, squad-aware fallback path (never direct move).
        /// Result is always safe, chaos/personality/suppression adjusted, never disables.
        /// </summary>
        public List<Vector3> GetCoverRetreatPath(Vector3 threatDir)
        {
            var result = TempListPool.Rent<Vector3>();
            try
            {
                if (!GameWorldHandler.IsLocalHost() || _bot == null || _bot.Transform == null || threatDir == Vector3.zero)
                    return result;

                string map = GameWorldHandler.TryGetValidMapName();
                if (string.IsNullOrEmpty(map)) return result;

                ClearExpiredCache();

                string squadId = _bot.Profile?.Info?.GroupId ?? _bot.ProfileId;
                if (!_squadRetreatCache.TryGetValue(map, out var squadCache))
                {
                    squadCache = new Dictionary<string, List<Vector3>>();
                    _squadRetreatCache[map] = squadCache;
                }

                // Try squad cache: use if valid and not overlapping
                if (squadCache.TryGetValue(squadId, out var cached) &&
                    cached.Count >= 2 && !SquadOverlapCheck(_bot, cached))
                {
                    result.AddRange(cached);
                    return result;
                }
                squadCache.Remove(squadId);

                // Overlay intent: ask global helper for retreat path (no direct pathing!)
                List<Vector3> overlayPath = null;
                try
                {
                    overlayPath = BotMovementHelper.GetSquadSafeRetreatPath(_bot, threatDir, SquadSpacingThreshold);
                }
                catch (Exception ex)
                {
                    Plugin.LoggerInstance.LogWarning("[BotCoverRetreatPlanner] GetSquadSafeRetreatPath error: " + ex);
                }

                if (overlayPath != null && overlayPath.Count >= 2)
                {
                    ApplyChaosOffset(overlayPath, _bot, threatDir);
                    for (int i = 0; i < overlayPath.Count; i++)
                        overlayPath[i] = NavMeshSampleSafe(overlayPath[i], _bot.Position);
                    squadCache[squadId] = overlayPath;
                    result.AddRange(overlayPath);
                    return result;
                }

                // Fallback: always return NavMesh-validated overlay, even if all above fail
                Vector3 origin = _bot.Position;
                Vector3 fallback = origin - threatDir.normalized * MinRetreatDist;
                Vector3 navSafeOrigin = NavMeshSampleSafe(origin, _bot.Position);
                Vector3 navSafeFallback = NavMeshSampleSafe(fallback, _bot.Position);
                result.Add(navSafeOrigin);
                result.Add(navSafeFallback);
                return result;
            }
            catch (Exception ex)
            {
                Plugin.LoggerInstance.LogError("[BotCoverRetreatPlanner] GetCoverRetreatPath failed: " + ex);
                return result;
            }
        }

        /// <summary>
        /// Probes for best cover point near current, with full NavMesh sampling and flicker/hysteresis.
        /// Matches EFT cover search: checks normals, dot to threat, avoids invalid spots, pooled.
        /// </summary>
        public bool TryGetBestCoverNear(Vector3 target, Vector3 current, out Vector3 coverPoint)
        {
            coverPoint = Vector3.zero;
            float now = Time.time;
            bool foundCover = false;
            Vector3 foundNormal = Vector3.zero;

            if (now - _lastCoverCheckTime < CoverCheckInterval)
            {
                if (_isInCover)
                {
                    coverPoint = NavMeshSampleSafe(current + _coverNormal * 1.15f, current);
                    return true;
                }
                return false;
            }
            _lastCoverCheckTime = now;

            float bestScore = float.MinValue;
            Vector3 best = Vector3.zero;
            Vector3 bestNormal = Vector3.zero;
            Vector3 directionToTarget = (target - current).normalized;

            for (int i = 0; i < CoverProbeRays; i++)
            {
                float angle = (360f / CoverProbeRays) * i;
                Vector3 dir = Quaternion.Euler(0f, angle, 0f) * -directionToTarget;
                Vector3 probe = current + dir * CoverProbeRadius;

                if (!NavMesh.SamplePosition(probe, out NavMeshHit navHit, 2.0f, NavMesh.AllAreas))
                    continue;

                Vector3 navPos = navHit.position;
                float dot = Vector3.Dot(dir, -directionToTarget);
                if (dot < MinCoverDot) continue; // only take valid backward cover

                float score = dot * 1.8f - Vector3.Distance(current, navPos) * 0.21f;
                Vector3 eye = navPos + Vector3.up * 1.43f;
                Vector3 toThreat = (target - navPos).normalized;
                Vector3 normal = Vector3.zero;

                if (Physics.Raycast(eye, toThreat, out RaycastHit hit, Vector3.Distance(navPos, target), AIRefactoredLayerMasks.CoverColliderMask))
                {
                    score += 2.7f;
                    normal = hit.normal;
                }

                if (score > bestScore)
                {
                    bestScore = score;
                    best = navPos;
                    bestNormal = normal != Vector3.zero ? normal : dir;
                    foundCover = true;
                }
            }
            // Hysteresis: only lose cover after multiple misses, never disables
            if (foundCover && bestScore > float.MinValue + 0.33f)
            {
                _isInCover = true;
                _coverLastFoundTime = now;
                _coverNormal = bestNormal.normalized;
                _coverMisses = 0;
                coverPoint = NavMeshSampleSafe(best, current);
                return true;
            }
            else
            {
                _coverMisses++;
                if (_coverMisses >= 2)
                {
                    _isInCover = false;
                    _coverNormal = Vector3.zero;
                }
                coverPoint = Vector3.zero;
                return false;
            }
        }

        #endregion

        #region Helpers

        /// <summary>
        /// Expire retreat cache when old or on new map/raid.
        /// </summary>
        private static void ClearExpiredCache()
        {
            if (Time.time - _lastClearTime > MemoryClearInterval)
            {
                _squadRetreatCache.Clear();
                _lastClearTime = Time.time;
            }
        }

        /// <summary>
        /// Checks if any squad retreat paths would overlap bot's current position (prevents jam/overlap).
        /// </summary>
        private static bool SquadOverlapCheck(BotOwner bot, List<Vector3> path)
        {
            if (bot == null || path == null || path.Count == 0)
                return false;

            // Only simple overlap check: last point not too close to current bot pos
            Vector3 last = path[path.Count - 1];
            return Vector3.Distance(bot.Position, last) < 2.2f;
        }

        /// <summary>
        /// Adds personality, panic, suppression, and micro-chaos to all overlays (never disables, pooled).
        /// </summary>
        private static void ApplyChaosOffset(List<Vector3> path, BotOwner bot, Vector3 threatDir)
        {
            if (path == null || path.Count == 0 || bot == null)
                return;

            var cache = bot.GetComponent<BotComponentCache>();
            if (cache == null) return;

            var profile = cache.PersonalityProfile ?? BotRegistry.GetOrGenerate(
                bot.ProfileId,
                PersonalityType.Balanced,
                bot.Profile?.Info?.Settings?.Role ?? WildSpawnType.assault);

            float chaosMul = 1f;
            if (cache.PanicHandler != null && cache.PanicHandler.IsPanicking)
                chaosMul += 0.8f;
            if (cache.Suppression != null && cache.Suppression.IsSuppressed())
                chaosMul += 0.45f;
            chaosMul += (1f - Mathf.Clamp01(profile.Caution)) * 0.22f;

            for (int i = 1; i < path.Count; i++)
            {
                float chaos = ChaosOffsetRadius * chaosMul * UnityEngine.Random.Range(0.77f, 1.18f);
                Vector3 offset = UnityEngine.Random.insideUnitSphere * chaos;
                offset.y = 0f;
                path[i] += offset;
            }
        }

        /// <summary>
        /// Full NavMesh Y-validation for any point; never returns unsafe vectors.
        /// </summary>
        private static Vector3 NavMeshSampleSafe(Vector3 candidate, Vector3 fallbackOrigin)
        {
            if (NavMesh.SamplePosition(candidate, out NavMeshHit navHit, NavSampleRadius, NavMesh.AllAreas))
            {
                Vector3 navSafe = navHit.position;
                if (Mathf.Abs(navSafe.y - fallbackOrigin.y) > 3.0f)
                    navSafe.y = fallbackOrigin.y;
                return navSafe;
            }
            // Fallback to last known valid if sample fails
            return fallbackOrigin;
        }

        #endregion
    }
}
