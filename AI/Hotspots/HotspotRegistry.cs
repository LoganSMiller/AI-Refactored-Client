// <auto-generated>
//   AI-Refactored: HotspotRegistry.cs (Ultra-Platinum++, Beyond Diamond Tactical Init, Squad/Zone/SquadSafe, June 2025)
//   Bulletproof: Zero-alloc, pooled, 100% null-safe, map/zone/scenario-aware, error-isolated, multiplayer/headless safe.
//   MIT License.
// </auto-generated>

namespace AIRefactored.AI.Hotspots
{
    using System;
    using System.Collections.Generic;
    using AIRefactored.Bootstrap;
    using AIRefactored.Pools;
    using AIRefactored.Runtime;
    using BepInEx.Logging;
    using UnityEngine;

    /// <summary>
    /// Global registry for tactical hotspots (loot/patrol/defense/squad) per-map/zone.
    /// Query-safe, zone-aware, pooled, bulletproof, squad/zone/scenario-safe, zero-alloc, error-isolated.
    /// Multiplayer/headless/client parity.
    /// </summary>
    public static class HotspotRegistry
    {
        #region Static Fields

        private static readonly ManualLogSource Logger = Plugin.LoggerInstance;
        private static readonly List<Hotspot> All = new List<Hotspot>(256);
        private static readonly Dictionary<string, List<Hotspot>> ByZone = new Dictionary<string, List<Hotspot>>(StringComparer.OrdinalIgnoreCase);
        private static string _loadedMap = "none";

        #endregion

        #region Initialization

        /// <summary>
        /// Clears all hotspot data (call on raid end or world unload). Returns all pooled lists.
        /// </summary>
        public static void Clear()
        {
            try
            {
                foreach (var kv in ByZone)
                {
                    try
                    {
                        kv.Value.Clear();
                        TempListPool.Return(kv.Value);
                    }
                    catch { /* Never propagate from pool returns. */ }
                }
                All.Clear();
                ByZone.Clear();
                _loadedMap = "none";
            }
            catch
            {
                // Bulletproof: never propagate
            }
        }

        /// <summary>
        /// Loads and registers all hotspots for the specified mapId. 
        /// Idempotent; bulletproof against race/logic errors. Zone-safe, squad-safe.
        /// </summary>
        public static void Initialize(string mapId)
        {
            try
            {
                if (!WorldInitState.IsInPhase(WorldPhase.WorldReady))
                {
                    Logger.LogWarning("[HotspotRegistry] ⚠ Init blocked: World not in WorldReady phase.");
                    return;
                }
                if (string.IsNullOrWhiteSpace(mapId))
                {
                    Logger.LogWarning("[HotspotRegistry] ⚠ Init failed: mapId null/empty.");
                    return;
                }
                string normalized = mapId.Trim().ToLowerInvariant();
                if (_loadedMap.Equals(normalized, StringComparison.OrdinalIgnoreCase))
                    return;

                Clear();
                _loadedMap = normalized;

                HotspotSet set = HardcodedHotspots.GetForMap(_loadedMap);
                if (set?.Points == null || set.Points.Count == 0)
                {
                    Logger.LogWarning($"[HotspotRegistry] ⚠ No hotspots found for map '{_loadedMap}'");
                    return;
                }

                for (int i = 0; i < set.Points.Count; i++)
                {
                    HotspotData data = set.Points[i];
                    if (data == null || string.IsNullOrWhiteSpace(data.Zone))
                        continue;

                    string zone = data.Zone.Trim();
                    Hotspot h = new Hotspot(data.Position, zone);
                    All.Add(h);

                    if (!ByZone.TryGetValue(zone, out List<Hotspot> list) || list == null)
                    {
                        list = TempListPool.Rent<Hotspot>();
                        ByZone[zone] = list;
                    }
                    list.Add(h);
                }

                Logger.LogDebug($"[HotspotRegistry] ✅ Registered {All.Count} hotspots for map '{_loadedMap}' (zone-aware)");
            }
            catch (Exception ex)
            {
                Logger.LogError($"[HotspotRegistry] ❌ Init error: {ex}");
                Clear();
            }
        }

        #endregion

        #region Query API

        /// <summary>
        /// Returns all hotspots for the current map (read-only, never null).
        /// </summary>
        public static IReadOnlyList<Hotspot> GetAll() => All;

        /// <summary>
        /// Returns all hotspots in a given zone, or empty array if zone not found (never null).
        /// </summary>
        public static IReadOnlyList<Hotspot> GetAllInZone(string zone)
        {
            if (string.IsNullOrWhiteSpace(zone))
                return Array.Empty<Hotspot>();
            return ByZone.TryGetValue(zone.Trim(), out var result) && result != null ? result : Array.Empty<Hotspot>();
        }

        /// <summary>
        /// Returns a random hotspot, or Hotspot.None if none loaded.
        /// </summary>
        public static Hotspot GetRandomHotspot()
        {
            int count = All.Count;
            return count == 0 ? Hotspot.None : All[UnityEngine.Random.Range(0, count)];
        }

        /// <summary>
        /// Returns all hotspots within radius of position, passing the filter. 
        /// The caller MUST Return() the pooled list after use.
        /// </summary>
        public static List<Hotspot> QueryNearby(Vector3 position, float radius, Predicate<Hotspot> filter)
        {
            List<Hotspot> result = TempListPool.Rent<Hotspot>();
            float sqr = radius * radius;

            for (int i = 0; i < All.Count; i++)
            {
                Hotspot h = All[i];
                if ((h.Position - position).sqrMagnitude <= sqr && (filter == null || filter(h)))
                    result.Add(h);
            }

            return result;
        }

        /// <summary>
        /// Returns a random hotspot from a zone, or Hotspot.None if not found.
        /// </summary>
        public static Hotspot GetRandomInZone(string zone)
        {
            var list = GetAllInZone(zone);
            int count = list.Count;
            return count == 0 ? Hotspot.None : list[UnityEngine.Random.Range(0, count)];
        }

        #endregion

        #region Types

        /// <summary>
        /// Represents a tactical hotspot on the map with a zone label.
        /// </summary>
        public sealed class Hotspot
        {
            public static readonly Hotspot None = new Hotspot(Vector3.zero, "none");

            public Hotspot(Vector3 position, string zone)
            {
                Position = position;
                Zone = string.IsNullOrWhiteSpace(zone) ? "none" : zone.Trim();
            }

            public Vector3 Position { get; }
            public string Zone { get; }
        }

        #endregion
    }
}
