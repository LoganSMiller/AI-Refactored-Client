// <auto-generated>
//   This file is part of AI-Refactored, an open-source project focused on realistic AI behavior in Escape from Tarkov.
//   Licensed under the MIT License. See LICENSE in the repository root for more information.
//
//   THIS FILE IS SYSTEMATICALLY MANAGED.
//   Please follow strict StyleCop, ReSharper, and AI-Refactored code standards for all modifications.
// </auto-generated>

#nullable enable

namespace AIRefactored.AI.Hotspots
{
    using System;
    using System.Collections.Generic;
    using AIRefactored.Runtime;
    using BepInEx.Logging;
    using UnityEngine;
    using Random = UnityEngine.Random;

    /// <summary>
    /// Global registry for map-specific hotspots (loot zones, patrol targets, tactical nodes).
    /// Dynamically builds spatial indexes (quadtree or grid) depending on map type.
    /// </summary>
    public static class HotspotRegistry
    {
        private static readonly List<Hotspot> All = new List<Hotspot>(256);
        private static readonly Dictionary<string, List<Hotspot>> ByZone = new Dictionary<string, List<Hotspot>>(StringComparer.OrdinalIgnoreCase);

        private static readonly Dictionary<string, SpatialIndexMode> IndexModeMap = new Dictionary<string, SpatialIndexMode>(StringComparer.OrdinalIgnoreCase)
        {
            ["woods"] = SpatialIndexMode.Quadtree,
            ["shoreline"] = SpatialIndexMode.Quadtree,
            ["lighthouse"] = SpatialIndexMode.Quadtree,
            ["interchange"] = SpatialIndexMode.Quadtree,
            ["bigmap"] = SpatialIndexMode.Quadtree,
            ["sandbox"] = SpatialIndexMode.Grid,
            ["sandbox_high"] = SpatialIndexMode.Grid,
            ["factory4_day"] = SpatialIndexMode.Grid,
            ["factory4_night"] = SpatialIndexMode.Grid,
            ["laboratory"] = SpatialIndexMode.Grid,
            ["tarkovstreets"] = SpatialIndexMode.Grid,
            ["rezervbase"] = SpatialIndexMode.Grid,
        };

        private static readonly ManualLogSource Log = AIRefactoredController.Logger;

        private static SpatialIndexMode ActiveMode = SpatialIndexMode.None;
        private static string LoadedMap = "none";
        private static HotspotQuadtree? Quadtree;
        private static HotspotSpatialGrid? Grid;

        private enum SpatialIndexMode
        {
            None,
            Quadtree,
            Grid
        }

        /// <summary>
        /// Clears all internal registry state.
        /// </summary>
        public static void Clear()
        {
            All.Clear();
            ByZone.Clear();
            Quadtree = null;
            Grid = null;
            LoadedMap = "none";
            ActiveMode = SpatialIndexMode.None;
        }

        /// <summary>
        /// Gets a read-only view of all registered hotspots.
        /// </summary>
        public static IReadOnlyList<Hotspot> GetAll()
        {
            return All;
        }

        /// <summary>
        /// Gets all hotspots registered in the given zone.
        /// </summary>
        /// <param name="zone">Zone name (case-insensitive).</param>
        /// <returns>List of hotspots, or empty list if none exist.</returns>
        public static IReadOnlyList<Hotspot> GetAllInZone(string zone)
        {
            return ByZone.TryGetValue(zone, out var list) ? list : Array.Empty<Hotspot>();
        }

        /// <summary>
        /// Returns a random hotspot across the map, or (0,0,0) if none are registered.
        /// </summary>
        public static Hotspot GetRandomHotspot()
        {
            return All.Count == 0 ? new Hotspot(Vector3.zero, "none") : All[Random.Range(0, All.Count)];
        }

        /// <summary>
        /// Initializes the hotspot registry for the given map ID.
        /// </summary>
        /// <param name="mapId">Map identifier (e.g., "factory4_day").</param>
        public static void Initialize(string mapId)
        {
            if (string.IsNullOrEmpty(mapId) || LoadedMap.Equals(mapId, StringComparison.OrdinalIgnoreCase))
            {
                return;
            }

            Clear();

            LoadedMap = mapId.ToLowerInvariant();
            ActiveMode = IndexModeMap.TryGetValue(LoadedMap, out var mode) ? mode : SpatialIndexMode.None;

            HotspotSet? set = HardcodedHotspots.GetForMap(LoadedMap);
            if (set == null || set.Points.Count == 0)
            {
                Log.LogWarning($"[HotspotRegistry] ⚠ No hotspots found for map '{LoadedMap}'");
                return;
            }

            for (int i = 0; i < set.Points.Count; i++)
            {
                HotspotData entry = set.Points[i];
                Hotspot hotspot = new Hotspot(entry.Position, entry.Zone);
                All.Add(hotspot);

                if (!ByZone.TryGetValue(entry.Zone, out var zoneList))
                {
                    zoneList = new List<Hotspot>(8);
                    ByZone[entry.Zone] = zoneList;
                }

                zoneList.Add(hotspot);
            }

            switch (ActiveMode)
            {
                case SpatialIndexMode.Quadtree:
                    BuildQuadtree();
                    break;
                case SpatialIndexMode.Grid:
                    BuildGrid();
                    break;
            }

            Log.LogInfo($"[HotspotRegistry] ✅ Registered {All.Count} hotspots for map '{LoadedMap}' using {ActiveMode}");
        }

        /// <summary>
        /// Returns all hotspots within the specified radius of a point.
        /// </summary>
        public static List<Hotspot> QueryNearby(Vector3 position, float radius, Predicate<Hotspot>? filter = null)
        {
            switch (ActiveMode)
            {
                case SpatialIndexMode.Quadtree:
                    if (Quadtree != null)
                    {
                        return Quadtree.Query(position, radius, filter);
                    }

                    break;

                case SpatialIndexMode.Grid:
                    if (Grid != null)
                    {
                        return Grid.Query(position, radius, filter);
                    }

                    break;
            }

            return FallbackQuery(position, radius, filter);
        }

        private static void BuildGrid()
        {
            Grid = new HotspotSpatialGrid(10f);
            for (int i = 0; i < All.Count; i++)
            {
                Grid.Insert(All[i]);
            }
        }

        private static void BuildQuadtree()
        {
            Vector2 center = EstimateCenter();
            float size = EstimateBoundsSize(center);
            Quadtree = new HotspotQuadtree(center, size);

            for (int i = 0; i < All.Count; i++)
            {
                Quadtree.Insert(All[i]);
            }
        }

        private static float EstimateBoundsSize(Vector2 center)
        {
            float maxDist = 0f;
            for (int i = 0; i < All.Count; i++)
            {
                Vector3 p = All[i].Position;
                float dist = Vector2.Distance(new Vector2(p.x, p.z), center);
                if (dist > maxDist)
                {
                    maxDist = dist;
                }
            }

            return Mathf.NextPowerOfTwo(Mathf.CeilToInt(maxDist * 2f));
        }

        private static Vector2 EstimateCenter()
        {
            float minX = float.MaxValue;
            float maxX = float.MinValue;
            float minZ = float.MaxValue;
            float maxZ = float.MinValue;

            for (int i = 0; i < All.Count; i++)
            {
                Vector3 p = All[i].Position;
                if (p.x < minX) minX = p.x;
                if (p.x > maxX) maxX = p.x;
                if (p.z < minZ) minZ = p.z;
                if (p.z > maxZ) maxZ = p.z;
            }

            return new Vector2((minX + maxX) * 0.5f, (minZ + maxZ) * 0.5f);
        }

        private static List<Hotspot> FallbackQuery(Vector3 pos, float radius, Predicate<Hotspot>? filter)
        {
            List<Hotspot> results = new List<Hotspot>(16);
            float radiusSq = radius * radius;

            for (int i = 0; i < All.Count; i++)
            {
                Hotspot h = All[i];
                if ((h.Position - pos).sqrMagnitude <= radiusSq && (filter == null || filter(h)))
                {
                    results.Add(h);
                }
            }

            return results;
        }

        /// <summary>
        /// Represents a single registered hotspot with position and zone.
        /// </summary>
        public class Hotspot
        {
            public Hotspot(Vector3 pos, string zone)
            {
                this.Position = pos;
                this.Zone = zone;
            }

            public Vector3 Position { get; }

            public string Zone { get; }
        }
    }
}
