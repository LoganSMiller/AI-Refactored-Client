// <auto-generated>
//   This file is part of AI-Refactored, an open-source project focused on realistic AI behavior in Escape from Tarkov.
//   Licensed under the MIT License. See LICENSE in the repository root for more information.
//
//   THIS FILE IS SYSTEMATICALLY MANAGED.
//   Please follow strict StyleCop, ReSharper, and AI-Refactored code standards for all modifications.
// </auto-generated>

#nullable enable

namespace AIRefactored.AI.Hotspots
{
    using System;
    using System.Collections.Generic;
    using AIRefactored.Runtime;
    using BepInEx.Logging;
    using UnityEngine;

    /// <summary>
    /// Global registry for map-specific hotspots (loot zones, patrol targets, tactical nodes).
    /// Dynamically builds spatial indexes (quadtree or grid) depending on map type.
    /// </summary>
    public static class HotspotRegistry
    {
        private static readonly List<Hotspot> _all = new List<Hotspot>(256);
        private static readonly Dictionary<string, List<Hotspot>> _byZone = new Dictionary<string, List<Hotspot>>(StringComparer.OrdinalIgnoreCase);

        private static readonly Dictionary<string, SpatialIndexMode> _indexModeMap = new Dictionary<string, SpatialIndexMode>(StringComparer.OrdinalIgnoreCase)
        {
            { "woods", SpatialIndexMode.Quadtree },
            { "shoreline", SpatialIndexMode.Quadtree },
            { "lighthouse", SpatialIndexMode.Quadtree },
            { "interchange", SpatialIndexMode.Quadtree },
            { "bigmap", SpatialIndexMode.Quadtree },
            { "sandbox", SpatialIndexMode.Grid },
            { "sandbox_high", SpatialIndexMode.Grid },
            { "factory4_day", SpatialIndexMode.Grid },
            { "factory4_night", SpatialIndexMode.Grid },
            { "laboratory", SpatialIndexMode.Grid },
            { "tarkovstreets", SpatialIndexMode.Grid },
            { "rezervbase", SpatialIndexMode.Grid }
        };

        private static readonly ManualLogSource _logger = AIRefactoredController.Logger;

        private static SpatialIndexMode _activeMode = SpatialIndexMode.None;
        private static string _loadedMap = "none";
        private static HotspotQuadtree? _quadtree;
        private static HotspotSpatialGrid? _grid;

        private enum SpatialIndexMode
        {
            None,
            Quadtree,
            Grid
        }

        public static void Clear()
        {
            _all.Clear();
            _byZone.Clear();
            _quadtree = null;
            _grid = null;
            _loadedMap = "none";
            _activeMode = SpatialIndexMode.None;
        }

        public static IReadOnlyList<Hotspot> GetAll()
        {
            return _all;
        }

        public static IReadOnlyList<Hotspot> GetAllInZone(string zone)
        {
            return _byZone.TryGetValue(zone, out var result) ? result : Array.Empty<Hotspot>();
        }

        public static Hotspot GetRandomHotspot()
        {
            return _all.Count == 0
                ? new Hotspot(Vector3.zero, "none")
                : _all[UnityEngine.Random.Range(0, _all.Count)];
        }

        public static void Initialize(string mapId)
        {
            if (string.IsNullOrEmpty(mapId) || _loadedMap.Equals(mapId, StringComparison.OrdinalIgnoreCase))
            {
                return;
            }

            Clear();

            _loadedMap = mapId.ToLowerInvariant();
            _activeMode = _indexModeMap.TryGetValue(_loadedMap, out SpatialIndexMode mode) ? mode : SpatialIndexMode.None;

            HotspotSet? set = HardcodedHotspots.GetForMap(_loadedMap);
            if (set == null || set.Points == null || set.Points.Count == 0)
            {
                _logger.LogWarning("[HotspotRegistry] ⚠ No hotspots found for map '" + _loadedMap + "'");
                return;
            }

            foreach (var entry in set.Points)
            {
                Hotspot h = new Hotspot(entry.Position, entry.Zone);
                _all.Add(h);

                if (!_byZone.TryGetValue(entry.Zone, out var list))
                {
                    list = new List<Hotspot>(8);
                    _byZone[entry.Zone] = list;
                }

                list.Add(h);
            }

            if (_activeMode == SpatialIndexMode.Quadtree)
            {
                BuildQuadtree();
            }
            else if (_activeMode == SpatialIndexMode.Grid)
            {
                BuildGrid();
            }

            _logger.LogInfo($"[HotspotRegistry] ✅ Registered {_all.Count} hotspots for map '{_loadedMap}' using {_activeMode}");
        }

        public static List<Hotspot> QueryNearby(Vector3 position, float radius, Predicate<Hotspot>? filter = null)
        {
            if (_activeMode == SpatialIndexMode.Quadtree && _quadtree != null)
            {
                return _quadtree.Query(position, radius, filter);
            }

            if (_activeMode == SpatialIndexMode.Grid && _grid != null)
            {
                return _grid.Query(position, radius, filter);
            }

            return FallbackQuery(position, radius, filter);
        }

        private static void BuildGrid()
        {
            _grid = new HotspotSpatialGrid(10.0f);
            foreach (var hotspot in _all)
            {
                _grid.Insert(hotspot);
            }
        }

        private static void BuildQuadtree()
        {
            Vector2 center = EstimateCenter();
            float size = EstimateBoundsSize(center);
            _quadtree = new HotspotQuadtree(center, size);

            foreach (var hotspot in _all)
            {
                _quadtree.Insert(hotspot);
            }
        }

        private static float EstimateBoundsSize(Vector2 center)
        {
            float max = 0.0f;

            foreach (var hotspot in _all)
            {
                Vector3 p = hotspot.Position;
                float dist = Vector2.Distance(new Vector2(p.x, p.z), center);
                if (dist > max)
                {
                    max = dist;
                }
            }

            return Mathf.NextPowerOfTwo(Mathf.CeilToInt(max * 2.0f));
        }

        private static Vector2 EstimateCenter()
        {
            float minX = float.MaxValue;
            float maxX = float.MinValue;
            float minZ = float.MaxValue;
            float maxZ = float.MinValue;

            foreach (var hotspot in _all)
            {
                Vector3 p = hotspot.Position;
                minX = Mathf.Min(minX, p.x);
                maxX = Mathf.Max(maxX, p.x);
                minZ = Mathf.Min(minZ, p.z);
                maxZ = Mathf.Max(maxZ, p.z);
            }

            return new Vector2((minX + maxX) * 0.5f, (minZ + maxZ) * 0.5f);
        }

        private static List<Hotspot> FallbackQuery(Vector3 position, float radius, Predicate<Hotspot>? filter)
        {
            List<Hotspot> result = new List<Hotspot>(16);
            float radiusSqr = radius * radius;

            foreach (var hotspot in _all)
            {
                if ((hotspot.Position - position).sqrMagnitude <= radiusSqr && (filter == null || filter(hotspot)))
                {
                    result.Add(hotspot);
                }
            }

            return result;
        }

        /// <summary>
        /// Represents a single registered hotspot with position and zone.
        /// </summary>
        public class Hotspot
        {
            public Hotspot(Vector3 pos, string zone)
            {
                this.Position = pos;
                this.Zone = zone;
            }

            public Vector3 Position { get; private set; }

            public string Zone { get; private set; }
        }
    }
}
