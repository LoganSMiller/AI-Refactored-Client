// <auto-generated>
//   AI-Refactored: HotspotSystem.cs (Beyond Diamond Tactical Nav Edition – Squad-Aware Hotspot Patrol, June 2025)
//   Full support for tactical personality-aware movement between hotspots with fallback, error shielding, and BotBrain integration.
//   All movement is NavMesh validated, cooldown-checked, deduped, and never tick-spammed. MIT License.
// </auto-generated>

namespace AIRefactored.AI.Hotspots
{
    using System;
    using System.Collections.Generic;
    using AIRefactored.AI.Core;
    using AIRefactored.AI.Helpers;
    using AIRefactored.Core;
    using AIRefactored.Runtime;
    using BepInEx.Logging;
    using Comfort.Common;
    using EFT;
    using EFT.HealthSystem;
    using UnityEngine;
    using UnityEngine.AI;

    /// <summary>
    /// Handles squad-aware hotspot patrol and defense for AI-Refactored bots.
    /// Full tactical and personality awareness, error isolation, and BotBrain-safe overlays.
    /// </summary>
    public sealed class HotspotSystem
    {
        private static readonly ManualLogSource Logger = Plugin.LoggerInstance;
        private static readonly List<BotOwner> BotList = new List<BotOwner>(64);

        private readonly Dictionary<BotOwner, HotspotSession> _sessions = new Dictionary<BotOwner, HotspotSession>(64);

        public void Initialize()
        {
            _sessions.Clear();
            string map = GameWorldHandler.TryGetValidMapName();
            HotspotRegistry.Initialize(map ?? string.Empty);
        }

        public void Tick()
        {
            try
            {
                BotsController ctrl = Singleton<BotsController>.Instance;
                if (ctrl?.Bots?.BotOwners == null)
                    return;

                BotList.Clear();
                BotList.AddRange(ctrl.Bots.BotOwners);

                foreach (var bot in BotList)
                {
                    if (!EFTPlayerUtil.IsValidBotOwner(bot) || bot.GetPlayer.IsYourPlayer)
                        continue;

                    try
                    {
                        if (!_sessions.TryGetValue(bot, out var session))
                        {
                            session = TryAssignRoute(bot);
                            if (session != null)
                                _sessions[bot] = session;
                        }

                        session?.Tick();
                    }
                    catch { }
                }
            }
            catch { }
        }

        private HotspotSession TryAssignRoute(BotOwner bot)
        {
            try
            {
                var profile = BotRegistry.Get(bot.ProfileId);
                if (profile == null)
                    return null;

                var all = HotspotRegistry.GetAll();
                if (all == null || all.Count == 0)
                    return null;

                List<HotspotRegistry.Hotspot> pool = HotspotRegistry.QueryNearby(bot.Position, 150f, null) ?? new List<HotspotRegistry.Hotspot>(all);

                if (pool.Count == 0)
                    pool = new List<HotspotRegistry.Hotspot>(all);

                bool defend = profile.Personality == PersonalityType.Camper ||
                              (profile.Personality == PersonalityType.Cautious && UnityEngine.Random.value < 0.5f);

                if (defend)
                {
                    var point = pool[UnityEngine.Random.Range(0, pool.Count)];
                    return new HotspotSession(bot, new List<HotspotRegistry.Hotspot> { point }, true);
                }

                int count = UnityEngine.Random.Range(2, 4);
                List<HotspotRegistry.Hotspot> route = new List<HotspotRegistry.Hotspot>(count);
                HashSet<int> used = new HashSet<int>();

                while (route.Count < count && used.Count < pool.Count)
                {
                    int index = UnityEngine.Random.Range(0, pool.Count);
                    if (used.Add(index))
                        route.Add(pool[index]);
                }

                return new HotspotSession(bot, route, false);
            }
            catch (Exception ex)
            {
                Logger.LogWarning($"[HotspotSystem] Route assignment error: {ex.Message}");
                return null;
            }
        }

        #region HotspotSession

        private sealed class HotspotSession
        {
            private const float BaseDefendRadius = 7f;
            private const float DamageCooldown = 6f;
            private const float NavSampleRadius = 1.2f;
            private const float MoveCooldown = 1.15f;

            private readonly BotOwner _bot;
            private readonly BotComponentCache _cache;
            private readonly List<HotspotRegistry.Hotspot> _route;
            private readonly bool _isDefender;

            private int _index;
            private float _lastHitTime;
            private float _nextSwitchTime;
            private float _lastMoveTime;
            private Vector3 _lastMoveTarget;

            public HotspotSession(BotOwner bot, List<HotspotRegistry.Hotspot> route, bool isDefender)
            {
                _bot = bot;
                _route = route;
                _isDefender = isDefender;
                _cache = BotCacheUtility.GetCache(bot);
                _index = 0;
                _lastHitTime = -999f;
                _nextSwitchTime = Time.time + GetSwitchTime();
                _lastMoveTime = -1000f;
                _lastMoveTarget = Vector3.zero;

                try
                {
                    if (_bot.GetPlayer?.HealthController is HealthControllerClass hc)
                        hc.ApplyDamageEvent += OnDamage;
                }
                catch { }
            }

            public void Tick()
            {
                if (!EFTPlayerUtil.IsValidBotOwner(_bot) || _route.Count == 0 || _bot.GetPlayer.IsYourPlayer)
                    return;

                // Skip movement if in combat or recently damaged
                if (_bot.Memory?.GoalEnemy != null || Time.time - _lastHitTime < DamageCooldown)
                    return;

                Vector3 dest = _route[_index].Position;
                if (!IsValid(dest)) return;

                if (!NavMesh.SamplePosition(dest, out var navHit, NavSampleRadius, NavMesh.AllAreas)) return;

                Vector3 safeTarget = navHit.position;
                if (!IsValid(safeTarget)) return;

                float now = Time.time;
                float dist = Vector3.Distance(_bot.Position, safeTarget);

                // Intent/overlay-based, deduped, cooldown
                if (_isDefender)
                {
                    float radius = BaseDefendRadius * Mathf.Clamp(1f + (1f - (_cache?.PanicHandler?.GetComposureLevel() ?? 1f)), 1f, 2.1f);
                    if (dist > radius && (now - _lastMoveTime > MoveCooldown || (_lastMoveTarget - safeTarget).sqrMagnitude > 0.25f))
                    {
                        Vector3 drifted = BotMovementHelper.ApplyMicroDrift(
                            safeTarget,
                            _bot.ProfileId,
                            Time.frameCount,
                            _cache?.PersonalityProfile
                        );
                        if (BotMovementHelper.ShouldMove(_bot, drifted))
                        {
                            BotMovementHelper.SmoothMoveToSafe(_bot, drifted, slow: true, cohesion: 1f);
                            _lastMoveTarget = drifted;
                            _lastMoveTime = now;
                        }
                    }
                }
                else
                {
                    if (now >= _nextSwitchTime || dist < 2f)
                    {
                        _index = (_index + 1) % _route.Count;
                        _nextSwitchTime = now + GetSwitchTime();
                    }

                    if (now - _lastMoveTime > MoveCooldown || (_lastMoveTarget - safeTarget).sqrMagnitude > 0.25f)
                    {
                        Vector3 jittered = AddJitter(safeTarget);
                        Vector3 drifted = BotMovementHelper.ApplyMicroDrift(
                            jittered,
                            _bot.ProfileId,
                            Time.frameCount,
                            _cache?.PersonalityProfile
                        );
                        if (BotMovementHelper.ShouldMove(_bot, drifted))
                        {
                            BotMovementHelper.SmoothMoveToSafe(_bot, drifted, slow: true, cohesion: 1f);
                            _lastMoveTarget = drifted;
                            _lastMoveTime = now;
                        }
                    }
                }
            }

            private static bool IsValid(Vector3 v)
            {
                return !float.IsNaN(v.x) && !float.IsNaN(v.y) && !float.IsNaN(v.z)
                    && v != Vector3.zero && Mathf.Abs(v.y) < 1000f;
            }

            private static Vector3 AddJitter(Vector3 basePos)
            {
                Vector3 jitter = UnityEngine.Random.insideUnitSphere * 0.65f;
                jitter.y = 0f;
                return basePos + jitter;
            }

            private float GetSwitchTime()
            {
                try
                {
                    var profile = BotRegistry.Get(_bot.ProfileId);
                    if (profile == null)
                        return 100f;

                    float chaos = Mathf.Clamp01(1f + profile.ChaosFactor * 0.6f);

                    switch (profile.Personality)
                    {
                        case PersonalityType.Camper:
                        case PersonalityType.Stoic:
                        case PersonalityType.Sentinel:
                            return 200f * chaos;
                        case PersonalityType.Methodical:
                        case PersonalityType.Supportive:
                            return 160f * chaos;
                        case PersonalityType.Balanced:
                        case PersonalityType.Vigilante:
                            return 100f * chaos;
                        case PersonalityType.Aggressive:
                        case PersonalityType.Hunter:
                            return 60f * chaos;
                        case PersonalityType.Frenzied:
                        case PersonalityType.Reckless:
                            return UnityEngine.Random.Range(45f, 90f) * chaos;
                        case PersonalityType.Dumb:
                        case PersonalityType.Fearful:
                            return 45f * chaos;
                        default:
                            return 100f * chaos;
                    }
                }
                catch
                {
                    return 100f;
                }
            }

            private void OnDamage(EBodyPart part, float dmg, DamageInfoStruct info)
            {
                try
                {
                    _lastHitTime = Time.time;
                    _cache?.PanicHandler?.TriggerPanic();
                }
                catch { }
            }
        }

        #endregion
    }
}
