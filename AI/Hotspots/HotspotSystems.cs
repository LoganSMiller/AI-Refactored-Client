// <auto-generated>
//   This file is part of AI-Refactored, an open-source project focused on realistic AI behavior in Escape from Tarkov.
//   Licensed under the MIT License. See LICENSE in the repository root for more information.
//
//   THIS FILE IS SYSTEMATICALLY MANAGED.
//   Please follow strict StyleCop, ReSharper, and AI-Refactored code standards for all modifications.
// </auto-generated>

#nullable enable

namespace AIRefactored.AI.Hotspots
{
    using System;
    using System.Collections.Generic;
    using AIRefactored.AI.Core;
    using AIRefactored.AI.Helpers;
    using AIRefactored.Core;
    using AIRefactored.Runtime;
    using BepInEx.Logging;
    using Comfort.Common;
    using EFT;
    using UnityEngine;

    /// <summary>
    /// Drives bot navigation between tactical hotspots on a map.
    /// Each bot maintains its own route or defense zone and adapts behavior based on combat state.
    /// </summary>
    public sealed class HotspotSystem
    {
        private static readonly List<BotOwner> BotList = new List<BotOwner>(64);
        private static readonly ManualLogSource Logger = AIRefactoredController.Logger;

        private readonly Dictionary<BotOwner, HotspotSession> _sessions = new Dictionary<BotOwner, HotspotSession>(64);

        public static Vector3 GetRandomHotspotPosition(BotOwner bot)
        {
            return HotspotRegistry.GetRandomHotspot().Position;
        }

        public void Initialize()
        {
            this._sessions.Clear();
            HotspotRegistry.Initialize(GameWorldHandler.GetCurrentMapName());
        }

        public void Tick()
        {
            BotsController? controller = Singleton<BotsController>.Instance;
            if (controller?.Bots?.BotOwners == null)
            {
                return;
            }

            BotList.Clear();
            BotList.AddRange(controller.Bots.BotOwners);

            for (int i = 0; i < BotList.Count; i++)
            {
                BotOwner bot = BotList[i];
                if (bot == null || bot.IsDead || bot.GetPlayer?.IsYourPlayer == true)
                {
                    continue;
                }

                if (!this._sessions.TryGetValue(bot, out HotspotSession? session) || session == null)
                {
                    session = this.AssignHotspotRoute(bot);
                    if (session != null)
                    {
                        this._sessions[bot] = session;
                    }
                }

                session?.Tick();
            }
        }

        private HotspotSession? AssignHotspotRoute(BotOwner bot)
        {
            BotPersonalityProfile profile = BotRegistry.Get(bot.ProfileId);
            string map = GameWorldHandler.GetCurrentMapName();
            IReadOnlyList<HotspotRegistry.Hotspot> all = HotspotRegistry.GetAll();

            if (all.Count == 0)
            {
                Logger.LogWarning("[HotspotSystem] ❌ No hotspots found for " + map);
                return null;
            }

            List<HotspotRegistry.Hotspot> nearby = HotspotRegistry.QueryNearby(bot.Position, 150f);
            if (nearby.Count == 0)
            {
                nearby = new List<HotspotRegistry.Hotspot>(all);
            }

            bool defendOnly = profile.Personality == PersonalityType.Camper ||
                              (profile.Personality == PersonalityType.Cautious && UnityEngine.Random.value < 0.5f);

            if (defendOnly)
            {
                HotspotRegistry.Hotspot defend = nearby[UnityEngine.Random.Range(0, nearby.Count)];
                return new HotspotSession(bot, new List<HotspotRegistry.Hotspot> { defend }, true);
            }

            int routeLen = UnityEngine.Random.Range(2, 4);
            List<HotspotRegistry.Hotspot> route = new List<HotspotRegistry.Hotspot>(routeLen);
            HashSet<int> used = new HashSet<int>();

            while (route.Count < routeLen && used.Count < nearby.Count)
            {
                int index = UnityEngine.Random.Range(0, nearby.Count);
                if (used.Add(index))
                {
                    route.Add(nearby[index]);
                }
            }

            return new HotspotSession(bot, route, false);
        }

        private sealed class HotspotSession
        {
            private const float BaseDefendRadius = 7f;
            private const float DamageCooldown = 6f;

            private readonly BotOwner _bot;
            private readonly BotComponentCache? _cache;
            private readonly bool _isDefender;
            private readonly List<HotspotRegistry.Hotspot> _route;

            private int _index;
            private float _lastHitTime;
            private float _nextSwitchTime;

            public HotspotSession(BotOwner bot, List<HotspotRegistry.Hotspot> route, bool isDefender)
            {
                this._bot = bot ?? throw new ArgumentNullException(nameof(bot));
                this._route = route ?? throw new ArgumentNullException(nameof(route));
                this._isDefender = isDefender;
                this._cache = BotCacheUtility.GetCache(bot);
                this._lastHitTime = -999f;
                this._index = 0;
                this._nextSwitchTime = Time.time + this.GetSwitchInterval();

                HealthControllerClass? health = bot.GetPlayer?.HealthController as HealthControllerClass;
                if (health != null)
                {
                    health.ApplyDamageEvent += this.OnDamaged;
                }
            }

            public void Tick()
            {
                if (this._bot.IsDead || this._route.Count == 0 || this._bot.GetPlayer?.IsYourPlayer == true)
                {
                    return;
                }

                if (this._bot.Memory?.GoalEnemy != null)
                {
                    this._bot.Sprint(true);
                    return;
                }

                if (Time.time - this._lastHitTime < DamageCooldown)
                {
                    return;
                }

                Vector3 target = this._route[this._index].Position;

                if (this._isDefender)
                {
                    float dist = Vector3.Distance(this._bot.Position, target);
                    float composure = this._cache?.PanicHandler?.GetComposureLevel() ?? 1f;
                    float defendRadius = BaseDefendRadius * Mathf.Clamp(1f + (1f - composure), 1f, 2f);

                    if (dist > defendRadius)
                    {
                        BotMovementHelper.SmoothMoveTo(this._bot, target);
                    }
                }
                else
                {
                    float distToTarget = Vector3.Distance(this._bot.Position, target);
                    if (Time.time >= this._nextSwitchTime || distToTarget < 2f)
                    {
                        this._index = (this._index + 1) % this._route.Count;
                        this._nextSwitchTime = Time.time + this.GetSwitchInterval();
                    }

                    BotMovementHelper.SmoothMoveTo(this._bot, this.AddJitterTo(target));
                }
            }

            private Vector3 AddJitterTo(Vector3 target)
            {
                BotPersonalityProfile? profile = this._cache?.AIRefactoredBotOwner?.PersonalityProfile;
                if (profile == null)
                {
                    return target;
                }

                Vector3 jitter = Vector3.zero;
                float chaos = profile.ChaosFactor;

                if (profile.IsFrenzied)
                {
                    jitter = UnityEngine.Random.insideUnitSphere * 2.5f;
                }
                else if (profile.IsSilentHunter)
                {
                    jitter = UnityEngine.Random.insideUnitSphere * 0.25f;
                }
                else if (chaos > 0.4f)
                {
                    jitter = new Vector3(Mathf.Sin(Time.time), 0f, Mathf.Cos(Time.time)) * chaos;
                }

                jitter.y = 0f;
                return target + jitter;
            }

            private float GetSwitchInterval()
            {
                BotPersonalityProfile profile = BotRegistry.Get(this._bot.ProfileId);
                float baseTime = 120f;

                switch (profile.Personality)
                {
                    case PersonalityType.Cautious:
                        baseTime = 160f;
                        break;
                    case PersonalityType.TeamPlayer:
                        baseTime = 100f;
                        break;
                    case PersonalityType.Strategic:
                        baseTime = 90f;
                        break;
                    case PersonalityType.Explorer:
                        baseTime = 75f;
                        break;
                    case PersonalityType.Dumb:
                        baseTime = 45f;
                        break;
                }

                return baseTime * Mathf.Clamp01(1f + profile.ChaosFactor * 0.6f);
            }

            private void OnDamaged(EBodyPart part, float damage, DamageInfoStruct info)
            {
                this._lastHitTime = Time.time;
                this._cache?.PanicHandler?.TriggerPanic();
            }
        }
    }
}
