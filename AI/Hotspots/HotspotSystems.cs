// <auto-generated>
//   AI-Refactored: HotspotSystem.cs (Supreme Arbitration++ Max Realism, Squad/SquadPath/Overlay Edition – June 2025)
//   All logic is pooled, squad-indexed, overlay/intent locked, 100% NavMesh/formation validated, anti-teleport, squad/personality/role safe, headless/client parity.
//   MIT License.
// </auto-generated>

namespace AIRefactored.AI.Hotspots
{
    using System;
    using System.Collections.Generic;
    using AIRefactored.AI.Core;
    using AIRefactored.AI.Helpers;
    using AIRefactored.AI.Groups;
    using AIRefactored.Core;
    using AIRefactored.Pools;
    using AIRefactored.Runtime;
    using BepInEx.Logging;
    using Comfort.Common;
    using EFT;
    using EFT.HealthSystem;
    using UnityEngine;
    using UnityEngine.AI;

    /// <summary>
    /// Handles squad/sync/overlay/personality-aware hotspot patrol/defense overlays.
    /// Supreme arbitration: pooled, deduped, squad-indexed, formation/squad-path safe, error-isolated.
    /// No tick-spam. No teleport. Personality/role/scenario ready. Full multiplayer/headless/client parity.
    /// </summary>
    public sealed class HotspotSystem
    {
        private static readonly ManualLogSource Logger = Plugin.LoggerInstance;
        private static readonly List<BotOwner> BotList = new List<BotOwner>(64);

        private readonly Dictionary<BotOwner, HotspotSession> _sessions = new Dictionary<BotOwner, HotspotSession>(64);

        /// <summary>
        /// Resets sessions and reinitializes the registry. Call on world/raid init.
        /// </summary>
        public void Initialize()
        {
            _sessions.Clear();
            string map = GameWorldHandler.TryGetValidMapName();
            HotspotRegistry.Initialize(map ?? string.Empty);
        }

        /// <summary>
        /// Called once per tick via BotBrain overlay/event dispatcher.
        /// </summary>
        public void Tick()
        {
            try
            {
                BotsController ctrl = Singleton<BotsController>.Instance;
                if (ctrl?.Bots?.BotOwners == null)
                    return;

                BotList.Clear();
                BotList.AddRange(ctrl.Bots.BotOwners);

                for (int i = 0; i < BotList.Count; i++)
                {
                    BotOwner bot = BotList[i];
                    if (!EFTPlayerUtil.IsValidBotOwner(bot) || bot.GetPlayer.IsYourPlayer)
                        continue;

                    try
                    {
                        if (!_sessions.TryGetValue(bot, out var session) || session.Stale)
                        {
                            session?.Dispose();
                            _sessions[bot] = TryAssignRoute(bot);
                        }
                        _sessions[bot]?.Tick();
                    }
                    catch { }
                }
            }
            catch { }
        }

        /// <summary>
        /// Assigns a fully group/squad/role/personality-aware patrol/defend route.
        /// </summary>
        private HotspotSession TryAssignRoute(BotOwner bot)
        {
            try
            {
                var profile = BotRegistry.Get(bot.ProfileId);
                if (profile == null) return null;

                var all = HotspotRegistry.GetAll();
                if (all == null || all.Count == 0) return null;

                // Use team tracker for true squad membership, prevents double-patrolling.
                string groupId = bot.GetPlayer?.Profile?.Info?.GroupId;
                List<BotOwner> squad = !string.IsNullOrEmpty(groupId) ? BotTeamTracker.GetGroup(groupId) : null;
                var squadPath = new SquadPathCoordinator();
                squadPath.Initialize(BotCacheUtility.GetCache(bot));

                var reserved = TempHashSetPool.Rent<HotspotData>();
                if (squad != null)
                {
                    for (int i = 0; i < squad.Count; i++)
                    {
                        if (squad[i] == null || squad[i] == bot) continue;
                        if (_sessions.TryGetValue(squad[i], out var sess) && sess?.CurrentSpot != null)
                            reserved.Add(sess.CurrentSpot);
                    }
                }

                // Build candidate pool: remove reserved, personality/role filter, NavMesh validate.
                var pool = TempListPool.Rent<HotspotData>(all.Count);
                for (int i = 0; i < all.Count; i++)
                {
                    var spot = all[i];
                    if (spot == null) continue;
                    if (reserved.Contains(spot)) continue;
                    if (!PersonalityHotspotFilter(spot, profile)) continue;
                    if (!NavMesh.SamplePosition(spot.Position, out var hit, 1.45f, NavMesh.AllAreas)) continue;
                    pool.Add(spot);
                }
                if (pool.Count == 0)
                {
                    // fallback to any unreserved NavMesh-valid spot
                    for (int i = 0; i < all.Count; i++)
                    {
                        var spot = all[i];
                        if (spot == null || reserved.Contains(spot)) continue;
                        if (NavMesh.SamplePosition(spot.Position, out var hit, 1.45f, NavMesh.AllAreas))
                            pool.Add(spot);
                    }
                }
                TempHashSetPool.Return(reserved);

                if (pool.Count == 0)
                {
                    TempListPool.Return(pool);
                    return null;
                }

                // True squad-indexed assignment: bots spread through the pool via group order.
                int squadIdx = 0, squadCount = 1;
                if (squad != null && squad.Count > 1)
                {
                    squadIdx = squad.IndexOf(bot);
                    if (squadIdx < 0) squadIdx = 0;
                    squadCount = squad.Count;
                }

                bool defend = profile.Personality == PersonalityType.Camper ||
                              profile.Personality == PersonalityType.Stoic ||
                              (profile.Personality == PersonalityType.Cautious && UnityEngine.Random.value < 0.5f);

                HotspotSession session;
                if (defend)
                {
                    int spotIdx = squadIdx % pool.Count;
                    var singleton = TempListPool.Rent<HotspotData>(1);
                    singleton.Add(pool[spotIdx]);
                    session = new HotspotSession(bot, singleton, true, squadPath, squadIdx, squadCount);
                }
                else
                {
                    int routeLen = UnityEngine.Random.Range(2, 4);
                    var route = TempListPool.Rent<HotspotData>(routeLen);
                    var used = TempHashSetPool.Rent<int>();
                    int attempt = 0;
                    while (route.Count < routeLen && attempt++ < pool.Count * 2)
                    {
                        int idx = (squadIdx + route.Count) % pool.Count;
                        if (used.Add(idx))
                            route.Add(pool[idx]);
                    }
                    TempHashSetPool.Return(used);
                    session = new HotspotSession(bot, route, false, squadPath, squadIdx, squadCount);
                }
                TempListPool.Return(pool);
                return session;
            }
            catch (Exception ex)
            {
                Logger.LogWarning($"[HotspotSystem] Route assignment error: {ex.Message}");
                return null;
            }
        }

        /// <summary>
        /// Filters candidate hotspots by personality and tactical type.
        /// </summary>
        private static bool PersonalityHotspotFilter(HotspotData spot, BotPersonalityProfile profile)
        {
            if (profile == null || spot == null) return true;
            switch (profile.Personality)
            {
                case PersonalityType.Camper:
                case PersonalityType.Stoic:
                case PersonalityType.Cautious:
                    return spot.IsType("fallback") || spot.IsType("defense") || spot.HasTag("cover") || spot.Priority > 0.6f;
                case PersonalityType.Aggressive:
                case PersonalityType.Hunter:
                case PersonalityType.Frenzied:
                    return spot.IsType("combat") || spot.IsType("patrol") || spot.IsType("push") || spot.Priority > 0.3f;
                case PersonalityType.Balanced:
                case PersonalityType.Vigilante:
                case PersonalityType.Methodical:
                default:
                    return spot.Priority > 0.3f;
            }
        }

        #region HotspotSession

        /// <summary>
        /// Tracks a bot's squad/overlay/formation/personality-aware patrol/defense overlay session.
        /// </summary>
        private sealed class HotspotSession : IDisposable
        {
            private const float BaseDefendRadius = 7.8f;
            private const float DamageCooldown = 6.4f;
            private const float NavSampleRadius = 1.5f;
            private const float MoveCooldown = 1.13f;
            private const float MinCohesion = 0.87f;
            private const float MaxCohesion = 1.18f;

            private readonly BotOwner _bot;
            private readonly BotComponentCache _cache;
            private readonly List<HotspotData> _route;
            private readonly bool _isDefender;
            private readonly SquadPathCoordinator _squadPath;
            private readonly int _squadIdx;
            private readonly int _squadCount;

            private int _index;
            private float _lastHitTime;
            private float _nextSwitchTime;
            private float _lastMoveTime;
            private Vector3 _lastMoveTarget;

            public bool Stale => _bot == null || _bot.HealthController == null || _route == null || _route.Count == 0 || _bot.GetPlayer == null;

            public HotspotData CurrentSpot => _route != null && _route.Count > 0 ? _route[_index] : null;

            public HotspotSession(BotOwner bot, List<HotspotData> route, bool isDefender, SquadPathCoordinator squadPath, int squadIdx, int squadCount)
            {
                _bot = bot;
                _route = route;
                _isDefender = isDefender;
                _cache = BotCacheUtility.GetCache(bot);
                _index = 0;
                _lastHitTime = -999f;
                _nextSwitchTime = Time.time + GetSwitchTime();
                _lastMoveTime = -1000f;
                _lastMoveTarget = Vector3.zero;
                _squadPath = squadPath;
                _squadIdx = squadIdx;
                _squadCount = squadCount;

                try
                {
                    if (_bot.GetPlayer?.HealthController is HealthControllerClass hc)
                        hc.ApplyDamageEvent += OnDamage;
                }
                catch { }
            }

            public void Dispose()
            {
                try { if (_route != null) TempListPool.Return(_route); } catch { }
            }

            /// <summary>
            /// Arbitration/overlay, squad/sync/navmesh-safe, anti-teleport patrol/defend tick.
            /// </summary>
            public void Tick()
            {
                if (Stale || _bot.GetPlayer.IsYourPlayer)
                    return;

                if (_bot.Memory?.GoalEnemy != null || Time.time - _lastHitTime < DamageCooldown)
                    return;

                Vector3 dest = _route[_index].Position;
                if (!IsValid(dest)) return;
                if (!NavMesh.SamplePosition(dest, out var navHit, NavSampleRadius, NavMesh.AllAreas)) return;
                Vector3 baseTarget = navHit.position;
                if (!IsValid(baseTarget)) return;

                float now = Time.time;
                float dist = Vector3.Distance(_bot.Position, baseTarget);

                // Formation offset: use squad path coordinator to offset from squadmates.
                Vector3 formation = _squadPath != null ? _squadPath.ApplyOffsetTo(baseTarget) : baseTarget;

                // Arbitration: one patrol move intent per tick, anti-spam.
                if (!BotOverlayManager.CanIssueMove(_bot, BotOverlayType.Patrol))
                    return;

                float squadCohesion = UnityEngine.Random.Range(MinCohesion, MaxCohesion);

                if (_isDefender)
                {
                    float radius = BaseDefendRadius * Mathf.Clamp(1.0f + (1f - (_cache?.PanicHandler?.GetComposureLevel() ?? 1f)), 1f, 2.1f);
                    if (dist > radius && (now - _lastMoveTime > MoveCooldown || (_lastMoveTarget - formation).sqrMagnitude > 0.22f))
                    {
                        Vector3 drifted = BotMovementHelper.ApplyMicroDrift(
                            formation,
                            _bot.ProfileId,
                            Time.frameCount,
                            _cache?.PersonalityProfile
                        );
                        if (BotMovementHelper.ShouldMove(_bot, drifted))
                        {
                            BotMovementHelper.SmoothMoveToSafe(_bot, drifted, slow: true, cohesion: squadCohesion);
                            BotOverlayManager.RegisterMove(_bot, BotOverlayType.Patrol);
                            _lastMoveTarget = drifted;
                            _lastMoveTime = now;
                        }
                    }
                }
                else
                {
                    if (now >= _nextSwitchTime || dist < 2.5f)
                    {
                        _index = (_index + 1) % _route.Count;
                        _nextSwitchTime = now + GetSwitchTime();
                    }

                    if (now - _lastMoveTime > MoveCooldown || (_lastMoveTarget - formation).sqrMagnitude > 0.19f)
                    {
                        Vector3 jittered = AddJitter(formation);
                        Vector3 drifted = BotMovementHelper.ApplyMicroDrift(
                            jittered,
                            _bot.ProfileId,
                            Time.frameCount,
                            _cache?.PersonalityProfile
                        );
                        if (BotMovementHelper.ShouldMove(_bot, drifted))
                        {
                            BotMovementHelper.SmoothMoveToSafe(_bot, drifted, slow: true, cohesion: squadCohesion);
                            BotOverlayManager.RegisterMove(_bot, BotOverlayType.Patrol);
                            _lastMoveTarget = drifted;
                            _lastMoveTime = now;
                        }
                    }
                }
            }

            private static bool IsValid(Vector3 v)
            {
                return !float.IsNaN(v.x) && !float.IsNaN(v.y) && !float.IsNaN(v.z)
                    && v != Vector3.zero && Mathf.Abs(v.y) < 1000f;
            }

            private static Vector3 AddJitter(Vector3 basePos)
            {
                Vector3 jitter = UnityEngine.Random.insideUnitSphere * 0.55f;
                jitter.y = 0f;
                return basePos + jitter;
            }

            private float GetSwitchTime()
            {
                try
                {
                    var profile = BotRegistry.Get(_bot.ProfileId);
                    if (profile == null)
                        return 100f;

                    float chaos = Mathf.Clamp01(1f + profile.ChaosFactor * 0.8f);

                    switch (profile.Personality)
                    {
                        case PersonalityType.Camper:
                        case PersonalityType.Stoic:
                        case PersonalityType.Sentinel:
                            return 210f * chaos;
                        case PersonalityType.Methodical:
                        case PersonalityType.Supportive:
                            return 145f * chaos;
                        case PersonalityType.Balanced:
                        case PersonalityType.Vigilante:
                            return 97f * chaos;
                        case PersonalityType.Aggressive:
                        case PersonalityType.Hunter:
                            return 63f * chaos;
                        case PersonalityType.Frenzied:
                        case PersonalityType.Reckless:
                            return UnityEngine.Random.Range(38f, 81f) * chaos;
                        case PersonalityType.Dumb:
                        case PersonalityType.Fearful:
                            return 41f * chaos;
                        default:
                            return 99f * chaos;
                    }
                }
                catch
                {
                    return 100f;
                }
            }

            private void OnDamage(EBodyPart part, float dmg, DamageInfoStruct info)
            {
                try
                {
                    _lastHitTime = Time.time;
                    _cache?.PanicHandler?.TriggerPanic();
                }
                catch { }
            }
        }

        #endregion
    }
}
