// <auto-generated>
//   AI-Refactored: BaseAIWorldSystemBootstrapper.cs (Ultra-Platinum++ Arbitration, Isolation & Bulletproof Fallback Edition, June 2025)
//   SYSTEMATICALLY MANAGED. All failures strictly isolated—never cascades, never disables global AI. 
//   Ultimate Realism, Headless/Client Parity, Error Isolation, Diagnostic/Recovery hooks, and Robust Cleanup.
//   MIT License.
// </auto-generated>

namespace AIRefactored.AI.Core
{
    using System;
    using System.Diagnostics;
    using AIRefactored.Bootstrap;
    using AIRefactored.Core;
    using BepInEx.Logging;

    /// <summary>
    /// Abstract base for all world-level AIRefactored systems.
    /// Hardened for bulletproof lifecycle, hard isolation, robust recovery, and diagnostics.
    /// All errors are strictly local—never propagate, never disable the global mod.
    /// </summary>
    public abstract class BaseAIWorldSystemBootstrapper : IAIWorldSystemBootstrapper
    {
        #region Internal State

        private volatile bool _hasFailed;
        private DateTime _failTime = DateTime.MinValue;
        private string _failMessage = null;
        private string _failStack = null;
        private int _failCount = 0;
        private bool _hasCleanupRun;

        #endregion

        #region Lifecycle

        /// <summary>
        /// Initializes the system at its required phase. All exceptions are strictly localized.
        /// Recovers if system has previously failed but is now safe to restart.
        /// </summary>
        public virtual void Initialize()
        {
            if (_hasFailed && !CanRecoverAfterFailure())
                return;

            try
            {
                _hasFailed = false;
                _failTime = DateTime.MinValue;
                _failMessage = null;
                _failStack = null;
                _failCount = 0;
                _hasCleanupRun = false;
                OnInitialize();
            }
            catch (Exception ex)
            {
                FailSystem("[BaseAIWorldSystem] Initialize error in " + GetType().Name, ex);
            }
        }

        /// <summary>
        /// Override with system-specific initialization logic.
        /// </summary>
        protected virtual void OnInitialize() { }

        /// <summary>
        /// Ticked by WorldBootstrapper or controller if ready. All exceptions are contained and do not escalate.
        /// </summary>
        /// <param name="deltaTime">Elapsed time since last tick.</param>
        public virtual void Tick(float deltaTime)
        {
            if (_hasFailed && !CanRecoverAfterFailure())
                return;

            try
            {
                OnTick(deltaTime);
            }
            catch (Exception ex)
            {
                FailSystem("[BaseAIWorldSystem] Tick error in " + GetType().Name, ex);
            }
        }

        /// <summary>
        /// Override with per-tick system logic.
        /// </summary>
        /// <param name="deltaTime">Elapsed time since last tick.</param>
        protected virtual void OnTick(float deltaTime) { }

        /// <summary>
        /// Handles teardown/cleanup at raid end or world unload. All exceptions are contained and do not propagate.
        /// </summary>
        public virtual void OnRaidEnd()
        {
            if (_hasCleanupRun)
                return;

            try
            {
                Cleanup();
                _hasCleanupRun = true;
            }
            catch (Exception ex)
            {
                FailSystem("[BaseAIWorldSystem] OnRaidEnd error in " + GetType().Name, ex);
            }
        }

        /// <summary>
        /// Override for per-system teardown and memory cleanup logic.
        /// </summary>
        protected virtual void Cleanup() { }

        /// <summary>
        /// Returns true if the system is ready and not failed. Ticked only if true.
        /// Can be overridden for custom gating (e.g. dependency on other systems).
        /// </summary>
        public virtual bool IsReady()
        {
            return !_hasFailed && OnIsReady();
        }

        /// <summary>
        /// Override for custom readiness gating (e.g. dependency on world state, external systems).
        /// </summary>
        protected virtual bool OnIsReady() => true;

        /// <summary>
        /// Returns the phase required for world bootstrapper to initialize this system.
        /// </summary>
        public virtual WorldPhase RequiredPhase() => WorldPhase.PostInit;

        /// <summary>
        /// Called on fatal/local error; disables only this system. Never escalate, never affect global mod state.
        /// Can be overridden in subclasses for local fallback, auto-retry, diagnostics, or reporting.
        /// </summary>
        protected virtual void OnFailover()
        {
            // Local fallback, auto-retry, or error reporting logic can be implemented in derived classes.
        }

        /// <summary>
        /// Returns true if this system is permanently failed and will never tick again (unless CanRecoverAfterFailure returns true).
        /// </summary>
        public bool IsFailed => _hasFailed;

        /// <summary>
        /// Returns diagnostic status, including failure info if applicable.
        /// </summary>
        public virtual string GetStatus()
        {
            if (!_hasFailed)
                return $"[{GetType().Name}] OK";
            return $"[{GetType().Name}] FAILED at {_failTime:O} ({_failMessage ?? "unknown error"})\n{_failStack}";
        }

        #endregion

        #region Failure/Recovery

        /// <summary>
        /// Marks this system as failed, logs error, performs failover. Never escalates.
        /// </summary>
        protected void FailSystem(string prefix, Exception ex)
        {
            _hasFailed = true;
            _failTime = DateTime.UtcNow;
            _failCount++;
            _failMessage = ex?.Message;
            _failStack = ex?.StackTrace ?? string.Empty;
            Plugin.LoggerInstance?.LogError($"{prefix}: {ex}");
            try { OnFailover(); } catch { /* Local only. */ }
        }

        /// <summary>
        /// Returns true if this system may attempt recovery (override for diagnostics, hot-reload, headless reset).
        /// </summary>
        protected virtual bool CanRecoverAfterFailure()
        {
            // By default, base systems do NOT attempt recovery. Override if hot-reload/restart is safe.
            return false;
        }

        /// <summary>
        /// Returns the number of consecutive failures.
        /// </summary>
        public int FailureCount => _failCount;

        #endregion
    }
}
