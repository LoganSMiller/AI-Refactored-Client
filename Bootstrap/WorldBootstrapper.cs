// <auto-generated>
//   AI-Refactored: WorldBootstrapper.cs (Ultra-Platinum++ – Supreme Realism, Isolation, Parity, June 2025)
//   SYSTEMATICALLY MANAGED. No disables, no split logic. All failures isolated; atomic attach/retry only. 
//   Headless gating is INIT-ONLY; never in runtime/tick. Zero deadlocks, zero state drift. 
//   Pooled memory, static prewarm, and global attach/teardown bulletproofed. 
//   All diagnostics are detailed, failovers local, teardown race- and leak-proof.
//   MIT License.
// </auto-generated>

namespace AIRefactored.Bootstrap
{
    using System;
    using System.Collections.Generic;
    using AIRefactored.AI.Core;
    using AIRefactored.AI.Hotspots;
    using AIRefactored.AI.Looting;
    using AIRefactored.AI.Navigation;
    using AIRefactored.AI.Optimization;
    using AIRefactored.AI.Threads;
    using AIRefactored.Core;
    using AIRefactored.Pools;
    using AIRefactored.Runtime;
    using BepInEx.Logging;
    using Comfort.Common;
    using EFT;
    using UnityEngine;

    /// <summary>
    /// AI-Refactored global world initializer and runtime tick manager.
    /// Ensures atomic, robust attach/retry; never disables. Always 1:1 logic for headless and client.
    /// Diagnostics and recovery are always on; no logic split at runtime, only at init.
    /// </summary>
    public static class WorldBootstrapper
    {
        #region Fields

        private static readonly List<IAIWorldSystemBootstrapper> Systems = new List<IAIWorldSystemBootstrapper>(24);
        private static ManualLogSource _loggerInstance = Plugin.LoggerInstance;
        private static bool _hasInitialized;
        private static bool _hasShutdownLogged;
        private static float _lastSweep;
        private const float SweepInterval = 19.8f;

        private static ManualLogSource Logger => _loggerInstance ?? Plugin.LoggerInstance;

        #endregion

        #region Initialization & Attach

        /// <summary>
        /// Initializes all world-level AI systems, with atomic, failover-safe attach. 
        /// Only INIT can branch for headless; runtime is always 1:1 parity.
        /// </summary>
        public static void Begin(ManualLogSource logger, string mapId)
        {
            _loggerInstance = logger ?? Plugin.LoggerInstance;

            if (_hasInitialized)
                return;

            // INIT-ONLY: Only headless gating allowed here.
            if (FikaHeadlessDetector.IsHeadless && !FikaHeadlessDetector.HasRaidStarted())
                return;

            try
            {
                _hasShutdownLogged = false;
                Systems.Clear();

                // Prewarm and reset all static pools/registries, race-safe
                TrySafe(BotRecoveryService.Reset, "[WorldBootstrapper] BotRecoveryService.Reset() failed: ");
                TrySafe(BotSpawnWatcherService.Reset, "[WorldBootstrapper] BotSpawnWatcherService.Reset() failed: ");
                TrySafe(LootRuntimeWatcher.Reset, "[WorldBootstrapper] LootRuntimeWatcher.Reset() failed: ");
                TrySafe(DeadBodyObserverService.Reset, "[WorldBootstrapper] DeadBodyObserverService.Reset() failed: ");
                TrySafe(DeadBodyContainerCache.Clear, "[WorldBootstrapper] DeadBodyContainerCache.Clear() failed: ");
                TrySafe(LootRegistry.Clear, "[WorldBootstrapper] LootRegistry.Clear() failed: ");
                TrySafe(HotspotRegistry.Clear, "[WorldBootstrapper] HotspotRegistry.Clear() failed: ");

                if (!string.IsNullOrEmpty(mapId))
                    TrySafe(() => HotspotRegistry.Initialize(mapId), "[WorldBootstrapper] HotspotRegistry.Initialize() failed: ");

                // Register all world-level systems (expandable)
                RegisterSystemSafe(new RaidLifecycleWatcher());
                RegisterSystemSafe(new BotRecoveryService());
                RegisterSystemSafe(new BotSpawnWatcherService());
                RegisterSystemSafe(new LootRuntimeWatcher());
                RegisterSystemSafe(new DeadBodyObserverService());
                RegisterSystemSafe(new HotspotRegistryBootstrapper());
                // Add future core/extension world systems here

                for (int i = 0; i < Systems.Count; i++)
                    TrySafe(Systems[i].Initialize, $"[WorldBootstrapper] Failed to initialize {Systems[i].GetType().Name}: ");

                _hasInitialized = true;
                Logger.LogInfo($"[WorldBootstrapper] ✅ World AI systems initialized for map '{mapId ?? "unknown"}'.");
            }
            catch (Exception ex)
            {
                Logger.LogError("[WorldBootstrapper] Initialization failed: " + ex);
            }
        }

        #endregion

        #region Teardown & Stop

        /// <summary>
        /// Cleanly shuts down all world-level AIRefactored systems, fully pooled, with local failover.
        /// </summary>
        public static void Stop()
        {
            if (!_hasInitialized)
                return;

            try
            {
                for (int i = 0; i < Systems.Count; i++)
                    TrySafe(Systems[i].OnRaidEnd, $"[WorldBootstrapper] OnRaidEnd error in {Systems[i].GetType().Name}: ");

                Systems.Clear();
                _hasInitialized = false;

                if (!_hasShutdownLogged)
                {
                    _hasShutdownLogged = true;
                    Logger.LogDebug("[WorldBootstrapper] 🔻 AIRefactored systems shut down.");
                }
            }
            catch (Exception ex)
            {
                Logger.LogError("[WorldBootstrapper] Stop() encountered error: " + ex);
            }
        }

        #endregion

        #region Central Tick

        /// <summary>
        /// Ticks all world-level and bot AI subsystems, always 1:1 between headless/client.
        /// Pooled, error-isolated, never disables, never branches at runtime.
        /// </summary>
        public static void Tick(float deltaTime)
        {
            if (!_hasInitialized)
                return;

            try
            {
                float now = Time.time;

                // Tick world-level AI systems
                for (int i = 0; i < Systems.Count; i++)
                {
                    IAIWorldSystemBootstrapper system = Systems[i];
                    if (system == null)
                        continue;

                    try
                    {
                        if (WorldInitState.IsInPhase(system.RequiredPhase()))
                            system.Tick(deltaTime);
                    }
                    catch (Exception ex)
                    {
                        Logger.LogError("[WorldBootstrapper] System Tick() error in " + system.GetType().Name + ": " + ex);
                    }
                }

                // Centralized pooled bot brain tick (maximum safety, bulletproof attach/retry)
                List<Player> players = GameWorldHandler.GetAllAlivePlayers();
                try
                {
                    for (int i = 0; i < players.Count; i++)
                    {
                        Player player = players[i];
                        if (!EFTPlayerUtil.IsValid(player) || !player.IsAI)
                            continue;

                        GameObject go = player.gameObject;
                        if (go == null)
                            continue;

                        BotBrain brain = go.GetComponent<BotBrain>();
                        if (brain != null && brain.enabled)
                        {
                            try
                            {
                                brain.Tick(deltaTime);
                            }
                            catch (Exception ex)
                            {
                                Logger.LogError("[WorldBootstrapper] BotBrain.Tick() error: " + ex);
                            }
                        }
                    }
                }
                finally
                {
                    TempListPool.Return(players);
                }

                // Periodic global sweep: dead bot cleanup, brain enforcement
                if (now - _lastSweep >= SweepInterval)
                {
                    _lastSweep = now;
                    TrySafe(GameWorldHandler.EnforceBotBrains, "[WorldBootstrapper] EnforceBotBrains() failed: ");
                    TrySafe(GameWorldHandler.CleanupDeadBotsSmoothly, "[WorldBootstrapper] CleanupDeadBotsSmoothly() failed: ");
                }
            }
            catch (Exception ex)
            {
                Logger.LogError("[WorldBootstrapper] Tick() outer error: " + ex);
            }
        }

        #endregion

        #region Attach/Atomic Reliability API

        /// <summary>
        /// Forces a bulletproof, atomic bot brain attach/retry for a given player+bot.
        /// Never disables, never breaks state, always parity-safe.
        /// </summary>
        public static void EnforceBotBrain(Player player, BotOwner bot)
        {
            if (!EFTPlayerUtil.IsValid(player) || !player.IsAI || bot == null)
                return;

            string profileId = bot.Profile?.Id;
            if (string.IsNullOrEmpty(profileId))
                return;

            GameObject go = player.gameObject;
            if (go == null)
                return;

            try
            {
                BotComponentCache cache = BotComponentCacheRegistry.GetOrCreate(bot);
                if (cache == null || cache.AIRefactoredBotOwner == null)
                    return;

                BotBrainGuardian.Enforce(go);

                BotBrain existing = go.GetComponent<BotBrain>();
                if (existing == null)
                {
                    BotBrain brain = go.AddComponent<BotBrain>();
                    brain.enabled = true;
                    brain.Initialize(bot);
                }
                else if (!existing.enabled)
                {
                    existing.enabled = true;
                }
            }
            catch (Exception ex)
            {
                Logger.LogWarning("[WorldBootstrapper] BotBrain init failed for " + profileId + ": " + ex);
            }
        }

        #endregion

        #region System Registry Helpers

        private static void RegisterSystemSafe(IAIWorldSystemBootstrapper system)
        {
            try
            {
                if (system == null || Systems.Contains(system))
                    return;
                Systems.Add(system);
            }
            catch (Exception ex)
            {
                Logger.LogError("[WorldBootstrapper] RegisterSystemSafe() failed: " + ex);
            }
        }

        /// <summary>
        /// Registers additional modular systems; public for mod extensions or expansion.
        /// </summary>
        public static void RegisterSystem(IAIWorldSystemBootstrapper system)
        {
            RegisterSystemSafe(system);
        }

        #endregion

        #region Failover-Safe Helper

        /// <summary>
        /// Executes an action, logs and contains all errors.
        /// </summary>
        private static void TrySafe(Action action, string errorPrefix)
        {
            try { action(); }
            catch (Exception ex) { Logger.LogError(errorPrefix + ex); }
        }

        #endregion
    }
}
