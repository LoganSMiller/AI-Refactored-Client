// <auto-generated>
//   This file is part of AI-Refactored, an open-source project focused on realistic AI behavior in Escape from Tarkov.
//   Licensed under the MIT License. See LICENSE in the repository root for more information.
//
//   THIS FILE IS SYSTEMATICALLY MANAGED.
//   Please follow strict StyleCop, ReSharper, and AI-Refactored code standards for all modifications.
// </auto-generated>

#nullable enable

namespace AIRefactored.Bootstrap
{
    using System.Collections;
    using AIRefactored.AI.Core;
    using AIRefactored.AI.Hotspots;
    using AIRefactored.AI.Looting;
    using AIRefactored.AI.Navigation;
    using AIRefactored.AI.Optimization;
    using AIRefactored.AI.Threads;
    using AIRefactored.Core;
    using AIRefactored.Runtime;
    using BepInEx.Logging;
    using Comfort.Common;
    using EFT;
    using Unity.AI.Navigation;
    using UnityEngine;

    /// <summary>
    /// Initializes AIRefactored world systems on scene load. Handles bot registration, NavMesh warm-up,
    /// and AI brain injection in both multiplayer and headless environments.
    /// </summary>
    public sealed class WorldBootstrapper : MonoBehaviour
    {
        private const float SweepInterval = 20f;
        private const float ZoneCheckInterval = 1f;
        private const float InitializationRetryInterval = 3f;
        private const int MaxInitializationRetries = 5;

        private static readonly ManualLogSource Logger = AIRefactoredController.Logger;
        private static readonly object LockObj = new object();

        // Only this host GameObject ever holds the real bootstrapper.
        private static GameObject? _injectedHost;

        private bool _isInitializing;
        private int _attempts;
        private bool _resetAfterReady;
        private float _lastSweep = -999f;
        private float _lastZoneCheck = -999f;
        private BotSystemRecoveryWatcher? _recoveryWatcher;

        /// <summary>
        /// Creates exactly one WorldBootstrapper on a new GameObject, if and only if we’re the authoritative host.
        /// </summary>
        public static void TryInitialize()
        {
            if (!GameWorldHandler.IsLocalHost())
            {
                Logger.LogWarning("[WorldBootstrapper] Skipped bootstrap — not authoritative.");
                return;
            }

            if (_injectedHost != null)
            {
                Logger.LogWarning("[WorldBootstrapper] Already injected — skipping.");
                return;
            }

            _injectedHost = new GameObject("WorldBootstrapper (Injected)");
            Object.DontDestroyOnLoad(_injectedHost);
            _injectedHost.AddComponent<WorldBootstrapper>();

            Logger.LogInfo("[WorldBootstrapper] ✅ Manual bootstrap injected.");
        }

        private void Awake()
        {
            // Only the one host GameObject may survive
            if (this.gameObject != _injectedHost)
            {
                Logger.LogWarning("[WorldBootstrapper] Duplicate instance detected — destroying.");
                Destroy(this.gameObject);
                return;
            }

            Logger.LogInfo("[WorldBootstrapper] 🟢 Awake on primary bootstrapper.");

            // Recovery watcher must exist exactly once
            _recoveryWatcher = this.gameObject.AddComponent<BotSystemRecoveryWatcher>();
            BotWorkScheduler.AutoInjectFlushHost();

            // Kick off deferred initialization
            if (GameWorldHandler.IsLocalHost())
            {
                Logger.LogInfo("[WorldBootstrapper] 🧠 Authoritative host — starting initialization.");
                StartCoroutine(SafeInitializeRoutine());
            }
            else
            {
                Logger.LogWarning("[WorldBootstrapper] 🚫 Non-host — skipping initialization.");
            }
        }

        private IEnumerator SafeInitializeRoutine()
        {
            if (_isInitializing)
            {
                Logger.LogWarning("[WorldBootstrapper] Initialization already in progress — skipping.");
                yield break;
            }

            _isInitializing = true;
            yield return StartCoroutine(DelayedInitialize());
            _isInitializing = false;
        }

        private IEnumerator DelayedInitialize()
        {
            lock (LockObj)
            {
                // Back off if we've retried too many times before the world was ready
                if (_attempts >= MaxInitializationRetries && !_resetAfterReady && GameWorldHandler.IsReady())
                {
                    _resetAfterReady = true;
                    _attempts = 0;
                }
                _attempts++;
            }

            yield return new WaitForSeconds(Mathf.Pow(2, _attempts) * InitializationRetryInterval);

            if (!GameWorldHandler.TryForceResolveMapName() || !GameWorldHandler.IsReady())
            {
                Logger.LogWarning("[WorldBootstrapper] 🚧 Deferring initialization until world ready.");
                yield break;
            }

            string mapId = GameWorldHandler.GetCurrentMapName();
            Logger.LogInfo($"[WorldBootstrapper] 🔧 Initializing systems for map: {mapId}");

            // Hotspots
            HotspotRegistry.Clear();
            HotspotRegistry.Initialize(mapId);

            // Zones + NavPoints
            ZoneAssignmentHelper.Clear();
            NavPointRegistry.Clear();
            IZones? zones = null;
            int wait = 0;
            while (!GameWorldHandler.TryGetIZones(out zones) || zones == null)
            {
                if (++wait > 60)
                {
                    Logger.LogWarning("[WorldBootstrapper] ⚠ Timed out waiting for IZones.");
                    break;
                }
                yield return null;
            }
            if (zones != null)
            {
                ZoneAssignmentHelper.Initialize(zones);
                NavPointRegistry.InitializeZoneSystem(zones);
            }
            NavPointRegistry.EnableSpatialIndexing(true);
            NavPointRegistry.RegisterAll(mapId);

            // Loot
            LootRegistry.Clear();
            LootBootstrapper.RegisterAllLoot();
            BotDeadBodyScanner.ScanAll();

            // NavMesh prewarm
            PrewarmAllNavMeshes();
            Logger.LogInfo("[WorldBootstrapper] ✅ All systems initialized.");
        }

        private void Update()
        {
            if (!GameWorldHandler.IsLocalHost())
                return;

            float now = Time.time;

            // Periodic brain enforcement
            if (now - _lastSweep >= SweepInterval)
            {
                _lastSweep = now;
                GameWorldHandler.EnforceBotBrains();
            }

            // Dead-bot cleanup
            GameWorldHandler.CleanupDeadBotsSmoothly();

            // Zone readiness check
            if (now - _lastZoneCheck >= ZoneCheckInterval)
            {
                _lastZoneCheck = now;
                if (!GameWorldHandler.TryGetIZones(out _))
                {
                    Logger.LogWarning("[WorldBootstrapper] ⚠ Zones not ready.");
                }
            }
        }

        private void OnDestroy()
        {
            // Only clear everything when our one true host is torn down
            if (this.gameObject == _injectedHost)
            {
                Logger.LogInfo("[WorldBootstrapper] 🔻 Destroying primary bootstrapper.");
                HotspotRegistry.Clear();
                LootRegistry.Clear();
                NavPointRegistry.Clear();
                ZoneAssignmentHelper.Clear();
                _injectedHost = null;
            }
        }

        private void PrewarmAllNavMeshes()
        {
            string mapId = GameWorldHandler.GetCurrentMapName();
            var surfaces = FindObjectsOfType<NavMeshSurface>();
            foreach (var s in surfaces)
            {
                if (s != null && s.enabled && s.gameObject.activeInHierarchy)
                {
                    s.BuildNavMesh();
                    BotCoverRetreatPlanner.RegisterSurface(mapId, s);
                }
            }
        }

        /// <summary>
        /// Helper to ensure any existing or newly spawned bot gets a BotBrain attached.
        /// </summary>
        public static void EnforceBotBrain(Player player, BotOwner? bot = null)
        {
            if (player == null || !player.IsAI || player.gameObject == null)
                return;

            var go = player.gameObject;
            BotBrainGuardian.Enforce(go);

            if (go.GetComponent<BotBrain>() == null && bot != null)
            {
                var brain = go.AddComponent<BotBrain>();
                brain.Initialize(bot);
            }
        }
    }
}
