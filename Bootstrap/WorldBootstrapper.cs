// <auto-generated>
//   This file is part of AI-Refactored, an open-source project focused on realistic AI behavior in Escape from Tarkov.
//   Licensed under the MIT License. See LICENSE in the repository root for more information.
//
//   THIS FILE IS SYSTEMATICALLY MANAGED.
//   Please follow strict StyleCop, ReSharper, and AI-Refactored code standards for all modifications.
// </auto-generated>

#nullable enable

namespace AIRefactored.Bootstrap
{
    using System.Collections;
    using AIRefactored.AI.Core;
    using AIRefactored.AI.Hotspots;
    using AIRefactored.AI.Looting;
    using AIRefactored.AI.Navigation;
    using AIRefactored.AI.Optimization;
    using AIRefactored.AI.Threads;
    using AIRefactored.Core;
    using AIRefactored.Runtime;
    using BepInEx.Logging;
    using Comfort.Common;
    using EFT;
    using Unity.AI.Navigation;
    using UnityEngine;

    /// <summary>
    /// Initializes AIRefactored world systems on scene load. Handles bot registration, NavMesh warm-up,
    /// and AI brain injection in both multiplayer and headless environments.
    /// </summary>
    public sealed class WorldBootstrapper : MonoBehaviour
    {
        #region Static Manual Bootstrap

        /// <summary>
        /// Triggers world system initialization for maps, safe for headless hosts and early plugin boot.
        /// </summary>
        public static void TryInitialize()
        {
            if (_hasInitialized)
            {
                return;
            }

            GameObject bootstrapperObj = new GameObject("WorldBootstrapper (Injected)");
            Object.DontDestroyOnLoad(bootstrapperObj);
            bootstrapperObj.AddComponent<WorldBootstrapper>();

            _hasInitialized = true;
            Logger.LogInfo("[WorldBootstrapper] ✅ Manual bootstrap injection complete.");
        }

        #endregion

        #region Fields

        private const float SweepInterval = 20f;

        private float _lastSweepTime = -999f;

        private static readonly ManualLogSource Logger = AIRefactoredController.Logger;

        private static bool _hasInitialized = false;

        #endregion

        #region Unity Lifecycle

        private void Awake()
        {
            Logger.LogInfo("[WorldBootstrapper] 🟢 Awake() triggered.");

            this.StartCoroutine(this.WatchForWorld());
            BotWorkScheduler.AutoInjectFlushHost();

            if (FikaHeadlessDetector.IsHeadless)
            {
                Logger.LogInfo("[WorldBootstrapper] 🧠 Headless mode detected. UI-dependent systems will be skipped.");
            }
        }

        private void Update()
        {
            float now = Time.time;

            if (now - this._lastSweepTime >= SweepInterval)
            {
                GameWorldHandler.EnforceBotBrains();
                this._lastSweepTime = now;
            }

            GameWorldHandler.CleanupDeadBotsSmoothly();
        }

        private void OnDestroy()
        {
            if (Singleton<BotSpawner>.Instantiated)
            {
                Singleton<BotSpawner>.Instance.OnBotCreated -= this.HandleBotCreated;
            }

            Logger.LogInfo("[WorldBootstrapper] 🔻 Unloaded — cleanup complete.");

            HotspotRegistry.Clear();
            LootRegistry.Clear();
            NavPointRegistry.Clear();
        }

        #endregion

        #region World Initialization

        private IEnumerator WatchForWorld()
        {
            if (FikaHeadlessDetector.IsHeadless)
            {
                Logger.LogInfo("[WorldBootstrapper] 🧠 Skipping GameWorld wait — running in headless mode.");
                this.InitializeWorldSystems();
                yield break;
            }

            while (!SingletonExists())
            {
                yield return null;
            }

            if (Singleton<BotSpawner>.Instantiated)
            {
                Singleton<BotSpawner>.Instance.OnBotCreated += this.HandleBotCreated;
            }

            Logger.LogInfo("[WorldBootstrapper] 🌍 World detected — beginning AIRefactored initialization...");

            this.InitializeWorldSystems();

            yield return new WaitForSeconds(3f);
            GameWorldHandler.EnforceBotBrains();
        }

        private static bool SingletonExists()
        {
            return Singleton<BotSpawner>.Instantiated &&
                   Singleton<GameWorld>.Instantiated &&
                   Singleton<GameWorld>.Instance != null;
        }

        private void InitializeWorldSystems()
        {
            string mapId = GameWorldHandler.GetCurrentMapName();

            Logger.LogInfo("[WorldBootstrapper] 🔧 Initializing world systems for map: " + mapId);

            // Hotspots
            HotspotRegistry.Clear();
            HotspotRegistry.Initialize(mapId);
            Logger.LogInfo("[WorldBootstrapper] ✅ Hotspot registry initialized.");

            // Zone system
            ZoneAssignmentHelper.Clear();
            IZones? zones;
            if (GameWorldHandler.TryGetIZones(out zones) && zones != null)
            {
                ZoneAssignmentHelper.Initialize(zones);
                NavPointRegistry.InitializeZoneSystem(zones);
                Logger.LogInfo("[WorldBootstrapper] ✅ Zone assignment system initialized.");
            }
            else
            {
                Logger.LogWarning("[WorldBootstrapper] ⚠️ No IZones found — zone tagging disabled for this session.");
            }

            // Navpoints
            NavPointRegistry.Clear();
            NavPointRegistry.EnableSpatialIndexing(true);
            NavPointBootstrapper.RegisterAll(mapId);
            Logger.LogInfo("[WorldBootstrapper] ✅ NavPoint registry populated.");

            // Looting
            LootRegistry.Clear();
            LootBootstrapper.RegisterAllLoot();
            BotDeadBodyScanner.ScanAll();
            Logger.LogInfo("[WorldBootstrapper] ✅ Loot and dead body systems initialized.");

            // NavMesh retreat logic
            this.PrewarmAllNavMeshes();

            Logger.LogInfo("[WorldBootstrapper] ✅ AIRefactored world systems initialized.");
        }

        private void PrewarmAllNavMeshes()
        {
            NavMeshSurface[] surfaces = Object.FindObjectsOfType<NavMeshSurface>();
            string map = GameWorldHandler.GetCurrentMapName();

            for (int i = 0; i < surfaces.Length; i++)
            {
                NavMeshSurface surface = surfaces[i];
                if (surface == null || !surface.enabled || !surface.gameObject.activeInHierarchy)
                {
                    continue;
                }

                surface.BuildNavMesh();
                BotCoverRetreatPlanner.RegisterSurface(map, surface);

                Logger.LogInfo("[WorldBootstrapper] 🔄 Prewarmed NavMesh: " + surface.name);
            }
        }

        #endregion

        #region Bot Injection

        private void HandleBotCreated(BotOwner bot)
        {
            if (!IsEligibleBot(bot))
            {
                return;
            }

            Player? eftPlayer = EFTPlayerUtil.ResolvePlayer(bot);
            if (eftPlayer == null)
            {
                return;
            }

            GameObject? playerObj = eftPlayer.gameObject;
            if (playerObj == null)
            {
                return;
            }

            Logger.LogInfo("[WorldBootstrapper] 🧠 Bot created: " + (eftPlayer.Profile?.Info?.Nickname ?? "Unnamed"));
            BotBrainGuardian.Enforce(playerObj);

            BotWorkScheduler.EnqueueToMainThread(() =>
                {
                    GameWorldHandler.TryAttachBotBrain(bot);
                });
        }

        private static bool IsEligibleBot(BotOwner? bot)
        {
            Player? player = EFTPlayerUtil.ResolvePlayer(bot);
            return bot != null && player != null && player.IsAI;
        }

        #endregion
    }
}
