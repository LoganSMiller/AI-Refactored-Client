// <auto-generated>
//   This file is part of AI-Refactored, an open-source project focused on realistic AI behavior in Escape from Tarkov.
//   Licensed under the MIT License. See LICENSE in the repository root for more information.
//
//   THIS FILE IS SYSTEMATICALLY MANAGED.
//   Please follow strict StyleCop, ReSharper, and AI-Refactored code standards for all modifications.
// </auto-generated>

#nullable enable

namespace AIRefactored.Bootstrap
{
    using System.Collections;
    using AIRefactored.AI.Core;
    using AIRefactored.AI.Hotspots;
    using AIRefactored.AI.Looting;
    using AIRefactored.AI.Navigation;
    using AIRefactored.AI.Optimization;
    using AIRefactored.AI.Threads;
    using AIRefactored.Core;
    using AIRefactored.Runtime;
    using BepInEx.Logging;
    using Comfort.Common;
    using EFT;
    using Unity.AI.Navigation;
    using UnityEngine;

    /// <summary>
    /// Initializes AIRefactored world systems on scene load. Handles bot registration, NavMesh warm-up,
    /// and AI brain injection in both multiplayer and headless environments.
    /// </summary>
    public sealed class WorldBootstrapper : MonoBehaviour
    {
        private const float SweepInterval = 20f;
        private const float InitializationRetryInterval = 3f; // Retry interval for headless
        private const int MaxInitializationRetries = 5; // Maximum retries for initialization
        private const float ZoneCheckInterval = 1f; // Interval to check zone availability

        private static readonly ManualLogSource Logger = AIRefactoredController.Logger;
        private static bool _hasInitialized;
        private static int _initializationAttempts = 0;
        private static bool _wasWorldReadyOnRetry;

        private float _lastSweepTime = -999f;
        private float _lastInitializationCheck = -999f;
        private float _lastZoneCheck = -999f;
        private BotSystemRecoveryWatcher? _recoveryWatcher;

        private static readonly object LockObj = new object(); // For thread safety

        /// <summary>
        /// Initializes the world if it's not already initialized, or if the host is valid.
        /// </summary>
        public static void TryInitialize()
        {
            if (_hasInitialized || !GameWorldHandler.IsLocalHost())
            {
                return;
            }

            GameObject host = new GameObject("WorldBootstrapper (Injected)");
            Object.DontDestroyOnLoad(host);
            host.AddComponent<WorldBootstrapper>();

            _hasInitialized = true;
            Logger.LogInfo("[WorldBootstrapper] ✅ Manual bootstrap injected.");
        }

        private void Awake()
        {
            Logger.LogInfo("[WorldBootstrapper] 🟢 Awake triggered.");

            this._recoveryWatcher = this.gameObject.AddComponent<BotSystemRecoveryWatcher>();
            BotWorkScheduler.AutoInjectFlushHost();

            if (GameWorldHandler.IsLocalHost())
            {
                Logger.LogInfo("[WorldBootstrapper] 🧠 Authoritative host detected — initializing world systems.");
                this.StartCoroutine(this.DelayedInitialize());
            }
            else
            {
                Logger.LogWarning("[WorldBootstrapper] 🚫 Non-host client detected — skipping world initialization.");
            }
        }

        private void Update()
        {
            if (!GameWorldHandler.IsLocalHost())
            {
                return;
            }

            float now = Time.time;
            if (now - this._lastSweepTime >= SweepInterval)
            {
                this._lastSweepTime = now;
                GameWorldHandler.EnforceBotBrains();
            }

            GameWorldHandler.CleanupDeadBotsSmoothly();

            // Zone availability check logic
            if (now - this._lastZoneCheck >= ZoneCheckInterval)
            {
                this._lastZoneCheck = now;
                if (!GameWorldHandler.TryGetIZones(out IZones? zones) || zones == null)
                {
                    Logger.LogWarning("[WorldBootstrapper] ⚠ Zones are not ready.");
                }
            }
        }

        private void OnDestroy()
        {
            if (this._recoveryWatcher != null)
            {
                Object.Destroy(this._recoveryWatcher);
                this._recoveryWatcher = null;
            }

            Logger.LogInfo("[WorldBootstrapper] 🔻 Destroyed — clearing world systems.");

            HotspotRegistry.Clear();
            LootRegistry.Clear();
            NavPointRegistry.Clear();
            ZoneAssignmentHelper.Clear();

            _hasInitialized = false;
        }

        private IEnumerator DelayedInitialize()
        {
            lock (LockObj)
            {
                // Check if retries have been exhausted but the world is available now
                if (_initializationAttempts >= MaxInitializationRetries)
                {
                    // If the world has now become available, reset the retry logic
                    if (!_wasWorldReadyOnRetry && GameWorldHandler.IsReady())
                    {
                        _wasWorldReadyOnRetry = true;
                        _initializationAttempts = 0;
                    }

                    if (_wasWorldReadyOnRetry)
                    {
                        Logger.LogInfo("[WorldBootstrapper] World is now ready after retries. Re-initializing.");
                    }
                    else
                    {
                        Logger.LogError("[WorldBootstrapper] Maximum retries reached for initialization. Aborting.");
                        yield break;
                    }
                }

                // Retry logic with exponential backoff (to avoid flooding retries)
                _initializationAttempts++;
                float delay = Mathf.Pow(2, _initializationAttempts) * InitializationRetryInterval;
                yield return new WaitForSeconds(delay);
            }

            if (Time.time - _lastInitializationCheck < InitializationRetryInterval)
            {
                yield break;
            }

            _lastInitializationCheck = Time.time;

            if (!GameWorldHandler.TryForceResolveMapName())
            {
                Logger.LogWarning("[WorldBootstrapper] 🚧 Map name unresolved — skipping initialization.");
                _hasInitialized = false;
                yield break;
            }

            if (!GameWorldHandler.IsReady())
            {
                Logger.LogWarning("[WorldBootstrapper] 🚧 GameWorld not fully ready — skipping initialization.");
                _hasInitialized = false;
                yield break;
            }

            string mapId = GameWorldHandler.GetCurrentMapName();
            Logger.LogInfo("[WorldBootstrapper] 🔧 Initializing systems for map: " + mapId);

            HotspotRegistry.Clear();
            HotspotRegistry.Initialize(mapId);
            Logger.LogInfo("[WorldBootstrapper] ✅ Hotspots ready.");

            ZoneAssignmentHelper.Clear();
            NavPointRegistry.Clear();

            int frameWait = 0;
            IZones? zones = null;

            // Retry IZones initialization if necessary
            while (!GameWorldHandler.TryGetIZones(out zones) || zones == null)
            {
                if (++frameWait > 60)
                {
                    Logger.LogWarning("[WorldBootstrapper] ⚠ Timed out waiting for IZones — skipping zone setup.");
                    break;
                }

                yield return null;
            }

            if (zones != null)
            {
                ZoneAssignmentHelper.Initialize(zones);
                NavPointRegistry.InitializeZoneSystem(zones);
                Logger.LogInfo("[WorldBootstrapper] ✅ Zones initialized.");
            }

            NavPointRegistry.EnableSpatialIndexing(true);
            NavPointRegistry.RegisterAll(mapId);
            Logger.LogInfo("[WorldBootstrapper] ✅ Navigation points registered.");

            LootRegistry.Clear();
            LootBootstrapper.RegisterAllLoot();
            BotDeadBodyScanner.ScanAll();
            Logger.LogInfo("[WorldBootstrapper] ✅ Loot systems initialized.");

            this.PrewarmAllNavMeshes();
            Logger.LogInfo("[WorldBootstrapper] ✅ NavMesh prewarm complete.");
        }

        private void PrewarmAllNavMeshes()
        {
            string mapId = GameWorldHandler.GetCurrentMapName();
            NavMeshSurface[] surfaces = Object.FindObjectsOfType<NavMeshSurface>();

            for (int i = 0; i < surfaces.Length; i++)
            {
                NavMeshSurface surface = surfaces[i];
                if (surface != null && surface.enabled && surface.gameObject.activeInHierarchy)
                {
                    surface.BuildNavMesh();
                    BotCoverRetreatPlanner.RegisterSurface(mapId, surface);
                    Logger.LogInfo("[WorldBootstrapper] 🔄 Built NavMesh for: " + surface.name);
                }
            }
        }

        public static void EnforceBotBrain(Player player, BotOwner? bot = null)
        {
            if (player == null || !player.IsAI || player.gameObject == null)
            {
                return;
            }

            GameObject obj = player.gameObject;
            BotBrainGuardian.Enforce(obj);

            if (obj.GetComponent<BotBrain>() != null)
            {
                return;
            }

            BotBrain brain = obj.AddComponent<BotBrain>();
            if (bot != null)
            {
                brain.Initialize(bot);
            }
        }
    }
}
