// <auto-generated>
//   AI-Refactored: LootBootstrapper.cs (Ultra-Platinum++ – Supreme Pool/Host/Parity, Bulletproof, June 2025)
//   SYSTEMATICALLY MANAGED. Full registry integration, zero alloc, strict error containment, diagnostics.
//   Parity for: Ultimate Realism, SPT/FIKA headless/client, error audit, and teardown.
//   MIT License.
// </auto-generated>

namespace AIRefactored.Bootstrap
{
    using System;
    using System.Collections.Generic;
    using AIRefactored.AI.Core;
    using AIRefactored.AI.Looting;
    using AIRefactored.Core;
    using AIRefactored.Pools;
    using AIRefactored.Runtime;
    using BepInEx.Logging;
    using EFT;
    using EFT.Interactive;
    using UnityEngine;

    /// <summary>
    /// Registers all lootable containers and loose loot items in the scene.
    /// Links dead player corpses to nearby loot containers for bot prioritization.
    /// All memory is pooled, registry is zero-fault, and state is always SPT/FIKA/headless/client parity.
    /// Diagnostics and stats are maintained for post-raid audits and teardown safety.
    /// </summary>
    public static class LootBootstrapper
    {
        #region Constants

        private const float MaxCorpseLinkDistance = 1.5f;
        private const int MaxContainers = 2048;
        private const int MaxLooseItems = 8192;

        #endregion

        #region Fields

        private static readonly ManualLogSource Logger = Plugin.LoggerInstance;
        private static int _lastContainerCount;
        private static int _lastItemCount;
        private static int _lastCorpseLinks;
        private static bool _lastWorldSafe;
        private static bool _lastHostSafe;

        #endregion

        #region Public API

        /// <summary>
        /// Registers all lootable containers and loose loot in the current scene, with deep integration to LootRegistry.
        /// Always host/world gated. Fully pooled, zero alloc, and diagnostic-safe.
        /// </summary>
        public static void RegisterAllLoot()
        {
            _lastWorldSafe = GameWorldHandler.IsInitialized;
            _lastHostSafe = GameWorldHandler.IsHost;
            _lastContainerCount = 0;
            _lastItemCount = 0;
            _lastCorpseLinks = 0;

            if (!_lastWorldSafe || !_lastHostSafe)
            {
                Logger.LogDebug("[LootBootstrapper] Skipped loot registration — not host or not ready.");
                return;
            }

            try
            {
                LootableContainer[] containers = Array.Empty<LootableContainer>();
                LootItem[] items = Array.Empty<LootItem>();

                try { containers = UnityEngine.Object.FindObjectsOfType<LootableContainer>(); }
                catch (Exception ex) { Logger.LogError("[LootBootstrapper] Failed to find LootableContainer: " + ex); }

                try { items = UnityEngine.Object.FindObjectsOfType<LootItem>(); }
                catch (Exception ex) { Logger.LogError("[LootBootstrapper] Failed to find LootItem: " + ex); }

                if (containers != null && containers.Length > 0)
                    RegisterContainers(containers);

                if (items != null && items.Length > 0)
                    RegisterLooseItems(items);

                // Audit/diagnostics: compare registry state after registration.
                AuditRegistryStats();
            }
            catch (Exception ex)
            {
                Logger.LogError("[LootBootstrapper] RegisterAllLoot() failed: " + ex);
            }
        }

        /// <summary>
        /// Returns a diagnostic string with the last registration/teardown stats.
        /// </summary>
        public static string GetLastStats()
        {
            int containerCount = 0, itemCount = 0, corpseLinks = 0;
            try
            {
                var containers = LootRegistry.GetAllContainers();
                containerCount = containers?.Count ?? 0;
                if (containers != null) TempListPool.Return(containers);

                var items = LootRegistry.GetAllItems();
                itemCount = items?.Count ?? 0;
                if (items != null) TempListPool.Return(items);

                corpseLinks = DeadBodyContainerCache.GetCount();
            }
            catch { /* Defensive: never throw in diagnostics. */ }

            return $"[LootBootstrapper] Host={_lastHostSafe}, World={_lastWorldSafe}, " +
                   $"Containers={_lastContainerCount}, Items={_lastItemCount}, CorpseLinks={_lastCorpseLinks}, " +
                   $"RegistryContainers={containerCount}, RegistryItems={itemCount}";
        }

        #endregion

        #region Container/Item Registration

        /// <summary>
        /// Registers all containers with the LootRegistry and attempts corpse linking.
        /// Bulletproof, deduped, pooled.
        /// </summary>
        private static void RegisterContainers(LootableContainer[] containers)
        {
            int registered = 0;
            var dedupe = TempHashSetPool.Rent<LootableContainer>();
            try
            {
                for (int i = 0; i < containers.Length && registered < MaxContainers; i++)
                {
                    var container = containers[i];
                    if (container == null || !container.enabled || container.transform == null)
                        continue;
                    if (dedupe.Contains(container))
                        continue;

                    try
                    {
                        LootRegistry.RegisterContainer(container);
                        TryLinkToCorpse(container);
                        dedupe.Add(container);
                        registered++;
                    }
                    catch (Exception ex)
                    {
                        Logger.LogError("[LootBootstrapper] RegisterContainers() failed: " + ex);
                    }
                }
            }
            finally
            {
                TempHashSetPool.Return(dedupe);
            }
            _lastContainerCount = registered;
        }

        /// <summary>
        /// Registers all loose loot items with the LootRegistry.
        /// Bulletproof, deduped, pooled.
        /// </summary>
        private static void RegisterLooseItems(LootItem[] items)
        {
            int registered = 0;
            var dedupe = TempHashSetPool.Rent<LootItem>();
            try
            {
                for (int i = 0; i < items.Length && registered < MaxLooseItems; i++)
                {
                    var item = items[i];
                    if (item == null || !item.enabled)
                        continue;
                    if (dedupe.Contains(item))
                        continue;

                    try
                    {
                        LootRegistry.RegisterItem(item);
                        dedupe.Add(item);
                        registered++;
                    }
                    catch (Exception ex)
                    {
                        Logger.LogError("[LootBootstrapper] RegisterLooseItems() failed: " + ex);
                    }
                }
            }
            finally
            {
                TempHashSetPool.Return(dedupe);
            }
            _lastItemCount = registered;
        }

        #endregion

        #region Corpse/Container Linking

        /// <summary>
        /// Attempts to link a loot container to the closest nearby corpse for bot prioritization.
        /// All corpse-container pairs are registered only once, using the closest corpse per container.
        /// </summary>
        private static void TryLinkToCorpse(LootableContainer container)
        {
            if (container == null || container.transform == null)
                return;

            var containerPos = container.transform.position;
            var world = GameWorldHandler.Get();
            if (world?.RegisteredPlayers == null || world.RegisteredPlayers.Count == 0)
                return;

            List<Player> deadPlayers = null;
            try
            {
                deadPlayers = TempListPool.Rent<Player>();
                var all = world.RegisteredPlayers;

                for (int i = 0; i < all.Count; i++)
                {
                    var p = EFTPlayerUtil.AsEFTPlayer(all[i]);
                    if (p != null && p.HealthController != null && !p.HealthController.IsAlive)
                        deadPlayers.Add(p);
                }

                // Find closest valid corpse not already registered.
                float closestDist = MaxCorpseLinkDistance + 1f;
                Player closest = null;
                for (int i = 0; i < deadPlayers.Count; i++)
                {
                    var corpse = deadPlayers[i];
                    string profileId = corpse.Profile?.Id;
                    if (string.IsNullOrEmpty(profileId) || DeadBodyContainerCache.Contains(profileId))
                        continue;

                    var corpsePos = EFTPlayerUtil.GetPosition(corpse);
                    float dist = Vector3.Distance(containerPos, corpsePos);
                    if (dist < closestDist)
                    {
                        closestDist = dist;
                        closest = corpse;
                    }
                }

                // Link container to corpse if found.
                if (closest != null && closestDist <= MaxCorpseLinkDistance)
                {
                    try
                    {
                        DeadBodyContainerCache.Register(closest, container);
                        _lastCorpseLinks++;
                        string nickname = closest.Profile?.Info?.Nickname ?? "Unnamed";
                        Logger.LogDebug("[LootBootstrapper] Linked container to corpse: " + nickname);
                    }
                    catch (Exception ex)
                    {
                        Logger.LogError("[LootBootstrapper] DeadBodyContainerCache.Register() failed: " + ex);
                    }
                }
            }
            catch (Exception ex)
            {
                Logger.LogError("[LootBootstrapper] TryLinkToCorpse() failed: " + ex);
            }
            finally
            {
                if (deadPlayers != null)
                    TempListPool.Return(deadPlayers);
            }
        }

        #endregion

        #region Diagnostics & Validation

        /// <summary>
        /// Audits registry state and logs diagnostics, warning if container/item counts appear mismatched.
        /// </summary>
        private static void AuditRegistryStats()
        {
            try
            {
                var containers = LootRegistry.GetAllContainers();
                var items = LootRegistry.GetAllItems();
                int cCount = containers?.Count ?? -1;
                int iCount = items?.Count ?? -1;

                // Defensive: Pool return for diagnostic lists.
                if (containers != null) TempListPool.Return(containers);
                if (items != null) TempListPool.Return(items);

                int corpseLinks = DeadBodyContainerCache.GetCount();
                if (_lastContainerCount != cCount || _lastItemCount != iCount)
                {
                    Logger.LogWarning($"[LootBootstrapper] Registry count mismatch: Registered Containers={_lastContainerCount}, Registry Containers={cCount}, Registered Items={_lastItemCount}, Registry Items={iCount}");
                }
                else
                {
                    Logger.LogInfo("[LootBootstrapper] Registry validated: Containers=" + cCount + ", Items=" + iCount + ", CorpseLinks=" + corpseLinks);
                }
            }
            catch (Exception ex)
            {
                Logger.LogError("[LootBootstrapper] AuditRegistryStats() failed: " + ex);
            }
        }

        #endregion
    }
}
