// <auto-generated>
//   AI-Refactored: TempDictionaryPool.cs (Ultimate Arbitration, Max-Safety, Zero-Alloc Edition – June 2025)
//   Bulletproof, type-safe pooling for Dictionary<TKey, TValue>. Thread-safe, teardown/reload safe, stats/diagnostics-ready.
//   MIT License.
// </auto-generated>

namespace AIRefactored.Pools
{
    using System;
    using System.Collections.Generic;

    /// <summary>
    /// Centralized pool for temporary <see cref="Dictionary{TKey, TValue}"/> reuse.
    /// Zero-allocation in hot path, bulletproof teardown/reload safety, infinite reloads, type-hygiene and monitoring.
    /// </summary>
    public static class TempDictionaryPool
    {
        private static readonly Dictionary<string, Stack<object>> PoolByTypeKey = new Dictionary<string, Stack<object>>(128);
        private static readonly object SyncRoot = new object();
        private static int _totalRented, _totalReturned, _totalPooled;

        static TempDictionaryPool()
        {
            try
            {
                AppDomain.CurrentDomain.DomainUnload += (_, __) => ClearAll();
            }
            catch { }
        }

        /// <summary>
        /// Rents a cleared dictionary of the given key/value types from the pool or creates a new one.
        /// </summary>
        public static Dictionary<TKey, TValue> Rent<TKey, TValue>()
        {
            string typeKey = GetTypeKey<TKey, TValue>();
            lock (SyncRoot)
            {
                if (PoolByTypeKey.TryGetValue(typeKey, out var stack) && stack.Count > 0)
                {
                    _totalRented++;
                    return (Dictionary<TKey, TValue>)stack.Pop();
                }
            }
            _totalRented++;
            return new Dictionary<TKey, TValue>();
        }

        /// <summary>
        /// Returns a dictionary to the pool after clearing it. Null and duplicate returns are ignored.
        /// </summary>
        public static void Return<TKey, TValue>(Dictionary<TKey, TValue> dict)
        {
            if (dict == null)
                return;

            dict.Clear();
            string typeKey = GetTypeKey<TKey, TValue>();
            lock (SyncRoot)
            {
                if (!PoolByTypeKey.TryGetValue(typeKey, out var stack))
                {
                    stack = new Stack<object>(32);
                    PoolByTypeKey[typeKey] = stack;
                }
                stack.Push(dict);
                _totalReturned++;
                _totalPooled = stack.Count;
            }
        }

        /// <summary>
        /// Prewarms the pool with a number of empty dictionaries of the specified type.
        /// </summary>
        public static void Prewarm<TKey, TValue>(int count)
        {
            if (count <= 0)
                return;
            string typeKey = GetTypeKey<TKey, TValue>();
            lock (SyncRoot)
            {
                if (!PoolByTypeKey.TryGetValue(typeKey, out var stack))
                {
                    stack = new Stack<object>(count);
                    PoolByTypeKey[typeKey] = stack;
                }
                for (int i = 0; i < count; i++)
                    stack.Push(new Dictionary<TKey, TValue>());
                _totalPooled = stack.Count;
            }
        }

        /// <summary>
        /// Clears all dictionary pools for all types. Bulletproof and teardown/reload safe.
        /// </summary>
        public static void ClearAll()
        {
            lock (SyncRoot)
            {
                foreach (var stack in PoolByTypeKey.Values)
                    stack.Clear();
                PoolByTypeKey.Clear();
                _totalPooled = 0;
                _totalRented = 0;
                _totalReturned = 0;
            }
        }

        /// <summary>
        /// Returns pooling stats for diagnostics/monitoring.
        /// </summary>
        public static (int typePools, int totalPooled, int totalRented, int totalReturned) GetStats()
        {
            lock (SyncRoot)
            {
                int pooled = 0;
                foreach (var stack in PoolByTypeKey.Values)
                    pooled += stack.Count;
                return (PoolByTypeKey.Count, pooled, _totalRented, _totalReturned);
            }
        }

        /// <summary>
        /// Constructs a unique type key for identifying generic dictionary stacks.
        /// </summary>
        private static string GetTypeKey<TKey, TValue>()
        {
            return typeof(TKey).FullName + "|" + typeof(TValue).FullName;
        }
    }
}
