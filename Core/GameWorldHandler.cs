// <auto-generated>
//   This file is part of AI-Refactored, an open-source project focused on realistic AI behavior in Escape from Tarkov.
//   Licensed under the MIT License. See LICENSE in the repository root for more information.
//
//   THIS FILE IS SYSTEMATICALLY MANAGED.
//   Please follow strict StyleCop, ReSharper, and AI-Refactored code standards for all modifications.
// </auto-generated>

#nullable enable

namespace AIRefactored.Core
{
    using System.Collections.Generic;
    using AIRefactored.AI.Core;
    using AIRefactored.AI.Hotspots;
    using AIRefactored.AI.Looting;
    using AIRefactored.AI.Optimization;
    using AIRefactored.AI.Threads;
    using AIRefactored.Bootstrap;
    using AIRefactored.Runtime;
    using BepInEx.Logging;
    using Comfort.Common;
    using EFT;
    using UnityEngine;

    /// <summary>
    /// Provides access to ClientGameWorld bots, squad checks, map info, and runtime bootstrap systems.
    /// Fully player-independent. BotBrain is strictly limited to AI players only.
    /// </summary>
    public static class GameWorldHandler
    {
        private const float DeadCleanupInterval = 10f;

        private static readonly HashSet<int> KnownDeadBotIds = new HashSet<int>(64);
        private static readonly ManualLogSource Logger = AIRefactoredController.Logger;

        private static GameObject? _bootstrapHost;
        private static bool _hasWarnedNoWorld;
        private static float _lastCleanupTime = -999f;

        public static bool IsInitialized { get; private set; }

        private static ClientGameWorld? CachedWorld
        {
            get
            {
                return Singleton<ClientGameWorld>.Instantiated ? Singleton<ClientGameWorld>.Instance : null;
            }
        }

        public static void CleanupDeadBotsSmoothly()
        {
            if (Time.time - _lastCleanupTime < DeadCleanupInterval)
            {
                return;
            }

            _lastCleanupTime = Time.time;

            ClientGameWorld? world = CachedWorld;
            if (world == null || world.AllAlivePlayersList == null)
            {
                return;
            }

            for (int i = 0; i < world.AllAlivePlayersList.Count; i++)
            {
                Player? player = world.AllAlivePlayersList[i];
                if (player == null || !player.IsAI)
                {
                    continue;
                }

                if (player.HealthController != null && !player.HealthController.IsAlive)
                {
                    int id = player.GetInstanceID();
                    if (!KnownDeadBotIds.Contains(id))
                    {
                        KnownDeadBotIds.Add(id);

                        if (player.gameObject != null)
                        {
                            player.gameObject.SetActive(false);
                            Object.Destroy(player.gameObject, 3f);
                        }

                        Logger.LogDebug("[GameWorldHandler] 🧹 Cleaned up dead bot " + (player.Profile?.Info?.Nickname ?? "Unknown"));
                    }
                }
            }
        }

        public static void EnforceBotBrains()
        {
            ClientGameWorld? world = CachedWorld;
            if (world == null || world.AllAlivePlayersList == null)
            {
                return;
            }

            for (int i = 0; i < world.AllAlivePlayersList.Count; i++)
            {
                Player? player = world.AllAlivePlayersList[i];
                if (player != null && player.IsAI && player.gameObject != null)
                {
                    BotBrainGuardian.Enforce(player.gameObject);
                }
            }
        }

        public static ClientGameWorld? Get()
        {
            return CachedWorld;
        }

        public static List<Player> GetAllAlivePlayers()
        {
            List<Player> result = new List<Player>();

            ClientGameWorld? world = CachedWorld;
            if (world == null || world.AllAlivePlayersList == null)
            {
                return result;
            }

            for (int i = 0; i < world.AllAlivePlayersList.Count; i++)
            {
                Player? p = world.AllAlivePlayersList[i];
                if (p != null && p.HealthController != null && p.HealthController.IsAlive)
                {
                    result.Add(p);
                }
            }

            return result;
        }

        public static List<Player> GetAllHumanPlayers()
        {
            List<Player> result = new List<Player>();

            ClientGameWorld? world = CachedWorld;
            if (world == null || world.AllAlivePlayersList == null)
            {
                return result;
            }

            for (int i = 0; i < world.AllAlivePlayersList.Count; i++)
            {
                Player? p = world.AllAlivePlayersList[i];
                if (p != null && p.AIData == null && p.HealthController != null && p.HealthController.IsAlive)
                {
                    result.Add(p);
                }
            }

            return result;
        }

        public static string GetCurrentMapName()
        {
            LocationSettingsClass? locationSettings = Singleton<LocationSettingsClass>.Instance;

            if (locationSettings != null && locationSettings.locations != null)
            {
                foreach (KeyValuePair<string, LocationSettingsClass.Location> kvp in locationSettings.locations)
                {
                    if (!kvp.Value.Enabled)
                    {
                        continue;
                    }

                    string mapName = kvp.Key;

                    for (int i = 0; i < LocationSettingsClass.Location.AvailableMaps.Length; i++)
                    {
                        if (LocationSettingsClass.Location.AvailableMaps[i] == mapName)
                        {
                            return mapName.ToLowerInvariant();
                        }
                    }
                }
            }

            return "unknown";
        }

        public static float GetNearestHumanPlayerDistance(Vector3 position)
        {
            float closest = float.MaxValue;
            List<Player> humans = GetAllHumanPlayers();

            for (int i = 0; i < humans.Count; i++)
            {
                Player human = humans[i];
                Vector3 humanPos = EFTPlayerUtil.GetPosition(human);
                float dist = Vector3.Distance(humanPos, position);
                if (dist < closest)
                {
                    closest = dist;
                }
            }

            return closest;
        }


        public static void HookBotSpawns()
        {
            if (_bootstrapHost != null)
            {
                return;
            }

            _bootstrapHost = new GameObject("AIRefactored.BootstrapHost");
            Object.DontDestroyOnLoad(_bootstrapHost);

            _bootstrapHost.AddComponent<WorldBootstrapper>();
            if (FikaHeadlessDetector.IsHeadless)
            {
                _bootstrapHost.AddComponent<BotWorkGroupDispatcher>();
            }

            Logger.LogInfo("[AIRefactored] ✅ GameWorldHandler initialized.");
        }

        public static bool IsNearRealPlayer(Vector3 position, float radius)
        {
            List<Player> humans = GetAllHumanPlayers();

            for (int i = 0; i < humans.Count; i++)
            {
                Player human = humans[i];
                Vector3 humanPos = EFTPlayerUtil.GetPosition(human);

                if (Vector3.Distance(humanPos, position) <= radius)
                {
                    return true;
                }
            }

            return false;
        }

        public static bool IsNearTeammate(Vector3 position, float radius, string? groupId = null)
        {
            if (string.IsNullOrEmpty(groupId))
            {
                return false;
            }

            ClientGameWorld? world = CachedWorld;
            if (world == null || world.AllAlivePlayersList == null)
            {
                return false;
            }

            for (int i = 0; i < world.AllAlivePlayersList.Count; i++)
            {
                Player? p = world.AllAlivePlayersList[i];
                if (p == null || !p.IsAI || p.HealthController == null || !p.HealthController.IsAlive)
                {
                    continue;
                }

                if (p.Profile != null && p.Profile.Info != null &&
                    p.Profile.Info.GroupId == groupId)
                {
                    Vector3 teammatePos = EFTPlayerUtil.GetPosition(p);
                    if (Vector3.Distance(teammatePos, position) <= radius)
                    {
                        return true;
                    }
                }
            }

            return false;
        }

        public static void RefreshLootRegistry()
        {
            Logger.LogInfo("[GameWorldHandler] 🔄 Refreshing loot registries...");
            LootRegistry.Clear();
            LootBootstrapper.RegisterAllLoot();
            BotDeadBodyScanner.ScanAll();
        }

        public static void TryAttachBotBrain(BotOwner bot)
        {
            if (bot == null || bot.IsDead)
            {
                return;
            }

            Player? eftPlayer = EFTPlayerUtil.ResolvePlayer(bot);
            if (eftPlayer == null || !eftPlayer.IsAI)
            {
                return;
            }

            GameObject? obj = eftPlayer.gameObject;
            if (obj == null)
            {
                return;
            }

            BotBrainGuardian.Enforce(obj);

            if (obj.GetComponent<BotBrain>() != null)
            {
                return;
            }

            BotBrain brain = obj.AddComponent<BotBrain>();
            brain.Initialize(bot);
        }

        public static bool TryGetIZones(out IZones? zones)
        {
            zones = null;

            ClientGameWorld? world = CachedWorld;
            if (world == null)
            {
                return false;
            }

            MonoBehaviour[] allBehaviours = Object.FindObjectsOfType<MonoBehaviour>();
            for (int i = 0; i < allBehaviours.Length; i++)
            {
                MonoBehaviour candidate = allBehaviours[i];
                if (candidate is IZones found)
                {
                    zones = found;
                    return true;
                }
            }

            return false;
        }

        public static void TryInitializeWorld()
        {
            if (IsInitialized)
            {
                return;
            }

            ClientGameWorld? world = CachedWorld;

            if (world == null)
            {
                if (!_hasWarnedNoWorld)
                {
                    Logger.LogWarning("[GameWorldHandler] ⚠ GameWorld is null — host may not have finished loading.");
                    _hasWarnedNoWorld = true;
                }

                return;
            }

            if (world.AllAlivePlayersList == null)
            {
                if (!_hasWarnedNoWorld)
                {
                    Logger.LogWarning("[GameWorldHandler] ⚠ Player list is null — world not ready.");
                    _hasWarnedNoWorld = true;
                }

                return;
            }

            _hasWarnedNoWorld = false;

            HookBotSpawns();
            IsInitialized = true;
        }

        public static void UnhookBotSpawns()
        {
            if (_bootstrapHost != null)
            {
                Object.Destroy(_bootstrapHost);
                _bootstrapHost = null;
            }

            HotspotRegistry.Clear();
            LootRegistry.Clear();
            IsInitialized = false;
            _hasWarnedNoWorld = false;

            Logger.LogInfo("[GameWorldHandler] 🔻 GameWorldHandler shut down.");
        }
    }
}
